<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Stellarium: StelRenderer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="stellarium-logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Stellarium 0.12.1</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="codingStyle.html"><span>Coding&#160;Style</span></a></li>
      <li><a href="scripting.html"><span>Scripting</span></a></li>
      <li><a href="plugins.html"><span>Plugins</span></a></li>
      <li><a href="renderer.html"><span>Renderer</span></a></li>
      <li><a href="fileStructure.html"><span>File&#160;Structure</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classStelRenderer-members.html">List of all members</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">StelRenderer Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Main class of the <a class="el" href="renderer.html">Renderer</a> subsystem.  
 <a href="classStelRenderer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="StelRenderer_8hpp_source.html">StelRenderer.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7e93fc36845699a0533e17b3d6d3888d"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#a7e93fc36845699a0533e17b3d6d3888d">~StelRenderer</a> ()</td></tr>
<tr class="memdesc:a7e93fc36845699a0533e17b3d6d3888d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a7e93fc36845699a0533e17b3d6d3888d">More...</a><br/></td></tr>
<tr class="separator:a7e93fc36845699a0533e17b3d6d3888d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc626548c3c14af69061765c7331fb40"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#adc626548c3c14af69061765c7331fb40">init</a> ()=0</td></tr>
<tr class="memdesc:adc626548c3c14af69061765c7331fb40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the renderer.  <a href="#adc626548c3c14af69061765c7331fb40">More...</a><br/></td></tr>
<tr class="separator:adc626548c3c14af69061765c7331fb40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf0122cc27cffce6c9dddc17af5b4f6f"><td class="memItemLeft" align="right" valign="top">virtual QImage&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#adf0122cc27cffce6c9dddc17af5b4f6f">screenshot</a> ()=0</td></tr>
<tr class="memdesc:adf0122cc27cffce6c9dddc17af5b4f6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a screenshot and return it.  <a href="#adf0122cc27cffce6c9dddc17af5b4f6f">More...</a><br/></td></tr>
<tr class="separator:adf0122cc27cffce6c9dddc17af5b4f6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9c21db50f37e99ea5cf851e23f996f8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#ae9c21db50f37e99ea5cf851e23f996f8">viewportHasBeenResized</a> (const QSize size)=0</td></tr>
<tr class="memdesc:ae9c21db50f37e99ea5cf851e23f996f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Must be called once at startup and on every GL viewport resize, specifying new size.  <a href="#ae9c21db50f37e99ea5cf851e23f996f8">More...</a><br/></td></tr>
<tr class="separator:ae9c21db50f37e99ea5cf851e23f996f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58f550570512df06eedf96f073510de6"><td class="memItemLeft" align="right" valign="top">virtual class <a class="el" href="classStelIndexBuffer.html">StelIndexBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#a58f550570512df06eedf96f073510de6">createIndexBuffer</a> (const IndexType type)=0</td></tr>
<tr class="memdesc:a58f550570512df06eedf96f073510de6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an empty index buffer and return a pointer to it.  <a href="#a58f550570512df06eedf96f073510de6">More...</a><br/></td></tr>
<tr class="separator:a58f550570512df06eedf96f073510de6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a977f76433ae9f9fc6f0a1f3109cd9cc6"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:a977f76433ae9f9fc6f0a1f3109cd9cc6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classStelVertexBuffer.html">StelVertexBuffer</a>&lt; V &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#a977f76433ae9f9fc6f0a1f3109cd9cc6">createVertexBuffer</a> (const PrimitiveType primitiveType)</td></tr>
<tr class="memdesc:a977f76433ae9f9fc6f0a1f3109cd9cc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an empty vertex buffer and return a pointer to it.  <a href="#a977f76433ae9f9fc6f0a1f3109cd9cc6">More...</a><br/></td></tr>
<tr class="separator:a977f76433ae9f9fc6f0a1f3109cd9cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad398e9ff5af7b6c0184376fdacb89e52"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:ad398e9ff5af7b6c0184376fdacb89e52"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#ad398e9ff5af7b6c0184376fdacb89e52">drawVertexBuffer</a> (<a class="el" href="classStelVertexBuffer.html">StelVertexBuffer</a>&lt; V &gt; *vertexBuffer, class <a class="el" href="classStelIndexBuffer.html">StelIndexBuffer</a> *indexBuffer=NULL, <a class="el" href="StelProjectorType_8hpp.html#a286221a2d4640bbeec2090cfbfadb0ff">StelProjectorP</a> projector=<a class="el" href="StelProjectorType_8hpp.html#a286221a2d4640bbeec2090cfbfadb0ff">StelProjectorP</a>(NULL), bool dontProject=false)</td></tr>
<tr class="memdesc:ad398e9ff5af7b6c0184376fdacb89e52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw contents of a vertex buffer.  <a href="#ad398e9ff5af7b6c0184376fdacb89e52">More...</a><br/></td></tr>
<tr class="separator:ad398e9ff5af7b6c0184376fdacb89e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa55ae40a73436bfeea416767ab048db5"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:aa55ae40a73436bfeea416767ab048db5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#aa55ae40a73436bfeea416767ab048db5">drawVertexBuffer</a> (<a class="el" href="classStelVertexBuffer.html">StelVertexBuffer</a>&lt; V &gt; *vertexBuffer, class <a class="el" href="classStelIndexBuffer.html">StelIndexBuffer</a> *indexBuffer, <a class="el" href="classStelProjector.html">StelProjector</a> *projector, bool dontProject=false)</td></tr>
<tr class="memdesc:aa55ae40a73436bfeea416767ab048db5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw contents of a vertex buffer.  <a href="#aa55ae40a73436bfeea416767ab048db5">More...</a><br/></td></tr>
<tr class="separator:aa55ae40a73436bfeea416767ab048db5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ff0e382823be0f621cb2b3d0329ac84"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#a3ff0e382823be0f621cb2b3d0329ac84">drawLine</a> (const float startX, const float startY, const float endX, const float endY)</td></tr>
<tr class="memdesc:a3ff0e382823be0f621cb2b3d0329ac84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a line with current global color to the screen.  <a href="#a3ff0e382823be0f621cb2b3d0329ac84">More...</a><br/></td></tr>
<tr class="separator:a3ff0e382823be0f621cb2b3d0329ac84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2bf023af721715f40058b711828fedf"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#ad2bf023af721715f40058b711828fedf">drawRect</a> (const float x, const float y, const float width, const float height, const float angle=0.0f)=0</td></tr>
<tr class="memdesc:ad2bf023af721715f40058b711828fedf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a rectangle to the screen.  <a href="#ad2bf023af721715f40058b711828fedf">More...</a><br/></td></tr>
<tr class="separator:ad2bf023af721715f40058b711828fedf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a416d3eb82d34af15fb748af6300d4363"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#a416d3eb82d34af15fb748af6300d4363">drawTexturedRect</a> (const float x, const float y, const float width, const float height, const float angle=0.0f)=0</td></tr>
<tr class="memdesc:a416d3eb82d34af15fb748af6300d4363"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a textured rectangle to the screen.  <a href="#a416d3eb82d34af15fb748af6300d4363">More...</a><br/></td></tr>
<tr class="separator:a416d3eb82d34af15fb748af6300d4363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f9c1ee188f6cf25ff5d7c6df4795416"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#a9f9c1ee188f6cf25ff5d7c6df4795416">drawText</a> (const <a class="el" href="structTextParams.html">TextParams</a> &amp;params)=0</td></tr>
<tr class="memdesc:a9f9c1ee188f6cf25ff5d7c6df4795416"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw text with specified parameters.  <a href="#a9f9c1ee188f6cf25ff5d7c6df4795416">More...</a><br/></td></tr>
<tr class="separator:a9f9c1ee188f6cf25ff5d7c6df4795416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0058e9561eb0e08e67f559d2606576a6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#a0058e9561eb0e08e67f559d2606576a6">setFont</a> (const QFont &amp;font)=0</td></tr>
<tr class="memdesc:a0058e9561eb0e08e67f559d2606576a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set font to use for drawing text.  <a href="#a0058e9561eb0e08e67f559d2606576a6">More...</a><br/></td></tr>
<tr class="separator:a0058e9561eb0e08e67f559d2606576a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a242b2ff1979f7b4adeec068796b8c8c9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#a242b2ff1979f7b4adeec068796b8c8c9">renderFrame</a> (<a class="el" href="classStelRenderClient.html">StelRenderClient</a> &amp;renderClient)=0</td></tr>
<tr class="memdesc:a242b2ff1979f7b4adeec068796b8c8c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render a frame.  <a href="#a242b2ff1979f7b4adeec068796b8c8c9">More...</a><br/></td></tr>
<tr class="separator:a242b2ff1979f7b4adeec068796b8c8c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b992518c241cc3a12ad964ad12959a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classStelTextureNew.html">StelTextureNew</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#a78b992518c241cc3a12ad964ad12959a">createTexture</a> (const QString &amp;filename, const <a class="el" href="structTextureParams.html">TextureParams</a> &amp;params=<a class="el" href="structTextureParams.html">TextureParams</a>(), const TextureLoadingMode loadingMode=TextureLoadingMode_Normal)</td></tr>
<tr class="memdesc:a78b992518c241cc3a12ad964ad12959a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a texture from specified file or URL.  <a href="#a78b992518c241cc3a12ad964ad12959a">More...</a><br/></td></tr>
<tr class="separator:a78b992518c241cc3a12ad964ad12959a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af881fe1677e3b21ebe24e0e35baf5d1f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classStelTextureNew.html">StelTextureNew</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#af881fe1677e3b21ebe24e0e35baf5d1f">createTexture</a> (QImage &amp;image, const <a class="el" href="structTextureParams.html">TextureParams</a> &amp;params=<a class="el" href="structTextureParams.html">TextureParams</a>())</td></tr>
<tr class="memdesc:af881fe1677e3b21ebe24e0e35baf5d1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a texture from an image.  <a href="#af881fe1677e3b21ebe24e0e35baf5d1f">More...</a><br/></td></tr>
<tr class="separator:af881fe1677e3b21ebe24e0e35baf5d1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50500ed0778b10caf4044a38718efc19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classStelTextureNew.html">StelTextureNew</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#a50500ed0778b10caf4044a38718efc19">createTexture</a> (const void *const data, const QSize size, const TextureDataFormat format, const <a class="el" href="structTextureParams.html">TextureParams</a> &amp;params=<a class="el" href="structTextureParams.html">TextureParams</a>())</td></tr>
<tr class="memdesc:a50500ed0778b10caf4044a38718efc19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a texture from raw data.  <a href="#a50500ed0778b10caf4044a38718efc19">More...</a><br/></td></tr>
<tr class="separator:a50500ed0778b10caf4044a38718efc19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7750ff0cc84161f0949aea61f77af6d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#ac7750ff0cc84161f0949aea61f77af6d">areFloatTexturesSupported</a> () const =0</td></tr>
<tr class="memdesc:ac7750ff0cc84161f0949aea61f77af6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if floating point textures are supported, false otherwise.  <a href="#ac7750ff0cc84161f0949aea61f77af6d">More...</a><br/></td></tr>
<tr class="separator:ac7750ff0cc84161f0949aea61f77af6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71f36b14d90531b697532f4b875617d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classStelTextureNew.html">StelTextureNew</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#a71f36b14d90531b697532f4b875617d9">getViewportTexture</a> ()</td></tr>
<tr class="memdesc:a71f36b14d90531b697532f4b875617d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a texture of the viewport, with everything drawn to the viewport so far.  <a href="#a71f36b14d90531b697532f4b875617d9">More...</a><br/></td></tr>
<tr class="separator:a71f36b14d90531b697532f4b875617d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b9f984032aa9dcc91ab8df6d9a5c648"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classStelGLSLShader.html">StelGLSLShader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#a0b9f984032aa9dcc91ab8df6d9a5c648">createGLSLShader</a> ()</td></tr>
<tr class="memdesc:a0b9f984032aa9dcc91ab8df6d9a5c648"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a GLSL shader.  <a href="#a0b9f984032aa9dcc91ab8df6d9a5c648">More...</a><br/></td></tr>
<tr class="separator:a0b9f984032aa9dcc91ab8df6d9a5c648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a216f1c1d98b7a22d33b7915d60cc8293"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#a216f1c1d98b7a22d33b7915d60cc8293">isGLSLSupported</a> () const =0</td></tr>
<tr class="memdesc:a216f1c1d98b7a22d33b7915d60cc8293"><td class="mdescLeft">&#160;</td><td class="mdescRight">Are GLSL shaders supported?  <a href="#a216f1c1d98b7a22d33b7915d60cc8293">More...</a><br/></td></tr>
<tr class="separator:a216f1c1d98b7a22d33b7915d60cc8293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbd5ae94bcf114bfd8f3b16cc72b7a6d"><td class="memItemLeft" align="right" valign="top">virtual QSize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#acbd5ae94bcf114bfd8f3b16cc72b7a6d">getViewportSize</a> () const =0</td></tr>
<tr class="memdesc:acbd5ae94bcf114bfd8f3b16cc72b7a6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get size of the viewport in pixels.  <a href="#acbd5ae94bcf114bfd8f3b16cc72b7a6d">More...</a><br/></td></tr>
<tr class="separator:acbd5ae94bcf114bfd8f3b16cc72b7a6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89005c9f1e22bbd5cf58839026168e27"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#a89005c9f1e22bbd5cf58839026168e27">setGlobalColor</a> (const <a class="el" href="classVector4.html">Vec4f</a> &amp;color)=0</td></tr>
<tr class="memdesc:a89005c9f1e22bbd5cf58839026168e27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the global vertex color.  <a href="#a89005c9f1e22bbd5cf58839026168e27">More...</a><br/></td></tr>
<tr class="separator:a89005c9f1e22bbd5cf58839026168e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c2e2d69a3571192a79eecd94f61fe76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#a3c2e2d69a3571192a79eecd94f61fe76">setGlobalColor</a> (const float r, const float g, const float b, const float a=1.0f)</td></tr>
<tr class="memdesc:a3c2e2d69a3571192a79eecd94f61fe76"><td class="mdescLeft">&#160;</td><td class="mdescRight">setGlobalColor overload specifying color channels directly instead of through Vec4f.  <a href="#a3c2e2d69a3571192a79eecd94f61fe76">More...</a><br/></td></tr>
<tr class="separator:a3c2e2d69a3571192a79eecd94f61fe76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af96317f54d1fdf7eeb290319ff42a48f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#af96317f54d1fdf7eeb290319ff42a48f">setBlendMode</a> (const BlendMode blendMode)=0</td></tr>
<tr class="memdesc:af96317f54d1fdf7eeb290319ff42a48f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set blend mode.  <a href="#af96317f54d1fdf7eeb290319ff42a48f">More...</a><br/></td></tr>
<tr class="separator:af96317f54d1fdf7eeb290319ff42a48f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8e882ad75fab3b0bddb24cb5bc3ef90"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#ae8e882ad75fab3b0bddb24cb5bc3ef90">setCulledFaces</a> (const CullFace cullFace)=0</td></tr>
<tr class="memdesc:ae8e882ad75fab3b0bddb24cb5bc3ef90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set which faces (triangles) should be culled.  <a href="#ae8e882ad75fab3b0bddb24cb5bc3ef90">More...</a><br/></td></tr>
<tr class="separator:ae8e882ad75fab3b0bddb24cb5bc3ef90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19809c61e76bd27ff903bc4550111d47"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#a19809c61e76bd27ff903bc4550111d47">clearDepthBuffer</a> ()=0</td></tr>
<tr class="memdesc:a19809c61e76bd27ff903bc4550111d47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the depth buffer to zeroes, removing any depth information.  <a href="#a19809c61e76bd27ff903bc4550111d47">More...</a><br/></td></tr>
<tr class="separator:a19809c61e76bd27ff903bc4550111d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5e882f5c441d744300627361634dc0c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#ab5e882f5c441d744300627361634dc0c">setDepthTest</a> (const DepthTest test)=0</td></tr>
<tr class="memdesc:ab5e882f5c441d744300627361634dc0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set depth test mode.  <a href="#ab5e882f5c441d744300627361634dc0c">More...</a><br/></td></tr>
<tr class="separator:ab5e882f5c441d744300627361634dc0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a339f3610ec4d75a39953f06d36aefc91"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#a339f3610ec4d75a39953f06d36aefc91">clearStencilBuffer</a> ()=0</td></tr>
<tr class="memdesc:a339f3610ec4d75a39953f06d36aefc91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the stencil buffer to zeroes, removing any stencil information.  <a href="#a339f3610ec4d75a39953f06d36aefc91">More...</a><br/></td></tr>
<tr class="separator:a339f3610ec4d75a39953f06d36aefc91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14c566946971937c4be5e97cf336c9f3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#a14c566946971937c4be5e97cf336c9f3">setStencilTest</a> (const StencilTest test)=0</td></tr>
<tr class="memdesc:a14c566946971937c4be5e97cf336c9f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set stencil test mode.  <a href="#a14c566946971937c4be5e97cf336c9f3">More...</a><br/></td></tr>
<tr class="separator:a14c566946971937c4be5e97cf336c9f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afea8473fd7b4877d40fb6a79e387822b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#afea8473fd7b4877d40fb6a79e387822b">swapBuffers</a> ()=0</td></tr>
<tr class="memdesc:afea8473fd7b4877d40fb6a79e387822b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap front and back buffers.  <a href="#afea8473fd7b4877d40fb6a79e387822b">More...</a><br/></td></tr>
<tr class="separator:afea8473fd7b4877d40fb6a79e387822b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2653097bc6da56c3507742ddf58424b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classStelRendererStatistics.html">StelRendererStatistics</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#ae2653097bc6da56c3507742ddf58424b">getStatistics</a> ()=0</td></tr>
<tr class="memdesc:ae2653097bc6da56c3507742ddf58424b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access statistics data.  <a href="#ae2653097bc6da56c3507742ddf58424b">More...</a><br/></td></tr>
<tr class="separator:ae2653097bc6da56c3507742ddf58424b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aac066b60608fbc338e7449e309dbcc39"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classStelVertexBufferBackend.html">StelVertexBufferBackend</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#aac066b60608fbc338e7449e309dbcc39">createVertexBufferBackend</a> (const PrimitiveType primitiveType, const QVector&lt; <a class="el" href="structStelVertexAttribute.html">StelVertexAttribute</a> &gt; &amp;attributes)=0</td></tr>
<tr class="memdesc:aac066b60608fbc338e7449e309dbcc39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a vertex buffer backend.  <a href="#aac066b60608fbc338e7449e309dbcc39">More...</a><br/></td></tr>
<tr class="separator:aac066b60608fbc338e7449e309dbcc39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87bc521b5e19d618f4257c580a841a9e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#a87bc521b5e19d618f4257c580a841a9e">drawVertexBufferBackend</a> (<a class="el" href="classStelVertexBufferBackend.html">StelVertexBufferBackend</a> *vertexBuffer, class <a class="el" href="classStelIndexBuffer.html">StelIndexBuffer</a> *indexBuffer, <a class="el" href="classStelProjector.html">StelProjector</a> *projector, const bool dontProject)=0</td></tr>
<tr class="memdesc:a87bc521b5e19d618f4257c580a841a9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw contents of a vertex buffer (backend).  <a href="#a87bc521b5e19d618f4257c580a841a9e">More...</a><br/></td></tr>
<tr class="separator:a87bc521b5e19d618f4257c580a841a9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc4f270649f47c9acd96f570d125d4b0"><td class="memItemLeft" align="right" valign="top">virtual class <a class="el" href="classStelTextureBackend.html">StelTextureBackend</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#acc4f270649f47c9acd96f570d125d4b0">createTextureBackend</a> (const QString &amp;filename, const <a class="el" href="structTextureParams.html">TextureParams</a> &amp;params, const TextureLoadingMode loadingMode)=0</td></tr>
<tr class="memdesc:acc4f270649f47c9acd96f570d125d4b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of createTexture.  <a href="#acc4f270649f47c9acd96f570d125d4b0">More...</a><br/></td></tr>
<tr class="separator:acc4f270649f47c9acd96f570d125d4b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f71077f84e3f5a7f03110ba429ad4d0"><td class="memItemLeft" align="right" valign="top">virtual class <a class="el" href="classStelTextureBackend.html">StelTextureBackend</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#a3f71077f84e3f5a7f03110ba429ad4d0">createTextureBackend</a> (QImage &amp;image, const <a class="el" href="structTextureParams.html">TextureParams</a> &amp;params)=0</td></tr>
<tr class="memdesc:a3f71077f84e3f5a7f03110ba429ad4d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of createTexture loading from image.  <a href="#a3f71077f84e3f5a7f03110ba429ad4d0">More...</a><br/></td></tr>
<tr class="separator:a3f71077f84e3f5a7f03110ba429ad4d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af175f0223ee53472fe01784a00e5f0af"><td class="memItemLeft" align="right" valign="top">virtual class <a class="el" href="classStelTextureBackend.html">StelTextureBackend</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#af175f0223ee53472fe01784a00e5f0af">createTextureBackend</a> (const void *data, const QSize size, const TextureDataFormat format, const <a class="el" href="structTextureParams.html">TextureParams</a> &amp;params)=0</td></tr>
<tr class="memdesc:af175f0223ee53472fe01784a00e5f0af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of createTexture loading from raw data.  <a href="#af175f0223ee53472fe01784a00e5f0af">More...</a><br/></td></tr>
<tr class="separator:af175f0223ee53472fe01784a00e5f0af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd5bd5854dff554adfe79603c429b189"><td class="memItemLeft" align="right" valign="top">virtual class <a class="el" href="classStelTextureBackend.html">StelTextureBackend</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#acd5bd5854dff554adfe79603c429b189">getViewportTextureBackend</a> ()=0</td></tr>
<tr class="memdesc:acd5bd5854dff554adfe79603c429b189"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of getViewportTexture.  <a href="#acd5bd5854dff554adfe79603c429b189">More...</a><br/></td></tr>
<tr class="separator:acd5bd5854dff554adfe79603c429b189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4675c0629e3ee3432650fd6f7efd01f3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#a4675c0629e3ee3432650fd6f7efd01f3">destroyTextureBackend</a> (class <a class="el" href="classStelTextureBackend.html">StelTextureBackend</a> *backend)=0</td></tr>
<tr class="memdesc:a4675c0629e3ee3432650fd6f7efd01f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a <a class="el" href="classStelTextureBackend.html" title="Base class for texture implementations.">StelTextureBackend</a>.  <a href="#a4675c0629e3ee3432650fd6f7efd01f3">More...</a><br/></td></tr>
<tr class="separator:a4675c0629e3ee3432650fd6f7efd01f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18db043e3b7d3f353af6b297ccf5e590"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#a18db043e3b7d3f353af6b297ccf5e590">bindTextureBackend</a> (class <a class="el" href="classStelTextureBackend.html">StelTextureBackend</a> *textureBackend, const int textureUnit)=0</td></tr>
<tr class="memdesc:a18db043e3b7d3f353af6b297ccf5e590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a texture (following draw calls will use this texture on specified texture unit).  <a href="#a18db043e3b7d3f353af6b297ccf5e590">More...</a><br/></td></tr>
<tr class="separator:a18db043e3b7d3f353af6b297ccf5e590"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Main class of the <a class="el" href="renderer.html">Renderer</a> subsystem. </p>
<p>Handles all drawing functionality.</p>
<dl class="section note"><dt>Note</dt><dd>This is an interface. It should have only functions, no data members, as it might be used in multiple inheritance. </dd></dl>

<p>Definition at line <a class="el" href="StelRenderer_8hpp_source.html#l00248">248</a> of file <a class="el" href="StelRenderer_8hpp_source.html">StelRenderer.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a7e93fc36845699a0533e17b3d6d3888d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual StelRenderer::~StelRenderer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

<p>Definition at line <a class="el" href="StelRenderer_8hpp_source.html#l00254">254</a> of file <a class="el" href="StelRenderer_8hpp_source.html">StelRenderer.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ac7750ff0cc84161f0949aea61f77af6d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool StelRenderer::areFloatTexturesSupported </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if floating point textures are supported, false otherwise. </p>

<p>Implemented in <a class="el" href="classStelQGL2Renderer.html#a32dde8f9480d61d3a54044bf038a4193">StelQGL2Renderer</a>, and <a class="el" href="classStelQGL1Renderer.html#af674d4de0e58816696de57186f9c6f29">StelQGL1Renderer</a>.</p>

</div>
</div>
<a class="anchor" id="a18db043e3b7d3f353af6b297ccf5e590"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelRenderer::bindTextureBackend </td>
          <td>(</td>
          <td class="paramtype">class <a class="el" href="classStelTextureBackend.html">StelTextureBackend</a> *&#160;</td>
          <td class="paramname"><em>textureBackend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>textureUnit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind a texture (following draw calls will use this texture on specified texture unit). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">textureBackend</td><td>Texture to bind. </td></tr>
    <tr><td class="paramname">textureUnit</td><td>Texture unit to use. If multitexturing is not supported, binds to texture units other than 0 are ignored. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classStelQGLRenderer.html#a2fea12ab8ca2784a373bc42dfaa588c3">StelQGLRenderer</a>.</p>

</div>
</div>
<a class="anchor" id="a19809c61e76bd27ff903bc4550111d47"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelRenderer::clearDepthBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the depth buffer to zeroes, removing any depth information. </p>

<p>Implemented in <a class="el" href="classStelQGLRenderer.html#a04ffa0277917c6c33f1550b5317b3181">StelQGLRenderer</a>.</p>

</div>
</div>
<a class="anchor" id="a339f3610ec4d75a39953f06d36aefc91"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelRenderer::clearStencilBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the stencil buffer to zeroes, removing any stencil information. </p>

<p>Implemented in <a class="el" href="classStelQGLRenderer.html#a6f403849ff423ebb377e14abc922d761">StelQGLRenderer</a>.</p>

</div>
</div>
<a class="anchor" id="a0b9f984032aa9dcc91ab8df6d9a5c648"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classStelGLSLShader.html">StelGLSLShader</a>* StelRenderer::createGLSLShader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a GLSL shader. </p>
<p>This can only be called if <a class="el" href="classStelRenderer.html#a216f1c1d98b7a22d33b7915d60cc8293" title="Are GLSL shaders supported?">isGLSLSupported()</a> is true.</p>
<p>The constructed shader must be deleted before the <a class="el" href="classStelRenderer.html" title="Main class of the Renderer subsystem.">StelRenderer</a> is destroyed. </p>

<p>Reimplemented in <a class="el" href="classStelQGL2Renderer.html#a55e7bf44e0629b72c97e3bce44f264b8">StelQGL2Renderer</a>, and <a class="el" href="classStelQGL1Renderer.html#ae803720db5a16b44444f49dba24d81e6">StelQGL1Renderer</a>.</p>

<p>Definition at line <a class="el" href="StelRenderer_8hpp_source.html#l00571">571</a> of file <a class="el" href="StelRenderer_8hpp_source.html">StelRenderer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a58f550570512df06eedf96f073510de6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual class <a class="el" href="classStelIndexBuffer.html">StelIndexBuffer</a>* StelRenderer::createIndexBuffer </td>
          <td>(</td>
          <td class="paramtype">const IndexType&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an empty index buffer and return a pointer to it. </p>

<p>Implemented in <a class="el" href="classStelQGLRenderer.html#a6a3ceac34aed22590eb2ee353f650c06">StelQGLRenderer</a>.</p>

</div>
</div>
<a class="anchor" id="a78b992518c241cc3a12ad964ad12959a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStelTextureNew.html">StelTextureNew</a>* StelRenderer::createTexture </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structTextureParams.html">TextureParams</a> &amp;&#160;</td>
          <td class="paramname"><em>params</em> = <code><a class="el" href="structTextureParams.html">TextureParams</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TextureLoadingMode&#160;</td>
          <td class="paramname"><em>loadingMode</em> = <code>TextureLoadingMode_Normal</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a texture from specified file or URL. </p>
<p>The texture must be deleted before the <a class="el" href="classStelRenderer.html" title="Main class of the Renderer subsystem.">StelRenderer</a> is destroyed.</p>
<p>This method never fails, but the texture returned might have the Error status. Even in that case, the texture can be bound, but a placeholder texture will be used internally instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>File name or URL of the image to load the texture from. If it's a file and it's not found, it's searched for in the <em>textures/</em> directory. Some renderer backends might also support compressed textures with custom file formats. These backend-specific files should not be specified by filename - instead, if a compressed texture with the same file name but different extension exists, it will be used. E.g. the GLES backend prefers a .pvr version of a texture if PVR is supported and it exists. </td></tr>
    <tr><td class="paramname">params</td><td>Texture parameters, such as filtering, wrapping, etc. </td></tr>
    <tr><td class="paramname">loadingMode</td><td>Texture loading mode to use. Normal immediately loads the texture, Asynchronous starts loading it in a background thread and LazyAsynchronous starts loading it when it's first needed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New texture.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Some renderer backends only support textures with power of two dimensions (e.g. 512x512 or 2048x256). On these backends, loading a texture with non-power-of-two dimensions will fail and result in a <a class="el" href="classStelTextureNew.html" title="Texture interface.">StelTextureNew</a> with status of TextureStatus_Error. </dd></dl>

<p>Definition at line <a class="el" href="StelRenderer_8hpp_source.html#l00461">461</a> of file <a class="el" href="StelRenderer_8hpp_source.html">StelRenderer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af881fe1677e3b21ebe24e0e35baf5d1f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStelTextureNew.html">StelTextureNew</a>* StelRenderer::createTexture </td>
          <td>(</td>
          <td class="paramtype">QImage &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structTextureParams.html">TextureParams</a> &amp;&#160;</td>
          <td class="paramname"><em>params</em> = <code><a class="el" href="structTextureParams.html">TextureParams</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a texture from an image. </p>
<p>The texture must be deleted before the <a class="el" href="classStelRenderer.html" title="Main class of the Renderer subsystem.">StelRenderer</a> is destroyed.</p>
<p>This method never fails, but the texture returned might have the Error status. Even in that case, the texture can be bound, but a placeholder texture will be used internally instead.</p>
<p>The texture is created immediately, as with TextureLoadingMode_Normal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>Image to load the texture from. </td></tr>
    <tr><td class="paramname">params</td><td>Texture parameters, such as filtering, wrapping, etc.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New texture.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Some renderer backends only support textures with power of two dimensions (e.g. 512x512 or 2048x256). On these backends, loading a texture with non-power-of-two dimensions will fail and result in a <a class="el" href="classStelTextureNew.html" title="Texture interface.">StelTextureNew</a> with status of TextureStatus_Error. </dd></dl>

<p>Definition at line <a class="el" href="StelRenderer_8hpp_source.html#l00500">500</a> of file <a class="el" href="StelRenderer_8hpp_source.html">StelRenderer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a50500ed0778b10caf4044a38718efc19"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStelTextureNew.html">StelTextureNew</a>* StelRenderer::createTexture </td>
          <td>(</td>
          <td class="paramtype">const void *const&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QSize&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TextureDataFormat&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structTextureParams.html">TextureParams</a> &amp;&#160;</td>
          <td class="paramname"><em>params</em> = <code><a class="el" href="structTextureParams.html">TextureParams</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a texture from raw data. </p>
<p>Used to load textures from image data unsupported by QImage, e.g. floating point textures.</p>
<dl class="section note"><dt>Note</dt><dd>If creating a floating point texture, use <a class="el" href="classStelRenderer.html#ac7750ff0cc84161f0949aea61f77af6d" title="Returns true if floating point textures are supported, false otherwise.">areFloatTexturesSupported()</a> to determine if if floating point textures are supported.</dd></dl>
<p>The texture must be deleted before the <a class="el" href="classStelRenderer.html" title="Main class of the Renderer subsystem.">StelRenderer</a> is destroyed.</p>
<p>This method never fails, but the texture returned might have the Error status. Even in that case, the texture can be bound, but a placeholder texture will be used internally instead.</p>
<p>The texture is created immediately, as with TextureLoadingMode_Normal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to raw image data. Size of the data must be size.width() * size.height() * <em>pixelSize</em>, where <em>pixelSize</em> is size of a pixel of specified format. </td></tr>
    <tr><td class="paramname">size</td><td>Size of the texture in pixels. </td></tr>
    <tr><td class="paramname">format</td><td>Format of pixels in data. </td></tr>
    <tr><td class="paramname">params</td><td>Texture parameters, such as filtering, wrapping, etc.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New texture.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Some renderer backends only support textures with power of two dimensions (e.g. 512x512 or 2048x256). On these backends, loading a texture with non-power-of-two dimensions will fail and result in a <a class="el" href="classStelTextureNew.html" title="Texture interface.">StelTextureNew</a> with status of TextureStatus_Error. </dd></dl>

<p>Definition at line <a class="el" href="StelRenderer_8hpp_source.html#l00537">537</a> of file <a class="el" href="StelRenderer_8hpp_source.html">StelRenderer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acc4f270649f47c9acd96f570d125d4b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual class <a class="el" href="classStelTextureBackend.html">StelTextureBackend</a>* StelRenderer::createTextureBackend </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structTextureParams.html">TextureParams</a> &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TextureLoadingMode&#160;</td>
          <td class="paramname"><em>loadingMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of createTexture. </p>
<p>Returns texture backend to be wrapped in a <a class="el" href="classStelTextureNew.html" title="Texture interface.">StelTextureNew</a>. Must not fail, but can return a backend in error state.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classStelRenderer.html#a78b992518c241cc3a12ad964ad12959a" title="Create a texture from specified file or URL.">createTexture</a> </dd></dl>

<p>Implemented in <a class="el" href="classStelQGLRenderer.html#a41cb4921bf8a35f9f02c053ba3c4d2b6">StelQGLRenderer</a>.</p>

</div>
</div>
<a class="anchor" id="a3f71077f84e3f5a7f03110ba429ad4d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual class <a class="el" href="classStelTextureBackend.html">StelTextureBackend</a>* StelRenderer::createTextureBackend </td>
          <td>(</td>
          <td class="paramtype">QImage &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structTextureParams.html">TextureParams</a> &amp;&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of createTexture loading from image. </p>
<p>Returns texture backend to be wrapped in a <a class="el" href="classStelTextureNew.html" title="Texture interface.">StelTextureNew</a>. Must not fail, but can return a backend in error state.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classStelRenderer.html#a78b992518c241cc3a12ad964ad12959a" title="Create a texture from specified file or URL.">createTexture</a> </dd></dl>

<p>Implemented in <a class="el" href="classStelQGLRenderer.html#a455d175e20a6130d92eef45c0ddc297d">StelQGLRenderer</a>.</p>

</div>
</div>
<a class="anchor" id="af175f0223ee53472fe01784a00e5f0af"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual class <a class="el" href="classStelTextureBackend.html">StelTextureBackend</a>* StelRenderer::createTextureBackend </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QSize&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TextureDataFormat&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structTextureParams.html">TextureParams</a> &amp;&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of createTexture loading from raw data. </p>
<p>Returns texture backend to be wrapped in a <a class="el" href="classStelTextureNew.html" title="Texture interface.">StelTextureNew</a>. Must not fail, but can return a backend in error state.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classStelRenderer.html#a78b992518c241cc3a12ad964ad12959a" title="Create a texture from specified file or URL.">createTexture</a> </dd></dl>

<p>Implemented in <a class="el" href="classStelQGLRenderer.html#ae503bcd9c4db93ab4a442e186d082601">StelQGLRenderer</a>.</p>

</div>
</div>
<a class="anchor" id="a977f76433ae9f9fc6f0a1f3109cd9cc6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStelVertexBuffer.html">StelVertexBuffer</a>&lt;V&gt;* StelRenderer::createVertexBuffer </td>
          <td>(</td>
          <td class="paramtype">const PrimitiveType&#160;</td>
          <td class="paramname"><em>primitiveType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an empty vertex buffer and return a pointer to it. </p>
<p>The vertex buffer must be deleted by the user once it is not used (and before the Renderer is destroyed).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td>Vertex type. See the example in <a class="el" href="classStelVertexBuffer.html" title="Vertex buffer interface.">StelVertexBuffer</a> documentation on how to define a vertex type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">primitiveType</td><td>Graphics primitive type stored in the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New vertex buffer storing vertices of type V. </dd></dl>

<p>Definition at line <a class="el" href="StelRenderer_8hpp_source.html#l00283">283</a> of file <a class="el" href="StelRenderer_8hpp_source.html">StelRenderer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aac066b60608fbc338e7449e309dbcc39"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classStelVertexBufferBackend.html">StelVertexBufferBackend</a>* StelRenderer::createVertexBufferBackend </td>
          <td>(</td>
          <td class="paramtype">const PrimitiveType&#160;</td>
          <td class="paramname"><em>primitiveType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QVector&lt; <a class="el" href="structStelVertexAttribute.html">StelVertexAttribute</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>attributes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a vertex buffer backend. </p>
<p>Used by createVertexBuffer.</p>
<p>This allows each Renderer backend to create its own vertex buffer backend.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">primitiveType</td><td>Graphics primitive type stored in the buffer. </td></tr>
    <tr><td class="paramname">attributes</td><td>Descriptions of all attributes of the vertex type stored in the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to a vertex buffer backend specific to the Renderer backend. </dd></dl>

<p>Implemented in <a class="el" href="classStelQGL2Renderer.html#a1fec1df533ad5b3e1d77cd17e701c882">StelQGL2Renderer</a>, and <a class="el" href="classStelQGL1Renderer.html#ac33b7e693f5f6c75b8e388c5992ce13d">StelQGL1Renderer</a>.</p>

</div>
</div>
<a class="anchor" id="a4675c0629e3ee3432650fd6f7efd01f3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelRenderer::destroyTextureBackend </td>
          <td>(</td>
          <td class="paramtype">class <a class="el" href="classStelTextureBackend.html">StelTextureBackend</a> *&#160;</td>
          <td class="paramname"><em>backend</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy a <a class="el" href="classStelTextureBackend.html" title="Base class for texture implementations.">StelTextureBackend</a>. </p>
<p>The backend might be destroyed, but the implementation might also cache the texture, not destroying it if it has muliple users. </p>

<p>Implemented in <a class="el" href="classStelQGLRenderer.html#ac458404691b59fb8b64c6dd269903043">StelQGLRenderer</a>.</p>

</div>
</div>
<a class="anchor" id="a3ff0e382823be0f621cb2b3d0329ac84"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelRenderer::drawLine </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>startX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>startY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>endX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>endY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw a line with current global color to the screen. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startX</td><td>X position of the starting point of the line in pixels. </td></tr>
    <tr><td class="paramname">startY</td><td>Y position of the starting point of the line in pixels. </td></tr>
    <tr><td class="paramname">endX</td><td>X position of the ending point of the line in pixels. </td></tr>
    <tr><td class="paramname">endY</td><td>Y position of the ending point of the line in pixels. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad2bf023af721715f40058b711828fedf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelRenderer::drawRect </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>angle</em> = <code>0.0f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw a rectangle to the screen. </p>
<p>The rectangle will be colored by the global color (which can be specified by <a class="el" href="classStelRenderer.html#a89005c9f1e22bbd5cf58839026168e27" title="Set the global vertex color.">setGlobalColor()</a>).</p>
<p>The rectangle can be rotated around its center by an angle specified in degrees.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>X position of the top left corner on the screen in pixels. </td></tr>
    <tr><td class="paramname">y</td><td>Y position of the top left corner on the screen in pixels. </td></tr>
    <tr><td class="paramname">width</td><td>Width in pixels. </td></tr>
    <tr><td class="paramname">height</td><td>Height in pixels. </td></tr>
    <tr><td class="paramname">angle</td><td>Angle to rotate the rectangle around its center in degrees. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classStelQGLRenderer.html#a60584228d8840bc4ebba3d40cb727a08">StelQGLRenderer</a>.</p>

</div>
</div>
<a class="anchor" id="a9f9c1ee188f6cf25ff5d7c6df4795416"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelRenderer::drawText </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structTextParams.html">TextParams</a> &amp;&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw text with specified parameters. </p>
<p>Parameters are specified by a builder-style struct.</p>
<p>Examples:</p>
<div class="fragment"><div class="line"><span class="comment">// Note that text position and string must be always specified, so they </span></div>
<div class="line"><span class="comment">// are in the constructor.</span></div>
<div class="line"><span class="comment">// Draw with default parameters (no rotation, no shift, no gravity, 2D projection).</span></div>
<div class="line">renderer-&gt;drawText(<a class="code" href="structTextParams.html" title="Parameters specifying how to draw text.">TextParams</a>(16, 16, <span class="stringliteral">&quot;Hello World&quot;</span>));</div>
<div class="line"><span class="comment">// Rotate by 30 degrees.</span></div>
<div class="line">renderer-&gt;drawText(<a class="code" href="structTextParams.html" title="Parameters specifying how to draw text.">TextParams</a>(16, 16 <span class="stringliteral">&quot;Hello World!&quot;</span>).angleDegrees(30.0f));</div>
<div class="line"><span class="comment">// Rotate by 30 degrees and shift by (8, 4) in rotated direction.</span></div>
<div class="line">renderer-&gt;drawText(<a class="code" href="structTextParams.html" title="Parameters specifying how to draw text.">TextParams</a>(16, 16 <span class="stringliteral">&quot;Hello World!&quot;</span>).angleDegrees(30.0f).shift(8.0f, 4.0f));</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>Parameters of the text to draw.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structTextParams.html" title="Parameters specifying how to draw text.">TextParams</a> </dd></dl>

<p>Implemented in <a class="el" href="classStelQGLRenderer.html#aaa4a9ea2f30cec537e00822ec07d0136">StelQGLRenderer</a>.</p>

</div>
</div>
<a class="anchor" id="a416d3eb82d34af15fb748af6300d4363"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelRenderer::drawTexturedRect </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>angle</em> = <code>0.0f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw a textured rectangle to the screen. </p>
<p>The rectangle will be textured by the currently bound texture.</p>
<p>The rectangle can be rotated around its center by an angle specified in degrees.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>X position of the top left corner on the screen in pixels. </td></tr>
    <tr><td class="paramname">y</td><td>Y position of the top left corner on the screen in pixels. </td></tr>
    <tr><td class="paramname">width</td><td>Width in pixels. </td></tr>
    <tr><td class="paramname">height</td><td>Height in pixels. </td></tr>
    <tr><td class="paramname">angle</td><td>Angle to rotate the rectangle around its center in degrees. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classStelQGLRenderer.html#a895d54cca409e3a24ca190b60fc09194">StelQGLRenderer</a>.</p>

</div>
</div>
<a class="anchor" id="ad398e9ff5af7b6c0184376fdacb89e52"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StelRenderer::drawVertexBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classStelVertexBuffer.html">StelVertexBuffer</a>&lt; V &gt; *&#160;</td>
          <td class="paramname"><em>vertexBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class <a class="el" href="classStelIndexBuffer.html">StelIndexBuffer</a> *&#160;</td>
          <td class="paramname"><em>indexBuffer</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="StelProjectorType_8hpp.html#a286221a2d4640bbeec2090cfbfadb0ff">StelProjectorP</a>&#160;</td>
          <td class="paramname"><em>projector</em> = <code><a class="el" href="StelProjectorType_8hpp.html#a286221a2d4640bbeec2090cfbfadb0ff">StelProjectorP</a>(NULL)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dontProject</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw contents of a vertex buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertexBuffer</td><td>Vertex buffer to draw. </td></tr>
    <tr><td class="paramname">indexBuffer</td><td>Index buffer specifying which vertices from the buffer to draw. If NULL, indexing will not be used and vertices will be drawn directly in order they are in the buffer. </td></tr>
    <tr><td class="paramname">projector</td><td>Projector to project vertices' positions before drawing. Also determines viewport to draw in. If NULL, no projection will be done and the vertices will be drawn directly. </td></tr>
    <tr><td class="paramname">dontProject</td><td>Disable vertex position projection. (Projection matrix and viewport information of the projector are still used) This is a hack to support <a class="el" href="classStelSkyDrawer.html" title="Provide a set of methods used to draw sky objects taking into account eyes adaptation, zoom level, instrument model and artificially set magnitude limits.">StelSkyDrawer</a>, which already projects the star positions before drawing them. Avoid using this if possible. <a class="el" href="classStelSkyDrawer.html" title="Provide a set of methods used to draw sky objects taking into account eyes adaptation, zoom level, instrument model and artificially set magnitude limits.">StelSkyDrawer</a> might be refactored in future to remove the need for dontProject, in which case it should be removed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When drawing with a custom <a class="el" href="classStelProjector.html" title="Provide the main interface to all operations of projecting coordinates from sky to screen...">StelProjector</a> only 3D vertex positions are supported. </dd></dl>

<p>Definition at line <a class="el" href="StelRenderer_8hpp_source.html#l00311">311</a> of file <a class="el" href="StelRenderer_8hpp_source.html">StelRenderer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa55ae40a73436bfeea416767ab048db5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StelRenderer::drawVertexBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classStelVertexBuffer.html">StelVertexBuffer</a>&lt; V &gt; *&#160;</td>
          <td class="paramname"><em>vertexBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class <a class="el" href="classStelIndexBuffer.html">StelIndexBuffer</a> *&#160;</td>
          <td class="paramname"><em>indexBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classStelProjector.html">StelProjector</a> *&#160;</td>
          <td class="paramname"><em>projector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dontProject</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw contents of a vertex buffer. </p>
<p>This version takes a StelProjector* instead of StelProjectorP - this is not a problem, as the renderer subsystem doesn't store or delete the projector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertexBuffer</td><td>Vertex buffer to draw. </td></tr>
    <tr><td class="paramname">indexBuffer</td><td>Index buffer specifying which vertices from the buffer to draw. If NULL, indexing will not be used and vertices will be drawn directly in order they are in the buffer. </td></tr>
    <tr><td class="paramname">projector</td><td>Projector to project vertices' positions before drawing. Also determines viewport to draw in. If NULL, no projection will be done and the vertices will be drawn directly. </td></tr>
    <tr><td class="paramname">dontProject</td><td>Disable vertex position projection. (Projection matrix and viewport information of the projector are still used) This is a hack to support <a class="el" href="classStelSkyDrawer.html" title="Provide a set of methods used to draw sky objects taking into account eyes adaptation, zoom level, instrument model and artificially set magnitude limits.">StelSkyDrawer</a>, which already projects the star positions before drawing them. Avoid using this if possible. <a class="el" href="classStelSkyDrawer.html" title="Provide a set of methods used to draw sky objects taking into account eyes adaptation, zoom level, instrument model and artificially set magnitude limits.">StelSkyDrawer</a> might be refactored in future to remove the need for dontProject, in which case it should be removed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When drawing with a custom <a class="el" href="classStelProjector.html" title="Provide the main interface to all operations of projecting coordinates from sky to screen...">StelProjector</a> only 3D vertex positions are supported. </dd></dl>

<p>Definition at line <a class="el" href="StelRenderer_8hpp_source.html#l00344">344</a> of file <a class="el" href="StelRenderer_8hpp_source.html">StelRenderer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a87bc521b5e19d618f4257c580a841a9e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelRenderer::drawVertexBufferBackend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classStelVertexBufferBackend.html">StelVertexBufferBackend</a> *&#160;</td>
          <td class="paramname"><em>vertexBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class <a class="el" href="classStelIndexBuffer.html">StelIndexBuffer</a> *&#160;</td>
          <td class="paramname"><em>indexBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classStelProjector.html">StelProjector</a> *&#160;</td>
          <td class="paramname"><em>projector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>dontProject</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw contents of a vertex buffer (backend). </p>
<p>Used by drawVertexBuffer.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classStelRenderer.html#ad398e9ff5af7b6c0184376fdacb89e52" title="Draw contents of a vertex buffer.">drawVertexBuffer</a> </dd></dl>

<p>Implemented in <a class="el" href="classStelQGL2Renderer.html#a8e9638f481c5220edd42ed290d754976">StelQGL2Renderer</a>, and <a class="el" href="classStelQGL1Renderer.html#a79e7ebdb9b9c985f7b7aedaa699a2ad7">StelQGL1Renderer</a>.</p>

</div>
</div>
<a class="anchor" id="ae2653097bc6da56c3507742ddf58424b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classStelRendererStatistics.html">StelRendererStatistics</a>&amp; StelRenderer::getStatistics </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access statistics data. </p>
<p>Contents are backend specific - might include thing like vertices per frame, estimated texture memory, etc. .</p>
<p>User code might add its own statistics as well (e.g. <a class="el" href="classStelSkyDrawer.html" title="Provide a set of methods used to draw sky objects taking into account eyes adaptation, zoom level, instrument model and artificially set magnitude limits.">StelSkyDrawer</a>). </p>

<p>Implemented in <a class="el" href="classStelQGLRenderer.html#a7af017729278c7724911d78c9ddb13e4">StelQGLRenderer</a>.</p>

</div>
</div>
<a class="anchor" id="acbd5ae94bcf114bfd8f3b16cc72b7a6d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual QSize StelRenderer::getViewportSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get size of the viewport in pixels. </p>

<p>Implemented in <a class="el" href="classStelQGLRenderer.html#ad302cec1f31deb1c3f75fd5b63f647c3">StelQGLRenderer</a>.</p>

</div>
</div>
<a class="anchor" id="a71f36b14d90531b697532f4b875617d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStelTextureNew.html">StelTextureNew</a>* StelRenderer::getViewportTexture </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a texture of the viewport, with everything drawn to the viewport so far. </p>
<dl class="section note"><dt>Note</dt><dd>Since some backends only support textures with power of two dimensions, the returned texture might be larger than the viewport in which case only the part of the texture matching viewport size (returned by getViewportSize) will be taken up by the viewport.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Viewport texture. </dd></dl>

<p>Definition at line <a class="el" href="StelRenderer_8hpp_source.html#l00561">561</a> of file <a class="el" href="StelRenderer_8hpp_source.html">StelRenderer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acd5bd5854dff554adfe79603c429b189"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual class <a class="el" href="classStelTextureBackend.html">StelTextureBackend</a>* StelRenderer::getViewportTextureBackend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of getViewportTexture. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classStelRenderer.html#a71f36b14d90531b697532f4b875617d9" title="Get a texture of the viewport, with everything drawn to the viewport so far.">getViewportTexture</a>. </dd></dl>

<p>Implemented in <a class="el" href="classStelQGLRenderer.html#a8250a04b4365870c09633df1b8e4b2a7">StelQGLRenderer</a>.</p>

</div>
</div>
<a class="anchor" id="adc626548c3c14af69061765c7331fb40"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool StelRenderer::init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the renderer. </p>
<p>Must be called before any other methods.</p>
<dl class="section return"><dt>Returns</dt><dd>true on success, false if there was an error. </dd></dl>

<p>Implemented in <a class="el" href="classStelQGLRenderer.html#a7d8ce574fbe4c2352e1f73db81c12856">StelQGLRenderer</a>, <a class="el" href="classStelQGL2Renderer.html#ace7f988e4a3ed17fce0a9cdd84681691">StelQGL2Renderer</a>, and <a class="el" href="classStelQGL1Renderer.html#a08018450d3c3c648b3226fa468a1127e">StelQGL1Renderer</a>.</p>

</div>
</div>
<a class="anchor" id="a216f1c1d98b7a22d33b7915d60cc8293"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool StelRenderer::isGLSLSupported </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Are GLSL shaders supported? </p>

<p>Implemented in <a class="el" href="classStelQGL2Renderer.html#a2ca96a7f0e373ce89616e7ab6f7b1221">StelQGL2Renderer</a>, and <a class="el" href="classStelQGL1Renderer.html#acf522dddb6161e1cb0fb5ef124c8b753">StelQGL1Renderer</a>.</p>

</div>
</div>
<a class="anchor" id="a242b2ff1979f7b4adeec068796b8c8c9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelRenderer::renderFrame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classStelRenderClient.html">StelRenderClient</a> &amp;&#160;</td>
          <td class="paramname"><em>renderClient</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Render a frame. </p>
<p>This might not render the entire frame - if rendering takes too long, the backend may (or may not) suspend the rendering to finish it next time renderFrame is called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">renderClient</td><td>Allows the renderer to draw the scene in parts.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classStelRenderClient.html" title="Provides access to scene rendering so StelRenderer can control it.">StelRenderClient</a> </dd></dl>

<p>Implemented in <a class="el" href="classStelQGLRenderer.html#add5a6c8e78455dc08fc70d0ed10ade4e">StelQGLRenderer</a>.</p>

</div>
</div>
<a class="anchor" id="adf0122cc27cffce6c9dddc17af5b4f6f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual QImage StelRenderer::screenshot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Take a screenshot and return it. </p>

<p>Implemented in <a class="el" href="classStelQGLRenderer.html#ad48378e7ceae49107a0c39960d5a292e">StelQGLRenderer</a>.</p>

</div>
</div>
<a class="anchor" id="af96317f54d1fdf7eeb290319ff42a48f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelRenderer::setBlendMode </td>
          <td>(</td>
          <td class="paramtype">const BlendMode&#160;</td>
          <td class="paramname"><em>blendMode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set blend mode. </p>
<p>Used to enable/disable transparency and similar effects.</p>
<p>On startup, the blend mode is BlendMode_None. </p>

<p>Implemented in <a class="el" href="classStelQGLRenderer.html#ab19d2ee86496acad683a10b146bf659a">StelQGLRenderer</a>.</p>

</div>
</div>
<a class="anchor" id="ae8e882ad75fab3b0bddb24cb5bc3ef90"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelRenderer::setCulledFaces </td>
          <td>(</td>
          <td class="paramtype">const CullFace&#160;</td>
          <td class="paramname"><em>cullFace</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set which faces (triangles) should be culled. </p>
<p>Front faces are usually those whose vertices are in counter-clockwise order, but a <a class="el" href="classStelProjector.html" title="Provide the main interface to all operations of projecting coordinates from sky to screen...">StelProjector</a> might flip this order after projection. If such a <a class="el" href="classStelProjector.html" title="Provide the main interface to all operations of projecting coordinates from sky to screen...">StelProjector</a> is used with <a class="el" href="classStelRenderer.html#ad398e9ff5af7b6c0184376fdacb89e52" title="Draw contents of a vertex buffer.">StelRenderer::drawVertexBuffer()</a>, front faces will be clock wise. This doesn't affect the user in any way as the projection is done inside renderer.</p>
<p>However, if doing manual projection and sending the already projected vertices for drawing, this order will be flipped, so previously counter-clockwise(front) faces will be clock-wise (back) faces, so if culling is used, opposite face should be used with <a class="el" href="classStelRenderer.html#ae8e882ad75fab3b0bddb24cb5bc3ef90" title="Set which faces (triangles) should be culled.">setCulledFaces()</a>.</p>
<p>Whether a <a class="el" href="classStelProjector.html" title="Provide the main interface to all operations of projecting coordinates from sky to screen...">StelProjector</a> changes clockwise-counterclockwise winding can be determined by <a class="el" href="classStelProjector.html#a200b47efbe9b2d6e5770cd3493e36ffb" title="Get whether front faces need to be oriented in the clockwise direction.">StelProjector::flipFrontBackFace()</a>. </p>

<p>Implemented in <a class="el" href="classStelQGLRenderer.html#ac93f760a53cd233e9d43e65f65077599">StelQGLRenderer</a>.</p>

</div>
</div>
<a class="anchor" id="ab5e882f5c441d744300627361634dc0c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelRenderer::setDepthTest </td>
          <td>(</td>
          <td class="paramtype">const DepthTest&#160;</td>
          <td class="paramname"><em>test</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set depth test mode. </p>
<p>Depth test is implemented to be as specific as possible, only supporting what Stellarium needs. This might be counterintuitive, as much of the power of OpenGL is removed. However, this makes it easier to implement different Renderer backends that might not necessarily be based on OpenGL. </p>

<p>Implemented in <a class="el" href="classStelQGLRenderer.html#ae3a342301d1fc9ef9f9956820bbe1034">StelQGLRenderer</a>.</p>

</div>
</div>
<a class="anchor" id="a0058e9561eb0e08e67f559d2606576a6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelRenderer::setFont </td>
          <td>(</td>
          <td class="paramtype">const QFont &amp;&#160;</td>
          <td class="paramname"><em>font</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set font to use for drawing text. </p>

<p>Implemented in <a class="el" href="classStelQGLRenderer.html#aa44134f8ff1348ac3bb8443b9935cafe">StelQGLRenderer</a>.</p>

</div>
</div>
<a class="anchor" id="a89005c9f1e22bbd5cf58839026168e27"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelRenderer::setGlobalColor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector4.html">Vec4f</a> &amp;&#160;</td>
          <td class="paramname"><em>color</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the global vertex color. </p>
<p>Default color is white.</p>
<p>This color is used when rendering vertex formats that have no vertex color attribute, lines, non-textured rectangles, etc. .</p>
<p>Per-vertex color completely overrides this (this is to keep behavior from before the GL refactor unchanged).</p>
<dl class="section note"><dt>Note</dt><dd>Color channel values can be outside of the 0-1 range. </dd></dl>

<p>Implemented in <a class="el" href="classStelQGLRenderer.html#a804b3001c2860f89baaf87bd93eb2075">StelQGLRenderer</a>.</p>

</div>
</div>
<a class="anchor" id="a3c2e2d69a3571192a79eecd94f61fe76"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StelRenderer::setGlobalColor </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>a</em> = <code>1.0f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>setGlobalColor overload specifying color channels directly instead of through Vec4f. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classStelRenderer.html#a89005c9f1e22bbd5cf58839026168e27" title="Set the global vertex color.">setGlobalColor</a> </dd></dl>

<p>Definition at line <a class="el" href="StelRenderer_8hpp_source.html#l00602">602</a> of file <a class="el" href="StelRenderer_8hpp_source.html">StelRenderer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a14c566946971937c4be5e97cf336c9f3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelRenderer::setStencilTest </td>
          <td>(</td>
          <td class="paramtype">const StencilTest&#160;</td>
          <td class="paramname"><em>test</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set stencil test mode. </p>
<p>Stencil test is implemented to be as specific as possible, only supporting what Stellarium needs. This might be counterintuitive, as much of the power of OpenGL is removed. However, this makes it easier to implement different Renderer backends that might not necessarily be based on OpenGL. </p>

<p>Implemented in <a class="el" href="classStelQGLRenderer.html#ae72e57b65cdd0e6891b702b12f52bc66">StelQGLRenderer</a>.</p>

</div>
</div>
<a class="anchor" id="afea8473fd7b4877d40fb6a79e387822b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelRenderer::swapBuffers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap front and back buffers. </p>
<p>This is only needed before the Renderer takes control of frame start/end, e.g. during loading at startup. </p>

<p>Implemented in <a class="el" href="classStelQGLRenderer.html#a67dc51c5ac6c2fa2a712283fd32311ae">StelQGLRenderer</a>.</p>

</div>
</div>
<a class="anchor" id="ae9c21db50f37e99ea5cf851e23f996f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelRenderer::viewportHasBeenResized </td>
          <td>(</td>
          <td class="paramtype">const QSize&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Must be called once at startup and on every GL viewport resize, specifying new size. </p>

<p>Implemented in <a class="el" href="classStelQGLRenderer.html#aca3b114f7e73fefb5b928d95dab8b29a">StelQGLRenderer</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>core/renderer/<a class="el" href="StelRenderer_8hpp_source.html">StelRenderer.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Mar 3 2013 17:02:57 for Stellarium by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>
