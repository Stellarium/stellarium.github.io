<?xml version="1.0" encoding="utf-8"?>
<html>
    <head>
      <title>Stellarium: StelGLSLShader Class Reference</title>
      <LINK HREF="doxygen.css" REL="stylesheet" TYPE="text/css">
    </HEAD>
    <BODY BGCOLOR="#FFFFFF">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td align="left" valign="top" width="32" rowspan="2"><a href="http://www.stellarium.org"><img src="stellarium-logo.png" align="left" border="0" /></a></td>
<td width="1" rowspan="2">&nbsp;&nbsp;</td>
<td style="font-size:120%;font-weight:bolder;">Stellarium 0.12.0</td>
<td align="right" valign="top" width="230" rowspan="2"></td></tr><tr>
<td class="postheader" valign="center">
 <a href="index.html">Home</a>&nbsp;&middot;
 <a href="namespaces.html">All&nbsp;Namespaces</a>&nbsp;&middot;
 <a href="classes.html">All&nbsp;Classes</a>&nbsp;&middot;
 <a href="functions.html">Functions</a>&nbsp;&middot;
 <a href="codingStyle.html">Coding Style</a>&nbsp;&middot;
 <a href="scripting.html">Scripting</a>&nbsp;&middot;
 <a href="plugins.html">Plugins</a>&nbsp;&middot;
 <a href="renderer.html">Renderer</a>&nbsp;&middot;
 <a href="fileStructure.html">File Structure</a>
</td>
</tr>
</table>
<!-- Generated by Doxygen 1.6.3 -->
<div class="contents">
<h1>StelGLSLShader Class Reference</h1><!-- doxytag: class="StelGLSLShader" -->
<p>GLSL shader program.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="StelGLSLShader_8hpp_source.html">StelGLSLShader.hpp</a>&gt;</code></p>

<p><a href="classStelGLSLShader-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelGLSLShader.html#af0b201fd9eb62e7fea9d2c4c9a645688">~StelGLSLShader</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy the shader program.  <a href="#af0b201fd9eb62e7fea9d2c4c9a645688"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelGLSLShader.html#a278e2dd210b77aad002f6750e5078126">addVertexShader</a> (const QString &amp;source)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a vertex shader from source, compiling it in the process.  <a href="#a278e2dd210b77aad002f6750e5078126"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelGLSLShader.html#aa0124e11de0e4cdbf8384d202367faa0">addFragmentShader</a> (const QString &amp;source)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a fragment shader from source, compiling it in the process.  <a href="#aa0124e11de0e4cdbf8384d202367faa0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelGLSLShader.html#a3710da7bb448c5a30a3eadd9fee04c83">addVertexShader</a> (const QString &amp;name, const QString &amp;source)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a named (optional) vertex shader.  <a href="#a3710da7bb448c5a30a3eadd9fee04c83"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelGLSLShader.html#aa344eb43fedd32b0e2b87fca9bd053bd">hasVertexShader</a> (const QString &amp;name) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Has a named vertex shader with specified name been added?  <a href="#aa344eb43fedd32b0e2b87fca9bd053bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelGLSLShader.html#ad1554e9e078314b55eeda310b25ebdad">enableVertexShader</a> (const QString &amp;name)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable previously added named vertex shader.  <a href="#ad1554e9e078314b55eeda310b25ebdad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelGLSLShader.html#ad695c0b27278e31db94682deb31d16a5">disableVertexShader</a> (const QString &amp;name)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disable previously added named vertex shader.  <a href="#ad695c0b27278e31db94682deb31d16a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelGLSLShader.html#a58cae3e4a1916cf6bd07cd5c58b9b34a">build</a> ()=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Build the shader program.  <a href="#a58cae3e4a1916cf6bd07cd5c58b9b34a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelGLSLShader.html#a725669d679573be1e6a9c8af2efbd708">unlock</a> ()=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlock the shader program for modifications.  <a href="#a725669d679573be1e6a9c8af2efbd708"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual QString&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelGLSLShader.html#a5ae3dd75f20c33c3a72d987585b44f1b">log</a> () const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a string containing the error log of the shader.  <a href="#a5ae3dd75f20c33c3a72d987585b44f1b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelGLSLShader.html#a7f5a6d53ef5352efcbfea770666e8c44">bind</a> ()=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bind the shader, using it for following draw calls.  <a href="#a7f5a6d53ef5352efcbfea770666e8c44"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelGLSLShader.html#ad5f3315bf08b16dec2d478fdbe0211f6">release</a> ()=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release a bound shader after use.  <a href="#ad5f3315bf08b16dec2d478fdbe0211f6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classStelGLSLShader.html#a1cb0bfb1ee5b44b453cdfb3382cea6a4">setUniformValue</a> (const char *const name, T value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set value of a uniform shader variable.  <a href="#a1cb0bfb1ee5b44b453cdfb3382cea6a4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelGLSLShader.html#a687a8efacfc1e876a754fe14c66e80eb">useUnprojectedPositionAttribute</a> ()=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Does this shader need the unprojected position attribute?  <a href="#a687a8efacfc1e876a754fe14c66e80eb"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classStelGLSLShader.html#af765b3176b8fad5e940530956692f39a">setUniformValue_</a> (const char *const name, T value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">"Default" overload of <a class="el" href="classStelGLSLShader.html#a1cb0bfb1ee5b44b453cdfb3382cea6a4" title="Set value of a uniform shader variable.">setUniformValue()</a> implementation.  <a href="#af765b3176b8fad5e940530956692f39a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelGLSLShader.html#a214c10ea3ff04c5589e047e5aaf78467">setUniformValue_</a> (const char *const name, const bool value)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classStelGLSLShader.html#a1cb0bfb1ee5b44b453cdfb3382cea6a4" title="Set value of a uniform shader variable.">setUniformValue()</a> implementation for type bool.  <a href="#a214c10ea3ff04c5589e047e5aaf78467"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelGLSLShader.html#ae75cfbb3292457627d12f43e4bf315a5">setUniformValue_</a> (const char *const name, const int value)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classStelGLSLShader.html#a1cb0bfb1ee5b44b453cdfb3382cea6a4" title="Set value of a uniform shader variable.">setUniformValue()</a> implementation for type int.  <a href="#ae75cfbb3292457627d12f43e4bf315a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelGLSLShader.html#ac1d01a179e3708399b25e0bc039eb321">setUniformValue_</a> (const char *const name, const float value)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classStelGLSLShader.html#a1cb0bfb1ee5b44b453cdfb3382cea6a4" title="Set value of a uniform shader variable.">setUniformValue()</a> implementation for type float.  <a href="#ac1d01a179e3708399b25e0bc039eb321"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelGLSLShader.html#a69f821fa909e80d8f57ef6e0656d0362">setUniformValue_</a> (const char *const name, const <a class="el" href="classVector2.html">Vec2f</a> value)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classStelGLSLShader.html#a1cb0bfb1ee5b44b453cdfb3382cea6a4" title="Set value of a uniform shader variable.">setUniformValue()</a> implementation for type Vec2f.  <a href="#a69f821fa909e80d8f57ef6e0656d0362"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelGLSLShader.html#a8bee668c13ea947c5df973fa54e05d23">setUniformValue_</a> (const char *const name, const <a class="el" href="classVector3.html">Vec3f</a> &amp;value)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classStelGLSLShader.html#a1cb0bfb1ee5b44b453cdfb3382cea6a4" title="Set value of a uniform shader variable.">setUniformValue()</a> implementation for type Vec3f.  <a href="#a8bee668c13ea947c5df973fa54e05d23"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelGLSLShader.html#af78d1988cf91914e098d1985309a314c">setUniformValue_</a> (const char *const name, const <a class="el" href="classVector4.html">Vec4f</a> &amp;value)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classStelGLSLShader.html#a1cb0bfb1ee5b44b453cdfb3382cea6a4" title="Set value of a uniform shader variable.">setUniformValue()</a> implementation for type Vec4f.  <a href="#af78d1988cf91914e098d1985309a314c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelGLSLShader.html#a8d3aa6519199afd04a9a35739d1f1224">setUniformValue_</a> (const char *const name, const <a class="el" href="classMatrix4.html">Mat4f</a> &amp;value)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classStelGLSLShader.html#a1cb0bfb1ee5b44b453cdfb3382cea6a4" title="Set value of a uniform shader variable.">setUniformValue()</a> implementation for type Mat4f.  <a href="#a8d3aa6519199afd04a9a35739d1f1224"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>GLSL shader program. </p>
<p>Can be used with Renderer backends that support GLSL, such as the <a class="el" href="classStelQGL2Renderer.html" title="Renderer backend using OpenGL 2.1 or GLSL 2.0 with Qt.">StelQGL2Renderer</a>.</p>
<p>Shader programs are created by <a class="el" href="classStelRenderer.html" title="Main class of the Renderer subsystem.">StelRenderer</a>. After creation, sources of used vertex and fragment shaders have to be added, and then the shader must be built using the <a class="el" href="classStelGLSLShader.html#a58cae3e4a1916cf6bd07cd5c58b9b34a" title="Build the shader program.">build()</a> member function. After that, the shader can be bound to be used for drawing. It can also be modified by calling the <a class="el" href="classStelGLSLShader.html#a725669d679573be1e6a9c8af2efbd708" title="Unlock the shader program for modifications.">unlock()</a> member function and adding more shaders, and even by disabling or reenabling them. Disabling/reenabling is only supported for vertex shaders, but fragment shader functions can be added when needed.</p>
<p>There is currently no geometry shader support, but it can be added when needed.</p>
<p>Uniform variables are set through the <a class="el" href="classStelGLSLShader.html#a1cb0bfb1ee5b44b453cdfb3382cea6a4" title="Set value of a uniform shader variable.">setUniformValue()</a> member function. Only most commonly used data types are supported, but it is easy to add support for more types if needed. Some uniform variables are specified internally and need to be declared in the shader:</p>
<ul>
<li>StelProjector's projection matrix: <em>mat4f projectionMatrix</em> </li>
<li>Global color (only specified if vertex has no color attribute): <em>vec4 globalColor</em></li>
</ul>
<p>Vertex attributes can't be set through the API - they are set internally from vertex buffer during drawing.</p>
<p>Any shader that uses <a class="el" href="classStelProjector.html" title="Provide the main interface to all operations of projecting coordinates from sky to...">StelProjector</a> projection (that is, any shader except of those working with 2D data) must declare and call the <em>project()</em> function to project the vertex position. If vertex projection is done on the CPU, this is a dummy function that simply returns its argument. If it's done on the GPU, it's done in this function.</p>
<p>The <em>project()</em> function must be declared (but not defined), as follows: </p>
<div class="fragment"><pre class="fragment"> vec4 project(in vec4 v);
</pre></div><p>Usage of the <em>project()</em> function: </p>
<div class="fragment"><pre class="fragment"> gl_Position = projectionMatrix * project(vertex);
</pre></div><p>Attribute variable names match vertex attribute interpretations as follows:</p>
<ul>
<li>Position: <em>vertex</em> </li>
<li>TexCoord: <em>texCoord</em> </li>
<li>Normal: <em>normal</em> </li>
<li>Color: <em>color</em></li>
</ul>
<p>If <a class="el" href="classStelGLSLShader.html#a687a8efacfc1e876a754fe14c66e80eb" title="Does this shader need the unprojected position attribute?">useUnprojectedPositionAttribute()</a> is called, another attribute is added:</p>
<ul>
<li>Position before <a class="el" href="classStelProjector.html" title="Provide the main interface to all operations of projecting coordinates from sky to...">StelProjector</a> projection: <em>unprojectedVertex</em></li>
</ul>
<p>Shader program building can fail. After a failure, the shader is invalid and should not be used (should be destroyed).</p>
<p>Shader creation example:</p>
<div class="fragment"><pre class="fragment"> <span class="comment">// renderer is a StelRenderer*</span>
 <span class="keywordflow">if</span>(renderer-&gt;isGLSLSupported())
 {
    <a class="code" href="classStelGLSLShader.html" title="GLSL shader program.">StelGLSLShader</a>* shader = renderer-&gt;createGLSLShader();
    <span class="keywordflow">if</span>(!shader-&gt;<a class="code" href="classStelGLSLShader.html#a278e2dd210b77aad002f6750e5078126" title="Add a vertex shader from source, compiling it in the process.">addVertexShader</a>(
       <span class="stringliteral">&quot;vec4 project(in vec4 v);\n&quot;</span>
       <span class="stringliteral">&quot;attribute mediump vec4 vertex;\n&quot;</span>
       <span class="stringliteral">&quot;uniform mediump mat4 projectionMatrix;\n&quot;</span>
       <span class="stringliteral">&quot;void main(void)\n&quot;</span>
       <span class="stringliteral">&quot;{\n&quot;</span>
       <span class="stringliteral">&quot;    gl_Position = projectionMatrix * project(vertex);\n&quot;</span>
       <span class="stringliteral">&quot;}\n&quot;</span>))
    {
        qWarning() &lt;&lt; <span class="stringliteral">&quot;Error adding vertex shader: &quot;</span> &lt;&lt; shader-&gt;<a class="code" href="classStelGLSLShader.html#a5ae3dd75f20c33c3a72d987585b44f1b" title="Return a string containing the error log of the shader.">log</a>();
        <span class="keyword">delete</span> shader;
        <span class="keywordflow">return</span> <span class="keyword">false</span>; <span class="comment">// Failed creating shader</span>
    }
    <span class="keywordflow">if</span>(!shader-&gt;<a class="code" href="classStelGLSLShader.html#aa0124e11de0e4cdbf8384d202367faa0" title="Add a fragment shader from source, compiling it in the process.">addFragmentShader</a>(
       <span class="stringliteral">&quot;uniform mediump vec4 globalColor;\n&quot;</span>
       <span class="stringliteral">&quot;void main(void)\n&quot;</span>
       <span class="stringliteral">&quot;{\n&quot;</span>
       <span class="stringliteral">&quot;    gl_FragColor = globalColor;\n&quot;</span>
       <span class="stringliteral">&quot;}\n&quot;</span>))
    {
        qWarning() &lt;&lt; <span class="stringliteral">&quot;Error adding fragment shader: &quot;</span> &lt;&lt; shader-&gt;<a class="code" href="classStelGLSLShader.html#a5ae3dd75f20c33c3a72d987585b44f1b" title="Return a string containing the error log of the shader.">log</a>();
        <span class="keyword">delete</span> shader;
        <span class="keywordflow">return</span> <span class="keyword">false</span>; <span class="comment">// Failed creating shader</span>
    }
    <span class="keywordflow">if</span>(!shader-&gt;<a class="code" href="classStelGLSLShader.html#a58cae3e4a1916cf6bd07cd5c58b9b34a" title="Build the shader program.">build</a>())
    {
        qWarning() &lt;&lt; <span class="stringliteral">&quot;Error building shader: &quot;</span> &lt;&lt; shader-&gt;<a class="code" href="classStelGLSLShader.html#a5ae3dd75f20c33c3a72d987585b44f1b" title="Return a string containing the error log of the shader.">log</a>();
        <span class="keyword">delete</span> shader;
        <span class="keywordflow">return</span> <span class="keyword">false</span>; <span class="comment">// failed creating shader</span>
    }
    <span class="comment">// Shader log might contain warnings.</span>
    <span class="keywordflow">if</span>(!shader-&gt;<a class="code" href="classStelGLSLShader.html#a5ae3dd75f20c33c3a72d987585b44f1b" title="Return a string containing the error log of the shader.">log</a>().isEmpty())
    {
        qWarning() &lt;&lt; <span class="stringliteral">&quot;Shader creation log: &quot;</span> &lt;&lt; shader-&gt;<a class="code" href="classStelGLSLShader.html#a5ae3dd75f20c33c3a72d987585b44f1b" title="Return a string containing the error log of the shader.">log</a>();
    }
 }
</pre></div><p>Shader usage example:</p>
<div class="fragment"><pre class="fragment"> <span class="comment">// shader is a StelGLSLShader*</span>
 <span class="comment">// renderer is a StelRenderer*</span>
 <span class="comment">// vertices is a StelVertexBuffer&lt;SomeVertexType&gt;*</span>
 <span class="comment">// indices is a StelIndexBuffer*</span>
 <span class="comment">// projector is a StelProjectorP</span>

 shader-&gt;<a class="code" href="classStelGLSLShader.html#a7f5a6d53ef5352efcbfea770666e8c44" title="Bind the shader, using it for following draw calls.">bind</a>();
 shader-&gt;<a class="code" href="classStelGLSLShader.html#a1cb0bfb1ee5b44b453cdfb3382cea6a4" title="Set value of a uniform shader variable.">setUniformValue</a>(<span class="stringliteral">&quot;ambientLight&quot;</span>, <a class="code" href="classVector4.html">Vec4f</a>(0.1f, 0.1f, 0.1f,0.1f));
 renderer-&gt;drawVertexBuffer(vertices, indices, projector);
 shader-&gt;<a class="code" href="classStelGLSLShader.html#ad5f3315bf08b16dec2d478fdbe0211f6" title="Release a bound shader after use.">release</a>();
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classStelRenderer.html" title="Main class of the Renderer subsystem.">StelRenderer</a> </dd></dl>

<p>Definition at line <a class="el" href="StelGLSLShader_8hpp_source.html#l00145">145</a> of file <a class="el" href="StelGLSLShader_8hpp_source.html">StelGLSLShader.hpp</a>.</p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="af0b201fd9eb62e7fea9d2c4c9a645688"></a><!-- doxytag: member="StelGLSLShader::~StelGLSLShader" ref="af0b201fd9eb62e7fea9d2c4c9a645688" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual StelGLSLShader::~StelGLSLShader </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destroy the shader program. </p>
<p><a class="el" href="classStelGLSLShader.html" title="GLSL shader program.">StelGLSLShader</a> must be destroyed by the user before its Renderer is destroyed. </p>

<p>Definition at line <a class="el" href="StelGLSLShader_8hpp_source.html#l00151">151</a> of file <a class="el" href="StelGLSLShader_8hpp_source.html">StelGLSLShader.hpp</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aa0124e11de0e4cdbf8384d202367faa0"></a><!-- doxytag: member="StelGLSLShader::addFragmentShader" ref="aa0124e11de0e4cdbf8384d202367faa0" args="(const QString &amp;source)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool StelGLSLShader::addFragmentShader </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a fragment shader from source, compiling it in the process. </p>
<p>This operation can fail. In case of failure, use <a class="el" href="classStelGLSLShader.html#a5ae3dd75f20c33c3a72d987585b44f1b" title="Return a string containing the error log of the shader.">log()</a> to find out the cause.</p>
<p>The shader must be unlocked when this is called.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>Source code of the shader. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if succesfully added and compiled, false otherwise. </dd></dl>

<p>Implemented in <a class="el" href="classStelQGLGLSLShader.html#ae256bbd5a3bd9c0be0017919ba95f2cb">StelQGLGLSLShader</a>.</p>

</div>
</div>
<a class="anchor" id="a3710da7bb448c5a30a3eadd9fee04c83"></a><!-- doxytag: member="StelGLSLShader::addVertexShader" ref="a3710da7bb448c5a30a3eadd9fee04c83" args="(const QString &amp;name, const QString &amp;source)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool StelGLSLShader::addVertexShader </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a named (optional) vertex shader. </p>
<p>Named vertex shaders can be disabled and reenabled. (Unnamed shaders are always enabled.) This allows to dynamically exchange implementations of functions, making shaders modular. GLSL projection is an example of this.</p>
<p>The shader must be unlocked when this is called.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of the shader. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>Source code of the shader. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classStelQGLGLSLShader.html#a4f631cf343291ccbbf5799e594f67cd8">StelQGLGLSLShader</a>.</p>

</div>
</div>
<a class="anchor" id="a278e2dd210b77aad002f6750e5078126"></a><!-- doxytag: member="StelGLSLShader::addVertexShader" ref="a278e2dd210b77aad002f6750e5078126" args="(const QString &amp;source)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool StelGLSLShader::addVertexShader </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a vertex shader from source, compiling it in the process. </p>
<p>This operation can fail. In case of failure, use <a class="el" href="classStelGLSLShader.html#a5ae3dd75f20c33c3a72d987585b44f1b" title="Return a string containing the error log of the shader.">log()</a> to find out the cause.</p>
<p>The shader must be unlocked when this is called.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>Source code of the shader. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if succesfully added and compiled, false otherwise. </dd></dl>

<p>Implemented in <a class="el" href="classStelQGLGLSLShader.html#a3622e52fdd0dbd362cb4e334b6cae82c">StelQGLGLSLShader</a>.</p>

</div>
</div>
<a class="anchor" id="a7f5a6d53ef5352efcbfea770666e8c44"></a><!-- doxytag: member="StelGLSLShader::bind" ref="a7f5a6d53ef5352efcbfea770666e8c44" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelGLSLShader::bind </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Bind the shader, using it for following draw calls. </p>
<p>This must be called before setting uniforms. The shader must be built when this is called.</p>
<p>Note that the shader must be released after any draw calls using the shader to allow default shaders to return to use. </p>

<p>Implemented in <a class="el" href="classStelQGLGLSLShader.html#aa77410a83e7cb4acb698b52e6356ccc8">StelQGLGLSLShader</a>.</p>

</div>
</div>
<a class="anchor" id="a58cae3e4a1916cf6bd07cd5c58b9b34a"></a><!-- doxytag: member="StelGLSLShader::build" ref="a58cae3e4a1916cf6bd07cd5c58b9b34a" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool StelGLSLShader::build </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Build the shader program. </p>
<p>This must be called before the shader can be bound.</p>
<p>This operation can fail. In case of failure, use <a class="el" href="classStelGLSLShader.html#a5ae3dd75f20c33c3a72d987585b44f1b" title="Return a string containing the error log of the shader.">log()</a> to find out the cause. If <a class="el" href="classStelGLSLShader.html#a58cae3e4a1916cf6bd07cd5c58b9b34a" title="Build the shader program.">build()</a> fails, the shader should be assumed to no longer be usable and be destroyed.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if succesfully built, false otherwise. </dd></dl>

<p>Implemented in <a class="el" href="classStelQGLGLSLShader.html#afce8499cfc8a6a35c57a315f02bff25f">StelQGLGLSLShader</a>.</p>

</div>
</div>
<a class="anchor" id="ad695c0b27278e31db94682deb31d16a5"></a><!-- doxytag: member="StelGLSLShader::disableVertexShader" ref="ad695c0b27278e31db94682deb31d16a5" args="(const QString &amp;name)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelGLSLShader::disableVertexShader </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disable previously added named vertex shader. </p>
<p>The shader must be unlocked when this is called.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of the shader to disable. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classStelQGLGLSLShader.html#aa7edd3270500c4162a62c3e8dc761721">StelQGLGLSLShader</a>.</p>

</div>
</div>
<a class="anchor" id="ad1554e9e078314b55eeda310b25ebdad"></a><!-- doxytag: member="StelGLSLShader::enableVertexShader" ref="ad1554e9e078314b55eeda310b25ebdad" args="(const QString &amp;name)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelGLSLShader::enableVertexShader </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enable previously added named vertex shader. </p>
<p>The shader must be unlocked when this is called.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of the shader to enable. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classStelQGLGLSLShader.html#a2df5e9b94a5f39cd733728845ef62d52">StelQGLGLSLShader</a>.</p>

</div>
</div>
<a class="anchor" id="aa344eb43fedd32b0e2b87fca9bd053bd"></a><!-- doxytag: member="StelGLSLShader::hasVertexShader" ref="aa344eb43fedd32b0e2b87fca9bd053bd" args="(const QString &amp;name) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool StelGLSLShader::hasVertexShader </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Has a named vertex shader with specified name been added? </p>

<p>Implemented in <a class="el" href="classStelQGLGLSLShader.html#af9db84b9cbed6ee5428bb2a1dde61c1f">StelQGLGLSLShader</a>.</p>

</div>
</div>
<a class="anchor" id="a5ae3dd75f20c33c3a72d987585b44f1b"></a><!-- doxytag: member="StelGLSLShader::log" ref="a5ae3dd75f20c33c3a72d987585b44f1b" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual QString StelGLSLShader::log </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a string containing the error log of the shader. </p>
<p>If the shader is succesfully built, it will contain a success message. It might also contain GLSL code warnings. </p>

<p>Implemented in <a class="el" href="classStelQGLGLSLShader.html#a91fe541891340fb1ff0b551aed3b0218">StelQGLGLSLShader</a>.</p>

</div>
</div>
<a class="anchor" id="ad5f3315bf08b16dec2d478fdbe0211f6"></a><!-- doxytag: member="StelGLSLShader::release" ref="ad5f3315bf08b16dec2d478fdbe0211f6" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelGLSLShader::release </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Release a bound shader after use. </p>
<p>This must be called after using the shader so that the <a class="el" href="classStelRenderer.html" title="Main class of the Renderer subsystem.">StelRenderer</a> backend can go back to using default shaders.</p>
<p>It also must be called before <a class="el" href="classStelGLSLShader.html#a7f5a6d53ef5352efcbfea770666e8c44" title="Bind the shader, using it for following draw calls.">bind()</a>-ing another <a class="el" href="classStelGLSLShader.html" title="GLSL shader program.">StelGLSLShader</a>. </p>

<p>Implemented in <a class="el" href="classStelQGLGLSLShader.html#af6092a51ab7d0ae0f6640c9bf14530d5">StelQGLGLSLShader</a>.</p>

</div>
</div>
<a class="anchor" id="a1cb0bfb1ee5b44b453cdfb3382cea6a4"></a><!-- doxytag: member="StelGLSLShader::setUniformValue" ref="a1cb0bfb1ee5b44b453cdfb3382cea6a4" args="(const char *const name, T value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void StelGLSLShader::setUniformValue </td>
          <td>(</td>
          <td class="paramtype">const char *const &nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set value of a uniform shader variable. </p>
<p>A uniform variable has the same value for each drawn vertex/pixel. This can be used for things such as a transformation matrix, global vertex color and so on.</p>
<p><a class="el" href="classStelGLSLShader.html#a1cb0bfb1ee5b44b453cdfb3382cea6a4" title="Set value of a uniform shader variable.">setUniformValue()</a> supports these data types (GLSL type in parentheses):</p>
<p>bool(bool), int(int), float(float), Vec2f(vec2), Vec3f(vec3), Vec4f(vec4), Mat4f(mat4)</p>
<p>The shader must be bound when this is called.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Due to dynamic shader re-linking needed to support modular shaders, uniforms are cached internally and only uploaded at the draw call when the shader is used. Fixed amount of storage is allocated (currently 512 bytes, which is enough for 8 4x4 matrices). Also only a fixed number of uniforms is supported (currently 32). Both of these limits can be increased if needed (see <a class="el" href="classStelQGLGLSLShader.html" title="QGL based StelGLSLShader implementation, used by the QGL2 renderer backend.">StelQGLGLSLShader</a>). This storage is written to with each <a class="el" href="classStelGLSLShader.html#a1cb0bfb1ee5b44b453cdfb3382cea6a4" title="Set value of a uniform shader variable.">setUniformValue()</a> call, and freed on a call to <a class="el" href="classStelGLSLShader.html#ad5f3315bf08b16dec2d478fdbe0211f6" title="Release a bound shader after use.">release()</a>.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of the uniform variable. Must match variable name in at least one of the used vertex/fragment shaders. For efficiency reasons, the name is not guaranteed to be copied within the shader backend. Therefore, the name string must exist until a call to <a class="el" href="classStelGLSLShader.html#ad5f3315bf08b16dec2d478fdbe0211f6" title="Release a bound shader after use.">release()</a>. (This is easiest to achieve by simply using string literals.) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>Value to set the variable to. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="StelGLSLShader_8hpp_source.html#l00275">275</a> of file <a class="el" href="StelGLSLShader_8hpp_source.html">StelGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8d3aa6519199afd04a9a35739d1f1224"></a><!-- doxytag: member="StelGLSLShader::setUniformValue_" ref="a8d3aa6519199afd04a9a35739d1f1224" args="(const char *const name, const Mat4f &amp;value)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelGLSLShader::setUniformValue_ </td>
          <td>(</td>
          <td class="paramtype">const char *const &nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrix4.html">Mat4f</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classStelGLSLShader.html#a1cb0bfb1ee5b44b453cdfb3382cea6a4" title="Set value of a uniform shader variable.">setUniformValue()</a> implementation for type Mat4f. </p>

<p>Implemented in <a class="el" href="classStelQGLGLSLShader.html#acce297bc9acde642067b4fe946fe06ca">StelQGLGLSLShader</a>.</p>

</div>
</div>
<a class="anchor" id="af78d1988cf91914e098d1985309a314c"></a><!-- doxytag: member="StelGLSLShader::setUniformValue_" ref="af78d1988cf91914e098d1985309a314c" args="(const char *const name, const Vec4f &amp;value)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelGLSLShader::setUniformValue_ </td>
          <td>(</td>
          <td class="paramtype">const char *const &nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector4.html">Vec4f</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classStelGLSLShader.html#a1cb0bfb1ee5b44b453cdfb3382cea6a4" title="Set value of a uniform shader variable.">setUniformValue()</a> implementation for type Vec4f. </p>

<p>Implemented in <a class="el" href="classStelQGLGLSLShader.html#adbf755525e35371a075446caaef2d82b">StelQGLGLSLShader</a>.</p>

</div>
</div>
<a class="anchor" id="a8bee668c13ea947c5df973fa54e05d23"></a><!-- doxytag: member="StelGLSLShader::setUniformValue_" ref="a8bee668c13ea947c5df973fa54e05d23" args="(const char *const name, const Vec3f &amp;value)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelGLSLShader::setUniformValue_ </td>
          <td>(</td>
          <td class="paramtype">const char *const &nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector3.html">Vec3f</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classStelGLSLShader.html#a1cb0bfb1ee5b44b453cdfb3382cea6a4" title="Set value of a uniform shader variable.">setUniformValue()</a> implementation for type Vec3f. </p>

<p>Implemented in <a class="el" href="classStelQGLGLSLShader.html#a5a0e34af39318399cc0467cd0fc3841f">StelQGLGLSLShader</a>.</p>

</div>
</div>
<a class="anchor" id="a69f821fa909e80d8f57ef6e0656d0362"></a><!-- doxytag: member="StelGLSLShader::setUniformValue_" ref="a69f821fa909e80d8f57ef6e0656d0362" args="(const char *const name, const Vec2f value)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelGLSLShader::setUniformValue_ </td>
          <td>(</td>
          <td class="paramtype">const char *const &nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector2.html">Vec2f</a>&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classStelGLSLShader.html#a1cb0bfb1ee5b44b453cdfb3382cea6a4" title="Set value of a uniform shader variable.">setUniformValue()</a> implementation for type Vec2f. </p>

<p>Implemented in <a class="el" href="classStelQGLGLSLShader.html#adc6d335b09ac9090f004accb5abb50d1">StelQGLGLSLShader</a>.</p>

</div>
</div>
<a class="anchor" id="ac1d01a179e3708399b25e0bc039eb321"></a><!-- doxytag: member="StelGLSLShader::setUniformValue_" ref="ac1d01a179e3708399b25e0bc039eb321" args="(const char *const name, const float value)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelGLSLShader::setUniformValue_ </td>
          <td>(</td>
          <td class="paramtype">const char *const &nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classStelGLSLShader.html#a1cb0bfb1ee5b44b453cdfb3382cea6a4" title="Set value of a uniform shader variable.">setUniformValue()</a> implementation for type float. </p>

<p>Implemented in <a class="el" href="classStelQGLGLSLShader.html#a6777673cd29406dd71a763ae4006e90f">StelQGLGLSLShader</a>.</p>

</div>
</div>
<a class="anchor" id="ae75cfbb3292457627d12f43e4bf315a5"></a><!-- doxytag: member="StelGLSLShader::setUniformValue_" ref="ae75cfbb3292457627d12f43e4bf315a5" args="(const char *const name, const int value)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelGLSLShader::setUniformValue_ </td>
          <td>(</td>
          <td class="paramtype">const char *const &nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classStelGLSLShader.html#a1cb0bfb1ee5b44b453cdfb3382cea6a4" title="Set value of a uniform shader variable.">setUniformValue()</a> implementation for type int. </p>

<p>Implemented in <a class="el" href="classStelQGLGLSLShader.html#ac3023513bbb3dd149985b4a82f085a9a">StelQGLGLSLShader</a>.</p>

</div>
</div>
<a class="anchor" id="a214c10ea3ff04c5589e047e5aaf78467"></a><!-- doxytag: member="StelGLSLShader::setUniformValue_" ref="a214c10ea3ff04c5589e047e5aaf78467" args="(const char *const name, const bool value)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelGLSLShader::setUniformValue_ </td>
          <td>(</td>
          <td class="paramtype">const char *const &nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classStelGLSLShader.html#a1cb0bfb1ee5b44b453cdfb3382cea6a4" title="Set value of a uniform shader variable.">setUniformValue()</a> implementation for type bool. </p>

<p>Implemented in <a class="el" href="classStelQGLGLSLShader.html#a0047941dae7309de8d2f16fcb9064653">StelQGLGLSLShader</a>.</p>

</div>
</div>
<a class="anchor" id="af765b3176b8fad5e940530956692f39a"></a><!-- doxytag: member="StelGLSLShader::setUniformValue_" ref="af765b3176b8fad5e940530956692f39a" args="(const char *const name, T value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void StelGLSLShader::setUniformValue_ </td>
          <td>(</td>
          <td class="paramtype">const char *const &nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>"Default" overload of <a class="el" href="classStelGLSLShader.html#a1cb0bfb1ee5b44b453cdfb3382cea6a4" title="Set value of a uniform shader variable.">setUniformValue()</a> implementation. </p>
<p>This is called for unsupported uniform types, and results in an error. </p>

<p>Definition at line <a class="el" href="StelGLSLShader_8hpp_source.html#l00295">295</a> of file <a class="el" href="StelGLSLShader_8hpp_source.html">StelGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a725669d679573be1e6a9c8af2efbd708"></a><!-- doxytag: member="StelGLSLShader::unlock" ref="a725669d679573be1e6a9c8af2efbd708" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelGLSLShader::unlock </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unlock the shader program for modifications. </p>
<p>Allows to, add, enable, disable vertex/fragment shaders.</p>
<p>This can be called even if the shader is bound (which is used for last-moment modifications, like GLSL projection in renderer backend), but it must be rebuilt before drawing and releasing. </p>

<p>Implemented in <a class="el" href="classStelQGLGLSLShader.html#a77cee9a54b10362701642fa443a9995a">StelQGLGLSLShader</a>.</p>

</div>
</div>
<a class="anchor" id="a687a8efacfc1e876a754fe14c66e80eb"></a><!-- doxytag: member="StelGLSLShader::useUnprojectedPositionAttribute" ref="a687a8efacfc1e876a754fe14c66e80eb" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelGLSLShader::useUnprojectedPositionAttribute </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Does this shader need the unprojected position attribute? </p>
<p>If called, the shader will have to declare another vertex attribute, <em>unprojectedVertex</em>, for vertex position before <a class="el" href="classStelProjector.html" title="Provide the main interface to all operations of projecting coordinates from sky to...">StelProjector</a> projection. Useful e.g. for lighting. </p>

<p>Implemented in <a class="el" href="classStelQGLGLSLShader.html#a2afb696e7f20bf5deb14e28aea141a10">StelQGLGLSLShader</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>core/renderer/<a class="el" href="StelGLSLShader_8hpp_source.html">StelGLSLShader.hpp</a></li>
</ul>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Thu Nov 22 16:11:56 2012 for Stellarium by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
