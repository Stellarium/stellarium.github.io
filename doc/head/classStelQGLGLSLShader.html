<?xml version="1.0" encoding="utf-8"?>
<html>
    <head>
      <title>Stellarium: StelQGLGLSLShader Class Reference</title>
      <LINK HREF="doxygen.css" REL="stylesheet" TYPE="text/css">
    </HEAD>
    <BODY BGCOLOR="#FFFFFF">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td align="left" valign="top" width="32" rowspan="2"><a href="http://www.stellarium.org"><img src="stellarium-logo.png" align="left" border="0" /></a></td>
<td width="1" rowspan="2">&nbsp;&nbsp;</td>
<td style="font-size:120%;font-weight:bolder;">Stellarium 0.12.0</td>
<td align="right" valign="top" width="230" rowspan="2"></td></tr><tr>
<td class="postheader" valign="center">
 <a href="index.html">Home</a>&nbsp;&middot;
 <a href="namespaces.html">All&nbsp;Namespaces</a>&nbsp;&middot;
 <a href="classes.html">All&nbsp;Classes</a>&nbsp;&middot;
 <a href="functions.html">Functions</a>&nbsp;&middot;
 <a href="codingStyle.html">Coding Style</a>&nbsp;&middot;
 <a href="scripting.html">Scripting</a>&nbsp;&middot;
 <a href="plugins.html">Plugins</a>&nbsp;&middot;
 <a href="renderer.html">Renderer</a>&nbsp;&middot;
 <a href="fileStructure.html">File Structure</a>
</td>
</tr>
</table>
<!-- Generated by Doxygen 1.6.3 -->
<div class="contents">
<h1>StelQGLGLSLShader Class Reference</h1><!-- doxytag: class="StelQGLGLSLShader" --><!-- doxytag: inherits="StelGLSLShader" -->
<p>QGL based <a class="el" href="classStelGLSLShader.html" title="GLSL shader program.">StelGLSLShader</a> implementation, used by the QGL2 renderer backend.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>&gt;</code></p>

<p><a href="classStelQGLGLSLShader-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>OptionalShader</b></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Simple struct that adds an "enabled" flag to a shader. <br/></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#a206cbfb25c246deb43e2e6b28f959058">StelQGLGLSLShader</a> (class <a class="el" href="classStelQGL2Renderer.html">StelQGL2Renderer</a> *<a class="el" href="classStelQGLGLSLShader.html#a04fa3a6d2b610b3c5724ed05d55f5874">renderer</a>, bool <a class="el" href="classStelQGLGLSLShader.html#afae0785547c259be63c0d1a84cb061a2">internal</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a <a class="el" href="classStelQGLGLSLShader.html" title="QGL based StelGLSLShader implementation, used by the QGL2 renderer backend.">StelQGLGLSLShader</a> owned by specified renderer.  <a href="#a206cbfb25c246deb43e2e6b28f959058"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#a3622e52fdd0dbd362cb4e334b6cae82c">addVertexShader</a> (const QString &amp;source)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a vertex shader from source, compiling it in the process.  <a href="#a3622e52fdd0dbd362cb4e334b6cae82c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#ae256bbd5a3bd9c0be0017919ba95f2cb">addFragmentShader</a> (const QString &amp;source)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a fragment shader from source, compiling it in the process.  <a href="#ae256bbd5a3bd9c0be0017919ba95f2cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#afce8499cfc8a6a35c57a315f02bff25f">build</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Build the shader program.  <a href="#afce8499cfc8a6a35c57a315f02bff25f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual QString&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#a91fe541891340fb1ff0b551aed3b0218">log</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a string containing the error log of the shader.  <a href="#a91fe541891340fb1ff0b551aed3b0218"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#a77cee9a54b10362701642fa443a9995a">unlock</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlock the shader program for modifications.  <a href="#a77cee9a54b10362701642fa443a9995a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#a4f631cf343291ccbbf5799e594f67cd8">addVertexShader</a> (const QString &amp;name, const QString &amp;source)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a named (optional) vertex shader.  <a href="#a4f631cf343291ccbbf5799e594f67cd8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#af9db84b9cbed6ee5428bb2a1dde61c1f">hasVertexShader</a> (const QString &amp;name) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Has a named vertex shader with specified name been added?  <a href="#af9db84b9cbed6ee5428bb2a1dde61c1f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#a2df5e9b94a5f39cd733728845ef62d52">enableVertexShader</a> (const QString &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable previously added named vertex shader.  <a href="#a2df5e9b94a5f39cd733728845ef62d52"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#aa7edd3270500c4162a62c3e8dc761721">disableVertexShader</a> (const QString &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disable previously added named vertex shader.  <a href="#aa7edd3270500c4162a62c3e8dc761721"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#aa77410a83e7cb4acb698b52e6356ccc8">bind</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bind the shader, using it for following draw calls.  <a href="#aa77410a83e7cb4acb698b52e6356ccc8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#af6092a51ab7d0ae0f6640c9bf14530d5">release</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release a bound shader after use.  <a href="#af6092a51ab7d0ae0f6640c9bf14530d5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#a2afb696e7f20bf5deb14e28aea141a10">useUnprojectedPositionAttribute</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Does this shader need the unprojected position attribute?  <a href="#a2afb696e7f20bf5deb14e28aea141a10"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QGLShaderProgram &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#a932c0f77d67e910b5b59df7183883fa0">getProgram</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a reference to the current underlying shader program.  <a href="#a932c0f77d67e910b5b59df7183883fa0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#a0b1f7c271bde1be2a1c3b1476d7d5bd7">useUnprojectedPosition</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Does this shader need the unprojected vertex position attribute?  <a href="#a0b1f7c271bde1be2a1c3b1476d7d5bd7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#ad055f5447dde2b203e503e56ebcc4343">uploadUniforms</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Upload the stored uniform variables.  <a href="#ad055f5447dde2b203e503e56ebcc4343"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#a341bdd163ed3e8cecd279e15e5f8d16c">pushUniformStorage</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Push uniform storage state.  <a href="#a341bdd163ed3e8cecd279e15e5f8d16c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#ab9e1c9cc088ae08d414e4fdd0fea948a">popUniformStorage</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Restores pushed uniform storage stage.  <a href="#ab9e1c9cc088ae08d414e4fdd0fea948a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#a37004c3b1e983f0d3e0803c09f2c19fa">clearUniforms</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear all stored uniforms, freeing uniform storage.  <a href="#a37004c3b1e983f0d3e0803c09f2c19fa"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#a6777673cd29406dd71a763ae4006e90f">setUniformValue_</a> (const char *const name, const float value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classStelGLSLShader.html#a1cb0bfb1ee5b44b453cdfb3382cea6a4" title="Set value of a uniform shader variable.">setUniformValue()</a> implementation for type float.  <a href="#a6777673cd29406dd71a763ae4006e90f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#adc6d335b09ac9090f004accb5abb50d1">setUniformValue_</a> (const char *const name, const <a class="el" href="classVector2.html">Vec2f</a> value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classStelGLSLShader.html#a1cb0bfb1ee5b44b453cdfb3382cea6a4" title="Set value of a uniform shader variable.">setUniformValue()</a> implementation for type Vec2f.  <a href="#adc6d335b09ac9090f004accb5abb50d1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#a5a0e34af39318399cc0467cd0fc3841f">setUniformValue_</a> (const char *const name, const <a class="el" href="classVector3.html">Vec3f</a> &amp;value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classStelGLSLShader.html#a1cb0bfb1ee5b44b453cdfb3382cea6a4" title="Set value of a uniform shader variable.">setUniformValue()</a> implementation for type Vec3f.  <a href="#a5a0e34af39318399cc0467cd0fc3841f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#adbf755525e35371a075446caaef2d82b">setUniformValue_</a> (const char *const name, const <a class="el" href="classVector4.html">Vec4f</a> &amp;value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classStelGLSLShader.html#a1cb0bfb1ee5b44b453cdfb3382cea6a4" title="Set value of a uniform shader variable.">setUniformValue()</a> implementation for type Vec4f.  <a href="#adbf755525e35371a075446caaef2d82b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#acce297bc9acde642067b4fe946fe06ca">setUniformValue_</a> (const char *const name, const <a class="el" href="classMatrix4.html">Mat4f</a> &amp;m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classStelGLSLShader.html#a1cb0bfb1ee5b44b453cdfb3382cea6a4" title="Set value of a uniform shader variable.">setUniformValue()</a> implementation for type Mat4f.  <a href="#acce297bc9acde642067b4fe946fe06ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#a0047941dae7309de8d2f16fcb9064653">setUniformValue_</a> (const char *const name, const bool value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classStelGLSLShader.html#a1cb0bfb1ee5b44b453cdfb3382cea6a4" title="Set value of a uniform shader variable.">setUniformValue()</a> implementation for type bool.  <a href="#a0047941dae7309de8d2f16fcb9064653"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#ac3023513bbb3dd149985b4a82f085a9a">setUniformValue_</a> (const char *const name, const int value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classStelGLSLShader.html#a1cb0bfb1ee5b44b453cdfb3382cea6a4" title="Set value of a uniform shader variable.">setUniformValue()</a> implementation for type int.  <a href="#ac3023513bbb3dd149985b4a82f085a9a"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class <a class="el" href="classStelQGL2Renderer.html">StelQGL2Renderer</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#a04fa3a6d2b610b3c5724ed05d55f5874">renderer</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Renderer that created this shader.  <a href="#a04fa3a6d2b610b3c5724ed05d55f5874"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QVector&lt; QGLShader * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#a9f2dd55d587dbd5443c1d41329318c87">defaultVertexShaders</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Vertex shaders that are always linked in (added by the nameless <a class="el" href="classStelQGLGLSLShader.html#a3622e52fdd0dbd362cb4e334b6cae82c" title="Add a vertex shader from source, compiling it in the process.">addVertexShader()</a> overload).  <a href="#a9f2dd55d587dbd5443c1d41329318c87"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QMap&lt; QString, OptionalShader &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#a565391e4284b3badb980a09291885084">namedVertexShaders</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Optional vertex shaders that may be enabled or disabled.  <a href="#a565391e4284b3badb980a09291885084"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QVector&lt; QGLShader * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#a2a38374f92387679f023bb1d202a0540">defaultFragmentShaders</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fragment shaders that are always linked in (added by the nameless <a class="el" href="classStelQGLGLSLShader.html#ae256bbd5a3bd9c0be0017919ba95f2cb" title="Add a fragment shader from source, compiling it in the process.">addFragmentShader()</a> overload).  <a href="#a2a38374f92387679f023bb1d202a0540"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QMap&lt; uintptr_t, <br class="typebreak"/>
QGLShaderProgram * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#aa78bede88d3b5459ca03b9f3559eeabf">programCache</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">All shader programs linked so far.  <a href="#aa78bede88d3b5459ca03b9f3559eeabf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QGLShaderProgram *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#abc2d5ce5297e4937215c82242c59481f">program</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Currently used shader program (linked from default and currently enabled shaders).  <a href="#abc2d5ce5297e4937215c82242c59481f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QString&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#a9fd83d7ef2e2c5ac29cc97e10e3a0996">aggregatedLog</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Log aggregated during all addXXXShader() and <a class="el" href="classStelQGLGLSLShader.html#afce8499cfc8a6a35c57a315f02bff25f" title="Build the shader program.">build()</a> calls.  <a href="#a9fd83d7ef2e2c5ac29cc97e10e3a0996"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">State&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#a19321a0ba32baa01d9ba9e3a24bb628e">state</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Current state of the shader.  <a href="#a19321a0ba32baa01d9ba9e3a24bb628e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#a6193d36aae27b3312a1a122fcfad159e">bound</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is the shader bound for drawing?  <a href="#a6193d36aae27b3312a1a122fcfad159e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#aec2685db40921e6f2c3c947f845a077f">useUnprojectedPosition_</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Does this shader need the <em>unprojectedVertex</em> attribute (position before <a class="el" href="classStelProjector.html" title="Provide the main interface to all operations of projecting coordinates from sky to...">StelProjector</a> projection) ?  <a href="#aec2685db40921e6f2c3c947f845a077f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#afae0785547c259be63c0d1a84cb061a2">internal</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is this an internal shader used by the renderer backend?  <a href="#afae0785547c259be63c0d1a84cb061a2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#a79eeb4a45f06b424ef54ead6944b9a3d">uniformStorage</a> [UNIFORM_STORAGE]</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Storage used for uniform data.  <a href="#a79eeb4a45f06b424ef54ead6944b9a3d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#ab1ab3c342f5397f1355129fefbc49f2d">uniformStoragePointer</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointer to uniformStorage[uniformStorageUsed]. Avoids breaking strict aliasing.  <a href="#ab1ab3c342f5397f1355129fefbc49f2d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#a822d864c42e34d66a623ddef2b9b56c4">uniformTypes</a> [MAX_UNIFORMS]</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Types of consecutive uniforms in uniformStorage.  <a href="#a822d864c42e34d66a623ddef2b9b56c4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#a0aa96f1a0f6ba78850f6384636d4694c">uniformNames</a> [MAX_UNIFORMS]</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Names of consecutive uniforms in uniformStorage.  <a href="#a0aa96f1a0f6ba78850f6384636d4694c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#a47cd60ceb84124f9fad3c44979ec3c3f">uniformStorageUsed</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bytes in uniformStorage used up at this moment.  <a href="#a47cd60ceb84124f9fad3c44979ec3c3f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#a2bac518707a795035d1b8688d0afb202">uniformCount</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Number of uniforms in uniformStorage at this moment.  <a href="#a2bac518707a795035d1b8688d0afb202"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#af52db252923a7ac39c645ba7122c03c0">uniformStorageUsedStack</a> [MAX_UNIFORMS]</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stack of uniformStorageUsed values used with pushUniformStorage/popUniformStorage.  <a href="#af52db252923a7ac39c645ba7122c03c0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#a22ba3cafd6c9b599e51440b8f4002c8c">uniformCountStack</a> [MAX_UNIFORMS]</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stack of uniformCount values used with pushUniformStorage/popUniformStorage.  <a href="#a22ba3cafd6c9b599e51440b8f4002c8c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#adb24900df95ca10bc0c4d2734472ed7f">uniformStorageStackSize</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Number of items in uniformStorageUsedStack and uniformCountStack.  <a href="#adb24900df95ca10bc0c4d2734472ed7f"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>QGL based <a class="el" href="classStelGLSLShader.html" title="GLSL shader program.">StelGLSLShader</a> implementation, used by the QGL2 renderer backend. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This is an internal class of the Renderer subsystem and should not be used elsewhere. </dd></dl>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00038">38</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a206cbfb25c246deb43e2e6b28f959058"></a><!-- doxytag: member="StelQGLGLSLShader::StelQGLGLSLShader" ref="a206cbfb25c246deb43e2e6b28f959058" args="(class StelQGL2Renderer *renderer, bool internal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StelQGLGLSLShader::StelQGLGLSLShader </td>
          <td>(</td>
          <td class="paramtype">class <a class="el" href="classStelQGL2Renderer.html">StelQGL2Renderer</a> *&nbsp;</td>
          <td class="paramname"> <em>renderer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>internal</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a <a class="el" href="classStelQGLGLSLShader.html" title="QGL based StelGLSLShader implementation, used by the QGL2 renderer backend.">StelQGLGLSLShader</a> owned by specified renderer. </p>
<p>Used by QGL2 renderer backend.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>renderer</em>&nbsp;</td><td>Renderer that created this shader. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>internal</em>&nbsp;</td><td>Is this shader internal to the renderer backend? (Not directly used by the user) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ae256bbd5a3bd9c0be0017919ba95f2cb"></a><!-- doxytag: member="StelQGLGLSLShader::addFragmentShader" ref="ae256bbd5a3bd9c0be0017919ba95f2cb" args="(const QString &amp;source)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool StelQGLGLSLShader::addFragmentShader </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a fragment shader from source, compiling it in the process. </p>
<p>This operation can fail. In case of failure, use <a class="el" href="classStelQGLGLSLShader.html#a91fe541891340fb1ff0b551aed3b0218" title="Return a string containing the error log of the shader.">log()</a> to find out the cause.</p>
<p>The shader must be unlocked when this is called.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>Source code of the shader. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if succesfully added and compiled, false otherwise. </dd></dl>

<p>Implements <a class="el" href="classStelGLSLShader.html#aa0124e11de0e4cdbf8384d202367faa0">StelGLSLShader</a>.</p>

</div>
</div>
<a class="anchor" id="a4f631cf343291ccbbf5799e594f67cd8"></a><!-- doxytag: member="StelQGLGLSLShader::addVertexShader" ref="a4f631cf343291ccbbf5799e594f67cd8" args="(const QString &amp;name, const QString &amp;source)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool StelQGLGLSLShader::addVertexShader </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a named (optional) vertex shader. </p>
<p>Named vertex shaders can be disabled and reenabled. (Unnamed shaders are always enabled.) This allows to dynamically exchange implementations of functions, making shaders modular. GLSL projection is an example of this.</p>
<p>The shader must be unlocked when this is called.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of the shader. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>Source code of the shader. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classStelGLSLShader.html#a3710da7bb448c5a30a3eadd9fee04c83">StelGLSLShader</a>.</p>

</div>
</div>
<a class="anchor" id="a3622e52fdd0dbd362cb4e334b6cae82c"></a><!-- doxytag: member="StelQGLGLSLShader::addVertexShader" ref="a3622e52fdd0dbd362cb4e334b6cae82c" args="(const QString &amp;source)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool StelQGLGLSLShader::addVertexShader </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a vertex shader from source, compiling it in the process. </p>
<p>This operation can fail. In case of failure, use <a class="el" href="classStelQGLGLSLShader.html#a91fe541891340fb1ff0b551aed3b0218" title="Return a string containing the error log of the shader.">log()</a> to find out the cause.</p>
<p>The shader must be unlocked when this is called.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>Source code of the shader. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if succesfully added and compiled, false otherwise. </dd></dl>

<p>Implements <a class="el" href="classStelGLSLShader.html#a278e2dd210b77aad002f6750e5078126">StelGLSLShader</a>.</p>

</div>
</div>
<a class="anchor" id="aa77410a83e7cb4acb698b52e6356ccc8"></a><!-- doxytag: member="StelQGLGLSLShader::bind" ref="aa77410a83e7cb4acb698b52e6356ccc8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelQGLGLSLShader::bind </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Bind the shader, using it for following draw calls. </p>
<p>This must be called before setting uniforms. The shader must be built when this is called.</p>
<p>Note that the shader must be released after any draw calls using the shader to allow default shaders to return to use. </p>

<p>Implements <a class="el" href="classStelGLSLShader.html#a7f5a6d53ef5352efcbfea770666e8c44">StelGLSLShader</a>.</p>

</div>
</div>
<a class="anchor" id="afce8499cfc8a6a35c57a315f02bff25f"></a><!-- doxytag: member="StelQGLGLSLShader::build" ref="afce8499cfc8a6a35c57a315f02bff25f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool StelQGLGLSLShader::build </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Build the shader program. </p>
<p>This must be called before the shader can be bound.</p>
<p>This operation can fail. In case of failure, use <a class="el" href="classStelQGLGLSLShader.html#a91fe541891340fb1ff0b551aed3b0218" title="Return a string containing the error log of the shader.">log()</a> to find out the cause. If <a class="el" href="classStelQGLGLSLShader.html#afce8499cfc8a6a35c57a315f02bff25f" title="Build the shader program.">build()</a> fails, the shader should be assumed to no longer be usable and be destroyed.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if succesfully built, false otherwise. </dd></dl>

<p>Implements <a class="el" href="classStelGLSLShader.html#a58cae3e4a1916cf6bd07cd5c58b9b34a">StelGLSLShader</a>.</p>

</div>
</div>
<a class="anchor" id="a37004c3b1e983f0d3e0803c09f2c19fa"></a><!-- doxytag: member="StelQGLGLSLShader::clearUniforms" ref="a37004c3b1e983f0d3e0803c09f2c19fa" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void StelQGLGLSLShader::clearUniforms </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clear all stored uniforms, freeing uniform storage. </p>
<p>Called by <a class="el" href="classStelQGLGLSLShader.html#af6092a51ab7d0ae0f6640c9bf14530d5" title="Release a bound shader after use.">release()</a>. </p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00320">320</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa7edd3270500c4162a62c3e8dc761721"></a><!-- doxytag: member="StelQGLGLSLShader::disableVertexShader" ref="aa7edd3270500c4162a62c3e8dc761721" args="(const QString &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelQGLGLSLShader::disableVertexShader </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disable previously added named vertex shader. </p>
<p>The shader must be unlocked when this is called.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of the shader to disable. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classStelGLSLShader.html#ad695c0b27278e31db94682deb31d16a5">StelGLSLShader</a>.</p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00171">171</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2df5e9b94a5f39cd733728845ef62d52"></a><!-- doxytag: member="StelQGLGLSLShader::enableVertexShader" ref="a2df5e9b94a5f39cd733728845ef62d52" args="(const QString &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelQGLGLSLShader::enableVertexShader </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enable previously added named vertex shader. </p>
<p>The shader must be unlocked when this is called.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of the shader to enable. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classStelGLSLShader.html#ad1554e9e078314b55eeda310b25ebdad">StelGLSLShader</a>.</p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00158">158</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a932c0f77d67e910b5b59df7183883fa0"></a><!-- doxytag: member="StelQGLGLSLShader::getProgram" ref="a932c0f77d67e910b5b59df7183883fa0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QGLShaderProgram&amp; StelQGLGLSLShader::getProgram </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a reference to the current underlying shader program. </p>
<p>Used by QGL2 renderer backend. </p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00196">196</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af9db84b9cbed6ee5428bb2a1dde61c1f"></a><!-- doxytag: member="StelQGLGLSLShader::hasVertexShader" ref="af9db84b9cbed6ee5428bb2a1dde61c1f" args="(const QString &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool StelQGLGLSLShader::hasVertexShader </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Has a named vertex shader with specified name been added? </p>

<p>Implements <a class="el" href="classStelGLSLShader.html#aa344eb43fedd32b0e2b87fca9bd053bd">StelGLSLShader</a>.</p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00153">153</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a91fe541891340fb1ff0b551aed3b0218"></a><!-- doxytag: member="StelQGLGLSLShader::log" ref="a91fe541891340fb1ff0b551aed3b0218" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual QString StelQGLGLSLShader::log </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a string containing the error log of the shader. </p>
<p>If the shader is succesfully built, it will contain a success message. It might also contain GLSL code warnings. </p>

<p>Implements <a class="el" href="classStelGLSLShader.html#a5ae3dd75f20c33c3a72d987585b44f1b">StelGLSLShader</a>.</p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00133">133</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab9e1c9cc088ae08d414e4fdd0fea948a"></a><!-- doxytag: member="StelQGLGLSLShader::popUniformStorage" ref="ab9e1c9cc088ae08d414e4fdd0fea948a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void StelQGLGLSLShader::popUniformStorage </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Restores pushed uniform storage stage. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classStelQGLGLSLShader.html#a341bdd163ed3e8cecd279e15e5f8d16c" title="Push uniform storage state.">pushUniformStorage</a> </dd></dl>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00305">305</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a341bdd163ed3e8cecd279e15e5f8d16c"></a><!-- doxytag: member="StelQGLGLSLShader::pushUniformStorage" ref="a341bdd163ed3e8cecd279e15e5f8d16c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void StelQGLGLSLShader::pushUniformStorage </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Push uniform storage state. </p>
<p>This is an optimization used internally by the renderer backend. This "saves" the state of uniform storage, allowing to "restore" it by calling <a class="el" href="classStelQGLGLSLShader.html#ab9e1c9cc088ae08d414e4fdd0fea948a" title="Restores pushed uniform storage stage.">popUniformStorage()</a>. This prevents the internal uniform-setting in repeated draw calls from filling the entire uniform storage.</p>
<p>How this works:</p>
<p>Setting uniforms just appends new data to uniform storage; setting the same uniform multiple times just uses more data (determining if a uniform with this name was set already would be expensive).</p>
<p><a class="el" href="classStelQGLGLSLShader.html#a341bdd163ed3e8cecd279e15e5f8d16c" title="Push uniform storage state.">pushUniformStorage()</a> pushes the number of uniforms and used storage to an internal stack. <a class="el" href="classStelQGLGLSLShader.html#ab9e1c9cc088ae08d414e4fdd0fea948a" title="Restores pushed uniform storage stage.">popUniformStorage()</a> restores this state, throwing away any uniforms set since the push. </p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00291">291</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af6092a51ab7d0ae0f6640c9bf14530d5"></a><!-- doxytag: member="StelQGLGLSLShader::release" ref="af6092a51ab7d0ae0f6640c9bf14530d5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelQGLGLSLShader::release </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Release a bound shader after use. </p>
<p>This must be called after using the shader so that the <a class="el" href="classStelRenderer.html" title="Main class of the Renderer subsystem.">StelRenderer</a> backend can go back to using default shaders.</p>
<p>It also must be called before <a class="el" href="classStelQGLGLSLShader.html#aa77410a83e7cb4acb698b52e6356ccc8" title="Bind the shader, using it for following draw calls.">bind()</a>-ing another <a class="el" href="classStelGLSLShader.html" title="GLSL shader program.">StelGLSLShader</a>. </p>

<p>Implements <a class="el" href="classStelGLSLShader.html#ad5f3315bf08b16dec2d478fdbe0211f6">StelGLSLShader</a>.</p>

</div>
</div>
<a class="anchor" id="ac3023513bbb3dd149985b4a82f085a9a"></a><!-- doxytag: member="StelQGLGLSLShader::setUniformValue_" ref="ac3023513bbb3dd149985b4a82f085a9a" args="(const char *const name, const int value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelQGLGLSLShader::setUniformValue_ </td>
          <td>(</td>
          <td class="paramtype">const char *const &nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classStelGLSLShader.html#a1cb0bfb1ee5b44b453cdfb3382cea6a4" title="Set value of a uniform shader variable.">setUniformValue()</a> implementation for type int. </p>

<p>Implements <a class="el" href="classStelGLSLShader.html#ae75cfbb3292457627d12f43e4bf315a5">StelGLSLShader</a>.</p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00521">521</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0047941dae7309de8d2f16fcb9064653"></a><!-- doxytag: member="StelQGLGLSLShader::setUniformValue_" ref="a0047941dae7309de8d2f16fcb9064653" args="(const char *const name, const bool value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelQGLGLSLShader::setUniformValue_ </td>
          <td>(</td>
          <td class="paramtype">const char *const &nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classStelGLSLShader.html#a1cb0bfb1ee5b44b453cdfb3382cea6a4" title="Set value of a uniform shader variable.">setUniformValue()</a> implementation for type bool. </p>

<p>Implements <a class="el" href="classStelGLSLShader.html#a214c10ea3ff04c5589e047e5aaf78467">StelGLSLShader</a>.</p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00506">506</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acce297bc9acde642067b4fe946fe06ca"></a><!-- doxytag: member="StelQGLGLSLShader::setUniformValue_" ref="acce297bc9acde642067b4fe946fe06ca" args="(const char *const name, const Mat4f &amp;m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelQGLGLSLShader::setUniformValue_ </td>
          <td>(</td>
          <td class="paramtype">const char *const &nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrix4.html">Mat4f</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classStelGLSLShader.html#a1cb0bfb1ee5b44b453cdfb3382cea6a4" title="Set value of a uniform shader variable.">setUniformValue()</a> implementation for type Mat4f. </p>

<p>Implements <a class="el" href="classStelGLSLShader.html#a8d3aa6519199afd04a9a35739d1f1224">StelGLSLShader</a>.</p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00491">491</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adbf755525e35371a075446caaef2d82b"></a><!-- doxytag: member="StelQGLGLSLShader::setUniformValue_" ref="adbf755525e35371a075446caaef2d82b" args="(const char *const name, const Vec4f &amp;value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelQGLGLSLShader::setUniformValue_ </td>
          <td>(</td>
          <td class="paramtype">const char *const &nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector4.html">Vec4f</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classStelGLSLShader.html#a1cb0bfb1ee5b44b453cdfb3382cea6a4" title="Set value of a uniform shader variable.">setUniformValue()</a> implementation for type Vec4f. </p>

<p>Implements <a class="el" href="classStelGLSLShader.html#af78d1988cf91914e098d1985309a314c">StelGLSLShader</a>.</p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00476">476</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5a0e34af39318399cc0467cd0fc3841f"></a><!-- doxytag: member="StelQGLGLSLShader::setUniformValue_" ref="a5a0e34af39318399cc0467cd0fc3841f" args="(const char *const name, const Vec3f &amp;value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelQGLGLSLShader::setUniformValue_ </td>
          <td>(</td>
          <td class="paramtype">const char *const &nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector3.html">Vec3f</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classStelGLSLShader.html#a1cb0bfb1ee5b44b453cdfb3382cea6a4" title="Set value of a uniform shader variable.">setUniformValue()</a> implementation for type Vec3f. </p>

<p>Implements <a class="el" href="classStelGLSLShader.html#a8bee668c13ea947c5df973fa54e05d23">StelGLSLShader</a>.</p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00461">461</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adc6d335b09ac9090f004accb5abb50d1"></a><!-- doxytag: member="StelQGLGLSLShader::setUniformValue_" ref="adc6d335b09ac9090f004accb5abb50d1" args="(const char *const name, const Vec2f value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelQGLGLSLShader::setUniformValue_ </td>
          <td>(</td>
          <td class="paramtype">const char *const &nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector2.html">Vec2f</a>&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classStelGLSLShader.html#a1cb0bfb1ee5b44b453cdfb3382cea6a4" title="Set value of a uniform shader variable.">setUniformValue()</a> implementation for type Vec2f. </p>

<p>Implements <a class="el" href="classStelGLSLShader.html#a69f821fa909e80d8f57ef6e0656d0362">StelGLSLShader</a>.</p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00446">446</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6777673cd29406dd71a763ae4006e90f"></a><!-- doxytag: member="StelQGLGLSLShader::setUniformValue_" ref="a6777673cd29406dd71a763ae4006e90f" args="(const char *const name, const float value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelQGLGLSLShader::setUniformValue_ </td>
          <td>(</td>
          <td class="paramtype">const char *const &nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classStelGLSLShader.html#a1cb0bfb1ee5b44b453cdfb3382cea6a4" title="Set value of a uniform shader variable.">setUniformValue()</a> implementation for type float. </p>

<p>Implements <a class="el" href="classStelGLSLShader.html#ac1d01a179e3708399b25e0bc039eb321">StelGLSLShader</a>.</p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00432">432</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a77cee9a54b10362701642fa443a9995a"></a><!-- doxytag: member="StelQGLGLSLShader::unlock" ref="a77cee9a54b10362701642fa443a9995a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelQGLGLSLShader::unlock </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unlock the shader program for modifications. </p>
<p>Allows to, add, enable, disable vertex/fragment shaders.</p>
<p>This can be called even if the shader is bound (which is used for last-moment modifications, like GLSL projection in renderer backend), but it must be rebuilt before drawing and releasing. </p>

<p>Implements <a class="el" href="classStelGLSLShader.html#a725669d679573be1e6a9c8af2efbd708">StelGLSLShader</a>.</p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00138">138</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad055f5447dde2b203e503e56ebcc4343"></a><!-- doxytag: member="StelQGLGLSLShader::uploadUniforms" ref="ad055f5447dde2b203e503e56ebcc4343" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void StelQGLGLSLShader::uploadUniforms </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Upload the stored uniform variables. </p>
<p>Called when the internally used shader program has been bound, before drawing, by the drawVertexBufferBackend() member function of the renderer backend. </p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00215">215</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0b1f7c271bde1be2a1c3b1476d7d5bd7"></a><!-- doxytag: member="StelQGLGLSLShader::useUnprojectedPosition" ref="a0b1f7c271bde1be2a1c3b1476d7d5bd7" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool StelQGLGLSLShader::useUnprojectedPosition </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Does this shader need the unprojected vertex position attribute? </p>
<p>Used by vertex buffer backend to determine if this attribute should be provided. </p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00206">206</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2afb696e7f20bf5deb14e28aea141a10"></a><!-- doxytag: member="StelQGLGLSLShader::useUnprojectedPositionAttribute" ref="a2afb696e7f20bf5deb14e28aea141a10" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelQGLGLSLShader::useUnprojectedPositionAttribute </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Does this shader need the unprojected position attribute? </p>
<p>If called, the shader will have to declare another vertex attribute, <em>unprojectedVertex</em>, for vertex position before <a class="el" href="classStelProjector.html" title="Provide the main interface to all operations of projecting coordinates from sky to...">StelProjector</a> projection. Useful e.g. for lighting. </p>

<p>Implements <a class="el" href="classStelGLSLShader.html#a687a8efacfc1e876a754fe14c66e80eb">StelGLSLShader</a>.</p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00188">188</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a9fd83d7ef2e2c5ac29cc97e10e3a0996"></a><!-- doxytag: member="StelQGLGLSLShader::aggregatedLog" ref="a9fd83d7ef2e2c5ac29cc97e10e3a0996" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QString <a class="el" href="classStelQGLGLSLShader.html#a9fd83d7ef2e2c5ac29cc97e10e3a0996">StelQGLGLSLShader::aggregatedLog</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Log aggregated during all addXXXShader() and <a class="el" href="classStelQGLGLSLShader.html#afce8499cfc8a6a35c57a315f02bff25f" title="Build the shader program.">build()</a> calls. </p>
<p>May be aggregated from multiple vertex programs if built multiple times with different shaders enabled. </p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00372">372</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6193d36aae27b3312a1a122fcfad159e"></a><!-- doxytag: member="StelQGLGLSLShader::bound" ref="a6193d36aae27b3312a1a122fcfad159e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classStelQGLGLSLShader.html#a6193d36aae27b3312a1a122fcfad159e">StelQGLGLSLShader::bound</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Is the shader bound for drawing? </p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00378">378</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2a38374f92387679f023bb1d202a0540"></a><!-- doxytag: member="StelQGLGLSLShader::defaultFragmentShaders" ref="a2a38374f92387679f023bb1d202a0540" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QVector&lt;QGLShader*&gt; <a class="el" href="classStelQGLGLSLShader.html#a2a38374f92387679f023bb1d202a0540">StelQGLGLSLShader::defaultFragmentShaders</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fragment shaders that are always linked in (added by the nameless <a class="el" href="classStelQGLGLSLShader.html#ae256bbd5a3bd9c0be0017919ba95f2cb" title="Add a fragment shader from source, compiling it in the process.">addFragmentShader()</a> overload). </p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00341">341</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9f2dd55d587dbd5443c1d41329318c87"></a><!-- doxytag: member="StelQGLGLSLShader::defaultVertexShaders" ref="a9f2dd55d587dbd5443c1d41329318c87" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QVector&lt;QGLShader*&gt; <a class="el" href="classStelQGLGLSLShader.html#a9f2dd55d587dbd5443c1d41329318c87">StelQGLGLSLShader::defaultVertexShaders</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Vertex shaders that are always linked in (added by the nameless <a class="el" href="classStelQGLGLSLShader.html#a3622e52fdd0dbd362cb4e334b6cae82c" title="Add a vertex shader from source, compiling it in the process.">addVertexShader()</a> overload). </p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00334">334</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afae0785547c259be63c0d1a84cb061a2"></a><!-- doxytag: member="StelQGLGLSLShader::internal" ref="afae0785547c259be63c0d1a84cb061a2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="classStelQGLGLSLShader.html#afae0785547c259be63c0d1a84cb061a2">StelQGLGLSLShader::internal</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Is this an internal shader used by the renderer backend? </p>
<p>Needed to avoing bind/release from calling renderer backend custom shader bind/release. </p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00387">387</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a565391e4284b3badb980a09291885084"></a><!-- doxytag: member="StelQGLGLSLShader::namedVertexShaders" ref="a565391e4284b3badb980a09291885084" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QMap&lt;QString, OptionalShader&gt; <a class="el" href="classStelQGLGLSLShader.html#a565391e4284b3badb980a09291885084">StelQGLGLSLShader::namedVertexShaders</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Optional vertex shaders that may be enabled or disabled. </p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00337">337</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abc2d5ce5297e4937215c82242c59481f"></a><!-- doxytag: member="StelQGLGLSLShader::program" ref="abc2d5ce5297e4937215c82242c59481f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QGLShaderProgram* <a class="el" href="classStelQGLGLSLShader.html#abc2d5ce5297e4937215c82242c59481f">StelQGLGLSLShader::program</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Currently used shader program (linked from default and currently enabled shaders). </p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00366">366</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa78bede88d3b5459ca03b9f3559eeabf"></a><!-- doxytag: member="StelQGLGLSLShader::programCache" ref="aa78bede88d3b5459ca03b9f3559eeabf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QMap&lt;uintptr_t, QGLShaderProgram*&gt; <a class="el" href="classStelQGLGLSLShader.html#aa78bede88d3b5459ca03b9f3559eeabf">StelQGLGLSLShader::programCache</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>All shader programs linked so far. </p>
<p>When <a class="el" href="classStelQGLGLSLShader.html#afce8499cfc8a6a35c57a315f02bff25f" title="Build the shader program.">build()</a> is called, the default and currently enabled optional shaders are linked to a shader program. As re-linking shaders on each frame would be too expensive, any shader combination is only linked once and then retrieved from this cache.</p>
<p><a class="el" href="classStelQGLGLSLShader.html#afce8499cfc8a6a35c57a315f02bff25f" title="Build the shader program.">build()</a> is called for each draw call (due to modular shaders being used for vertex projection), so the lookup must be very fast. The ID used for lookup - a 64 bit unsigned integer, is a sum of pointers of all shaders linked in the program.</p>
<p>It is not impossible for false positives to happen, but it's very unlikely. 64bit is not going to overflow any soon (you need a 16EiB address space for that), and as shaders are never deleted or moved in memory, two shaders can never have identical pointers. Then only risk is that two sets of pointers will accidentally add up to the same number, but this is very unlikely as well.</p>
<p>In case this happens, some very simple hash algorithm (still on pointers) might be used instead. </p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00363">363</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a04fa3a6d2b610b3c5724ed05d55f5874"></a><!-- doxytag: member="StelQGLGLSLShader::renderer" ref="a04fa3a6d2b610b3c5724ed05d55f5874" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="classStelQGL2Renderer.html">StelQGL2Renderer</a>* <a class="el" href="classStelQGLGLSLShader.html#a04fa3a6d2b610b3c5724ed05d55f5874">StelQGLGLSLShader::renderer</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Renderer that created this shader. </p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00331">331</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a19321a0ba32baa01d9ba9e3a24bb628e"></a><!-- doxytag: member="StelQGLGLSLShader::state" ref="a19321a0ba32baa01d9ba9e3a24bb628e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">State <a class="el" href="classStelQGLGLSLShader.html#a19321a0ba32baa01d9ba9e3a24bb628e">StelQGLGLSLShader::state</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Current state of the shader. </p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00375">375</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2bac518707a795035d1b8688d0afb202"></a><!-- doxytag: member="StelQGLGLSLShader::uniformCount" ref="a2bac518707a795035d1b8688d0afb202" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classStelQGLGLSLShader.html#a2bac518707a795035d1b8688d0afb202">StelQGLGLSLShader::uniformCount</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Number of uniforms in uniformStorage at this moment. </p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00417">417</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a22ba3cafd6c9b599e51440b8f4002c8c"></a><!-- doxytag: member="StelQGLGLSLShader::uniformCountStack" ref="a22ba3cafd6c9b599e51440b8f4002c8c" args="[MAX_UNIFORMS]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char <a class="el" href="classStelQGLGLSLShader.html#a22ba3cafd6c9b599e51440b8f4002c8c">StelQGLGLSLShader::uniformCountStack</a>[MAX_UNIFORMS]<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Stack of uniformCount values used with pushUniformStorage/popUniformStorage. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classStelQGLGLSLShader.html#a341bdd163ed3e8cecd279e15e5f8d16c" title="Push uniform storage state.">pushUniformStorage</a>, <a class="el" href="classStelQGLGLSLShader.html#ab9e1c9cc088ae08d414e4fdd0fea948a" title="Restores pushed uniform storage stage.">popUniformStorage</a> </dd></dl>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00427">427</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0aa96f1a0f6ba78850f6384636d4694c"></a><!-- doxytag: member="StelQGLGLSLShader::uniformNames" ref="a0aa96f1a0f6ba78850f6384636d4694c" args="[MAX_UNIFORMS]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* <a class="el" href="classStelQGLGLSLShader.html#a0aa96f1a0f6ba78850f6384636d4694c">StelQGLGLSLShader::uniformNames</a>[MAX_UNIFORMS]<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Names of consecutive uniforms in uniformStorage. </p>
<p>We don't own these strings, we just have pointers to them. This means the user code needs to preserve the string until <a class="el" href="classStelQGLGLSLShader.html#af6092a51ab7d0ae0f6640c9bf14530d5" title="Release a bound shader after use.">release()</a> is called. </p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00411">411</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a79eeb4a45f06b424ef54ead6944b9a3d"></a><!-- doxytag: member="StelQGLGLSLShader::uniformStorage" ref="a79eeb4a45f06b424ef54ead6944b9a3d" args="[UNIFORM_STORAGE]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char <a class="el" href="classStelQGLGLSLShader.html#a79eeb4a45f06b424ef54ead6944b9a3d">StelQGLGLSLShader::uniformStorage</a>[UNIFORM_STORAGE]<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Storage used for uniform data. </p>
<p>As we're linking shaders dynamically and the final shader program is only bound directly before drawing, we need to delay uniform upload until that point. Therefore, setUniformValue_ functions just add data to this storage. The data is then uploaded by <a class="el" href="classStelQGLGLSLShader.html#ad055f5447dde2b203e503e56ebcc4343" title="Upload the stored uniform variables.">uploadUniforms()</a>.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classStelQGLGLSLShader.html#ad055f5447dde2b203e503e56ebcc4343" title="Upload the stored uniform variables.">uploadUniforms</a>, <a class="el" href="classStelQGLGLSLShader.html#a37004c3b1e983f0d3e0803c09f2c19fa" title="Clear all stored uniforms, freeing uniform storage.">clearUniforms</a>, <a class="el" href="classStelQGLGLSLShader.html#a341bdd163ed3e8cecd279e15e5f8d16c" title="Push uniform storage state.">pushUniformStorage</a> </dd></dl>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00397">397</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab1ab3c342f5397f1355129fefbc49f2d"></a><!-- doxytag: member="StelQGLGLSLShader::uniformStoragePointer" ref="ab1ab3c342f5397f1355129fefbc49f2d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classStelQGLGLSLShader.html#ab1ab3c342f5397f1355129fefbc49f2d">StelQGLGLSLShader::uniformStoragePointer</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pointer to uniformStorage[uniformStorageUsed]. Avoids breaking strict aliasing. </p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00400">400</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adb24900df95ca10bc0c4d2734472ed7f"></a><!-- doxytag: member="StelQGLGLSLShader::uniformStorageStackSize" ref="adb24900df95ca10bc0c4d2734472ed7f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classStelQGLGLSLShader.html#adb24900df95ca10bc0c4d2734472ed7f">StelQGLGLSLShader::uniformStorageStackSize</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Number of items in uniformStorageUsedStack and uniformCountStack. </p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00430">430</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a47cd60ceb84124f9fad3c44979ec3c3f"></a><!-- doxytag: member="StelQGLGLSLShader::uniformStorageUsed" ref="a47cd60ceb84124f9fad3c44979ec3c3f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classStelQGLGLSLShader.html#a47cd60ceb84124f9fad3c44979ec3c3f">StelQGLGLSLShader::uniformStorageUsed</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Bytes in uniformStorage used up at this moment. </p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00414">414</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af52db252923a7ac39c645ba7122c03c0"></a><!-- doxytag: member="StelQGLGLSLShader::uniformStorageUsedStack" ref="af52db252923a7ac39c645ba7122c03c0" args="[MAX_UNIFORMS]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classStelQGLGLSLShader.html#af52db252923a7ac39c645ba7122c03c0">StelQGLGLSLShader::uniformStorageUsedStack</a>[MAX_UNIFORMS]<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Stack of uniformStorageUsed values used with pushUniformStorage/popUniformStorage. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classStelQGLGLSLShader.html#a341bdd163ed3e8cecd279e15e5f8d16c" title="Push uniform storage state.">pushUniformStorage</a>, <a class="el" href="classStelQGLGLSLShader.html#ab9e1c9cc088ae08d414e4fdd0fea948a" title="Restores pushed uniform storage stage.">popUniformStorage</a> </dd></dl>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00422">422</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a822d864c42e34d66a623ddef2b9b56c4"></a><!-- doxytag: member="StelQGLGLSLShader::uniformTypes" ref="a822d864c42e34d66a623ddef2b9b56c4" args="[MAX_UNIFORMS]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char <a class="el" href="classStelQGLGLSLShader.html#a822d864c42e34d66a623ddef2b9b56c4">StelQGLGLSLShader::uniformTypes</a>[MAX_UNIFORMS]<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Types of consecutive uniforms in uniformStorage. </p>
<p>Needed to interpret uniformStorage data when uploading. </p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00405">405</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aec2685db40921e6f2c3c947f845a077f"></a><!-- doxytag: member="StelQGLGLSLShader::useUnprojectedPosition_" ref="aec2685db40921e6f2c3c947f845a077f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classStelQGLGLSLShader.html#aec2685db40921e6f2c3c947f845a077f">StelQGLGLSLShader::useUnprojectedPosition_</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Does this shader need the <em>unprojectedVertex</em> attribute (position before <a class="el" href="classStelProjector.html" title="Provide the main interface to all operations of projecting coordinates from sky to...">StelProjector</a> projection) ? </p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00382">382</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>core/renderer/<a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a></li>
</ul>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Wed Sep 26 20:39:33 2012 for Stellarium by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
