<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Stellarium: StelQGLGLSLShader Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="stellarium-logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Stellarium 0.12.1</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="codingStyle.html"><span>Coding&#160;Style</span></a></li>
      <li><a href="scripting.html"><span>Scripting</span></a></li>
      <li><a href="plugins.html"><span>Plugins</span></a></li>
      <li><a href="renderer.html"><span>Renderer</span></a></li>
      <li><a href="fileStructure.html"><span>File&#160;Structure</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classStelQGLGLSLShader-members.html">List of all members</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">StelQGLGLSLShader Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>QGL based <a class="el" href="classStelGLSLShader.html" title="GLSL shader program.">StelGLSLShader</a> implementation, used by the QGL2 renderer backend.  
 <a href="classStelQGLGLSLShader.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a206cbfb25c246deb43e2e6b28f959058"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#a206cbfb25c246deb43e2e6b28f959058">StelQGLGLSLShader</a> (class <a class="el" href="classStelQGL2Renderer.html">StelQGL2Renderer</a> *<a class="el" href="classStelQGLGLSLShader.html#a04fa3a6d2b610b3c5724ed05d55f5874">renderer</a>, bool <a class="el" href="classStelQGLGLSLShader.html#afae0785547c259be63c0d1a84cb061a2">internal</a>)</td></tr>
<tr class="memdesc:a206cbfb25c246deb43e2e6b28f959058"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classStelQGLGLSLShader.html" title="QGL based StelGLSLShader implementation, used by the QGL2 renderer backend.">StelQGLGLSLShader</a> owned by specified renderer.  <a href="#a206cbfb25c246deb43e2e6b28f959058">More...</a><br/></td></tr>
<tr class="separator:a206cbfb25c246deb43e2e6b28f959058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3622e52fdd0dbd362cb4e334b6cae82c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#a3622e52fdd0dbd362cb4e334b6cae82c">addVertexShader</a> (const QString &amp;source)</td></tr>
<tr class="memdesc:a3622e52fdd0dbd362cb4e334b6cae82c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a vertex shader from source, compiling it in the process.  <a href="#a3622e52fdd0dbd362cb4e334b6cae82c">More...</a><br/></td></tr>
<tr class="separator:a3622e52fdd0dbd362cb4e334b6cae82c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae256bbd5a3bd9c0be0017919ba95f2cb"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#ae256bbd5a3bd9c0be0017919ba95f2cb">addFragmentShader</a> (const QString &amp;source)</td></tr>
<tr class="memdesc:ae256bbd5a3bd9c0be0017919ba95f2cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a fragment shader from source, compiling it in the process.  <a href="#ae256bbd5a3bd9c0be0017919ba95f2cb">More...</a><br/></td></tr>
<tr class="separator:ae256bbd5a3bd9c0be0017919ba95f2cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce8499cfc8a6a35c57a315f02bff25f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#afce8499cfc8a6a35c57a315f02bff25f">build</a> ()</td></tr>
<tr class="memdesc:afce8499cfc8a6a35c57a315f02bff25f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the shader program.  <a href="#afce8499cfc8a6a35c57a315f02bff25f">More...</a><br/></td></tr>
<tr class="separator:afce8499cfc8a6a35c57a315f02bff25f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91fe541891340fb1ff0b551aed3b0218"><td class="memItemLeft" align="right" valign="top">virtual QString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#a91fe541891340fb1ff0b551aed3b0218">log</a> () const </td></tr>
<tr class="memdesc:a91fe541891340fb1ff0b551aed3b0218"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a string containing the error log of the shader.  <a href="#a91fe541891340fb1ff0b551aed3b0218">More...</a><br/></td></tr>
<tr class="separator:a91fe541891340fb1ff0b551aed3b0218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77cee9a54b10362701642fa443a9995a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#a77cee9a54b10362701642fa443a9995a">unlock</a> ()</td></tr>
<tr class="memdesc:a77cee9a54b10362701642fa443a9995a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock the shader program for modifications.  <a href="#a77cee9a54b10362701642fa443a9995a">More...</a><br/></td></tr>
<tr class="separator:a77cee9a54b10362701642fa443a9995a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f631cf343291ccbbf5799e594f67cd8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#a4f631cf343291ccbbf5799e594f67cd8">addVertexShader</a> (const QString &amp;name, const QString &amp;source)</td></tr>
<tr class="memdesc:a4f631cf343291ccbbf5799e594f67cd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a named (optional) vertex shader.  <a href="#a4f631cf343291ccbbf5799e594f67cd8">More...</a><br/></td></tr>
<tr class="separator:a4f631cf343291ccbbf5799e594f67cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9db84b9cbed6ee5428bb2a1dde61c1f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#af9db84b9cbed6ee5428bb2a1dde61c1f">hasVertexShader</a> (const QString &amp;name) const </td></tr>
<tr class="memdesc:af9db84b9cbed6ee5428bb2a1dde61c1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has a named vertex shader with specified name been added?  <a href="#af9db84b9cbed6ee5428bb2a1dde61c1f">More...</a><br/></td></tr>
<tr class="separator:af9db84b9cbed6ee5428bb2a1dde61c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2df5e9b94a5f39cd733728845ef62d52"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#a2df5e9b94a5f39cd733728845ef62d52">enableVertexShader</a> (const QString &amp;name)</td></tr>
<tr class="memdesc:a2df5e9b94a5f39cd733728845ef62d52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable previously added named vertex shader.  <a href="#a2df5e9b94a5f39cd733728845ef62d52">More...</a><br/></td></tr>
<tr class="separator:a2df5e9b94a5f39cd733728845ef62d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7edd3270500c4162a62c3e8dc761721"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#aa7edd3270500c4162a62c3e8dc761721">disableVertexShader</a> (const QString &amp;name)</td></tr>
<tr class="memdesc:aa7edd3270500c4162a62c3e8dc761721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable previously added named vertex shader.  <a href="#aa7edd3270500c4162a62c3e8dc761721">More...</a><br/></td></tr>
<tr class="separator:aa7edd3270500c4162a62c3e8dc761721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa77410a83e7cb4acb698b52e6356ccc8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#aa77410a83e7cb4acb698b52e6356ccc8">bind</a> ()</td></tr>
<tr class="memdesc:aa77410a83e7cb4acb698b52e6356ccc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind the shader, using it for following draw calls.  <a href="#aa77410a83e7cb4acb698b52e6356ccc8">More...</a><br/></td></tr>
<tr class="separator:aa77410a83e7cb4acb698b52e6356ccc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6092a51ab7d0ae0f6640c9bf14530d5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#af6092a51ab7d0ae0f6640c9bf14530d5">release</a> ()</td></tr>
<tr class="memdesc:af6092a51ab7d0ae0f6640c9bf14530d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release a bound shader after use.  <a href="#af6092a51ab7d0ae0f6640c9bf14530d5">More...</a><br/></td></tr>
<tr class="separator:af6092a51ab7d0ae0f6640c9bf14530d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2afb696e7f20bf5deb14e28aea141a10"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#a2afb696e7f20bf5deb14e28aea141a10">useUnprojectedPositionAttribute</a> ()</td></tr>
<tr class="memdesc:a2afb696e7f20bf5deb14e28aea141a10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this shader need the unprojected position attribute?  <a href="#a2afb696e7f20bf5deb14e28aea141a10">More...</a><br/></td></tr>
<tr class="separator:a2afb696e7f20bf5deb14e28aea141a10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a932c0f77d67e910b5b59df7183883fa0"><td class="memItemLeft" align="right" valign="top">QGLShaderProgram &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#a932c0f77d67e910b5b59df7183883fa0">getProgram</a> ()</td></tr>
<tr class="memdesc:a932c0f77d67e910b5b59df7183883fa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the current underlying shader program.  <a href="#a932c0f77d67e910b5b59df7183883fa0">More...</a><br/></td></tr>
<tr class="separator:a932c0f77d67e910b5b59df7183883fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b1f7c271bde1be2a1c3b1476d7d5bd7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#a0b1f7c271bde1be2a1c3b1476d7d5bd7">useUnprojectedPosition</a> () const </td></tr>
<tr class="memdesc:a0b1f7c271bde1be2a1c3b1476d7d5bd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this shader need the unprojected vertex position attribute?  <a href="#a0b1f7c271bde1be2a1c3b1476d7d5bd7">More...</a><br/></td></tr>
<tr class="separator:a0b1f7c271bde1be2a1c3b1476d7d5bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad055f5447dde2b203e503e56ebcc4343"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#ad055f5447dde2b203e503e56ebcc4343">uploadUniforms</a> ()</td></tr>
<tr class="memdesc:ad055f5447dde2b203e503e56ebcc4343"><td class="mdescLeft">&#160;</td><td class="mdescRight">Upload the stored uniform variables.  <a href="#ad055f5447dde2b203e503e56ebcc4343">More...</a><br/></td></tr>
<tr class="separator:ad055f5447dde2b203e503e56ebcc4343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a341bdd163ed3e8cecd279e15e5f8d16c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#a341bdd163ed3e8cecd279e15e5f8d16c">pushUniformStorage</a> ()</td></tr>
<tr class="memdesc:a341bdd163ed3e8cecd279e15e5f8d16c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push uniform storage state.  <a href="#a341bdd163ed3e8cecd279e15e5f8d16c">More...</a><br/></td></tr>
<tr class="separator:a341bdd163ed3e8cecd279e15e5f8d16c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9e1c9cc088ae08d414e4fdd0fea948a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#ab9e1c9cc088ae08d414e4fdd0fea948a">popUniformStorage</a> ()</td></tr>
<tr class="memdesc:ab9e1c9cc088ae08d414e4fdd0fea948a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restores pushed uniform storage stage.  <a href="#ab9e1c9cc088ae08d414e4fdd0fea948a">More...</a><br/></td></tr>
<tr class="separator:ab9e1c9cc088ae08d414e4fdd0fea948a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37004c3b1e983f0d3e0803c09f2c19fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#a37004c3b1e983f0d3e0803c09f2c19fa">clearUniforms</a> ()</td></tr>
<tr class="memdesc:a37004c3b1e983f0d3e0803c09f2c19fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear all stored uniforms, freeing uniform storage.  <a href="#a37004c3b1e983f0d3e0803c09f2c19fa">More...</a><br/></td></tr>
<tr class="separator:a37004c3b1e983f0d3e0803c09f2c19fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classStelGLSLShader"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classStelGLSLShader')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classStelGLSLShader.html">StelGLSLShader</a></td></tr>
<tr class="memitem:af0b201fd9eb62e7fea9d2c4c9a645688 inherit pub_methods_classStelGLSLShader"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelGLSLShader.html#af0b201fd9eb62e7fea9d2c4c9a645688">~StelGLSLShader</a> ()</td></tr>
<tr class="memdesc:af0b201fd9eb62e7fea9d2c4c9a645688 inherit pub_methods_classStelGLSLShader"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the shader program.  <a href="#af0b201fd9eb62e7fea9d2c4c9a645688">More...</a><br/></td></tr>
<tr class="separator:af0b201fd9eb62e7fea9d2c4c9a645688 inherit pub_methods_classStelGLSLShader"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bc28e48dec14620b194f613b9794bcb inherit pub_methods_classStelGLSLShader"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a9bc28e48dec14620b194f613b9794bcb inherit pub_methods_classStelGLSLShader"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classStelGLSLShader.html#a9bc28e48dec14620b194f613b9794bcb">setUniformValue</a> (const char *const name, T value)</td></tr>
<tr class="memdesc:a9bc28e48dec14620b194f613b9794bcb inherit pub_methods_classStelGLSLShader"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set value of a uniform shader variable.  <a href="#a9bc28e48dec14620b194f613b9794bcb">More...</a><br/></td></tr>
<tr class="separator:a9bc28e48dec14620b194f613b9794bcb inherit pub_methods_classStelGLSLShader"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a6777673cd29406dd71a763ae4006e90f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#a6777673cd29406dd71a763ae4006e90f">setUniformValue_</a> (const char *const name, const float value)</td></tr>
<tr class="memdesc:a6777673cd29406dd71a763ae4006e90f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classStelGLSLShader.html#a9bc28e48dec14620b194f613b9794bcb" title="Set value of a uniform shader variable.">setUniformValue()</a> implementation for type float.  <a href="#a6777673cd29406dd71a763ae4006e90f">More...</a><br/></td></tr>
<tr class="separator:a6777673cd29406dd71a763ae4006e90f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc6d335b09ac9090f004accb5abb50d1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#adc6d335b09ac9090f004accb5abb50d1">setUniformValue_</a> (const char *const name, const <a class="el" href="classVector2.html">Vec2f</a> value)</td></tr>
<tr class="memdesc:adc6d335b09ac9090f004accb5abb50d1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classStelGLSLShader.html#a9bc28e48dec14620b194f613b9794bcb" title="Set value of a uniform shader variable.">setUniformValue()</a> implementation for type Vec2f.  <a href="#adc6d335b09ac9090f004accb5abb50d1">More...</a><br/></td></tr>
<tr class="separator:adc6d335b09ac9090f004accb5abb50d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a0e34af39318399cc0467cd0fc3841f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#a5a0e34af39318399cc0467cd0fc3841f">setUniformValue_</a> (const char *const name, const <a class="el" href="classVector3.html">Vec3f</a> &amp;value)</td></tr>
<tr class="memdesc:a5a0e34af39318399cc0467cd0fc3841f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classStelGLSLShader.html#a9bc28e48dec14620b194f613b9794bcb" title="Set value of a uniform shader variable.">setUniformValue()</a> implementation for type Vec3f.  <a href="#a5a0e34af39318399cc0467cd0fc3841f">More...</a><br/></td></tr>
<tr class="separator:a5a0e34af39318399cc0467cd0fc3841f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf755525e35371a075446caaef2d82b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#adbf755525e35371a075446caaef2d82b">setUniformValue_</a> (const char *const name, const <a class="el" href="classVector4.html">Vec4f</a> &amp;value)</td></tr>
<tr class="memdesc:adbf755525e35371a075446caaef2d82b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classStelGLSLShader.html#a9bc28e48dec14620b194f613b9794bcb" title="Set value of a uniform shader variable.">setUniformValue()</a> implementation for type Vec4f.  <a href="#adbf755525e35371a075446caaef2d82b">More...</a><br/></td></tr>
<tr class="separator:adbf755525e35371a075446caaef2d82b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acce297bc9acde642067b4fe946fe06ca"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#acce297bc9acde642067b4fe946fe06ca">setUniformValue_</a> (const char *const name, const <a class="el" href="classMatrix4.html">Mat4f</a> &amp;m)</td></tr>
<tr class="memdesc:acce297bc9acde642067b4fe946fe06ca"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classStelGLSLShader.html#a9bc28e48dec14620b194f613b9794bcb" title="Set value of a uniform shader variable.">setUniformValue()</a> implementation for type Mat4f.  <a href="#acce297bc9acde642067b4fe946fe06ca">More...</a><br/></td></tr>
<tr class="separator:acce297bc9acde642067b4fe946fe06ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0047941dae7309de8d2f16fcb9064653"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#a0047941dae7309de8d2f16fcb9064653">setUniformValue_</a> (const char *const name, const bool value)</td></tr>
<tr class="memdesc:a0047941dae7309de8d2f16fcb9064653"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classStelGLSLShader.html#a9bc28e48dec14620b194f613b9794bcb" title="Set value of a uniform shader variable.">setUniformValue()</a> implementation for type bool.  <a href="#a0047941dae7309de8d2f16fcb9064653">More...</a><br/></td></tr>
<tr class="separator:a0047941dae7309de8d2f16fcb9064653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3023513bbb3dd149985b4a82f085a9a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#ac3023513bbb3dd149985b4a82f085a9a">setUniformValue_</a> (const char *const name, const int value)</td></tr>
<tr class="memdesc:ac3023513bbb3dd149985b4a82f085a9a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classStelGLSLShader.html#a9bc28e48dec14620b194f613b9794bcb" title="Set value of a uniform shader variable.">setUniformValue()</a> implementation for type int.  <a href="#ac3023513bbb3dd149985b4a82f085a9a">More...</a><br/></td></tr>
<tr class="separator:ac3023513bbb3dd149985b4a82f085a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classStelGLSLShader"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classStelGLSLShader')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classStelGLSLShader.html">StelGLSLShader</a></td></tr>
<tr class="memitem:a91a733d6e3181c859889cac2263d50a5 inherit pro_methods_classStelGLSLShader"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a91a733d6e3181c859889cac2263d50a5 inherit pro_methods_classStelGLSLShader"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classStelGLSLShader.html#a91a733d6e3181c859889cac2263d50a5">setUniformValue_</a> (const char *const name, T value)</td></tr>
<tr class="memdesc:a91a733d6e3181c859889cac2263d50a5 inherit pro_methods_classStelGLSLShader"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Default" overload of <a class="el" href="classStelGLSLShader.html#a9bc28e48dec14620b194f613b9794bcb" title="Set value of a uniform shader variable.">setUniformValue()</a> implementation.  <a href="#a91a733d6e3181c859889cac2263d50a5">More...</a><br/></td></tr>
<tr class="separator:a91a733d6e3181c859889cac2263d50a5 inherit pro_methods_classStelGLSLShader"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a04fa3a6d2b610b3c5724ed05d55f5874"><td class="memItemLeft" align="right" valign="top">class <a class="el" href="classStelQGL2Renderer.html">StelQGL2Renderer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#a04fa3a6d2b610b3c5724ed05d55f5874">renderer</a></td></tr>
<tr class="memdesc:a04fa3a6d2b610b3c5724ed05d55f5874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renderer that created this shader.  <a href="#a04fa3a6d2b610b3c5724ed05d55f5874">More...</a><br/></td></tr>
<tr class="separator:a04fa3a6d2b610b3c5724ed05d55f5874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f2dd55d587dbd5443c1d41329318c87"><td class="memItemLeft" align="right" valign="top">QVector&lt; QGLShader * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#a9f2dd55d587dbd5443c1d41329318c87">defaultVertexShaders</a></td></tr>
<tr class="memdesc:a9f2dd55d587dbd5443c1d41329318c87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vertex shaders that are always linked in (added by the nameless <a class="el" href="classStelQGLGLSLShader.html#a3622e52fdd0dbd362cb4e334b6cae82c" title="Add a vertex shader from source, compiling it in the process.">addVertexShader()</a> overload).  <a href="#a9f2dd55d587dbd5443c1d41329318c87">More...</a><br/></td></tr>
<tr class="separator:a9f2dd55d587dbd5443c1d41329318c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a565391e4284b3badb980a09291885084"><td class="memItemLeft" align="right" valign="top">QMap&lt; QString, OptionalShader &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#a565391e4284b3badb980a09291885084">namedVertexShaders</a></td></tr>
<tr class="memdesc:a565391e4284b3badb980a09291885084"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional vertex shaders that may be enabled or disabled.  <a href="#a565391e4284b3badb980a09291885084">More...</a><br/></td></tr>
<tr class="separator:a565391e4284b3badb980a09291885084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a38374f92387679f023bb1d202a0540"><td class="memItemLeft" align="right" valign="top">QVector&lt; QGLShader * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#a2a38374f92387679f023bb1d202a0540">defaultFragmentShaders</a></td></tr>
<tr class="memdesc:a2a38374f92387679f023bb1d202a0540"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fragment shaders that are always linked in (added by the nameless <a class="el" href="classStelQGLGLSLShader.html#ae256bbd5a3bd9c0be0017919ba95f2cb" title="Add a fragment shader from source, compiling it in the process.">addFragmentShader()</a> overload).  <a href="#a2a38374f92387679f023bb1d202a0540">More...</a><br/></td></tr>
<tr class="separator:a2a38374f92387679f023bb1d202a0540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa78bede88d3b5459ca03b9f3559eeabf"><td class="memItemLeft" align="right" valign="top">QMap&lt; uintptr_t, <br class="typebreak"/>
QGLShaderProgram * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#aa78bede88d3b5459ca03b9f3559eeabf">programCache</a></td></tr>
<tr class="memdesc:aa78bede88d3b5459ca03b9f3559eeabf"><td class="mdescLeft">&#160;</td><td class="mdescRight">All shader programs linked so far.  <a href="#aa78bede88d3b5459ca03b9f3559eeabf">More...</a><br/></td></tr>
<tr class="separator:aa78bede88d3b5459ca03b9f3559eeabf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc2d5ce5297e4937215c82242c59481f"><td class="memItemLeft" align="right" valign="top">QGLShaderProgram *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#abc2d5ce5297e4937215c82242c59481f">program</a></td></tr>
<tr class="memdesc:abc2d5ce5297e4937215c82242c59481f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Currently used shader program (linked from default and currently enabled shaders).  <a href="#abc2d5ce5297e4937215c82242c59481f">More...</a><br/></td></tr>
<tr class="separator:abc2d5ce5297e4937215c82242c59481f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd83d7ef2e2c5ac29cc97e10e3a0996"><td class="memItemLeft" align="right" valign="top">QString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#a9fd83d7ef2e2c5ac29cc97e10e3a0996">aggregatedLog</a></td></tr>
<tr class="memdesc:a9fd83d7ef2e2c5ac29cc97e10e3a0996"><td class="mdescLeft">&#160;</td><td class="mdescRight">Log aggregated during all addXXXShader() and <a class="el" href="classStelQGLGLSLShader.html#afce8499cfc8a6a35c57a315f02bff25f" title="Build the shader program.">build()</a> calls.  <a href="#a9fd83d7ef2e2c5ac29cc97e10e3a0996">More...</a><br/></td></tr>
<tr class="separator:a9fd83d7ef2e2c5ac29cc97e10e3a0996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19321a0ba32baa01d9ba9e3a24bb628e"><td class="memItemLeft" align="right" valign="top">State&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#a19321a0ba32baa01d9ba9e3a24bb628e">state</a></td></tr>
<tr class="memdesc:a19321a0ba32baa01d9ba9e3a24bb628e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current state of the shader.  <a href="#a19321a0ba32baa01d9ba9e3a24bb628e">More...</a><br/></td></tr>
<tr class="separator:a19321a0ba32baa01d9ba9e3a24bb628e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6193d36aae27b3312a1a122fcfad159e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#a6193d36aae27b3312a1a122fcfad159e">bound</a></td></tr>
<tr class="memdesc:a6193d36aae27b3312a1a122fcfad159e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the shader bound for drawing?  <a href="#a6193d36aae27b3312a1a122fcfad159e">More...</a><br/></td></tr>
<tr class="separator:a6193d36aae27b3312a1a122fcfad159e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec2685db40921e6f2c3c947f845a077f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#aec2685db40921e6f2c3c947f845a077f">useUnprojectedPosition_</a></td></tr>
<tr class="memdesc:aec2685db40921e6f2c3c947f845a077f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this shader need the <em>unprojectedVertex</em> attribute (position before <a class="el" href="classStelProjector.html" title="Provide the main interface to all operations of projecting coordinates from sky to screen...">StelProjector</a> projection) ?  <a href="#aec2685db40921e6f2c3c947f845a077f">More...</a><br/></td></tr>
<tr class="separator:aec2685db40921e6f2c3c947f845a077f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afae0785547c259be63c0d1a84cb061a2"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#afae0785547c259be63c0d1a84cb061a2">internal</a></td></tr>
<tr class="memdesc:afae0785547c259be63c0d1a84cb061a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this an internal shader used by the renderer backend?  <a href="#afae0785547c259be63c0d1a84cb061a2">More...</a><br/></td></tr>
<tr class="separator:afae0785547c259be63c0d1a84cb061a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79eeb4a45f06b424ef54ead6944b9a3d"><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#a79eeb4a45f06b424ef54ead6944b9a3d">uniformStorage</a> [UNIFORM_STORAGE]</td></tr>
<tr class="memdesc:a79eeb4a45f06b424ef54ead6944b9a3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage used for uniform data.  <a href="#a79eeb4a45f06b424ef54ead6944b9a3d">More...</a><br/></td></tr>
<tr class="separator:a79eeb4a45f06b424ef54ead6944b9a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ab3c342f5397f1355129fefbc49f2d"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#ab1ab3c342f5397f1355129fefbc49f2d">uniformStoragePointer</a></td></tr>
<tr class="memdesc:ab1ab3c342f5397f1355129fefbc49f2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to uniformStorage[uniformStorageUsed]. Avoids breaking strict aliasing.  <a href="#ab1ab3c342f5397f1355129fefbc49f2d">More...</a><br/></td></tr>
<tr class="separator:ab1ab3c342f5397f1355129fefbc49f2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a822d864c42e34d66a623ddef2b9b56c4"><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#a822d864c42e34d66a623ddef2b9b56c4">uniformTypes</a> [MAX_UNIFORMS]</td></tr>
<tr class="memdesc:a822d864c42e34d66a623ddef2b9b56c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types of consecutive uniforms in uniformStorage.  <a href="#a822d864c42e34d66a623ddef2b9b56c4">More...</a><br/></td></tr>
<tr class="separator:a822d864c42e34d66a623ddef2b9b56c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aa96f1a0f6ba78850f6384636d4694c"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#a0aa96f1a0f6ba78850f6384636d4694c">uniformNames</a> [MAX_UNIFORMS]</td></tr>
<tr class="memdesc:a0aa96f1a0f6ba78850f6384636d4694c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Names of consecutive uniforms in uniformStorage.  <a href="#a0aa96f1a0f6ba78850f6384636d4694c">More...</a><br/></td></tr>
<tr class="separator:a0aa96f1a0f6ba78850f6384636d4694c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47cd60ceb84124f9fad3c44979ec3c3f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#a47cd60ceb84124f9fad3c44979ec3c3f">uniformStorageUsed</a></td></tr>
<tr class="memdesc:a47cd60ceb84124f9fad3c44979ec3c3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bytes in uniformStorage used up at this moment.  <a href="#a47cd60ceb84124f9fad3c44979ec3c3f">More...</a><br/></td></tr>
<tr class="separator:a47cd60ceb84124f9fad3c44979ec3c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bac518707a795035d1b8688d0afb202"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#a2bac518707a795035d1b8688d0afb202">uniformCount</a></td></tr>
<tr class="memdesc:a2bac518707a795035d1b8688d0afb202"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of uniforms in uniformStorage at this moment.  <a href="#a2bac518707a795035d1b8688d0afb202">More...</a><br/></td></tr>
<tr class="separator:a2bac518707a795035d1b8688d0afb202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af52db252923a7ac39c645ba7122c03c0"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#af52db252923a7ac39c645ba7122c03c0">uniformStorageUsedStack</a> [MAX_UNIFORMS]</td></tr>
<tr class="memdesc:af52db252923a7ac39c645ba7122c03c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stack of uniformStorageUsed values used with pushUniformStorage/popUniformStorage.  <a href="#af52db252923a7ac39c645ba7122c03c0">More...</a><br/></td></tr>
<tr class="separator:af52db252923a7ac39c645ba7122c03c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22ba3cafd6c9b599e51440b8f4002c8c"><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#a22ba3cafd6c9b599e51440b8f4002c8c">uniformCountStack</a> [MAX_UNIFORMS]</td></tr>
<tr class="memdesc:a22ba3cafd6c9b599e51440b8f4002c8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stack of uniformCount values used with pushUniformStorage/popUniformStorage.  <a href="#a22ba3cafd6c9b599e51440b8f4002c8c">More...</a><br/></td></tr>
<tr class="separator:a22ba3cafd6c9b599e51440b8f4002c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb24900df95ca10bc0c4d2734472ed7f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelQGLGLSLShader.html#adb24900df95ca10bc0c4d2734472ed7f">uniformStorageStackSize</a></td></tr>
<tr class="memdesc:adb24900df95ca10bc0c4d2734472ed7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of items in uniformStorageUsedStack and uniformCountStack.  <a href="#adb24900df95ca10bc0c4d2734472ed7f">More...</a><br/></td></tr>
<tr class="separator:adb24900df95ca10bc0c4d2734472ed7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>QGL based <a class="el" href="classStelGLSLShader.html" title="GLSL shader program.">StelGLSLShader</a> implementation, used by the QGL2 renderer backend. </p>
<dl class="section note"><dt>Note</dt><dd>This is an internal class of the Renderer subsystem and should not be used elsewhere. </dd></dl>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00038">38</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a206cbfb25c246deb43e2e6b28f959058"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StelQGLGLSLShader::StelQGLGLSLShader </td>
          <td>(</td>
          <td class="paramtype">class <a class="el" href="classStelQGL2Renderer.html">StelQGL2Renderer</a> *&#160;</td>
          <td class="paramname"><em>renderer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>internal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="classStelQGLGLSLShader.html" title="QGL based StelGLSLShader implementation, used by the QGL2 renderer backend.">StelQGLGLSLShader</a> owned by specified renderer. </p>
<p>Used by QGL2 renderer backend.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">renderer</td><td>Renderer that created this shader. </td></tr>
    <tr><td class="paramname">internal</td><td>Is this shader internal to the renderer backend? (Not directly used by the user) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ae256bbd5a3bd9c0be0017919ba95f2cb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool StelQGLGLSLShader::addFragmentShader </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a fragment shader from source, compiling it in the process. </p>
<p>This operation can fail. In case of failure, use <a class="el" href="classStelQGLGLSLShader.html#a91fe541891340fb1ff0b551aed3b0218" title="Return a string containing the error log of the shader.">log()</a> to find out the cause.</p>
<p>The shader must be unlocked when this is called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>Source code of the shader. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if succesfully added and compiled, false otherwise. </dd></dl>

<p>Implements <a class="el" href="classStelGLSLShader.html#aa0124e11de0e4cdbf8384d202367faa0">StelGLSLShader</a>.</p>

</div>
</div>
<a class="anchor" id="a3622e52fdd0dbd362cb4e334b6cae82c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool StelQGLGLSLShader::addVertexShader </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a vertex shader from source, compiling it in the process. </p>
<p>This operation can fail. In case of failure, use <a class="el" href="classStelQGLGLSLShader.html#a91fe541891340fb1ff0b551aed3b0218" title="Return a string containing the error log of the shader.">log()</a> to find out the cause.</p>
<p>The shader must be unlocked when this is called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>Source code of the shader. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if succesfully added and compiled, false otherwise. </dd></dl>

<p>Implements <a class="el" href="classStelGLSLShader.html#a278e2dd210b77aad002f6750e5078126">StelGLSLShader</a>.</p>

</div>
</div>
<a class="anchor" id="a4f631cf343291ccbbf5799e594f67cd8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool StelQGLGLSLShader::addVertexShader </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a named (optional) vertex shader. </p>
<p>Named vertex shaders can be disabled and reenabled. (Unnamed shaders are always enabled.) This allows to dynamically exchange implementations of functions, making shaders modular. GLSL projection is an example of this.</p>
<p>The shader must be unlocked when this is called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the shader. </td></tr>
    <tr><td class="paramname">source</td><td>Source code of the shader. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classStelGLSLShader.html#a3710da7bb448c5a30a3eadd9fee04c83">StelGLSLShader</a>.</p>

</div>
</div>
<a class="anchor" id="aa77410a83e7cb4acb698b52e6356ccc8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelQGLGLSLShader::bind </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind the shader, using it for following draw calls. </p>
<p>This must be called before setting uniforms. The shader must be built when this is called.</p>
<p>Note that the shader must be released after any draw calls using the shader to allow default shaders to return to use. </p>

<p>Implements <a class="el" href="classStelGLSLShader.html#a7f5a6d53ef5352efcbfea770666e8c44">StelGLSLShader</a>.</p>

</div>
</div>
<a class="anchor" id="afce8499cfc8a6a35c57a315f02bff25f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool StelQGLGLSLShader::build </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build the shader program. </p>
<p>This must be called before the shader can be bound.</p>
<p>This operation can fail. In case of failure, use <a class="el" href="classStelQGLGLSLShader.html#a91fe541891340fb1ff0b551aed3b0218" title="Return a string containing the error log of the shader.">log()</a> to find out the cause. If <a class="el" href="classStelQGLGLSLShader.html#afce8499cfc8a6a35c57a315f02bff25f" title="Build the shader program.">build()</a> fails, the shader should be assumed to no longer be usable and be destroyed.</p>
<dl class="section return"><dt>Returns</dt><dd>true if succesfully built, false otherwise. </dd></dl>

<p>Implements <a class="el" href="classStelGLSLShader.html#a58cae3e4a1916cf6bd07cd5c58b9b34a">StelGLSLShader</a>.</p>

</div>
</div>
<a class="anchor" id="a37004c3b1e983f0d3e0803c09f2c19fa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StelQGLGLSLShader::clearUniforms </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear all stored uniforms, freeing uniform storage. </p>
<p>Called by <a class="el" href="classStelQGLGLSLShader.html#af6092a51ab7d0ae0f6640c9bf14530d5" title="Release a bound shader after use.">release()</a>. </p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00320">320</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa7edd3270500c4162a62c3e8dc761721"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelQGLGLSLShader::disableVertexShader </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disable previously added named vertex shader. </p>
<p>The shader must be unlocked when this is called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the shader to disable. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classStelGLSLShader.html#ad695c0b27278e31db94682deb31d16a5">StelGLSLShader</a>.</p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00171">171</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2df5e9b94a5f39cd733728845ef62d52"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelQGLGLSLShader::enableVertexShader </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable previously added named vertex shader. </p>
<p>The shader must be unlocked when this is called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the shader to enable. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classStelGLSLShader.html#ad1554e9e078314b55eeda310b25ebdad">StelGLSLShader</a>.</p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00158">158</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a932c0f77d67e910b5b59df7183883fa0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">QGLShaderProgram&amp; StelQGLGLSLShader::getProgram </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a reference to the current underlying shader program. </p>
<p>Used by QGL2 renderer backend. </p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00196">196</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af9db84b9cbed6ee5428bb2a1dde61c1f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool StelQGLGLSLShader::hasVertexShader </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Has a named vertex shader with specified name been added? </p>

<p>Implements <a class="el" href="classStelGLSLShader.html#aa344eb43fedd32b0e2b87fca9bd053bd">StelGLSLShader</a>.</p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00153">153</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a91fe541891340fb1ff0b551aed3b0218"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual QString StelQGLGLSLShader::log </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a string containing the error log of the shader. </p>
<p>If the shader is succesfully built, it will contain a success message. It might also contain GLSL code warnings. </p>

<p>Implements <a class="el" href="classStelGLSLShader.html#a5ae3dd75f20c33c3a72d987585b44f1b">StelGLSLShader</a>.</p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00133">133</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab9e1c9cc088ae08d414e4fdd0fea948a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StelQGLGLSLShader::popUniformStorage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restores pushed uniform storage stage. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classStelQGLGLSLShader.html#a341bdd163ed3e8cecd279e15e5f8d16c" title="Push uniform storage state.">pushUniformStorage</a> </dd></dl>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00305">305</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a341bdd163ed3e8cecd279e15e5f8d16c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StelQGLGLSLShader::pushUniformStorage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Push uniform storage state. </p>
<p>This is an optimization used internally by the renderer backend. This "saves" the state of uniform storage, allowing to "restore" it by calling <a class="el" href="classStelQGLGLSLShader.html#ab9e1c9cc088ae08d414e4fdd0fea948a" title="Restores pushed uniform storage stage.">popUniformStorage()</a>. This prevents the internal uniform-setting in repeated draw calls from filling the entire uniform storage.</p>
<p>How this works:</p>
<p>Setting uniforms just appends new data to uniform storage; setting the same uniform multiple times just uses more data (determining if a uniform with this name was set already would be expensive).</p>
<p><a class="el" href="classStelQGLGLSLShader.html#a341bdd163ed3e8cecd279e15e5f8d16c" title="Push uniform storage state.">pushUniformStorage()</a> pushes the number of uniforms and used storage to an internal stack. <a class="el" href="classStelQGLGLSLShader.html#ab9e1c9cc088ae08d414e4fdd0fea948a" title="Restores pushed uniform storage stage.">popUniformStorage()</a> restores this state, throwing away any uniforms set since the push. </p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00291">291</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af6092a51ab7d0ae0f6640c9bf14530d5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelQGLGLSLShader::release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release a bound shader after use. </p>
<p>This must be called after using the shader so that the <a class="el" href="classStelRenderer.html" title="Main class of the Renderer subsystem.">StelRenderer</a> backend can go back to using default shaders.</p>
<p>It also must be called before <a class="el" href="classStelQGLGLSLShader.html#aa77410a83e7cb4acb698b52e6356ccc8" title="Bind the shader, using it for following draw calls.">bind()</a>-ing another <a class="el" href="classStelGLSLShader.html" title="GLSL shader program.">StelGLSLShader</a>. </p>

<p>Implements <a class="el" href="classStelGLSLShader.html#ad5f3315bf08b16dec2d478fdbe0211f6">StelGLSLShader</a>.</p>

</div>
</div>
<a class="anchor" id="a6777673cd29406dd71a763ae4006e90f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelQGLGLSLShader::setUniformValue_ </td>
          <td>(</td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classStelGLSLShader.html#a9bc28e48dec14620b194f613b9794bcb" title="Set value of a uniform shader variable.">setUniformValue()</a> implementation for type float. </p>

<p>Implements <a class="el" href="classStelGLSLShader.html#ac1d01a179e3708399b25e0bc039eb321">StelGLSLShader</a>.</p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00432">432</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adc6d335b09ac9090f004accb5abb50d1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelQGLGLSLShader::setUniformValue_ </td>
          <td>(</td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector2.html">Vec2f</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classStelGLSLShader.html#a9bc28e48dec14620b194f613b9794bcb" title="Set value of a uniform shader variable.">setUniformValue()</a> implementation for type Vec2f. </p>

<p>Implements <a class="el" href="classStelGLSLShader.html#a69f821fa909e80d8f57ef6e0656d0362">StelGLSLShader</a>.</p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00446">446</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5a0e34af39318399cc0467cd0fc3841f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelQGLGLSLShader::setUniformValue_ </td>
          <td>(</td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector3.html">Vec3f</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classStelGLSLShader.html#a9bc28e48dec14620b194f613b9794bcb" title="Set value of a uniform shader variable.">setUniformValue()</a> implementation for type Vec3f. </p>

<p>Implements <a class="el" href="classStelGLSLShader.html#a8bee668c13ea947c5df973fa54e05d23">StelGLSLShader</a>.</p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00461">461</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adbf755525e35371a075446caaef2d82b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelQGLGLSLShader::setUniformValue_ </td>
          <td>(</td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector4.html">Vec4f</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classStelGLSLShader.html#a9bc28e48dec14620b194f613b9794bcb" title="Set value of a uniform shader variable.">setUniformValue()</a> implementation for type Vec4f. </p>

<p>Implements <a class="el" href="classStelGLSLShader.html#af78d1988cf91914e098d1985309a314c">StelGLSLShader</a>.</p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00476">476</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acce297bc9acde642067b4fe946fe06ca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelQGLGLSLShader::setUniformValue_ </td>
          <td>(</td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrix4.html">Mat4f</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classStelGLSLShader.html#a9bc28e48dec14620b194f613b9794bcb" title="Set value of a uniform shader variable.">setUniformValue()</a> implementation for type Mat4f. </p>

<p>Implements <a class="el" href="classStelGLSLShader.html#a8d3aa6519199afd04a9a35739d1f1224">StelGLSLShader</a>.</p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00491">491</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0047941dae7309de8d2f16fcb9064653"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelQGLGLSLShader::setUniformValue_ </td>
          <td>(</td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classStelGLSLShader.html#a9bc28e48dec14620b194f613b9794bcb" title="Set value of a uniform shader variable.">setUniformValue()</a> implementation for type bool. </p>

<p>Implements <a class="el" href="classStelGLSLShader.html#a214c10ea3ff04c5589e047e5aaf78467">StelGLSLShader</a>.</p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00506">506</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac3023513bbb3dd149985b4a82f085a9a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelQGLGLSLShader::setUniformValue_ </td>
          <td>(</td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classStelGLSLShader.html#a9bc28e48dec14620b194f613b9794bcb" title="Set value of a uniform shader variable.">setUniformValue()</a> implementation for type int. </p>

<p>Implements <a class="el" href="classStelGLSLShader.html#ae75cfbb3292457627d12f43e4bf315a5">StelGLSLShader</a>.</p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00521">521</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a77cee9a54b10362701642fa443a9995a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelQGLGLSLShader::unlock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unlock the shader program for modifications. </p>
<p>Allows to, add, enable, disable vertex/fragment shaders.</p>
<p>This can be called even if the shader is bound (which is used for last-moment modifications, like GLSL projection in renderer backend), but it must be rebuilt before drawing and releasing. </p>

<p>Implements <a class="el" href="classStelGLSLShader.html#a725669d679573be1e6a9c8af2efbd708">StelGLSLShader</a>.</p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00138">138</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad055f5447dde2b203e503e56ebcc4343"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StelQGLGLSLShader::uploadUniforms </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Upload the stored uniform variables. </p>
<p>Called when the internally used shader program has been bound, before drawing, by the drawVertexBufferBackend() member function of the renderer backend. </p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00215">215</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0b1f7c271bde1be2a1c3b1476d7d5bd7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool StelQGLGLSLShader::useUnprojectedPosition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does this shader need the unprojected vertex position attribute? </p>
<p>Used by vertex buffer backend to determine if this attribute should be provided. </p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00206">206</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2afb696e7f20bf5deb14e28aea141a10"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelQGLGLSLShader::useUnprojectedPositionAttribute </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does this shader need the unprojected position attribute? </p>
<p>If called, the shader will have to declare another vertex attribute, <em>unprojectedVertex</em>, for vertex position before <a class="el" href="classStelProjector.html" title="Provide the main interface to all operations of projecting coordinates from sky to screen...">StelProjector</a> projection. Useful e.g. for lighting. </p>

<p>Implements <a class="el" href="classStelGLSLShader.html#a687a8efacfc1e876a754fe14c66e80eb">StelGLSLShader</a>.</p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00188">188</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a9fd83d7ef2e2c5ac29cc97e10e3a0996"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">QString StelQGLGLSLShader::aggregatedLog</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Log aggregated during all addXXXShader() and <a class="el" href="classStelQGLGLSLShader.html#afce8499cfc8a6a35c57a315f02bff25f" title="Build the shader program.">build()</a> calls. </p>
<p>May be aggregated from multiple vertex programs if built multiple times with different shaders enabled. </p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00372">372</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6193d36aae27b3312a1a122fcfad159e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool StelQGLGLSLShader::bound</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the shader bound for drawing? </p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00378">378</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2a38374f92387679f023bb1d202a0540"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">QVector&lt;QGLShader*&gt; StelQGLGLSLShader::defaultFragmentShaders</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fragment shaders that are always linked in (added by the nameless <a class="el" href="classStelQGLGLSLShader.html#ae256bbd5a3bd9c0be0017919ba95f2cb" title="Add a fragment shader from source, compiling it in the process.">addFragmentShader()</a> overload). </p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00341">341</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9f2dd55d587dbd5443c1d41329318c87"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">QVector&lt;QGLShader*&gt; StelQGLGLSLShader::defaultVertexShaders</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vertex shaders that are always linked in (added by the nameless <a class="el" href="classStelQGLGLSLShader.html#a3622e52fdd0dbd362cb4e334b6cae82c" title="Add a vertex shader from source, compiling it in the process.">addVertexShader()</a> overload). </p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00334">334</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afae0785547c259be63c0d1a84cb061a2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool StelQGLGLSLShader::internal</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this an internal shader used by the renderer backend? </p>
<p>Needed to avoing bind/release from calling renderer backend custom shader bind/release. </p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00387">387</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a565391e4284b3badb980a09291885084"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">QMap&lt;QString, OptionalShader&gt; StelQGLGLSLShader::namedVertexShaders</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Optional vertex shaders that may be enabled or disabled. </p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00337">337</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abc2d5ce5297e4937215c82242c59481f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">QGLShaderProgram* StelQGLGLSLShader::program</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Currently used shader program (linked from default and currently enabled shaders). </p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00366">366</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa78bede88d3b5459ca03b9f3559eeabf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">QMap&lt;uintptr_t, QGLShaderProgram*&gt; StelQGLGLSLShader::programCache</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>All shader programs linked so far. </p>
<p>When <a class="el" href="classStelQGLGLSLShader.html#afce8499cfc8a6a35c57a315f02bff25f" title="Build the shader program.">build()</a> is called, the default and currently enabled optional shaders are linked to a shader program. As re-linking shaders on each frame would be too expensive, any shader combination is only linked once and then retrieved from this cache.</p>
<p><a class="el" href="classStelQGLGLSLShader.html#afce8499cfc8a6a35c57a315f02bff25f" title="Build the shader program.">build()</a> is called for each draw call (due to modular shaders being used for vertex projection), so the lookup must be very fast. The ID used for lookup - a 64 bit unsigned integer, is a sum of pointers of all shaders linked in the program.</p>
<p>It is not impossible for false positives to happen, but it's very unlikely. 64bit is not going to overflow any soon (you need a 16EiB address space for that), and as shaders are never deleted or moved in memory, two shaders can never have identical pointers. Then only risk is that two sets of pointers will accidentally add up to the same number, but this is very unlikely as well.</p>
<p>In case this happens, some very simple hash algorithm (still on pointers) might be used instead. </p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00363">363</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a04fa3a6d2b610b3c5724ed05d55f5874"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="classStelQGL2Renderer.html">StelQGL2Renderer</a>* StelQGLGLSLShader::renderer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Renderer that created this shader. </p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00331">331</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a19321a0ba32baa01d9ba9e3a24bb628e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">State StelQGLGLSLShader::state</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Current state of the shader. </p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00375">375</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2bac518707a795035d1b8688d0afb202"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int StelQGLGLSLShader::uniformCount</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of uniforms in uniformStorage at this moment. </p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00417">417</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a22ba3cafd6c9b599e51440b8f4002c8c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char StelQGLGLSLShader::uniformCountStack[MAX_UNIFORMS]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stack of uniformCount values used with pushUniformStorage/popUniformStorage. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classStelQGLGLSLShader.html#a341bdd163ed3e8cecd279e15e5f8d16c" title="Push uniform storage state.">pushUniformStorage</a>, <a class="el" href="classStelQGLGLSLShader.html#ab9e1c9cc088ae08d414e4fdd0fea948a" title="Restores pushed uniform storage stage.">popUniformStorage</a> </dd></dl>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00427">427</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0aa96f1a0f6ba78850f6384636d4694c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* StelQGLGLSLShader::uniformNames[MAX_UNIFORMS]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Names of consecutive uniforms in uniformStorage. </p>
<p>We don't own these strings, we just have pointers to them. This means the user code needs to preserve the string until <a class="el" href="classStelQGLGLSLShader.html#af6092a51ab7d0ae0f6640c9bf14530d5" title="Release a bound shader after use.">release()</a> is called. </p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00411">411</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a79eeb4a45f06b424ef54ead6944b9a3d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char StelQGLGLSLShader::uniformStorage[UNIFORM_STORAGE]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Storage used for uniform data. </p>
<p>As we're linking shaders dynamically and the final shader program is only bound directly before drawing, we need to delay uniform upload until that point. Therefore, setUniformValue_ functions just add data to this storage. The data is then uploaded by <a class="el" href="classStelQGLGLSLShader.html#ad055f5447dde2b203e503e56ebcc4343" title="Upload the stored uniform variables.">uploadUniforms()</a>.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classStelQGLGLSLShader.html#ad055f5447dde2b203e503e56ebcc4343" title="Upload the stored uniform variables.">uploadUniforms</a>, <a class="el" href="classStelQGLGLSLShader.html#a37004c3b1e983f0d3e0803c09f2c19fa" title="Clear all stored uniforms, freeing uniform storage.">clearUniforms</a>, <a class="el" href="classStelQGLGLSLShader.html#a341bdd163ed3e8cecd279e15e5f8d16c" title="Push uniform storage state.">pushUniformStorage</a> </dd></dl>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00397">397</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab1ab3c342f5397f1355129fefbc49f2d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* StelQGLGLSLShader::uniformStoragePointer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer to uniformStorage[uniformStorageUsed]. Avoids breaking strict aliasing. </p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00400">400</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adb24900df95ca10bc0c4d2734472ed7f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int StelQGLGLSLShader::uniformStorageStackSize</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of items in uniformStorageUsedStack and uniformCountStack. </p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00430">430</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a47cd60ceb84124f9fad3c44979ec3c3f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int StelQGLGLSLShader::uniformStorageUsed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bytes in uniformStorage used up at this moment. </p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00414">414</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af52db252923a7ac39c645ba7122c03c0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int StelQGLGLSLShader::uniformStorageUsedStack[MAX_UNIFORMS]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stack of uniformStorageUsed values used with pushUniformStorage/popUniformStorage. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classStelQGLGLSLShader.html#a341bdd163ed3e8cecd279e15e5f8d16c" title="Push uniform storage state.">pushUniformStorage</a>, <a class="el" href="classStelQGLGLSLShader.html#ab9e1c9cc088ae08d414e4fdd0fea948a" title="Restores pushed uniform storage stage.">popUniformStorage</a> </dd></dl>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00422">422</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a822d864c42e34d66a623ddef2b9b56c4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char StelQGLGLSLShader::uniformTypes[MAX_UNIFORMS]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Types of consecutive uniforms in uniformStorage. </p>
<p>Needed to interpret uniformStorage data when uploading. </p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00405">405</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aec2685db40921e6f2c3c947f845a077f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool StelQGLGLSLShader::useUnprojectedPosition_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does this shader need the <em>unprojectedVertex</em> attribute (position before <a class="el" href="classStelProjector.html" title="Provide the main interface to all operations of projecting coordinates from sky to screen...">StelProjector</a> projection) ? </p>

<p>Definition at line <a class="el" href="StelQGLGLSLShader_8hpp_source.html#l00382">382</a> of file <a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>core/renderer/<a class="el" href="StelQGLGLSLShader_8hpp_source.html">StelQGLGLSLShader.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Feb 7 2013 14:06:16 for Stellarium by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>
