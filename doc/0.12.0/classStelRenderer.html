<?xml version="1.0" encoding="utf-8"?>
<html>
    <head>
      <title>Stellarium: StelRenderer Class Reference</title>
      <LINK HREF="doxygen.css" REL="stylesheet" TYPE="text/css">
    </HEAD>
    <BODY BGCOLOR="#FFFFFF">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td align="left" valign="top" width="32" rowspan="2"><a href="http://www.stellarium.org"><img src="stellarium-logo.png" align="left" border="0" /></a></td>
<td width="1" rowspan="2">&nbsp;&nbsp;</td>
<td style="font-size:120%;font-weight:bolder;">Stellarium 0.12.0</td>
<td align="right" valign="top" width="230" rowspan="2"></td></tr><tr>
<td class="postheader" valign="center">
 <a href="index.html">Home</a>&nbsp;&middot;
 <a href="namespaces.html">All&nbsp;Namespaces</a>&nbsp;&middot;
 <a href="classes.html">All&nbsp;Classes</a>&nbsp;&middot;
 <a href="functions.html">Functions</a>&nbsp;&middot;
 <a href="codingStyle.html">Coding Style</a>&nbsp;&middot;
 <a href="scripting.html">Scripting</a>&nbsp;&middot;
 <a href="plugins.html">Plugins</a>&nbsp;&middot;
 <a href="renderer.html">Renderer</a>&nbsp;&middot;
 <a href="fileStructure.html">File Structure</a>
</td>
</tr>
</table>
<!-- Generated by Doxygen 1.6.3 -->
<div class="contents">
<h1>StelRenderer Class Reference</h1><!-- doxytag: class="StelRenderer" -->
<p>Main class of the <a class="el" href="renderer.html">Renderer</a> subsystem.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="StelRenderer_8hpp_source.html">StelRenderer.hpp</a>&gt;</code></p>

<p><a href="classStelRenderer-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#a7e93fc36845699a0533e17b3d6d3888d">~StelRenderer</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#a7e93fc36845699a0533e17b3d6d3888d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#adc626548c3c14af69061765c7331fb40">init</a> ()=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize the renderer.  <a href="#adc626548c3c14af69061765c7331fb40"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual QImage&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#adf0122cc27cffce6c9dddc17af5b4f6f">screenshot</a> ()=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Take a screenshot and return it.  <a href="#adf0122cc27cffce6c9dddc17af5b4f6f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#ae9c21db50f37e99ea5cf851e23f996f8">viewportHasBeenResized</a> (const QSize size)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Must be called once at startup and on every GL viewport resize, specifying new size.  <a href="#ae9c21db50f37e99ea5cf851e23f996f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual class <a class="el" href="classStelIndexBuffer.html">StelIndexBuffer</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#a58f550570512df06eedf96f073510de6">createIndexBuffer</a> (const IndexType type)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an empty index buffer and return a pointer to it.  <a href="#a58f550570512df06eedf96f073510de6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classStelVertexBuffer.html">StelVertexBuffer</a>&lt; V &gt; *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#ab20687284a2419e5db806e74dfe91b5b">createVertexBuffer</a> (const PrimitiveType primitiveType)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an empty vertex buffer and return a pointer to it.  <a href="#ab20687284a2419e5db806e74dfe91b5b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#a1ff46049a6698fe6fb648d175052df4a">drawVertexBuffer</a> (<a class="el" href="classStelVertexBuffer.html">StelVertexBuffer</a>&lt; V &gt; *vertexBuffer, class <a class="el" href="classStelIndexBuffer.html">StelIndexBuffer</a> *indexBuffer=NULL, <a class="el" href="classQSharedPointer.html">StelProjectorP</a> projector=<a class="el" href="classQSharedPointer.html">StelProjectorP</a>(NULL), bool dontProject=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draw contents of a vertex buffer.  <a href="#a1ff46049a6698fe6fb648d175052df4a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#a52dcc1a022495f83a4bf1c448c388e3e">drawVertexBuffer</a> (<a class="el" href="classStelVertexBuffer.html">StelVertexBuffer</a>&lt; V &gt; *vertexBuffer, class <a class="el" href="classStelIndexBuffer.html">StelIndexBuffer</a> *indexBuffer, <a class="el" href="classStelProjector.html">StelProjector</a> *projector, bool dontProject=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draw contents of a vertex buffer.  <a href="#a52dcc1a022495f83a4bf1c448c388e3e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#a3ff0e382823be0f621cb2b3d0329ac84">drawLine</a> (const float startX, const float startY, const float endX, const float endY)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draw a line with current global color to the screen.  <a href="#a3ff0e382823be0f621cb2b3d0329ac84"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#ad2bf023af721715f40058b711828fedf">drawRect</a> (const float x, const float y, const float width, const float height, const float angle=0.0f)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draw a rectangle to the screen.  <a href="#ad2bf023af721715f40058b711828fedf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#a416d3eb82d34af15fb748af6300d4363">drawTexturedRect</a> (const float x, const float y, const float width, const float height, const float angle=0.0f)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draw a textured rectangle to the screen.  <a href="#a416d3eb82d34af15fb748af6300d4363"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#a9f9c1ee188f6cf25ff5d7c6df4795416">drawText</a> (const <a class="el" href="structTextParams.html">TextParams</a> &amp;params)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draw text with specified parameters.  <a href="#a9f9c1ee188f6cf25ff5d7c6df4795416"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#a0058e9561eb0e08e67f559d2606576a6">setFont</a> (const QFont &amp;font)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set font to use for drawing text.  <a href="#a0058e9561eb0e08e67f559d2606576a6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#a242b2ff1979f7b4adeec068796b8c8c9">renderFrame</a> (<a class="el" href="classStelRenderClient.html">StelRenderClient</a> &amp;renderClient)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Render a frame.  <a href="#a242b2ff1979f7b4adeec068796b8c8c9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classStelTextureNew.html">StelTextureNew</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#a78b992518c241cc3a12ad964ad12959a">createTexture</a> (const QString &amp;filename, const <a class="el" href="structTextureParams.html">TextureParams</a> &amp;params=<a class="el" href="structTextureParams.html">TextureParams</a>(), const TextureLoadingMode loadingMode=TextureLoadingMode_Normal)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a texture from specified file or URL.  <a href="#a78b992518c241cc3a12ad964ad12959a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classStelTextureNew.html">StelTextureNew</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#af881fe1677e3b21ebe24e0e35baf5d1f">createTexture</a> (QImage &amp;image, const <a class="el" href="structTextureParams.html">TextureParams</a> &amp;params=<a class="el" href="structTextureParams.html">TextureParams</a>())</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a texture from an image.  <a href="#af881fe1677e3b21ebe24e0e35baf5d1f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classStelTextureNew.html">StelTextureNew</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#a50500ed0778b10caf4044a38718efc19">createTexture</a> (const void *const data, const QSize size, const TextureDataFormat format, const <a class="el" href="structTextureParams.html">TextureParams</a> &amp;params=<a class="el" href="structTextureParams.html">TextureParams</a>())</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a texture from raw data.  <a href="#a50500ed0778b10caf4044a38718efc19"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#ac7750ff0cc84161f0949aea61f77af6d">areFloatTexturesSupported</a> () const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if floating point textures are supported, false otherwise.  <a href="#ac7750ff0cc84161f0949aea61f77af6d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classStelTextureNew.html">StelTextureNew</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#a71f36b14d90531b697532f4b875617d9">getViewportTexture</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a texture of the viewport, with everything drawn to the viewport so far.  <a href="#a71f36b14d90531b697532f4b875617d9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classStelGLSLShader.html">StelGLSLShader</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#a0b9f984032aa9dcc91ab8df6d9a5c648">createGLSLShader</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a GLSL shader.  <a href="#a0b9f984032aa9dcc91ab8df6d9a5c648"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#a216f1c1d98b7a22d33b7915d60cc8293">isGLSLSupported</a> () const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Are GLSL shaders supported?  <a href="#a216f1c1d98b7a22d33b7915d60cc8293"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual QSize&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#acbd5ae94bcf114bfd8f3b16cc72b7a6d">getViewportSize</a> () const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get size of the viewport in pixels.  <a href="#acbd5ae94bcf114bfd8f3b16cc72b7a6d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#a89005c9f1e22bbd5cf58839026168e27">setGlobalColor</a> (const <a class="el" href="classVector4.html">Vec4f</a> &amp;color)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the global vertex color.  <a href="#a89005c9f1e22bbd5cf58839026168e27"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#a3c2e2d69a3571192a79eecd94f61fe76">setGlobalColor</a> (const float r, const float g, const float b, const float a=1.0f)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">setGlobalColor overload specifying color channels directly instead of through Vec4f.  <a href="#a3c2e2d69a3571192a79eecd94f61fe76"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#af96317f54d1fdf7eeb290319ff42a48f">setBlendMode</a> (const BlendMode blendMode)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set blend mode.  <a href="#af96317f54d1fdf7eeb290319ff42a48f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#ae8e882ad75fab3b0bddb24cb5bc3ef90">setCulledFaces</a> (const CullFace cullFace)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set which faces (triangles) should be culled.  <a href="#ae8e882ad75fab3b0bddb24cb5bc3ef90"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#a19809c61e76bd27ff903bc4550111d47">clearDepthBuffer</a> ()=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear the depth buffer to zeroes, removing any depth information.  <a href="#a19809c61e76bd27ff903bc4550111d47"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#ab5e882f5c441d744300627361634dc0c">setDepthTest</a> (const DepthTest test)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set depth test mode.  <a href="#ab5e882f5c441d744300627361634dc0c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#a339f3610ec4d75a39953f06d36aefc91">clearStencilBuffer</a> ()=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear the stencil buffer to zeroes, removing any stencil information.  <a href="#a339f3610ec4d75a39953f06d36aefc91"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#a14c566946971937c4be5e97cf336c9f3">setStencilTest</a> (const StencilTest test)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set stencil test mode.  <a href="#a14c566946971937c4be5e97cf336c9f3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#afea8473fd7b4877d40fb6a79e387822b">swapBuffers</a> ()=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swap front and back buffers.  <a href="#afea8473fd7b4877d40fb6a79e387822b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classStelRendererStatistics.html">StelRendererStatistics</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#ae2653097bc6da56c3507742ddf58424b">getStatistics</a> ()=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access statistics data.  <a href="#ae2653097bc6da56c3507742ddf58424b"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classStelVertexBufferBackend.html">StelVertexBufferBackend</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#aac066b60608fbc338e7449e309dbcc39">createVertexBufferBackend</a> (const PrimitiveType primitiveType, const QVector&lt; <a class="el" href="structStelVertexAttribute.html">StelVertexAttribute</a> &gt; &amp;attributes)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a vertex buffer backend.  <a href="#aac066b60608fbc338e7449e309dbcc39"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#a87bc521b5e19d618f4257c580a841a9e">drawVertexBufferBackend</a> (<a class="el" href="classStelVertexBufferBackend.html">StelVertexBufferBackend</a> *vertexBuffer, class <a class="el" href="classStelIndexBuffer.html">StelIndexBuffer</a> *indexBuffer, <a class="el" href="classStelProjector.html">StelProjector</a> *projector, const bool dontProject)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draw contents of a vertex buffer (backend).  <a href="#a87bc521b5e19d618f4257c580a841a9e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual class <a class="el" href="classStelTextureBackend.html">StelTextureBackend</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#acc4f270649f47c9acd96f570d125d4b0">createTextureBackend</a> (const QString &amp;filename, const <a class="el" href="structTextureParams.html">TextureParams</a> &amp;params, const TextureLoadingMode loadingMode)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of createTexture.  <a href="#acc4f270649f47c9acd96f570d125d4b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual class <a class="el" href="classStelTextureBackend.html">StelTextureBackend</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#a3f71077f84e3f5a7f03110ba429ad4d0">createTextureBackend</a> (QImage &amp;image, const <a class="el" href="structTextureParams.html">TextureParams</a> &amp;params)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of createTexture loading from image.  <a href="#a3f71077f84e3f5a7f03110ba429ad4d0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual class <a class="el" href="classStelTextureBackend.html">StelTextureBackend</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#af175f0223ee53472fe01784a00e5f0af">createTextureBackend</a> (const void *data, const QSize size, const TextureDataFormat format, const <a class="el" href="structTextureParams.html">TextureParams</a> &amp;params)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of createTexture loading from raw data.  <a href="#af175f0223ee53472fe01784a00e5f0af"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual class <a class="el" href="classStelTextureBackend.html">StelTextureBackend</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#acd5bd5854dff554adfe79603c429b189">getViewportTextureBackend</a> ()=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of getViewportTexture.  <a href="#acd5bd5854dff554adfe79603c429b189"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#a4675c0629e3ee3432650fd6f7efd01f3">destroyTextureBackend</a> (class <a class="el" href="classStelTextureBackend.html">StelTextureBackend</a> *backend)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy a <a class="el" href="classStelTextureBackend.html" title="Base class for texture implementations.">StelTextureBackend</a>.  <a href="#a4675c0629e3ee3432650fd6f7efd01f3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelRenderer.html#a18db043e3b7d3f353af6b297ccf5e590">bindTextureBackend</a> (class <a class="el" href="classStelTextureBackend.html">StelTextureBackend</a> *textureBackend, const int textureUnit)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bind a texture (following draw calls will use this texture on specified texture unit).  <a href="#a18db043e3b7d3f353af6b297ccf5e590"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Main class of the <a class="el" href="renderer.html">Renderer</a> subsystem. </p>
<p>Handles all drawing functionality.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This is an interface. It should have only functions, no data members, as it might be used in multiple inheritance. </dd></dl>

<p>Definition at line <a class="el" href="StelRenderer_8hpp_source.html#l00248">248</a> of file <a class="el" href="StelRenderer_8hpp_source.html">StelRenderer.hpp</a>.</p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a7e93fc36845699a0533e17b3d6d3888d"></a><!-- doxytag: member="StelRenderer::~StelRenderer" ref="a7e93fc36845699a0533e17b3d6d3888d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual StelRenderer::~StelRenderer </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor. </p>

<p>Definition at line <a class="el" href="StelRenderer_8hpp_source.html#l00254">254</a> of file <a class="el" href="StelRenderer_8hpp_source.html">StelRenderer.hpp</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ac7750ff0cc84161f0949aea61f77af6d"></a><!-- doxytag: member="StelRenderer::areFloatTexturesSupported" ref="ac7750ff0cc84161f0949aea61f77af6d" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool StelRenderer::areFloatTexturesSupported </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if floating point textures are supported, false otherwise. </p>

<p>Implemented in <a class="el" href="classStelQGL1Renderer.html#af674d4de0e58816696de57186f9c6f29">StelQGL1Renderer</a>, and <a class="el" href="classStelQGL2Renderer.html#a32dde8f9480d61d3a54044bf038a4193">StelQGL2Renderer</a>.</p>

</div>
</div>
<a class="anchor" id="a18db043e3b7d3f353af6b297ccf5e590"></a><!-- doxytag: member="StelRenderer::bindTextureBackend" ref="a18db043e3b7d3f353af6b297ccf5e590" args="(class StelTextureBackend *textureBackend, const int textureUnit)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelRenderer::bindTextureBackend </td>
          <td>(</td>
          <td class="paramtype">class <a class="el" href="classStelTextureBackend.html">StelTextureBackend</a> *&nbsp;</td>
          <td class="paramname"> <em>textureBackend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>textureUnit</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Bind a texture (following draw calls will use this texture on specified texture unit). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>textureBackend</em>&nbsp;</td><td>Texture to bind. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>textureUnit</em>&nbsp;</td><td>Texture unit to use. If multitexturing is not supported, binds to texture units other than 0 are ignored. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classStelQGLRenderer.html#a2fea12ab8ca2784a373bc42dfaa588c3">StelQGLRenderer</a>.</p>

</div>
</div>
<a class="anchor" id="a19809c61e76bd27ff903bc4550111d47"></a><!-- doxytag: member="StelRenderer::clearDepthBuffer" ref="a19809c61e76bd27ff903bc4550111d47" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelRenderer::clearDepthBuffer </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clear the depth buffer to zeroes, removing any depth information. </p>

<p>Implemented in <a class="el" href="classStelQGLRenderer.html#a04ffa0277917c6c33f1550b5317b3181">StelQGLRenderer</a>.</p>

</div>
</div>
<a class="anchor" id="a339f3610ec4d75a39953f06d36aefc91"></a><!-- doxytag: member="StelRenderer::clearStencilBuffer" ref="a339f3610ec4d75a39953f06d36aefc91" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelRenderer::clearStencilBuffer </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clear the stencil buffer to zeroes, removing any stencil information. </p>

<p>Implemented in <a class="el" href="classStelQGLRenderer.html#a6f403849ff423ebb377e14abc922d761">StelQGLRenderer</a>.</p>

</div>
</div>
<a class="anchor" id="a0b9f984032aa9dcc91ab8df6d9a5c648"></a><!-- doxytag: member="StelRenderer::createGLSLShader" ref="a0b9f984032aa9dcc91ab8df6d9a5c648" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classStelGLSLShader.html">StelGLSLShader</a>* StelRenderer::createGLSLShader </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a GLSL shader. </p>
<p>This can only be called if <a class="el" href="classStelRenderer.html#a216f1c1d98b7a22d33b7915d60cc8293" title="Are GLSL shaders supported?">isGLSLSupported()</a> is true.</p>
<p>The constructed shader must be deleted before the <a class="el" href="classStelRenderer.html" title="Main class of the Renderer subsystem.">StelRenderer</a> is destroyed. </p>

<p>Reimplemented in <a class="el" href="classStelQGL1Renderer.html#ae803720db5a16b44444f49dba24d81e6">StelQGL1Renderer</a>, and <a class="el" href="classStelQGL2Renderer.html#a55e7bf44e0629b72c97e3bce44f264b8">StelQGL2Renderer</a>.</p>

<p>Definition at line <a class="el" href="StelRenderer_8hpp_source.html#l00571">571</a> of file <a class="el" href="StelRenderer_8hpp_source.html">StelRenderer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a58f550570512df06eedf96f073510de6"></a><!-- doxytag: member="StelRenderer::createIndexBuffer" ref="a58f550570512df06eedf96f073510de6" args="(const IndexType type)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual class <a class="el" href="classStelIndexBuffer.html">StelIndexBuffer</a>* StelRenderer::createIndexBuffer </td>
          <td>(</td>
          <td class="paramtype">const IndexType&nbsp;</td>
          <td class="paramname"> <em>type</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create an empty index buffer and return a pointer to it. </p>

<p>Implemented in <a class="el" href="classStelQGLRenderer.html#a6a3ceac34aed22590eb2ee353f650c06">StelQGLRenderer</a>.</p>

</div>
</div>
<a class="anchor" id="a50500ed0778b10caf4044a38718efc19"></a><!-- doxytag: member="StelRenderer::createTexture" ref="a50500ed0778b10caf4044a38718efc19" args="(const void *const data, const QSize size, const TextureDataFormat format, const TextureParams &amp;params=TextureParams())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStelTextureNew.html">StelTextureNew</a>* StelRenderer::createTexture </td>
          <td>(</td>
          <td class="paramtype">const void *const &nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QSize&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TextureDataFormat&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structTextureParams.html">TextureParams</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>params</em> = <code><a class="el" href="structTextureParams.html">TextureParams</a>()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a texture from raw data. </p>
<p>Used to load textures from image data unsupported by QImage, e.g. floating point textures.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>If creating a floating point texture, use <a class="el" href="classStelRenderer.html#ac7750ff0cc84161f0949aea61f77af6d" title="Returns true if floating point textures are supported, false otherwise.">areFloatTexturesSupported()</a> to determine if if floating point textures are supported.</dd></dl>
<p>The texture must be deleted before the <a class="el" href="classStelRenderer.html" title="Main class of the Renderer subsystem.">StelRenderer</a> is destroyed.</p>
<p>This method never fails, but the texture returned might have the Error status. Even in that case, the texture can be bound, but a placeholder texture will be used internally instead.</p>
<p>The texture is created immediately, as with TextureLoadingMode_Normal.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>Pointer to raw image data. Size of the data must be size.width() * size.height() * <em>pixelSize</em>, where <em>pixelSize</em> is size of a pixel of specified format. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Size of the texture in pixels. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>format</em>&nbsp;</td><td>Format of pixels in data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>params</em>&nbsp;</td><td>Texture parameters, such as filtering, wrapping, etc.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>New texture.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Some renderer backends only support textures with power of two dimensions (e.g. 512x512 or 2048x256). On these backends, loading a texture with non-power-of-two dimensions will fail and result in a <a class="el" href="classStelTextureNew.html" title="Texture interface.">StelTextureNew</a> with status of TextureStatus_Error. </dd></dl>

<p>Definition at line <a class="el" href="StelRenderer_8hpp_source.html#l00537">537</a> of file <a class="el" href="StelRenderer_8hpp_source.html">StelRenderer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af881fe1677e3b21ebe24e0e35baf5d1f"></a><!-- doxytag: member="StelRenderer::createTexture" ref="af881fe1677e3b21ebe24e0e35baf5d1f" args="(QImage &amp;image, const TextureParams &amp;params=TextureParams())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStelTextureNew.html">StelTextureNew</a>* StelRenderer::createTexture </td>
          <td>(</td>
          <td class="paramtype">QImage &amp;&nbsp;</td>
          <td class="paramname"> <em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structTextureParams.html">TextureParams</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>params</em> = <code><a class="el" href="structTextureParams.html">TextureParams</a>()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a texture from an image. </p>
<p>The texture must be deleted before the <a class="el" href="classStelRenderer.html" title="Main class of the Renderer subsystem.">StelRenderer</a> is destroyed.</p>
<p>This method never fails, but the texture returned might have the Error status. Even in that case, the texture can be bound, but a placeholder texture will be used internally instead.</p>
<p>The texture is created immediately, as with TextureLoadingMode_Normal.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>image</em>&nbsp;</td><td>Image to load the texture from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>params</em>&nbsp;</td><td>Texture parameters, such as filtering, wrapping, etc.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>New texture.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Some renderer backends only support textures with power of two dimensions (e.g. 512x512 or 2048x256). On these backends, loading a texture with non-power-of-two dimensions will fail and result in a <a class="el" href="classStelTextureNew.html" title="Texture interface.">StelTextureNew</a> with status of TextureStatus_Error. </dd></dl>

<p>Definition at line <a class="el" href="StelRenderer_8hpp_source.html#l00500">500</a> of file <a class="el" href="StelRenderer_8hpp_source.html">StelRenderer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a78b992518c241cc3a12ad964ad12959a"></a><!-- doxytag: member="StelRenderer::createTexture" ref="a78b992518c241cc3a12ad964ad12959a" args="(const QString &amp;filename, const TextureParams &amp;params=TextureParams(), const TextureLoadingMode loadingMode=TextureLoadingMode_Normal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStelTextureNew.html">StelTextureNew</a>* StelRenderer::createTexture </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structTextureParams.html">TextureParams</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>params</em> = <code><a class="el" href="structTextureParams.html">TextureParams</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TextureLoadingMode&nbsp;</td>
          <td class="paramname"> <em>loadingMode</em> = <code>TextureLoadingMode_Normal</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a texture from specified file or URL. </p>
<p>The texture must be deleted before the <a class="el" href="classStelRenderer.html" title="Main class of the Renderer subsystem.">StelRenderer</a> is destroyed.</p>
<p>This method never fails, but the texture returned might have the Error status. Even in that case, the texture can be bound, but a placeholder texture will be used internally instead.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>filename</em>&nbsp;</td><td>File name or URL of the image to load the texture from. If it's a file and it's not found, it's searched for in the <em>textures/</em> directory. Some renderer backends might also support compressed textures with custom file formats. These backend-specific files should not be specified by filename - instead, if a compressed texture with the same file name but different extension exists, it will be used. E.g. the GLES backend prefers a .pvr version of a texture if PVR is supported and it exists. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>params</em>&nbsp;</td><td>Texture parameters, such as filtering, wrapping, etc. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>loadingMode</em>&nbsp;</td><td>Texture loading mode to use. Normal immediately loads the texture, Asynchronous starts loading it in a background thread and LazyAsynchronous starts loading it when it's first needed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>New texture.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Some renderer backends only support textures with power of two dimensions (e.g. 512x512 or 2048x256). On these backends, loading a texture with non-power-of-two dimensions will fail and result in a <a class="el" href="classStelTextureNew.html" title="Texture interface.">StelTextureNew</a> with status of TextureStatus_Error. </dd></dl>

<p>Definition at line <a class="el" href="StelRenderer_8hpp_source.html#l00461">461</a> of file <a class="el" href="StelRenderer_8hpp_source.html">StelRenderer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af175f0223ee53472fe01784a00e5f0af"></a><!-- doxytag: member="StelRenderer::createTextureBackend" ref="af175f0223ee53472fe01784a00e5f0af" args="(const void *data, const QSize size, const TextureDataFormat format, const TextureParams &amp;params)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual class <a class="el" href="classStelTextureBackend.html">StelTextureBackend</a>* StelRenderer::createTextureBackend </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QSize&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TextureDataFormat&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structTextureParams.html">TextureParams</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>params</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of createTexture loading from raw data. </p>
<p>Returns texture backend to be wrapped in a <a class="el" href="classStelTextureNew.html" title="Texture interface.">StelTextureNew</a>. Must not fail, but can return a backend in error state.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classStelRenderer.html#a78b992518c241cc3a12ad964ad12959a" title="Create a texture from specified file or URL.">createTexture</a> </dd></dl>

<p>Implemented in <a class="el" href="classStelQGLRenderer.html#ae503bcd9c4db93ab4a442e186d082601">StelQGLRenderer</a>.</p>

</div>
</div>
<a class="anchor" id="a3f71077f84e3f5a7f03110ba429ad4d0"></a><!-- doxytag: member="StelRenderer::createTextureBackend" ref="a3f71077f84e3f5a7f03110ba429ad4d0" args="(QImage &amp;image, const TextureParams &amp;params)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual class <a class="el" href="classStelTextureBackend.html">StelTextureBackend</a>* StelRenderer::createTextureBackend </td>
          <td>(</td>
          <td class="paramtype">QImage &amp;&nbsp;</td>
          <td class="paramname"> <em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structTextureParams.html">TextureParams</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>params</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of createTexture loading from image. </p>
<p>Returns texture backend to be wrapped in a <a class="el" href="classStelTextureNew.html" title="Texture interface.">StelTextureNew</a>. Must not fail, but can return a backend in error state.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classStelRenderer.html#a78b992518c241cc3a12ad964ad12959a" title="Create a texture from specified file or URL.">createTexture</a> </dd></dl>

<p>Implemented in <a class="el" href="classStelQGLRenderer.html#a455d175e20a6130d92eef45c0ddc297d">StelQGLRenderer</a>.</p>

</div>
</div>
<a class="anchor" id="acc4f270649f47c9acd96f570d125d4b0"></a><!-- doxytag: member="StelRenderer::createTextureBackend" ref="acc4f270649f47c9acd96f570d125d4b0" args="(const QString &amp;filename, const TextureParams &amp;params, const TextureLoadingMode loadingMode)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual class <a class="el" href="classStelTextureBackend.html">StelTextureBackend</a>* StelRenderer::createTextureBackend </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structTextureParams.html">TextureParams</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TextureLoadingMode&nbsp;</td>
          <td class="paramname"> <em>loadingMode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of createTexture. </p>
<p>Returns texture backend to be wrapped in a <a class="el" href="classStelTextureNew.html" title="Texture interface.">StelTextureNew</a>. Must not fail, but can return a backend in error state.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classStelRenderer.html#a78b992518c241cc3a12ad964ad12959a" title="Create a texture from specified file or URL.">createTexture</a> </dd></dl>

<p>Implemented in <a class="el" href="classStelQGLRenderer.html#a41cb4921bf8a35f9f02c053ba3c4d2b6">StelQGLRenderer</a>.</p>

</div>
</div>
<a class="anchor" id="ab20687284a2419e5db806e74dfe91b5b"></a><!-- doxytag: member="StelRenderer::createVertexBuffer" ref="ab20687284a2419e5db806e74dfe91b5b" args="(const PrimitiveType primitiveType)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStelVertexBuffer.html">StelVertexBuffer</a>&lt;V&gt;* StelRenderer::createVertexBuffer </td>
          <td>(</td>
          <td class="paramtype">const PrimitiveType&nbsp;</td>
          <td class="paramname"> <em>primitiveType</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create an empty vertex buffer and return a pointer to it. </p>
<p>The vertex buffer must be deleted by the user once it is not used (and before the Renderer is destroyed).</p>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>V</em>&nbsp;</td><td>Vertex type. See the example in <a class="el" href="classStelVertexBuffer.html" title="Vertex buffer interface.">StelVertexBuffer</a> documentation on how to define a vertex type. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>primitiveType</em>&nbsp;</td><td>Graphics primitive type stored in the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>New vertex buffer storing vertices of type V. </dd></dl>

<p>Definition at line <a class="el" href="StelRenderer_8hpp_source.html#l00283">283</a> of file <a class="el" href="StelRenderer_8hpp_source.html">StelRenderer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aac066b60608fbc338e7449e309dbcc39"></a><!-- doxytag: member="StelRenderer::createVertexBufferBackend" ref="aac066b60608fbc338e7449e309dbcc39" args="(const PrimitiveType primitiveType, const QVector&lt; StelVertexAttribute &gt; &amp;attributes)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classStelVertexBufferBackend.html">StelVertexBufferBackend</a>* StelRenderer::createVertexBufferBackend </td>
          <td>(</td>
          <td class="paramtype">const PrimitiveType&nbsp;</td>
          <td class="paramname"> <em>primitiveType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QVector&lt; <a class="el" href="structStelVertexAttribute.html">StelVertexAttribute</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>attributes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a vertex buffer backend. </p>
<p>Used by createVertexBuffer.</p>
<p>This allows each Renderer backend to create its own vertex buffer backend.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>primitiveType</em>&nbsp;</td><td>Graphics primitive type stored in the buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>attributes</em>&nbsp;</td><td>Descriptions of all attributes of the vertex type stored in the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to a vertex buffer backend specific to the Renderer backend. </dd></dl>

<p>Implemented in <a class="el" href="classStelQGL1Renderer.html#ac33b7e693f5f6c75b8e388c5992ce13d">StelQGL1Renderer</a>, and <a class="el" href="classStelQGL2Renderer.html#a1fec1df533ad5b3e1d77cd17e701c882">StelQGL2Renderer</a>.</p>

</div>
</div>
<a class="anchor" id="a4675c0629e3ee3432650fd6f7efd01f3"></a><!-- doxytag: member="StelRenderer::destroyTextureBackend" ref="a4675c0629e3ee3432650fd6f7efd01f3" args="(class StelTextureBackend *backend)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelRenderer::destroyTextureBackend </td>
          <td>(</td>
          <td class="paramtype">class <a class="el" href="classStelTextureBackend.html">StelTextureBackend</a> *&nbsp;</td>
          <td class="paramname"> <em>backend</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destroy a <a class="el" href="classStelTextureBackend.html" title="Base class for texture implementations.">StelTextureBackend</a>. </p>
<p>The backend might be destroyed, but the implementation might also cache the texture, not destroying it if it has muliple users. </p>

<p>Implemented in <a class="el" href="classStelQGLRenderer.html#ac458404691b59fb8b64c6dd269903043">StelQGLRenderer</a>.</p>

</div>
</div>
<a class="anchor" id="a3ff0e382823be0f621cb2b3d0329ac84"></a><!-- doxytag: member="StelRenderer::drawLine" ref="a3ff0e382823be0f621cb2b3d0329ac84" args="(const float startX, const float startY, const float endX, const float endY)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelRenderer::drawLine </td>
          <td>(</td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>startX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>startY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>endX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>endY</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draw a line with current global color to the screen. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>startX</em>&nbsp;</td><td>X position of the starting point of the line in pixels. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startY</em>&nbsp;</td><td>Y position of the starting point of the line in pixels. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>endX</em>&nbsp;</td><td>X position of the ending point of the line in pixels. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>endY</em>&nbsp;</td><td>Y position of the ending point of the line in pixels. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad2bf023af721715f40058b711828fedf"></a><!-- doxytag: member="StelRenderer::drawRect" ref="ad2bf023af721715f40058b711828fedf" args="(const float x, const float y, const float width, const float height, const float angle=0.0f)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelRenderer::drawRect </td>
          <td>(</td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>angle</em> = <code>0.0f</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draw a rectangle to the screen. </p>
<p>The rectangle will be colored by the global color (which can be specified by <a class="el" href="classStelRenderer.html#a89005c9f1e22bbd5cf58839026168e27" title="Set the global vertex color.">setGlobalColor()</a>).</p>
<p>The rectangle can be rotated around its center by an angle specified in degrees.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>X position of the top left corner on the screen in pixels. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>Y position of the top left corner on the screen in pixels. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>Width in pixels. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>height</em>&nbsp;</td><td>Height in pixels. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>angle</em>&nbsp;</td><td>Angle to rotate the rectangle around its center in degrees. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classStelQGLRenderer.html#a60584228d8840bc4ebba3d40cb727a08">StelQGLRenderer</a>.</p>

</div>
</div>
<a class="anchor" id="a9f9c1ee188f6cf25ff5d7c6df4795416"></a><!-- doxytag: member="StelRenderer::drawText" ref="a9f9c1ee188f6cf25ff5d7c6df4795416" args="(const TextParams &amp;params)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelRenderer::drawText </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structTextParams.html">TextParams</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>params</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draw text with specified parameters. </p>
<p>Parameters are specified by a builder-style struct.</p>
<p>Examples:</p>
<div class="fragment"><pre class="fragment"> <span class="comment">// Note that text position and string must be always specified, so they </span>
 <span class="comment">// are in the constructor.</span>
 <span class="comment">// Draw with default parameters (no rotation, no shift, no gravity, 2D projection).</span>
 renderer-&gt;drawText(<a class="code" href="structTextParams.html" title="Parameters specifying how to draw text.">TextParams</a>(16, 16, <span class="stringliteral">&quot;Hello World&quot;</span>));
 <span class="comment">// Rotate by 30 degrees.</span>
 renderer-&gt;drawText(<a class="code" href="structTextParams.html" title="Parameters specifying how to draw text.">TextParams</a>(16, 16 <span class="stringliteral">&quot;Hello World!&quot;</span>).angleDegrees(30.0f));
 <span class="comment">// Rotate by 30 degrees and shift by (8, 4) in rotated direction.</span>
 renderer-&gt;drawText(<a class="code" href="structTextParams.html" title="Parameters specifying how to draw text.">TextParams</a>(16, 16 <span class="stringliteral">&quot;Hello World!&quot;</span>).angleDegrees(30.0f).shift(8.0f, 4.0f));
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>params</em>&nbsp;</td><td>Parameters of the text to draw.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="structTextParams.html" title="Parameters specifying how to draw text.">TextParams</a> </dd></dl>

<p>Implemented in <a class="el" href="classStelQGLRenderer.html#aaa4a9ea2f30cec537e00822ec07d0136">StelQGLRenderer</a>.</p>

</div>
</div>
<a class="anchor" id="a416d3eb82d34af15fb748af6300d4363"></a><!-- doxytag: member="StelRenderer::drawTexturedRect" ref="a416d3eb82d34af15fb748af6300d4363" args="(const float x, const float y, const float width, const float height, const float angle=0.0f)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelRenderer::drawTexturedRect </td>
          <td>(</td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>angle</em> = <code>0.0f</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draw a textured rectangle to the screen. </p>
<p>The rectangle will be textured by the currently bound texture.</p>
<p>The rectangle can be rotated around its center by an angle specified in degrees.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>X position of the top left corner on the screen in pixels. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>Y position of the top left corner on the screen in pixels. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>Width in pixels. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>height</em>&nbsp;</td><td>Height in pixels. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>angle</em>&nbsp;</td><td>Angle to rotate the rectangle around its center in degrees. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classStelQGLRenderer.html#a895d54cca409e3a24ca190b60fc09194">StelQGLRenderer</a>.</p>

</div>
</div>
<a class="anchor" id="a52dcc1a022495f83a4bf1c448c388e3e"></a><!-- doxytag: member="StelRenderer::drawVertexBuffer" ref="a52dcc1a022495f83a4bf1c448c388e3e" args="(StelVertexBuffer&lt; V &gt; *vertexBuffer, class StelIndexBuffer *indexBuffer, StelProjector *projector, bool dontProject=false)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void StelRenderer::drawVertexBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classStelVertexBuffer.html">StelVertexBuffer</a>&lt; V &gt; *&nbsp;</td>
          <td class="paramname"> <em>vertexBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class <a class="el" href="classStelIndexBuffer.html">StelIndexBuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>indexBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classStelProjector.html">StelProjector</a> *&nbsp;</td>
          <td class="paramname"> <em>projector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>dontProject</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draw contents of a vertex buffer. </p>
<p>This version takes a StelProjector* instead of StelProjectorP - this is not a problem, as the renderer subsystem doesn't store or delete the projector.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vertexBuffer</em>&nbsp;</td><td>Vertex buffer to draw. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>indexBuffer</em>&nbsp;</td><td>Index buffer specifying which vertices from the buffer to draw. If NULL, indexing will not be used and vertices will be drawn directly in order they are in the buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>projector</em>&nbsp;</td><td>Projector to project vertices' positions before drawing. Also determines viewport to draw in. If NULL, no projection will be done and the vertices will be drawn directly. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dontProject</em>&nbsp;</td><td>Disable vertex position projection. (Projection matrix and viewport information of the projector are still used) This is a hack to support <a class="el" href="classStelSkyDrawer.html" title="Provide a set of methods used to draw sky objects taking into account eyes adaptation...">StelSkyDrawer</a>, which already projects the star positions before drawing them. Avoid using this if possible. <a class="el" href="classStelSkyDrawer.html" title="Provide a set of methods used to draw sky objects taking into account eyes adaptation...">StelSkyDrawer</a> might be refactored in future to remove the need for dontProject, in which case it should be removed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>When drawing with a custom <a class="el" href="classStelProjector.html" title="Provide the main interface to all operations of projecting coordinates from sky to...">StelProjector</a> only 3D vertex positions are supported. </dd></dl>

<p>Definition at line <a class="el" href="StelRenderer_8hpp_source.html#l00344">344</a> of file <a class="el" href="StelRenderer_8hpp_source.html">StelRenderer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1ff46049a6698fe6fb648d175052df4a"></a><!-- doxytag: member="StelRenderer::drawVertexBuffer" ref="a1ff46049a6698fe6fb648d175052df4a" args="(StelVertexBuffer&lt; V &gt; *vertexBuffer, class StelIndexBuffer *indexBuffer=NULL, StelProjectorP projector=StelProjectorP(NULL), bool dontProject=false)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void StelRenderer::drawVertexBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classStelVertexBuffer.html">StelVertexBuffer</a>&lt; V &gt; *&nbsp;</td>
          <td class="paramname"> <em>vertexBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class <a class="el" href="classStelIndexBuffer.html">StelIndexBuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>indexBuffer</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQSharedPointer.html">StelProjectorP</a>&nbsp;</td>
          <td class="paramname"> <em>projector</em> = <code><a class="el" href="classQSharedPointer.html">StelProjectorP</a>(NULL)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>dontProject</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draw contents of a vertex buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vertexBuffer</em>&nbsp;</td><td>Vertex buffer to draw. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>indexBuffer</em>&nbsp;</td><td>Index buffer specifying which vertices from the buffer to draw. If NULL, indexing will not be used and vertices will be drawn directly in order they are in the buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>projector</em>&nbsp;</td><td>Projector to project vertices' positions before drawing. Also determines viewport to draw in. If NULL, no projection will be done and the vertices will be drawn directly. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dontProject</em>&nbsp;</td><td>Disable vertex position projection. (Projection matrix and viewport information of the projector are still used) This is a hack to support <a class="el" href="classStelSkyDrawer.html" title="Provide a set of methods used to draw sky objects taking into account eyes adaptation...">StelSkyDrawer</a>, which already projects the star positions before drawing them. Avoid using this if possible. <a class="el" href="classStelSkyDrawer.html" title="Provide a set of methods used to draw sky objects taking into account eyes adaptation...">StelSkyDrawer</a> might be refactored in future to remove the need for dontProject, in which case it should be removed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>When drawing with a custom <a class="el" href="classStelProjector.html" title="Provide the main interface to all operations of projecting coordinates from sky to...">StelProjector</a> only 3D vertex positions are supported. </dd></dl>

<p>Definition at line <a class="el" href="StelRenderer_8hpp_source.html#l00311">311</a> of file <a class="el" href="StelRenderer_8hpp_source.html">StelRenderer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a87bc521b5e19d618f4257c580a841a9e"></a><!-- doxytag: member="StelRenderer::drawVertexBufferBackend" ref="a87bc521b5e19d618f4257c580a841a9e" args="(StelVertexBufferBackend *vertexBuffer, class StelIndexBuffer *indexBuffer, StelProjector *projector, const bool dontProject)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelRenderer::drawVertexBufferBackend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classStelVertexBufferBackend.html">StelVertexBufferBackend</a> *&nbsp;</td>
          <td class="paramname"> <em>vertexBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class <a class="el" href="classStelIndexBuffer.html">StelIndexBuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>indexBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classStelProjector.html">StelProjector</a> *&nbsp;</td>
          <td class="paramname"> <em>projector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>dontProject</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draw contents of a vertex buffer (backend). </p>
<p>Used by drawVertexBuffer.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classStelRenderer.html#a1ff46049a6698fe6fb648d175052df4a" title="Draw contents of a vertex buffer.">drawVertexBuffer</a> </dd></dl>

<p>Implemented in <a class="el" href="classStelQGL1Renderer.html#a79e7ebdb9b9c985f7b7aedaa699a2ad7">StelQGL1Renderer</a>, and <a class="el" href="classStelQGL2Renderer.html#a8e9638f481c5220edd42ed290d754976">StelQGL2Renderer</a>.</p>

</div>
</div>
<a class="anchor" id="ae2653097bc6da56c3507742ddf58424b"></a><!-- doxytag: member="StelRenderer::getStatistics" ref="ae2653097bc6da56c3507742ddf58424b" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classStelRendererStatistics.html">StelRendererStatistics</a>&amp; StelRenderer::getStatistics </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Access statistics data. </p>
<p>Contents are backend specific - might include thing like vertices per frame, estimated texture memory, etc. .</p>
<p>User code might add its own statistics as well (e.g. <a class="el" href="classStelSkyDrawer.html" title="Provide a set of methods used to draw sky objects taking into account eyes adaptation...">StelSkyDrawer</a>). </p>

<p>Implemented in <a class="el" href="classStelQGLRenderer.html#a7af017729278c7724911d78c9ddb13e4">StelQGLRenderer</a>.</p>

</div>
</div>
<a class="anchor" id="acbd5ae94bcf114bfd8f3b16cc72b7a6d"></a><!-- doxytag: member="StelRenderer::getViewportSize" ref="acbd5ae94bcf114bfd8f3b16cc72b7a6d" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual QSize StelRenderer::getViewportSize </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get size of the viewport in pixels. </p>

<p>Implemented in <a class="el" href="classStelQGLRenderer.html#ad302cec1f31deb1c3f75fd5b63f647c3">StelQGLRenderer</a>.</p>

</div>
</div>
<a class="anchor" id="a71f36b14d90531b697532f4b875617d9"></a><!-- doxytag: member="StelRenderer::getViewportTexture" ref="a71f36b14d90531b697532f4b875617d9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStelTextureNew.html">StelTextureNew</a>* StelRenderer::getViewportTexture </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a texture of the viewport, with everything drawn to the viewport so far. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Since some backends only support textures with power of two dimensions, the returned texture might be larger than the viewport in which case only the part of the texture matching viewport size (returned by getViewportSize) will be taken up by the viewport.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Viewport texture. </dd></dl>

<p>Definition at line <a class="el" href="StelRenderer_8hpp_source.html#l00561">561</a> of file <a class="el" href="StelRenderer_8hpp_source.html">StelRenderer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acd5bd5854dff554adfe79603c429b189"></a><!-- doxytag: member="StelRenderer::getViewportTextureBackend" ref="acd5bd5854dff554adfe79603c429b189" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual class <a class="el" href="classStelTextureBackend.html">StelTextureBackend</a>* StelRenderer::getViewportTextureBackend </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of getViewportTexture. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classStelRenderer.html#a71f36b14d90531b697532f4b875617d9" title="Get a texture of the viewport, with everything drawn to the viewport so far.">getViewportTexture</a>. </dd></dl>

<p>Implemented in <a class="el" href="classStelQGLRenderer.html#a8250a04b4365870c09633df1b8e4b2a7">StelQGLRenderer</a>.</p>

</div>
</div>
<a class="anchor" id="adc626548c3c14af69061765c7331fb40"></a><!-- doxytag: member="StelRenderer::init" ref="adc626548c3c14af69061765c7331fb40" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool StelRenderer::init </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize the renderer. </p>
<p>Must be called before any other methods.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true on success, false if there was an error. </dd></dl>

<p>Implemented in <a class="el" href="classStelQGL1Renderer.html#a08018450d3c3c648b3226fa468a1127e">StelQGL1Renderer</a>, <a class="el" href="classStelQGL2Renderer.html#ace7f988e4a3ed17fce0a9cdd84681691">StelQGL2Renderer</a>, and <a class="el" href="classStelQGLRenderer.html#a7d8ce574fbe4c2352e1f73db81c12856">StelQGLRenderer</a>.</p>

</div>
</div>
<a class="anchor" id="a216f1c1d98b7a22d33b7915d60cc8293"></a><!-- doxytag: member="StelRenderer::isGLSLSupported" ref="a216f1c1d98b7a22d33b7915d60cc8293" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool StelRenderer::isGLSLSupported </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Are GLSL shaders supported? </p>

<p>Implemented in <a class="el" href="classStelQGL1Renderer.html#acf522dddb6161e1cb0fb5ef124c8b753">StelQGL1Renderer</a>, and <a class="el" href="classStelQGL2Renderer.html#a2ca96a7f0e373ce89616e7ab6f7b1221">StelQGL2Renderer</a>.</p>

</div>
</div>
<a class="anchor" id="a242b2ff1979f7b4adeec068796b8c8c9"></a><!-- doxytag: member="StelRenderer::renderFrame" ref="a242b2ff1979f7b4adeec068796b8c8c9" args="(StelRenderClient &amp;renderClient)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelRenderer::renderFrame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classStelRenderClient.html">StelRenderClient</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>renderClient</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Render a frame. </p>
<p>This might not render the entire frame - if rendering takes too long, the backend may (or may not) suspend the rendering to finish it next time renderFrame is called.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>renderClient</em>&nbsp;</td><td>Allows the renderer to draw the scene in parts.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classStelRenderClient.html" title="Provides access to scene rendering so StelRenderer can control it.">StelRenderClient</a> </dd></dl>

<p>Implemented in <a class="el" href="classStelQGLRenderer.html#add5a6c8e78455dc08fc70d0ed10ade4e">StelQGLRenderer</a>.</p>

</div>
</div>
<a class="anchor" id="adf0122cc27cffce6c9dddc17af5b4f6f"></a><!-- doxytag: member="StelRenderer::screenshot" ref="adf0122cc27cffce6c9dddc17af5b4f6f" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual QImage StelRenderer::screenshot </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Take a screenshot and return it. </p>

<p>Implemented in <a class="el" href="classStelQGLRenderer.html#ad48378e7ceae49107a0c39960d5a292e">StelQGLRenderer</a>.</p>

</div>
</div>
<a class="anchor" id="af96317f54d1fdf7eeb290319ff42a48f"></a><!-- doxytag: member="StelRenderer::setBlendMode" ref="af96317f54d1fdf7eeb290319ff42a48f" args="(const BlendMode blendMode)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelRenderer::setBlendMode </td>
          <td>(</td>
          <td class="paramtype">const BlendMode&nbsp;</td>
          <td class="paramname"> <em>blendMode</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set blend mode. </p>
<p>Used to enable/disable transparency and similar effects.</p>
<p>On startup, the blend mode is BlendMode_None. </p>

<p>Implemented in <a class="el" href="classStelQGLRenderer.html#ab19d2ee86496acad683a10b146bf659a">StelQGLRenderer</a>.</p>

</div>
</div>
<a class="anchor" id="ae8e882ad75fab3b0bddb24cb5bc3ef90"></a><!-- doxytag: member="StelRenderer::setCulledFaces" ref="ae8e882ad75fab3b0bddb24cb5bc3ef90" args="(const CullFace cullFace)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelRenderer::setCulledFaces </td>
          <td>(</td>
          <td class="paramtype">const CullFace&nbsp;</td>
          <td class="paramname"> <em>cullFace</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set which faces (triangles) should be culled. </p>
<p>Front faces are usually those whose vertices are in counter-clockwise order, but a <a class="el" href="classStelProjector.html" title="Provide the main interface to all operations of projecting coordinates from sky to...">StelProjector</a> might flip this order after projection. If such a <a class="el" href="classStelProjector.html" title="Provide the main interface to all operations of projecting coordinates from sky to...">StelProjector</a> is used with <a class="el" href="classStelRenderer.html#a1ff46049a6698fe6fb648d175052df4a" title="Draw contents of a vertex buffer.">StelRenderer::drawVertexBuffer()</a>, front faces will be clock wise. This doesn't affect the user in any way as the projection is done inside renderer.</p>
<p>However, if doing manual projection and sending the already projected vertices for drawing, this order will be flipped, so previously counter-clockwise(front) faces will be clock-wise (back) faces, so if culling is used, opposite face should be used with <a class="el" href="classStelRenderer.html#ae8e882ad75fab3b0bddb24cb5bc3ef90" title="Set which faces (triangles) should be culled.">setCulledFaces()</a>.</p>
<p>Whether a <a class="el" href="classStelProjector.html" title="Provide the main interface to all operations of projecting coordinates from sky to...">StelProjector</a> changes clockwise-counterclockwise winding can be determined by <a class="el" href="classStelProjector.html#a200b47efbe9b2d6e5770cd3493e36ffb" title="Get whether front faces need to be oriented in the clockwise direction.">StelProjector::flipFrontBackFace()</a>. </p>

<p>Implemented in <a class="el" href="classStelQGLRenderer.html#ac93f760a53cd233e9d43e65f65077599">StelQGLRenderer</a>.</p>

</div>
</div>
<a class="anchor" id="ab5e882f5c441d744300627361634dc0c"></a><!-- doxytag: member="StelRenderer::setDepthTest" ref="ab5e882f5c441d744300627361634dc0c" args="(const DepthTest test)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelRenderer::setDepthTest </td>
          <td>(</td>
          <td class="paramtype">const DepthTest&nbsp;</td>
          <td class="paramname"> <em>test</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set depth test mode. </p>
<p>Depth test is implemented to be as specific as possible, only supporting what Stellarium needs. This might be counterintuitive, as much of the power of OpenGL is removed. However, this makes it easier to implement different Renderer backends that might not necessarily be based on OpenGL. </p>

<p>Implemented in <a class="el" href="classStelQGLRenderer.html#ae3a342301d1fc9ef9f9956820bbe1034">StelQGLRenderer</a>.</p>

</div>
</div>
<a class="anchor" id="a0058e9561eb0e08e67f559d2606576a6"></a><!-- doxytag: member="StelRenderer::setFont" ref="a0058e9561eb0e08e67f559d2606576a6" args="(const QFont &amp;font)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelRenderer::setFont </td>
          <td>(</td>
          <td class="paramtype">const QFont &amp;&nbsp;</td>
          <td class="paramname"> <em>font</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set font to use for drawing text. </p>

<p>Implemented in <a class="el" href="classStelQGLRenderer.html#aa44134f8ff1348ac3bb8443b9935cafe">StelQGLRenderer</a>.</p>

</div>
</div>
<a class="anchor" id="a3c2e2d69a3571192a79eecd94f61fe76"></a><!-- doxytag: member="StelRenderer::setGlobalColor" ref="a3c2e2d69a3571192a79eecd94f61fe76" args="(const float r, const float g, const float b, const float a=1.0f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void StelRenderer::setGlobalColor </td>
          <td>(</td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>a</em> = <code>1.0f</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>setGlobalColor overload specifying color channels directly instead of through Vec4f. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classStelRenderer.html#a89005c9f1e22bbd5cf58839026168e27" title="Set the global vertex color.">setGlobalColor</a> </dd></dl>

<p>Definition at line <a class="el" href="StelRenderer_8hpp_source.html#l00602">602</a> of file <a class="el" href="StelRenderer_8hpp_source.html">StelRenderer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a89005c9f1e22bbd5cf58839026168e27"></a><!-- doxytag: member="StelRenderer::setGlobalColor" ref="a89005c9f1e22bbd5cf58839026168e27" args="(const Vec4f &amp;color)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelRenderer::setGlobalColor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector4.html">Vec4f</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>color</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the global vertex color. </p>
<p>Default color is white.</p>
<p>This color is used when rendering vertex formats that have no vertex color attribute, lines, non-textured rectangles, etc. .</p>
<p>Per-vertex color completely overrides this (this is to keep behavior from before the GL refactor unchanged).</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Color channel values can be outside of the 0-1 range. </dd></dl>

<p>Implemented in <a class="el" href="classStelQGLRenderer.html#a804b3001c2860f89baaf87bd93eb2075">StelQGLRenderer</a>.</p>

</div>
</div>
<a class="anchor" id="a14c566946971937c4be5e97cf336c9f3"></a><!-- doxytag: member="StelRenderer::setStencilTest" ref="a14c566946971937c4be5e97cf336c9f3" args="(const StencilTest test)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelRenderer::setStencilTest </td>
          <td>(</td>
          <td class="paramtype">const StencilTest&nbsp;</td>
          <td class="paramname"> <em>test</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set stencil test mode. </p>
<p>Stencil test is implemented to be as specific as possible, only supporting what Stellarium needs. This might be counterintuitive, as much of the power of OpenGL is removed. However, this makes it easier to implement different Renderer backends that might not necessarily be based on OpenGL. </p>

<p>Implemented in <a class="el" href="classStelQGLRenderer.html#ae72e57b65cdd0e6891b702b12f52bc66">StelQGLRenderer</a>.</p>

</div>
</div>
<a class="anchor" id="afea8473fd7b4877d40fb6a79e387822b"></a><!-- doxytag: member="StelRenderer::swapBuffers" ref="afea8473fd7b4877d40fb6a79e387822b" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelRenderer::swapBuffers </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swap front and back buffers. </p>
<p>This is only needed before the Renderer takes control of frame start/end, e.g. during loading at startup. </p>

<p>Implemented in <a class="el" href="classStelQGLRenderer.html#a67dc51c5ac6c2fa2a712283fd32311ae">StelQGLRenderer</a>.</p>

</div>
</div>
<a class="anchor" id="ae9c21db50f37e99ea5cf851e23f996f8"></a><!-- doxytag: member="StelRenderer::viewportHasBeenResized" ref="ae9c21db50f37e99ea5cf851e23f996f8" args="(const QSize size)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelRenderer::viewportHasBeenResized </td>
          <td>(</td>
          <td class="paramtype">const QSize&nbsp;</td>
          <td class="paramname"> <em>size</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Must be called once at startup and on every GL viewport resize, specifying new size. </p>

<p>Implemented in <a class="el" href="classStelQGLRenderer.html#aca3b114f7e73fefb5b928d95dab8b29a">StelQGLRenderer</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>core/renderer/<a class="el" href="StelRenderer_8hpp_source.html">StelRenderer.hpp</a></li>
</ul>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Fri Jan 18 16:15:52 2013 for Stellarium by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
