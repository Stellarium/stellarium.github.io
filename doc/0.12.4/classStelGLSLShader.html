<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Stellarium: StelGLSLShader Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="stellarium-logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Stellarium 0.12.4</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="codingStyle.html"><span>Coding&#160;Style</span></a></li>
      <li><a href="scripting.html"><span>Scripting</span></a></li>
      <li><a href="plugins.html"><span>Plugins</span></a></li>
      <li><a href="renderer.html"><span>Renderer</span></a></li>
      <li><a href="fileStructure.html"><span>File&#160;Structure</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classStelGLSLShader-members.html">List of all members</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">StelGLSLShader Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>GLSL shader program.  
 <a href="classStelGLSLShader.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="StelGLSLShader_8hpp_source.html">StelGLSLShader.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af0b201fd9eb62e7fea9d2c4c9a645688"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelGLSLShader.html#af0b201fd9eb62e7fea9d2c4c9a645688">~StelGLSLShader</a> ()</td></tr>
<tr class="memdesc:af0b201fd9eb62e7fea9d2c4c9a645688"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the shader program.  <a href="#af0b201fd9eb62e7fea9d2c4c9a645688">More...</a><br/></td></tr>
<tr class="separator:af0b201fd9eb62e7fea9d2c4c9a645688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a278e2dd210b77aad002f6750e5078126"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelGLSLShader.html#a278e2dd210b77aad002f6750e5078126">addVertexShader</a> (const QString &amp;source)=0</td></tr>
<tr class="memdesc:a278e2dd210b77aad002f6750e5078126"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a vertex shader from source, compiling it in the process.  <a href="#a278e2dd210b77aad002f6750e5078126">More...</a><br/></td></tr>
<tr class="separator:a278e2dd210b77aad002f6750e5078126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0124e11de0e4cdbf8384d202367faa0"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelGLSLShader.html#aa0124e11de0e4cdbf8384d202367faa0">addFragmentShader</a> (const QString &amp;source)=0</td></tr>
<tr class="memdesc:aa0124e11de0e4cdbf8384d202367faa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a fragment shader from source, compiling it in the process.  <a href="#aa0124e11de0e4cdbf8384d202367faa0">More...</a><br/></td></tr>
<tr class="separator:aa0124e11de0e4cdbf8384d202367faa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3710da7bb448c5a30a3eadd9fee04c83"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelGLSLShader.html#a3710da7bb448c5a30a3eadd9fee04c83">addVertexShader</a> (const QString &amp;name, const QString &amp;source)=0</td></tr>
<tr class="memdesc:a3710da7bb448c5a30a3eadd9fee04c83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a named (optional) vertex shader.  <a href="#a3710da7bb448c5a30a3eadd9fee04c83">More...</a><br/></td></tr>
<tr class="separator:a3710da7bb448c5a30a3eadd9fee04c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa344eb43fedd32b0e2b87fca9bd053bd"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelGLSLShader.html#aa344eb43fedd32b0e2b87fca9bd053bd">hasVertexShader</a> (const QString &amp;name) const =0</td></tr>
<tr class="memdesc:aa344eb43fedd32b0e2b87fca9bd053bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has a named vertex shader with specified name been added?  <a href="#aa344eb43fedd32b0e2b87fca9bd053bd">More...</a><br/></td></tr>
<tr class="separator:aa344eb43fedd32b0e2b87fca9bd053bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1554e9e078314b55eeda310b25ebdad"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelGLSLShader.html#ad1554e9e078314b55eeda310b25ebdad">enableVertexShader</a> (const QString &amp;name)=0</td></tr>
<tr class="memdesc:ad1554e9e078314b55eeda310b25ebdad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable previously added named vertex shader.  <a href="#ad1554e9e078314b55eeda310b25ebdad">More...</a><br/></td></tr>
<tr class="separator:ad1554e9e078314b55eeda310b25ebdad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad695c0b27278e31db94682deb31d16a5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelGLSLShader.html#ad695c0b27278e31db94682deb31d16a5">disableVertexShader</a> (const QString &amp;name)=0</td></tr>
<tr class="memdesc:ad695c0b27278e31db94682deb31d16a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable previously added named vertex shader.  <a href="#ad695c0b27278e31db94682deb31d16a5">More...</a><br/></td></tr>
<tr class="separator:ad695c0b27278e31db94682deb31d16a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58cae3e4a1916cf6bd07cd5c58b9b34a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelGLSLShader.html#a58cae3e4a1916cf6bd07cd5c58b9b34a">build</a> ()=0</td></tr>
<tr class="memdesc:a58cae3e4a1916cf6bd07cd5c58b9b34a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the shader program.  <a href="#a58cae3e4a1916cf6bd07cd5c58b9b34a">More...</a><br/></td></tr>
<tr class="separator:a58cae3e4a1916cf6bd07cd5c58b9b34a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a725669d679573be1e6a9c8af2efbd708"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelGLSLShader.html#a725669d679573be1e6a9c8af2efbd708">unlock</a> ()=0</td></tr>
<tr class="memdesc:a725669d679573be1e6a9c8af2efbd708"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock the shader program for modifications.  <a href="#a725669d679573be1e6a9c8af2efbd708">More...</a><br/></td></tr>
<tr class="separator:a725669d679573be1e6a9c8af2efbd708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ae3dd75f20c33c3a72d987585b44f1b"><td class="memItemLeft" align="right" valign="top">virtual QString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelGLSLShader.html#a5ae3dd75f20c33c3a72d987585b44f1b">log</a> () const =0</td></tr>
<tr class="memdesc:a5ae3dd75f20c33c3a72d987585b44f1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a string containing the error log of the shader.  <a href="#a5ae3dd75f20c33c3a72d987585b44f1b">More...</a><br/></td></tr>
<tr class="separator:a5ae3dd75f20c33c3a72d987585b44f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f5a6d53ef5352efcbfea770666e8c44"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelGLSLShader.html#a7f5a6d53ef5352efcbfea770666e8c44">bind</a> ()=0</td></tr>
<tr class="memdesc:a7f5a6d53ef5352efcbfea770666e8c44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind the shader, using it for following draw calls.  <a href="#a7f5a6d53ef5352efcbfea770666e8c44">More...</a><br/></td></tr>
<tr class="separator:a7f5a6d53ef5352efcbfea770666e8c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f3315bf08b16dec2d478fdbe0211f6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelGLSLShader.html#ad5f3315bf08b16dec2d478fdbe0211f6">release</a> ()=0</td></tr>
<tr class="memdesc:ad5f3315bf08b16dec2d478fdbe0211f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release a bound shader after use.  <a href="#ad5f3315bf08b16dec2d478fdbe0211f6">More...</a><br/></td></tr>
<tr class="separator:ad5f3315bf08b16dec2d478fdbe0211f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bc28e48dec14620b194f613b9794bcb"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a9bc28e48dec14620b194f613b9794bcb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classStelGLSLShader.html#a9bc28e48dec14620b194f613b9794bcb">setUniformValue</a> (const char *const name, T value)</td></tr>
<tr class="memdesc:a9bc28e48dec14620b194f613b9794bcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set value of a uniform shader variable.  <a href="#a9bc28e48dec14620b194f613b9794bcb">More...</a><br/></td></tr>
<tr class="separator:a9bc28e48dec14620b194f613b9794bcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a687a8efacfc1e876a754fe14c66e80eb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelGLSLShader.html#a687a8efacfc1e876a754fe14c66e80eb">useUnprojectedPositionAttribute</a> ()=0</td></tr>
<tr class="memdesc:a687a8efacfc1e876a754fe14c66e80eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this shader need the unprojected position attribute?  <a href="#a687a8efacfc1e876a754fe14c66e80eb">More...</a><br/></td></tr>
<tr class="separator:a687a8efacfc1e876a754fe14c66e80eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a91a733d6e3181c859889cac2263d50a5"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a91a733d6e3181c859889cac2263d50a5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classStelGLSLShader.html#a91a733d6e3181c859889cac2263d50a5">setUniformValue_</a> (const char *const name, T value)</td></tr>
<tr class="memdesc:a91a733d6e3181c859889cac2263d50a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Default" overload of <a class="el" href="classStelGLSLShader.html#a9bc28e48dec14620b194f613b9794bcb" title="Set value of a uniform shader variable.">setUniformValue()</a> implementation.  <a href="#a91a733d6e3181c859889cac2263d50a5">More...</a><br/></td></tr>
<tr class="separator:a91a733d6e3181c859889cac2263d50a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a214c10ea3ff04c5589e047e5aaf78467"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelGLSLShader.html#a214c10ea3ff04c5589e047e5aaf78467">setUniformValue_</a> (const char *const name, const bool value)=0</td></tr>
<tr class="memdesc:a214c10ea3ff04c5589e047e5aaf78467"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classStelGLSLShader.html#a9bc28e48dec14620b194f613b9794bcb" title="Set value of a uniform shader variable.">setUniformValue()</a> implementation for type bool.  <a href="#a214c10ea3ff04c5589e047e5aaf78467">More...</a><br/></td></tr>
<tr class="separator:a214c10ea3ff04c5589e047e5aaf78467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae75cfbb3292457627d12f43e4bf315a5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelGLSLShader.html#ae75cfbb3292457627d12f43e4bf315a5">setUniformValue_</a> (const char *const name, const int value)=0</td></tr>
<tr class="memdesc:ae75cfbb3292457627d12f43e4bf315a5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classStelGLSLShader.html#a9bc28e48dec14620b194f613b9794bcb" title="Set value of a uniform shader variable.">setUniformValue()</a> implementation for type int.  <a href="#ae75cfbb3292457627d12f43e4bf315a5">More...</a><br/></td></tr>
<tr class="separator:ae75cfbb3292457627d12f43e4bf315a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1d01a179e3708399b25e0bc039eb321"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelGLSLShader.html#ac1d01a179e3708399b25e0bc039eb321">setUniformValue_</a> (const char *const name, const float value)=0</td></tr>
<tr class="memdesc:ac1d01a179e3708399b25e0bc039eb321"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classStelGLSLShader.html#a9bc28e48dec14620b194f613b9794bcb" title="Set value of a uniform shader variable.">setUniformValue()</a> implementation for type float.  <a href="#ac1d01a179e3708399b25e0bc039eb321">More...</a><br/></td></tr>
<tr class="separator:ac1d01a179e3708399b25e0bc039eb321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69f821fa909e80d8f57ef6e0656d0362"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelGLSLShader.html#a69f821fa909e80d8f57ef6e0656d0362">setUniformValue_</a> (const char *const name, const <a class="el" href="classVector2.html">Vec2f</a> value)=0</td></tr>
<tr class="memdesc:a69f821fa909e80d8f57ef6e0656d0362"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classStelGLSLShader.html#a9bc28e48dec14620b194f613b9794bcb" title="Set value of a uniform shader variable.">setUniformValue()</a> implementation for type Vec2f.  <a href="#a69f821fa909e80d8f57ef6e0656d0362">More...</a><br/></td></tr>
<tr class="separator:a69f821fa909e80d8f57ef6e0656d0362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bee668c13ea947c5df973fa54e05d23"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelGLSLShader.html#a8bee668c13ea947c5df973fa54e05d23">setUniformValue_</a> (const char *const name, const <a class="el" href="classVector3.html">Vec3f</a> &amp;value)=0</td></tr>
<tr class="memdesc:a8bee668c13ea947c5df973fa54e05d23"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classStelGLSLShader.html#a9bc28e48dec14620b194f613b9794bcb" title="Set value of a uniform shader variable.">setUniformValue()</a> implementation for type Vec3f.  <a href="#a8bee668c13ea947c5df973fa54e05d23">More...</a><br/></td></tr>
<tr class="separator:a8bee668c13ea947c5df973fa54e05d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af78d1988cf91914e098d1985309a314c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelGLSLShader.html#af78d1988cf91914e098d1985309a314c">setUniformValue_</a> (const char *const name, const <a class="el" href="classVector4.html">Vec4f</a> &amp;value)=0</td></tr>
<tr class="memdesc:af78d1988cf91914e098d1985309a314c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classStelGLSLShader.html#a9bc28e48dec14620b194f613b9794bcb" title="Set value of a uniform shader variable.">setUniformValue()</a> implementation for type Vec4f.  <a href="#af78d1988cf91914e098d1985309a314c">More...</a><br/></td></tr>
<tr class="separator:af78d1988cf91914e098d1985309a314c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d3aa6519199afd04a9a35739d1f1224"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStelGLSLShader.html#a8d3aa6519199afd04a9a35739d1f1224">setUniformValue_</a> (const char *const name, const <a class="el" href="classMatrix4.html">Mat4f</a> &amp;value)=0</td></tr>
<tr class="memdesc:a8d3aa6519199afd04a9a35739d1f1224"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classStelGLSLShader.html#a9bc28e48dec14620b194f613b9794bcb" title="Set value of a uniform shader variable.">setUniformValue()</a> implementation for type Mat4f.  <a href="#a8d3aa6519199afd04a9a35739d1f1224">More...</a><br/></td></tr>
<tr class="separator:a8d3aa6519199afd04a9a35739d1f1224"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>GLSL shader program. </p>
<p>Can be used with Renderer backends that support GLSL, such as the <a class="el" href="classStelQGL2Renderer.html" title="Renderer backend using OpenGL 2.1 or GLSL 2.0 with Qt.">StelQGL2Renderer</a>.</p>
<p>Shader programs are created by <a class="el" href="classStelRenderer.html" title="Main class of the Renderer subsystem.">StelRenderer</a>. After creation, sources of used vertex and fragment shaders have to be added, and then the shader must be built using the <a class="el" href="classStelGLSLShader.html#a58cae3e4a1916cf6bd07cd5c58b9b34a" title="Build the shader program.">build()</a> member function. After that, the shader can be bound to be used for drawing. It can also be modified by calling the <a class="el" href="classStelGLSLShader.html#a725669d679573be1e6a9c8af2efbd708" title="Unlock the shader program for modifications.">unlock()</a> member function and adding more shaders, and even by disabling or reenabling them. Disabling/reenabling is only supported for vertex shaders, but fragment shader functions can be added when needed.</p>
<p>There is currently no geometry shader support, but it can be added when needed.</p>
<p>Uniform variables are set through the <a class="el" href="classStelGLSLShader.html#a9bc28e48dec14620b194f613b9794bcb" title="Set value of a uniform shader variable.">setUniformValue()</a> member function. Only most commonly used data types are supported, but it is easy to add support for more types if needed. Some uniform variables are specified internally and need to be declared in the shader:</p>
<ul>
<li><a class="el" href="classStelProjector.html" title="Provide the main interface to all operations of projecting coordinates from sky to screen...">StelProjector</a>'s projection matrix: <em>mat4f projectionMatrix</em> </li>
<li>Global color (only specified if vertex has no color attribute): <em>vec4 globalColor</em></li>
</ul>
<p>Vertex attributes can't be set through the API - they are set internally from vertex buffer during drawing.</p>
<p>Any shader that uses <a class="el" href="classStelProjector.html" title="Provide the main interface to all operations of projecting coordinates from sky to screen...">StelProjector</a> projection (that is, any shader except of those working with 2D data) must declare and call the <em>project()</em> function to project the vertex position. If vertex projection is done on the CPU, this is a dummy function that simply returns its argument. If it's done on the GPU, it's done in this function.</p>
<p>The <em>project()</em> function must be declared (but not defined), as follows: </p>
<div class="fragment"><div class="line">vec4 project(in vec4 v);</div>
</div><!-- fragment --><p>Usage of the <em>project()</em> function: </p>
<div class="fragment"><div class="line">gl_Position = projectionMatrix * project(vertex);</div>
</div><!-- fragment --><p>Attribute variable names match vertex attribute interpretations as follows:</p>
<ul>
<li>Position: <em>vertex</em> </li>
<li>TexCoord: <em>texCoord</em> </li>
<li>Normal: <em>normal</em> </li>
<li>Color: <em>color</em></li>
</ul>
<p>If <a class="el" href="classStelGLSLShader.html#a687a8efacfc1e876a754fe14c66e80eb" title="Does this shader need the unprojected position attribute?">useUnprojectedPositionAttribute()</a> is called, another attribute is added:</p>
<ul>
<li>Position before <a class="el" href="classStelProjector.html" title="Provide the main interface to all operations of projecting coordinates from sky to screen...">StelProjector</a> projection: <em>unprojectedVertex</em></li>
</ul>
<p>Shader program building can fail. After a failure, the shader is invalid and should not be used (should be destroyed).</p>
<p>Shader creation example:</p>
<div class="fragment"><div class="line"><span class="comment">// renderer is a StelRenderer*</span></div>
<div class="line"><span class="keywordflow">if</span>(renderer-&gt;isGLSLSupported())</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classStelGLSLShader.html" title="GLSL shader program.">StelGLSLShader</a>* shader = renderer-&gt;createGLSLShader();</div>
<div class="line">    <span class="keywordflow">if</span>(!shader-&gt;<a class="code" href="classStelGLSLShader.html#a278e2dd210b77aad002f6750e5078126" title="Add a vertex shader from source, compiling it in the process.">addVertexShader</a>(</div>
<div class="line">       <span class="stringliteral">&quot;vec4 project(in vec4 v);\n&quot;</span></div>
<div class="line">       <span class="stringliteral">&quot;attribute mediump vec4 vertex;\n&quot;</span></div>
<div class="line">       <span class="stringliteral">&quot;uniform mediump mat4 projectionMatrix;\n&quot;</span></div>
<div class="line">       <span class="stringliteral">&quot;void main(void)\n&quot;</span></div>
<div class="line">       <span class="stringliteral">&quot;{\n&quot;</span></div>
<div class="line">       <span class="stringliteral">&quot;    gl_Position = projectionMatrix * project(vertex);\n&quot;</span></div>
<div class="line">       <span class="stringliteral">&quot;}\n&quot;</span>))</div>
<div class="line">    {</div>
<div class="line">        qWarning() &lt;&lt; <span class="stringliteral">&quot;Error adding vertex shader: &quot;</span> &lt;&lt; shader-&gt;<a class="code" href="classStelGLSLShader.html#a5ae3dd75f20c33c3a72d987585b44f1b" title="Return a string containing the error log of the shader.">log</a>();</div>
<div class="line">        <span class="keyword">delete</span> shader;</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>; <span class="comment">// Failed creating shader</span></div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span>(!shader-&gt;<a class="code" href="classStelGLSLShader.html#aa0124e11de0e4cdbf8384d202367faa0" title="Add a fragment shader from source, compiling it in the process.">addFragmentShader</a>(</div>
<div class="line">       <span class="stringliteral">&quot;uniform mediump vec4 globalColor;\n&quot;</span></div>
<div class="line">       <span class="stringliteral">&quot;void main(void)\n&quot;</span></div>
<div class="line">       <span class="stringliteral">&quot;{\n&quot;</span></div>
<div class="line">       <span class="stringliteral">&quot;    gl_FragColor = globalColor;\n&quot;</span></div>
<div class="line">       <span class="stringliteral">&quot;}\n&quot;</span>))</div>
<div class="line">    {</div>
<div class="line">        qWarning() &lt;&lt; <span class="stringliteral">&quot;Error adding fragment shader: &quot;</span> &lt;&lt; shader-&gt;<a class="code" href="classStelGLSLShader.html#a5ae3dd75f20c33c3a72d987585b44f1b" title="Return a string containing the error log of the shader.">log</a>();</div>
<div class="line">        <span class="keyword">delete</span> shader;</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>; <span class="comment">// Failed creating shader</span></div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span>(!shader-&gt;<a class="code" href="classStelGLSLShader.html#a58cae3e4a1916cf6bd07cd5c58b9b34a" title="Build the shader program.">build</a>())</div>
<div class="line">    {</div>
<div class="line">        qWarning() &lt;&lt; <span class="stringliteral">&quot;Error building shader: &quot;</span> &lt;&lt; shader-&gt;<a class="code" href="classStelGLSLShader.html#a5ae3dd75f20c33c3a72d987585b44f1b" title="Return a string containing the error log of the shader.">log</a>();</div>
<div class="line">        <span class="keyword">delete</span> shader;</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>; <span class="comment">// failed creating shader</span></div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// Shader log might contain warnings.</span></div>
<div class="line">    <span class="keywordflow">if</span>(!shader-&gt;<a class="code" href="classStelGLSLShader.html#a5ae3dd75f20c33c3a72d987585b44f1b" title="Return a string containing the error log of the shader.">log</a>().isEmpty())</div>
<div class="line">    {</div>
<div class="line">        qWarning() &lt;&lt; <span class="stringliteral">&quot;Shader creation log: &quot;</span> &lt;&lt; shader-&gt;<a class="code" href="classStelGLSLShader.html#a5ae3dd75f20c33c3a72d987585b44f1b" title="Return a string containing the error log of the shader.">log</a>();</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Shader usage example:</p>
<div class="fragment"><div class="line"><span class="comment">// shader is a StelGLSLShader*</span></div>
<div class="line"><span class="comment">// renderer is a StelRenderer*</span></div>
<div class="line"><span class="comment">// vertices is a StelVertexBuffer&lt;SomeVertexType&gt;*</span></div>
<div class="line"><span class="comment">// indices is a StelIndexBuffer*</span></div>
<div class="line"><span class="comment">// projector is a StelProjectorP</span></div>
<div class="line"></div>
<div class="line">shader-&gt;<a class="code" href="classStelGLSLShader.html#a7f5a6d53ef5352efcbfea770666e8c44" title="Bind the shader, using it for following draw calls.">bind</a>();</div>
<div class="line">shader-&gt;<a class="code" href="classStelGLSLShader.html#a9bc28e48dec14620b194f613b9794bcb" title="Set value of a uniform shader variable.">setUniformValue</a>(<span class="stringliteral">&quot;ambientLight&quot;</span>, <a class="code" href="classVector4.html">Vec4f</a>(0.1f, 0.1f, 0.1f,0.1f));</div>
<div class="line">renderer-&gt;drawVertexBuffer(vertices, indices, projector);</div>
<div class="line">shader-&gt;<a class="code" href="classStelGLSLShader.html#ad5f3315bf08b16dec2d478fdbe0211f6" title="Release a bound shader after use.">release</a>();</div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a class="el" href="classStelRenderer.html" title="Main class of the Renderer subsystem.">StelRenderer</a> </dd></dl>

<p>Definition at line <a class="el" href="StelGLSLShader_8hpp_source.html#l00145">145</a> of file <a class="el" href="StelGLSLShader_8hpp_source.html">StelGLSLShader.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="af0b201fd9eb62e7fea9d2c4c9a645688"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual StelGLSLShader::~StelGLSLShader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy the shader program. </p>
<p><a class="el" href="classStelGLSLShader.html" title="GLSL shader program.">StelGLSLShader</a> must be destroyed by the user before its Renderer is destroyed. </p>

<p>Definition at line <a class="el" href="StelGLSLShader_8hpp_source.html#l00151">151</a> of file <a class="el" href="StelGLSLShader_8hpp_source.html">StelGLSLShader.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aa0124e11de0e4cdbf8384d202367faa0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool StelGLSLShader::addFragmentShader </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a fragment shader from source, compiling it in the process. </p>
<p>This operation can fail. In case of failure, use <a class="el" href="classStelGLSLShader.html#a5ae3dd75f20c33c3a72d987585b44f1b" title="Return a string containing the error log of the shader.">log()</a> to find out the cause.</p>
<p>The shader must be unlocked when this is called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>Source code of the shader. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if succesfully added and compiled, false otherwise. </dd></dl>

<p>Implemented in <a class="el" href="classStelQGLGLSLShader.html#ae256bbd5a3bd9c0be0017919ba95f2cb">StelQGLGLSLShader</a>.</p>

</div>
</div>
<a class="anchor" id="a278e2dd210b77aad002f6750e5078126"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool StelGLSLShader::addVertexShader </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a vertex shader from source, compiling it in the process. </p>
<p>This operation can fail. In case of failure, use <a class="el" href="classStelGLSLShader.html#a5ae3dd75f20c33c3a72d987585b44f1b" title="Return a string containing the error log of the shader.">log()</a> to find out the cause.</p>
<p>The shader must be unlocked when this is called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>Source code of the shader. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if succesfully added and compiled, false otherwise. </dd></dl>

<p>Implemented in <a class="el" href="classStelQGLGLSLShader.html#a3622e52fdd0dbd362cb4e334b6cae82c">StelQGLGLSLShader</a>.</p>

</div>
</div>
<a class="anchor" id="a3710da7bb448c5a30a3eadd9fee04c83"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool StelGLSLShader::addVertexShader </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a named (optional) vertex shader. </p>
<p>Named vertex shaders can be disabled and reenabled. (Unnamed shaders are always enabled.) This allows to dynamically exchange implementations of functions, making shaders modular. GLSL projection is an example of this.</p>
<p>The shader must be unlocked when this is called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the shader. </td></tr>
    <tr><td class="paramname">source</td><td>Source code of the shader. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classStelQGLGLSLShader.html#a4f631cf343291ccbbf5799e594f67cd8">StelQGLGLSLShader</a>.</p>

</div>
</div>
<a class="anchor" id="a7f5a6d53ef5352efcbfea770666e8c44"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelGLSLShader::bind </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind the shader, using it for following draw calls. </p>
<p>This must be called before setting uniforms. The shader must be built when this is called.</p>
<p>Note that the shader must be released after any draw calls using the shader to allow default shaders to return to use. </p>

<p>Implemented in <a class="el" href="classStelQGLGLSLShader.html#aa77410a83e7cb4acb698b52e6356ccc8">StelQGLGLSLShader</a>.</p>

</div>
</div>
<a class="anchor" id="a58cae3e4a1916cf6bd07cd5c58b9b34a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool StelGLSLShader::build </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build the shader program. </p>
<p>This must be called before the shader can be bound.</p>
<p>This operation can fail. In case of failure, use <a class="el" href="classStelGLSLShader.html#a5ae3dd75f20c33c3a72d987585b44f1b" title="Return a string containing the error log of the shader.">log()</a> to find out the cause. If <a class="el" href="classStelGLSLShader.html#a58cae3e4a1916cf6bd07cd5c58b9b34a" title="Build the shader program.">build()</a> fails, the shader should be assumed to no longer be usable and be destroyed.</p>
<dl class="section return"><dt>Returns</dt><dd>true if succesfully built, false otherwise. </dd></dl>

<p>Implemented in <a class="el" href="classStelQGLGLSLShader.html#afce8499cfc8a6a35c57a315f02bff25f">StelQGLGLSLShader</a>.</p>

</div>
</div>
<a class="anchor" id="ad695c0b27278e31db94682deb31d16a5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelGLSLShader::disableVertexShader </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disable previously added named vertex shader. </p>
<p>The shader must be unlocked when this is called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the shader to disable. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classStelQGLGLSLShader.html#aa7edd3270500c4162a62c3e8dc761721">StelQGLGLSLShader</a>.</p>

</div>
</div>
<a class="anchor" id="ad1554e9e078314b55eeda310b25ebdad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelGLSLShader::enableVertexShader </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable previously added named vertex shader. </p>
<p>The shader must be unlocked when this is called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the shader to enable. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classStelQGLGLSLShader.html#a2df5e9b94a5f39cd733728845ef62d52">StelQGLGLSLShader</a>.</p>

</div>
</div>
<a class="anchor" id="aa344eb43fedd32b0e2b87fca9bd053bd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool StelGLSLShader::hasVertexShader </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Has a named vertex shader with specified name been added? </p>

<p>Implemented in <a class="el" href="classStelQGLGLSLShader.html#af9db84b9cbed6ee5428bb2a1dde61c1f">StelQGLGLSLShader</a>.</p>

</div>
</div>
<a class="anchor" id="a5ae3dd75f20c33c3a72d987585b44f1b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual QString StelGLSLShader::log </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a string containing the error log of the shader. </p>
<p>If the shader is succesfully built, it will contain a success message. It might also contain GLSL code warnings. </p>

<p>Implemented in <a class="el" href="classStelQGLGLSLShader.html#a91fe541891340fb1ff0b551aed3b0218">StelQGLGLSLShader</a>.</p>

</div>
</div>
<a class="anchor" id="ad5f3315bf08b16dec2d478fdbe0211f6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelGLSLShader::release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release a bound shader after use. </p>
<p>This must be called after using the shader so that the <a class="el" href="classStelRenderer.html" title="Main class of the Renderer subsystem.">StelRenderer</a> backend can go back to using default shaders.</p>
<p>It also must be called before <a class="el" href="classStelGLSLShader.html#a7f5a6d53ef5352efcbfea770666e8c44" title="Bind the shader, using it for following draw calls.">bind()</a>-ing another <a class="el" href="classStelGLSLShader.html" title="GLSL shader program.">StelGLSLShader</a>. </p>

<p>Implemented in <a class="el" href="classStelQGLGLSLShader.html#af6092a51ab7d0ae0f6640c9bf14530d5">StelQGLGLSLShader</a>.</p>

</div>
</div>
<a class="anchor" id="a9bc28e48dec14620b194f613b9794bcb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StelGLSLShader::setUniformValue </td>
          <td>(</td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set value of a uniform shader variable. </p>
<p>A uniform variable has the same value for each drawn vertex/pixel. This can be used for things such as a transformation matrix, global vertex color and so on.</p>
<p><a class="el" href="classStelGLSLShader.html#a9bc28e48dec14620b194f613b9794bcb" title="Set value of a uniform shader variable.">setUniformValue()</a> supports these data types (GLSL type in parentheses):</p>
<p>bool(bool), int(int), float(float), Vec2f(vec2), Vec3f(vec3), Vec4f(vec4), Mat4f(mat4)</p>
<p>The shader must be bound when this is called.</p>
<dl class="section note"><dt>Note</dt><dd>Due to dynamic shader re-linking needed to support modular shaders, uniforms are cached internally and only uploaded at the draw call when the shader is used. Fixed amount of storage is allocated (currently 512 bytes, which is enough for 8 4x4 matrices). Also only a fixed number of uniforms is supported (currently 32). Both of these limits can be increased if needed (see <a class="el" href="classStelQGLGLSLShader.html" title="QGL based StelGLSLShader implementation, used by the QGL2 renderer backend.">StelQGLGLSLShader</a>). This storage is written to with each <a class="el" href="classStelGLSLShader.html#a9bc28e48dec14620b194f613b9794bcb" title="Set value of a uniform shader variable.">setUniformValue()</a> call, and freed on a call to <a class="el" href="classStelGLSLShader.html#ad5f3315bf08b16dec2d478fdbe0211f6" title="Release a bound shader after use.">release()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the uniform variable. Must match variable name in at least one of the used vertex/fragment shaders. For efficiency reasons, the name is not guaranteed to be copied within the shader backend. Therefore, the name string must exist until a call to <a class="el" href="classStelGLSLShader.html#ad5f3315bf08b16dec2d478fdbe0211f6" title="Release a bound shader after use.">release()</a>. (This is easiest to achieve by simply using string literals.) </td></tr>
    <tr><td class="paramname">value</td><td>Value to set the variable to. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="StelGLSLShader_8hpp_source.html#l00275">275</a> of file <a class="el" href="StelGLSLShader_8hpp_source.html">StelGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a91a733d6e3181c859889cac2263d50a5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StelGLSLShader::setUniformValue_ </td>
          <td>(</td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>"Default" overload of <a class="el" href="classStelGLSLShader.html#a9bc28e48dec14620b194f613b9794bcb" title="Set value of a uniform shader variable.">setUniformValue()</a> implementation. </p>
<p>This is called for unsupported uniform types, and results in an error. </p>

<p>Definition at line <a class="el" href="StelGLSLShader_8hpp_source.html#l00295">295</a> of file <a class="el" href="StelGLSLShader_8hpp_source.html">StelGLSLShader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a214c10ea3ff04c5589e047e5aaf78467"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelGLSLShader::setUniformValue_ </td>
          <td>(</td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classStelGLSLShader.html#a9bc28e48dec14620b194f613b9794bcb" title="Set value of a uniform shader variable.">setUniformValue()</a> implementation for type bool. </p>

<p>Implemented in <a class="el" href="classStelQGLGLSLShader.html#a0047941dae7309de8d2f16fcb9064653">StelQGLGLSLShader</a>.</p>

</div>
</div>
<a class="anchor" id="ae75cfbb3292457627d12f43e4bf315a5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelGLSLShader::setUniformValue_ </td>
          <td>(</td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classStelGLSLShader.html#a9bc28e48dec14620b194f613b9794bcb" title="Set value of a uniform shader variable.">setUniformValue()</a> implementation for type int. </p>

<p>Implemented in <a class="el" href="classStelQGLGLSLShader.html#ac3023513bbb3dd149985b4a82f085a9a">StelQGLGLSLShader</a>.</p>

</div>
</div>
<a class="anchor" id="ac1d01a179e3708399b25e0bc039eb321"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelGLSLShader::setUniformValue_ </td>
          <td>(</td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classStelGLSLShader.html#a9bc28e48dec14620b194f613b9794bcb" title="Set value of a uniform shader variable.">setUniformValue()</a> implementation for type float. </p>

<p>Implemented in <a class="el" href="classStelQGLGLSLShader.html#a6777673cd29406dd71a763ae4006e90f">StelQGLGLSLShader</a>.</p>

</div>
</div>
<a class="anchor" id="a69f821fa909e80d8f57ef6e0656d0362"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelGLSLShader::setUniformValue_ </td>
          <td>(</td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector2.html">Vec2f</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classStelGLSLShader.html#a9bc28e48dec14620b194f613b9794bcb" title="Set value of a uniform shader variable.">setUniformValue()</a> implementation for type Vec2f. </p>

<p>Implemented in <a class="el" href="classStelQGLGLSLShader.html#adc6d335b09ac9090f004accb5abb50d1">StelQGLGLSLShader</a>.</p>

</div>
</div>
<a class="anchor" id="a8bee668c13ea947c5df973fa54e05d23"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelGLSLShader::setUniformValue_ </td>
          <td>(</td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector3.html">Vec3f</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classStelGLSLShader.html#a9bc28e48dec14620b194f613b9794bcb" title="Set value of a uniform shader variable.">setUniformValue()</a> implementation for type Vec3f. </p>

<p>Implemented in <a class="el" href="classStelQGLGLSLShader.html#a5a0e34af39318399cc0467cd0fc3841f">StelQGLGLSLShader</a>.</p>

</div>
</div>
<a class="anchor" id="af78d1988cf91914e098d1985309a314c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelGLSLShader::setUniformValue_ </td>
          <td>(</td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector4.html">Vec4f</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classStelGLSLShader.html#a9bc28e48dec14620b194f613b9794bcb" title="Set value of a uniform shader variable.">setUniformValue()</a> implementation for type Vec4f. </p>

<p>Implemented in <a class="el" href="classStelQGLGLSLShader.html#adbf755525e35371a075446caaef2d82b">StelQGLGLSLShader</a>.</p>

</div>
</div>
<a class="anchor" id="a8d3aa6519199afd04a9a35739d1f1224"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelGLSLShader::setUniformValue_ </td>
          <td>(</td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrix4.html">Mat4f</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classStelGLSLShader.html#a9bc28e48dec14620b194f613b9794bcb" title="Set value of a uniform shader variable.">setUniformValue()</a> implementation for type Mat4f. </p>

<p>Implemented in <a class="el" href="classStelQGLGLSLShader.html#acce297bc9acde642067b4fe946fe06ca">StelQGLGLSLShader</a>.</p>

</div>
</div>
<a class="anchor" id="a725669d679573be1e6a9c8af2efbd708"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelGLSLShader::unlock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unlock the shader program for modifications. </p>
<p>Allows to, add, enable, disable vertex/fragment shaders.</p>
<p>This can be called even if the shader is bound (which is used for last-moment modifications, like GLSL projection in renderer backend), but it must be rebuilt before drawing and releasing. </p>

<p>Implemented in <a class="el" href="classStelQGLGLSLShader.html#a77cee9a54b10362701642fa443a9995a">StelQGLGLSLShader</a>.</p>

</div>
</div>
<a class="anchor" id="a687a8efacfc1e876a754fe14c66e80eb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void StelGLSLShader::useUnprojectedPositionAttribute </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does this shader need the unprojected position attribute? </p>
<p>If called, the shader will have to declare another vertex attribute, <em>unprojectedVertex</em>, for vertex position before <a class="el" href="classStelProjector.html" title="Provide the main interface to all operations of projecting coordinates from sky to screen...">StelProjector</a> projection. Useful e.g. for lighting. </p>

<p>Implemented in <a class="el" href="classStelQGLGLSLShader.html#a2afb696e7f20bf5deb14e28aea141a10">StelQGLGLSLShader</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>core/renderer/<a class="el" href="StelGLSLShader_8hpp_source.html">StelGLSLShader.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Sep 25 2013 22:30:31 for Stellarium by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>
