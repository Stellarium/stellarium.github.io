<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Stellarium: Renderer</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="stellarium-logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Stellarium 0.12.4</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="codingStyle.html"><span>Coding&#160;Style</span></a></li>
      <li><a href="scripting.html"><span>Scripting</span></a></li>
      <li><a href="plugins.html"><span>Plugins</span></a></li>
      <li><a href="renderer.html"><span>Renderer</span></a></li>
      <li><a href="fileStructure.html"><span>File&#160;Structure</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Renderer </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="introduction"></a>
Introduction</h1>
<p>During Google Summer of Code 2012, graphics code was separated into a subsystem called Renderer (<code>src/core/renderer</code>).</p>
<p>Renderer is composed of interface classes abstracting away low-level graphics work, and backend classes either derived from or used by the interface classes.</p>
<p>This allows to change underlying implementation without rewriting drawing code. For example, we now have two sets of backend classes: GL1 and GL2. Which one is used is decided at startup without affecting drawing code.</p>
<h1><a class="anchor" id="outline"></a>
API outline</h1>
<div class="image">
<img src="renderer-api-overview.png" alt="renderer-api-overview.png"/>
</div>
<h2><a class="anchor" id="stelrenderer"></a>
StelRenderer</h2>
<p>The central class of the Renderer subsystem is <a class="el" href="classStelRenderer.html" title="Main class of the Renderer subsystem.">StelRenderer</a>. It constructs other graphics classes (textures, vertex and index buffers, etc.) and sets graphics state (global color, depth test mode, etc.). It also handles drawing. There is always only one <a class="el" href="classStelRenderer.html" title="Main class of the Renderer subsystem.">StelRenderer</a> instance, though it's not a singleton (no global access). While the graphics classes are constructed by <a class="el" href="classStelRenderer.html" title="Main class of the Renderer subsystem.">StelRenderer</a>, it's the caller's responsibility to delete them. Also, they must be destroyed before <a class="el" href="classStelRenderer.html" title="Main class of the Renderer subsystem.">StelRenderer</a> (which is destroyed right before the program exits).</p>
<p>For example, to construct a texture (<a class="el" href="classStelTextureNew.html" title="Texture interface.">StelTextureNew</a>), call <a class="el" href="classStelRenderer.html#a78b992518c241cc3a12ad964ad12959a" title="Create a texture from specified file or URL.">StelRenderer::createTexture()</a>, to construct a vertex buffer (<a class="el" href="classStelVertexBuffer.html" title="Vertex buffer interface.">StelVertexBuffer</a>), call <a class="el" href="classStelRenderer.html#a977f76433ae9f9fc6f0a1f3109cd9cc6" title="Create an empty vertex buffer and return a pointer to it.">StelRenderer::createVertexBuffer()</a>, and so on.</p>
<p>Handling construction of graphics classes in <a class="el" href="classStelRenderer.html" title="Main class of the Renderer subsystem.">StelRenderer</a> allows different backends (e.g. GL1, GL2) to construct their own implementations.</p>
<h2><a class="anchor" id="stelvertexbuffer"></a>
StelVertexBuffer</h2>
<p><a class="el" href="classStelVertexBuffer.html" title="Vertex buffer interface.">StelVertexBuffer</a> is a templated array-like container constructed by <a class="el" href="classStelRenderer.html" title="Main class of the Renderer subsystem.">StelRenderer</a> that stores vertices. A vertex is a struct specified by user through the template argument; it has to fulfill some requirements (see <a class="el" href="classStelVertexBuffer.html" title="Vertex buffer interface.">StelVertexBuffer</a> documentation), e.g. it can't have data members that don't make sense in a vertex. Various vertex types are possible; vertex type specifies what attributes to use (position, texcoord, color, normal) as well as their dimensions.</p>
<p>Before drawing, a vertex buffer must be locked, allowing things like uploading vertices to the GPU. Vertex buffers are drawn using <a class="el" href="classStelRenderer.html" title="Main class of the Renderer subsystem.">StelRenderer</a>. If possible, they should be filled once, locked, and never unlocked again. Backend might then move the vertex data to the GPU, greatly improving performance even if some extra vertices are drawn.</p>
<h2><a class="anchor" id="stelindexbuffer"></a>
StelIndexBuffer</h2>
<p>Index buffers can be used with vertex buffers to specify which vertices to draw. For example, a vertex buffer containing a 2D grid might be used with many index buffers (one draw per index buffer), each specifying a row of the grid as a triangle strip. <a class="el" href="classStelIndexBuffer.html" title="Generic index buffer interface usable with all Renderer backends.">StelIndexBuffer</a> API is similar to <a class="el" href="classStelVertexBuffer.html" title="Vertex buffer interface.">StelVertexBuffer</a>, but it's not templated. There are 2 index types (specified at construction); 16bit and 32bit. 16bit is faster but only usable with with up to 65535 vertices. Again, the buffer must be locked before drawing, and it's best to keep it locked for a long time without modifications.</p>
<h2><a class="anchor" id="steltexturenew"></a>
StelTextureNew</h2>
<p>Textures are bound to texture units to be used in following draws. Textures are used only with vertex types that have texture coordinates. By default, only the texture bound to the first texture unit is drawn, interpreted as color. Shaders can also use other texture units and interpret the texture differently (as normals, specularity, etc.).</p>
<p><a class="el" href="classStelTextureNew.html" title="Texture interface.">StelTextureNew</a> is the interface class for textures. <a class="el" href="classStelRenderer.html" title="Main class of the Renderer subsystem.">StelRenderer</a> never fails to construct a texture, but the new texture might be in various states. If loading fails, the texture is in "Error" state, and, when bound, a placeholder texture is used instead. Depending on creation parameters, a texture might still be loading in background when constructed. It might even wait to start loading until the first time it's bound. In this case the placeholder is used until loading finishes.</p>
<h2><a class="anchor" id="stelglslshader"></a>
StelGLSLShader</h2>
<p>Shaders are programs running on the GPU that can override default graphics functionality. They are usually used for advanced effects such as normal mapping, shadows, and so on. Some backends (GL2) might draw everything with shaders internally, but default graphics functionality is unchanged. Graphics APIs have different shader languages; for OpenGL, GLSL is used. There is no simple way to abstract this behind a backend-independent interface, so instead of a generic "Shader" class, GLSL is used as an optional <a class="el" href="classStelRenderer.html" title="Main class of the Renderer subsystem.">StelRenderer</a> feature that might not be supported by a backend. If ever needed, support for HLSL (used by Direct3D) might be implemented in a similar way.</p>
<p><a class="el" href="classStelGLSLShader.html" title="GLSL shader program.">StelGLSLShader</a> is a GLSL shader program class constructed by <a class="el" href="classStelRenderer.html" title="Main class of the Renderer subsystem.">StelRenderer</a>. The program is composed of vertex and fragment shaders, equivalent to .c files in a C program. There must be at least one vertex and one fragment shader. There might be more, which is useful for more complex shaders. There can only be one main() function for vertex shader and one for fragment shader. Shaders can be named, and enabled or disabled by name, allowing for exchangeable modules.</p>
<p>Vertex shaders run once per vertex while fragment shaders run at least once per pixel. Keep this in mind; a graphics scene might have 100000 vertices but it will likely have many more pixels, e.g. 1920x1080 is roughly 2000000 pixels.</p>
<p>Code using GLSL must be optional as the renderer might not support it. The code must first ask <a class="el" href="classStelRenderer.html" title="Main class of the Renderer subsystem.">StelRenderer</a> if GLSL is supported, if so, use the GLSL-based code, and otherwise use a fallback implemented without shaders. For non-essential effects, like shadows, disabling the effect without a fallback might be enough.</p>
<h2><a class="anchor" id="extensions"></a>
Renderer extension classes</h2>
<p>Some graphics functionality is commonly used but can be implemented using existing Renderer API. Unless heavy optimizations are needed , this functionality should be built on top of other Renderer classes. I call this "extensions". The advantage of extensions is that they only depend on the public Renderer API, reducing work needed to be done in each backend.</p>
<p>An example is sphere drawing. While <a class="el" href="classStelRenderer.html" title="Main class of the Renderer subsystem.">StelRenderer</a> could have a "drawSphere" member function, adding such functions might result in a difficult to implement API. So instead we have a class that builds sphere vertex/index buffers using existing API.</p>
<p>Current extension classes are <a class="el" href="classStelGeometryBuilder.html" title="Builds various geometry primitives, storing them in vertex buffers.">StelGeometryBuilder</a> and <a class="el" href="classStelCircleArcRenderer.html" title="Provides functions to draw circle arcs using StelRenderer.">StelCircleArcRenderer</a>. The former builds vertex buffers with various geometry to be drawn. The latter draws circle arcs, used to display various lines in the sky with correct curvature.</p>
<h1><a class="anchor" id="api_philosophy"></a>
API design philosophy</h1>
<p>Renderer is designed with five priorities, in this order:</p>
<ol>
<li>
ease of use (code using Renderer)  </li>
<li>
portability (ease of backend implementation)  </li>
<li>
maintainability (avoid bug creep, avoid API breaking)  </li>
<li>
speed (FPS)  </li>
<li>
power (features)  </li>
</ol>
<p>This is not absolute. Portability can trump ease of use; otherwise we'd use a plain GL2+ wrapper. Same is true for speed; otherwise we'd have an immediate mode style API.</p>
<p>Ease of use is rather obvious. Drawing code should be as simple as possible. While some graphics knowledge is required, we should not require mastery of OpenGL.</p>
<p>Portability matters as Stellarium runs not only on the PC OS's, but also on mobile platforms and maybe even some embedded systems. Getting a basic backend for a new platform to work should be a straightforward, one-week task. Eventually, Stellarium will need backends for OpenGL 4+ and OpenGL ES 3. A backend should not need to implement hundreds of functions.</p>
<p>Maintainability is close to portability. To be portable, an API should be simple, and a simple API will also be more maintainable. Features should not be added because they are cool; they should be added when needed. They should be well documented, both API and implementation. Documentation should include code examples if possible, and be updated immediately when a feature changes, not "when time allows it". Tests should be added when possible; we still need to improve this. Code should be simple first. Unless it absolutely needs to be powerful and/or optimized, it should be easy to read. 100-line functions are bad. 1000-line files are unacceptable.</p>
<p>Speed is important as Stellarium is a real-time app. It's not Crysis, so speed isn't the main priority, but it's not Crysis, so it shouldn't require high-end hardware. Old GPUs should work, as should modern integrated GPUs. With Stellarium's graphics it's viable to support mainstream hardware up to 10 years old. That said, speed often conflicts with maintainability. Optimization should only be done based on careful profiling and measurable gains. Adding 1000 lines to get 0.1 FPS will result in bugs and maybe even slowdown as code rots and hardware changes.</p>
<p>The API must be powerful to draw everything Stellarium needs. However, we don't compete in the demoscene; if not adding a feature Stellarium does not need will make the API simpler or more portable, we shouldn't add it. For example, <a class="el" href="classStelRenderer.html" title="Main class of the Renderer subsystem.">StelRenderer</a> depth buffer functionality doesn't match OpenGL; it only covers the cases we use (with a mechanism to add more if needed). This disallows creating some effects possible with OpenGL, but it is simpler, and much easier to emulate on a backend that does not support these particular OpenGL features.</p>
<h1><a class="anchor" id="implementation"></a>
Implementation</h1>
<h2><a class="anchor" id="impl_overview"></a>
Overview</h2>
<div class="image">
<img src="renderer-implementation-overview.png" alt="renderer-implementation-overview.png"/>
</div>
<p>Currently there are two Renderer backends: QGL1 and QGL2, based on OpenGL 1.2 and OpenGL 2.1 respectively. They use Qt's QGL classes for things like context management and texture upload. Code common for both versions, like some GL state, textures, viewport and vertex array manipulation, is shared between these, while code such as fixed-function/shaders and drawing is separate.</p>
<p>The QGL1 backend is designed for compatibility with old hardware; it doesn't usually use new features brought by extensions or later GL 1.x versions. It requires GL 1.2 for vertex array and texture clamp to edge wrapping mode support. After Qt5 removes GL 1.x support this backend should still work as GL 2.x is backwards compatible with GL 1.x; but only on drivers that support GL 2.x . It provides better compatibility/speed for older GPUs and buggy drivers.</p>
<p>The QGL2 backend should use GL 2.1 to its fullest, and might even have optionally use features from GL 3.x and extensions, but never require them. An example is float texture support, which requires GL 3.0 . It's required for advanced effects such as shadows, and obviously for any GLSL based effects. It's also likely to be slower than the QGL1 backend.</p>
<h2><a class="anchor" id="viewport"></a>
StelQGLViewport</h2>
<p>Manages the viewport. It handles capturing the screen to a texture, screenshots and so on. If FBOs are supported and not disabled, custom double buffering logic is used allowing to interrupt a frame in progress to increase responsiveness, finishing the drawing later.</p>
<h2><a class="anchor" id="vertexbufferbackend"></a>
StelVertexBufferBackend and implementations</h2>
<p>In C++, a templated function can never be virtual; so <b>createVertexBuffer()</b> functions of <a class="el" href="classStelRenderer.html" title="Main class of the Renderer subsystem.">StelRenderer</a> implementations can't construct objects derived from <b>StelVertexBuffer&lt;SomeVertexType&gt;</b> . To work around this limitation without sacrificing its safe templated API <a class="el" href="classStelVertexBuffer.html" title="Vertex buffer interface.">StelVertexBuffer</a> wraps a non-templated class, <a class="el" href="classStelVertexBufferBackend.html" title="Base class of all vertex buffer backends.">StelVertexBufferBackend</a>, from which backend vertex buffers are derived. <a class="el" href="classStelRenderer.html" title="Main class of the Renderer subsystem.">StelRenderer</a> has an internal virtual function that allows its implementations to return a custom vertex buffer backend type.</p>
<p><a class="el" href="classStelVertexBufferBackend.html" title="Base class of all vertex buffer backends.">StelVertexBufferBackend</a> doesn't know the vertex type directly; it uses metadata from the VERTEX_ATTRIBUTES macro in the vertex type describing its layout and vertex attributes (data members).</p>
<p>Currently, only one vertex buffer backend exists; <a class="el" href="classStelQGLArrayVertexBufferBackend.html" title="Base class for QGL-using vertex buffer backends based on separate attribute arrays.">StelQGLArrayVertexBufferBackend</a>, based on vertex arrays where each vertex attribute is in a separate array. GL version specific backends <a class="el" href="classStelQGL1ArrayVertexBufferBackend.html" title="OpenGL 1 vertex array style VertexBuffer backend.">StelQGL1ArrayVertexBufferBackend</a> and <a class="el" href="classStelQGL2ArrayVertexBufferBackend.html" title="OpenGL 2 vertex array style VertexBuffer backend, used for testing and transition.">StelQGL2ArrayVertexBufferBackend</a>, used by <a class="el" href="classStelQGL1Renderer.html" title="Renderer backend using OpenGL 1.2 with Qt.">StelQGL1Renderer</a> and <a class="el" href="classStelQGL2Renderer.html" title="Renderer backend using OpenGL 2.1 or GLSL 2.0 with Qt.">StelQGL2Renderer</a> respectively, derive from it, specifying drawing logic (fixed function for QGL1 and shaders for QGL2).</p>
<h2><a class="anchor" id="texturebackend"></a>
StelTextureBackend and implementations</h2>
<p>Like <a class="el" href="classStelVertexBuffer.html" title="Vertex buffer interface.">StelVertexBuffer</a>, <a class="el" href="classStelTextureNew.html" title="Texture interface.">StelTextureNew</a> wraps a backend class; <a class="el" href="classStelTextureBackend.html" title="Base class for texture implementations.">StelTextureBackend</a>, from which the each backend derives. The reason is not templating; the API class and backend are separate so the former is owned by user code, while the latter might be owned by the renderer backend. This allows for features like texture caching; deleting the frontend decreases a reference count of the backend in cache. Caching is used internally to avoid loading the same texture twice. If creating a texture from a previously loaded file we can return a cached texture instead, wrapping the same <a class="el" href="classStelTextureBackend.html" title="Base class for texture implementations.">StelTextureBackend</a> in a different <a class="el" href="classStelTextureNew.html" title="Texture interface.">StelTextureNew</a>. Caching is not mandatory, so there might be backends that don't use it.</p>
<p>The only backend right now is <a class="el" href="classStelQGLTextureBackend.html" title="Texture backend based on QGL, usable with both GL1 and GL2.">StelQGLTextureBackend</a>, used both for GL1 and GL2 (it's managed by <a class="el" href="classStelQGLRenderer.html" title="Base class for renderer based on OpenGL and at the same time Qt&#39;s QGL.">StelQGLRenderer</a>). It uses Qt functions to load textures with some exceptions like loading textures from raw data, when plain GL texture functions are used.</p>
<h2><a class="anchor" id="qglglslshader"></a>
StelQGLGLSLShader</h2>
<p>This is the shader backend used by <a class="el" href="classStelQGL2Renderer.html" title="Renderer backend using OpenGL 2.1 or GLSL 2.0 with Qt.">StelQGL2Renderer</a>. It uses QGL to manage shaders. All shaders added are stored in compiled form. When <b>build()</b> is called, enabled shaders are linked into a shader program, but the program is only bound inside <a class="el" href="classStelQGL2Renderer.html" title="Renderer backend using OpenGL 2.1 or GLSL 2.0 with Qt.">StelQGL2Renderer</a>'s draw code. Linked programs are cached so we never link the same program twice. Any uniforms set are stored in temporary storage and only passed when the underlying program is bound.</p>
<h2><a class="anchor" id="rendererbackend"></a>
StelQGLRenderer, StelQGL1Renderer, StelQGL2Renderer</h2>
<p>The GL1 and GL2 backends share much code; this code is in the <a class="el" href="classStelQGLRenderer.html" title="Base class for renderer based on OpenGL and at the same time Qt&#39;s QGL.">StelQGLRenderer</a> class. This includes text and rectangle drawing, texture management, viewport (<a class="el" href="classStelQGLViewport.html" title="Manages OpenGL viewport.">StelQGLViewport</a>), and so on.</p>
<p><a class="el" href="classStelQGL1Renderer.html" title="Renderer backend using OpenGL 1.2 with Qt.">StelQGL1Renderer</a> contains GL1 specific code. This is mostly pre-draw setup (drawing is done by <a class="el" href="classStelQGL1ArrayVertexBufferBackend.html" title="OpenGL 1 vertex array style VertexBuffer backend.">StelQGL1ArrayVertexBufferBackend</a>) and various GL1 specific state.</p>
<p><a class="el" href="classStelQGL2Renderer.html" title="Renderer backend using OpenGL 2.1 or GLSL 2.0 with Qt.">StelQGL2Renderer</a> is more complicated. Along with functionality equivalent to <a class="el" href="classStelQGL1Renderer.html" title="Renderer backend using OpenGL 1.2 with Qt.">StelQGL1Renderer</a>, it also manages shaders. Especially important is swapping of default shaders, which emulate a simplified fixed function pipeline with specific vertex formats, and custom shaders specified by the user by binding a <a class="el" href="classStelGLSLShader.html" title="GLSL shader program.">StelGLSLShader</a>.</p>
<h1><a class="anchor" id="implementation_philosophy"></a>
Implementation philosophy</h1>
<p>Implementation is usually secondary to the API (ease of use); it needs to work within its constraints. It's not acceptable to break the API just to make implementation a bit more convenient. The main priorities of the implementation are maintainability and speed. Portability is not much of a concern - we might e.g. have a Windows-only Direct3D implementation, as long as we have implementations to cover other platforms. Power and ease of use are determined by the API.</p>
<p>Maintainability is often in direct conflict with speed; highly optimized code is hard to maintain. There is one way we can deal with this; for any part of the subsystem, a simple and readable, not necessarily fast, implementation should exist. This can then be used as a reference when writing other implementations (for different platforms or for speed) and for testing. <a class="el" href="classStelQGLArrayVertexBufferBackend.html" title="Base class for QGL-using vertex buffer backends based on separate attribute arrays.">StelQGLArrayVertexBufferBackend</a>, <a class="el" href="classStelQGLIndexBuffer.html" title="Qt-OpenGL index buffer implementation.">StelQGLIndexBuffer</a>, <a class="el" href="classStelQGLGLSLShader.html" title="QGL based StelGLSLShader implementation, used by the QGL2 renderer backend.">StelQGLGLSLShader</a> and <a class="el" href="classStelQGLTextureBackend.html" title="Texture backend based on QGL, usable with both GL1 and GL2.">StelQGLTextureBackend</a> can be considered such references, but they could probably be simpler if they should serve exclusively this purpose.</p>
<p>We can also have implementations designed for speed, optimized as much as possible. For example, a vertex buffer implementation could internally switch between vertex arrays and VBOs based on last time the buffer was updated. Complexity is acceptable here as long as it brings speed gains.</p>
<p>The advantage of this approach is that we always have an implementation that works and is maintainable. Optimized implementations might be thrown out and replaced if maintainability is a problem, but we still have something that works.</p>
<h1><a class="anchor" id="usage_patterns"></a>
Why not singleton &amp; Usage patterns</h1>
<p>Unlike other core services, <a class="el" href="classStelRenderer.html" title="Main class of the Renderer subsystem.">StelRenderer</a> is not directly accessible through <a class="el" href="classStelCore.html" title="Main class for Stellarium core processing.">StelCore</a>, nor is there any way to access it globally. Only one <a class="el" href="classStelRenderer.html" title="Main class of the Renderer subsystem.">StelRenderer</a> exists, but it's not a singleton. Drawing code usually gets a <a class="el" href="classStelRenderer.html" title="Main class of the Renderer subsystem.">StelRenderer</a> through a parameter. This has more to do with maintainability than ease of use; a globally accessible <a class="el" href="classStelRenderer.html" title="Main class of the Renderer subsystem.">StelRenderer</a> might be easier to use, removing need for lazy initialization.</p>
<p>Initialization and destruction of <a class="el" href="classStelRenderer.html" title="Main class of the Renderer subsystem.">StelRenderer</a> backend happens at well defined times and when a <a class="el" href="classStelRenderer.html" title="Main class of the Renderer subsystem.">StelRenderer</a> pointer is passed to drawing code, it's guaranteed to be initialized. Graphics accessing a <a class="el" href="classStelRenderer.html" title="Main class of the Renderer subsystem.">StelRenderer</a> globally might end up using an uninitialized <a class="el" href="classStelRenderer.html" title="Main class of the Renderer subsystem.">StelRenderer</a>, or, if it was a lazily initialized singleton, trigger premature initialization.</p>
<p>In future Renderer could be enhanced to allow switching backends post-initialization, even for single frames (e.g. export to document formats). This would be more complicated with a global renderer, although the main problem here is different - allowing API objects constructed by one renderer to work with another.</p>
<p>Finally, the main reason why <a class="el" href="classStelRenderer.html" title="Main class of the Renderer subsystem.">StelRenderer</a> is not globally accessible is making any future (however distant) major rewrites less complicated. Refactoring previous drawing code was made difficult by circular dependencies of various parts of code; not in the "include" sense, but in "classes using each other" sense. There was no clear point to start - many things had to be refactored simultaneously. Removing global accessibility makes dependencies more similar to a directed acyclic graph and there are clear points to start changes.</p>
<p>The disadvantage of a non-global <a class="el" href="classStelRenderer.html" title="Main class of the Renderer subsystem.">StelRenderer</a> is that we can't access it when initializing drawing code (unless it's explicitly passed). I.e. we can't load our textures when a class using <a class="el" href="classStelRenderer.html" title="Main class of the Renderer subsystem.">StelRenderer</a> is constructed. However, we don't need to initialize at construction; we only need the drawing objects to be ready before drawing. We can initialize them lazily. One way to do this is initializing drawing data in a function called during the first draw,setting an "initialized" flag, and only letting destructor destroy this data if this flag is set. This is less convenient, but it might actually improve performance as we only initialize drawing data once we need it.</p>
<h1><a class="anchor" id="future"></a>
Future development</h1>
<p>The Renderer API is quite complete and should be sufficient for some time; especially the shader support can be used for various new graphics features. However, backend performance, especially the GL2 backend, leaves something to be desired. Also, now that all drawing is separated, new debugging and profiling features are possible.</p>
<p>One near-term goal is collection of statistics about the backend's operation. We should be able to collect data about things such as the number of calls of specific functions per frame, triangles/vertices/indices per frame, underlying OpenGL draw calls, state changes, etc. . In combination with profiling data this should make finding bottlenecks easier. More importantly, it should help find inefficiencies in user code, such as plugins, and help plugin authors improve performance of their code.</p>
<p>Currently, Renderer backend classes are implemented in a mostly straightforward way. We should be able to improve performance by optimizing or adding alternative high-performance backends.</p>
<p>A major optimization would be a VBO (vertex buffer object) vertex buffer backend. With VBOs, vertex data is in GPU memory, freeing the bus. This can result in massive performance increase, even an order of magnitude. As the data must be stored on the GPU instead of being permanently re-uploaded, this is only useful if we have a lot of graphics data that never changes. Otherwise performance is likely to drop instead of increasing. Right now VBOs could help with things like planets and models, but the majority of drawing is done by <a class="el" href="classStelSkyDrawer.html" title="Provide a set of methods used to draw sky objects taking into account eyes adaptation, zoom level, instrument model and artificially set magnitude limits.">StelSkyDrawer</a> (point sources, mostly stars), where vertex data is regenerated every frame. Rewriting some <a class="el" href="classStelSkyDrawer.html" title="Provide a set of methods used to draw sky objects taking into account eyes adaptation, zoom level, instrument model and artificially set magnitude limits.">StelSkyDrawer</a> users, especially <a class="el" href="classBigStarCatalogExtension_1_1ZoneArray.html" title="Manages all ZoneData structures of a given StelGeodesicGrid level.">BigStarCatalogExtension::ZoneArray</a>, to use static vertex buffers initialized once and never modified, would result in more vertices per frame, but it might make VBOs viable which would likely bring massive performance boost. Other work currently done on the CPU, such as vertex projection, would also have to be done on GPU (this is already done for stereographic projection).</p>
<p>A non-essential, but useful future addition would be the ability to switch backends at any time. This would require all <a class="el" href="classStelRenderer.html" title="Main class of the Renderer subsystem.">StelRenderer</a> constructed classes to have separate frontend and backend objects, as <a class="el" href="classStelVertexBuffer.html" title="Vertex buffer interface.">StelVertexBuffer</a> and <a class="el" href="classStelTextureNew.html" title="Texture interface.">StelTextureNew</a> already have, and the frontends would need to store all data needed to reconstruct the backends - probably duplicating a lot of data. If a <a class="el" href="classStelRenderer.html" title="Main class of the Renderer subsystem.">StelRenderer</a> backend would be passed an object constructed by a different backend, it would delete the object's backend and replace it with its own. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Sep 25 2013 22:30:31 for Stellarium by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>
