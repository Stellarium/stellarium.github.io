<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"> 
<!-- Generated by rfcdiff 1.41: rfcdiff  --> 
<!-- <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional" > -->
<!-- System: Linux fomalhaut.local 3.13.0-38-generic #65-Ubuntu SMP Thu Oct 9 11:36:50 UTC 2014 x86_64 x86_64 x86_64 GNU/Linux --> 
<!-- Using awk: /usr/bin/gawk: GNU Awk 4.0.1 --> 
<!-- Using diff: /usr/bin/diff: diff (GNU diffutils) 3.3 --> 
<!-- Using wdiff: /usr/bin/wdiff: wdiff (GNU wdiff) 1.2.1 --> 
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"> 
<head> 
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /> 
  <meta http-equiv="Content-Style-Type" content="text/css" /> 
  <title>Diff: StelPainter.cpp - StelPainter.cpp</title> 
  <style type="text/css"> 
    body    { font-size:16px; margin: 0.4ex; margin-right: auto; } 
    tr      { } 
    td      { white-space: pre; font-family: Consolas, "DejaVu Sans Mono", "Droid Sans Mono", Monaco, Monospace; vertical-align: top; font-size: 0.86em;} 
    th      { font-size: 0.86em; } 
    .small  { font-size: 0.6em; font-style: italic; font-family: Verdana, Helvetica, sans-serif; } 
    .left   { background-color: #EEE; } 
    .right  { background-color: #FFF; } 
    .diff   { background-color: #CCF; } 
    .lblock { background-color: #BFB; } 
    .rblock { background-color: #FF8; } 
    .insert { background-color: #8FF; } 
    .delete { background-color: #ACF; } 
    .void   { background-color: #FFB; } 
    .cont   { background-color: #EEE; } 
    .linebr { background-color: #AAA; } 
    .lineno { color: red; background-color: #FFF; font-size: 0.7em; text-align: right; padding: 0 2px; } 
    .elipsis{ background-color: #AAA; } 
    .left .cont { background-color: #DDD; } 
    .right .cont { background-color: #EEE; } 
    .lblock .cont { background-color: #9D9; } 
    .rblock .cont { background-color: #DD6; } 
    .insert .cont { background-color: #0DD; } 
    .delete .cont { background-color: #8AD; } 
    .stats, .stats td, .stats th { background-color: #EEE; padding: 2px 0; } 
  </style> 
</head> 
<body > 
  <table border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th></th><th>&nbsp;StelPainter.cpp&nbsp;</th><th> </th><th>&nbsp;StelPainter.cpp&nbsp;</th><th></th></tr> 
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l1" /><small>skipping to change at</small><em> line 401</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 401</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       x = rad[i]*cos_sin_theta_p[0];</td><td> </td><td class="right">                       x = rad[i]*cos_sin_theta_p[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       y = rad[i]*cos_sin_theta_p[1];</td><td> </td><td class="right">                       y = rad[i]*cos_sin_theta_p[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       texCoordArr &lt;&lt; 0.5f+x/radius &lt;&lt; 0.5f+y/radius;</td><td> </td><td class="right">                       texCoordArr &lt;&lt; 0.5f+x/radius &lt;&lt; 0.5f+y/radius;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       vertexArr &lt;&lt; x &lt;&lt; y &lt;&lt; 0;</td><td> </td><td class="right">                       vertexArr &lt;&lt; x &lt;&lt; y &lt;&lt; 0;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // draw the inner polygon</td><td> </td><td class="right">       // draw the inner polygon</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       slices_step&gt;&gt;=1;</td><td> </td><td class="right">       slices_step&gt;&gt;=1;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       cos_sin_theta_p=cos_sin_theta;</td><td> </td><td class="right">       cos_sin_theta_p=cos_sin_theta;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       x = rad[0]*cos_sin_theta_p[0];</td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       y = rad[0]*cos_sin_theta_p[1];</td><td> </td><td class="rblock">       <span class="insert">if (slices==1)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       texCoordArr &lt;&lt; 0.5f+x/radius &lt;&lt; 0.5f+y/radius;</td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       vertexArr &lt;&lt; x &lt;&lt; y &lt;&lt; 0;</td><td> </td><td class="rblock">               x = rad[0]*cos_sin_theta_p[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       cos_sin_theta_p+=2*slices_step;</td><td> </td><td class="rblock">               y = rad[0]*cos_sin_theta_p[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       x = rad[0]*cos_sin_theta_p[0];</td><td> </td><td class="rblock">               texCoordArr &lt;&lt; 0.5f+x/radius &lt;&lt; 0.5f+y/radius;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       y = rad[0]*cos_sin_theta_p[1];</td><td> </td><td class="rblock">               vertexArr &lt;&lt; x &lt;&lt; y &lt;&lt; 0;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       texCoordArr &lt;&lt; 0.5f+x/radius &lt;&lt; 0.5f+y/radius;</td><td> </td><td class="rblock">               cos_sin_theta_p+=2*slices_step;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       vertexArr &lt;&lt; x &lt;&lt; y &lt;&lt; 0;</td><td> </td><td class="rblock">               x = rad[0]*cos_sin_theta_p[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       cos_sin_theta_p+=2*slices_step;</td><td> </td><td class="rblock">               y = rad[0]*cos_sin_theta_p[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       x = rad[0]*cos_sin_theta_p[0];</td><td> </td><td class="rblock">               texCoordArr &lt;&lt; 0.5f+x/radius &lt;&lt; 0.5f+y/radius;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       y = rad[0]*cos_sin_theta_p[1];</td><td> </td><td class="rblock">               vertexArr &lt;&lt; x &lt;&lt; y &lt;&lt; 0;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       texCoordArr &lt;&lt; 0.5f+x/radius &lt;&lt; 0.5f+y/radius;</td><td> </td><td class="rblock">               cos_sin_theta_p+=2*slices_step;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       vertexArr &lt;&lt; x &lt;&lt; y &lt;&lt; 0;</td><td> </td><td class="rblock">               x = rad[0]*cos_sin_theta_p[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">               y = rad[0]*cos_sin_theta_p[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">               texCoordArr &lt;&lt; 0.5f+x/radius &lt;&lt; 0.5f+y/radius;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">               vertexArr &lt;&lt; x &lt;&lt; y &lt;&lt; 0;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">}</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       else</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               j=0;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               while (j&lt;slices)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       texCoordArr &lt;&lt; 0.5f &lt;&lt; 0.5f;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       vertexArr &lt;&lt; 0 &lt;&lt; 0 &lt;&lt; 0;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       x = rad[0]*cos_sin_theta_p[0];</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       y = rad[0]*cos_sin_theta_p[1];</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       texCoordArr &lt;&lt; 0.5f+x/radius &lt;&lt; 0.5f+y/radius;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       vertexArr &lt;&lt; x &lt;&lt; y &lt;&lt; 0;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       j+=slices_step;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       cos_sin_theta_p+=2*slices_step;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       x = rad[0]*cos_sin_theta_p[0];</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       y = rad[0]*cos_sin_theta_p[1];</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       texCoordArr &lt;&lt; 0.5f+x/radius &lt;&lt; 0.5f+y/radius;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       vertexArr &lt;&lt; x &lt;&lt; y &lt;&lt; 0;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void StelPainter::sRing(float rMin, float rMax, int slices, int stacks, int
 orientInside)</td><td> </td><td class="right">void StelPainter::sRing(float rMin, float rMax, int slices, int stacks, int
 orientInside)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       float x,y;</td><td> </td><td class="right">       float x,y;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       int j;</td><td> </td><td class="right">       int j;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       static Vec3f lightPos3;</td><td> </td><td class="right">       static Vec3f lightPos3;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       static Vec4f ambientLight;</td><td> </td><td class="right">       static Vec4f ambientLight;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l2" /><small>skipping to change at</small><em> line 575</em></th><th> </th><th><a name="part-r2" /><small>skipping to change at</small><em> line 598</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               z = cos_sin_rho_p[0];</td><td> </td><td class="right">                               z = cos_sin_rho_p[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               sSphereMapTexCoordFast(rho, cos_sin_theta_p[
0], -cos_sin_theta_p[1], texCoordArr);</td><td> </td><td class="right">                               sSphereMapTexCoordFast(rho, cos_sin_theta_p[
0], -cos_sin_theta_p[1], texCoordArr);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               vertexArr &lt;&lt; x*radius &lt;&lt; y*radius &lt;&lt; z*radiu
s;</td><td> </td><td class="right">                               vertexArr &lt;&lt; x*radius &lt;&lt; y*radius &lt;&lt; z*radiu
s;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       }</td><td> </td><td class="right">                       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       setArrays((Vec3d*)vertexArr.constData(), (Vec2f*)tex
CoordArr.constData());</td><td> </td><td class="right">                       setArrays((Vec3d*)vertexArr.constData(), (Vec2f*)tex
CoordArr.constData());</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       drawFromArray(TriangleStrip, vertexArr.size()/3);</td><td> </td><td class="right">                       drawFromArray(TriangleStrip, vertexArr.size()/3);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0002" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">void StelPainter::drawTextGravity180(float x, float y, const QString&amp; ws, f
loat xshift, float yshift)<span class="delete"> const</span></td><td> </td><td class="rblock">void StelPainter::drawTextGravity180(float x, float y, const QString&amp; ws, f
loat xshift, float yshift)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       float dx, dy, d, theta, psi;</td><td> </td><td class="right">       float dx, dy, d, theta, psi;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       dx = x - prj-&gt;viewportCenter[0];</td><td> </td><td class="right">       dx = x - prj-&gt;viewportCenter[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       dy = y - prj-&gt;viewportCenter[1];</td><td> </td><td class="right">       dy = y - prj-&gt;viewportCenter[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       d = std::sqrt(dx*dx + dy*dy);</td><td> </td><td class="right">       d = std::sqrt(dx*dx + dy*dy);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // If the text is too far away to be visible in the screen return</td><td> </td><td class="right">       // If the text is too far away to be visible in the screen return</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (d&gt;qMax(prj-&gt;viewportXywh[3], prj-&gt;viewportXywh[2])*2)</td><td> </td><td class="right">       if (d&gt;qMax(prj-&gt;viewportXywh[3], prj-&gt;viewportXywh[2])*2)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return;</td><td> </td><td class="right">               return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       theta = M_PI + std::atan2(dx, dy - 1);</td><td> </td><td class="right">       theta = M_PI + std::atan2(dx, dy - 1);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       psi = std::atan2((float)qPainter-&gt;fontMetrics().width(ws)/ws.length(
),d + 1) * 180./M_PI;</td><td> </td><td class="right">       psi = std::atan2((float)qPainter-&gt;fontMetrics().width(ws)/ws.length(
),d + 1) * 180./M_PI;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (psi&gt;5)</td><td> </td><td class="right">       if (psi&gt;5)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               psi = 5;</td><td> </td><td class="right">               psi = 5;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0003" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">if (qPainter-&gt;paintEngine()-&gt;type()==QPaintEngine::OpenGL2)</span></td><td> </td><td class="rblock">       <span class="insert">const float cosr = std::cos(-theta * M_PI/180.);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       {</span></td><td> </td><td class="rblock"><span class="insert">       const float sinr = std::sin(-theta * M_PI/180.);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               qPainter-&gt;translate(x, prj-&gt;viewportXywh[3]-y);</span></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               qPainter-&gt;rotate(theta*180./M_PI);</span></td><td> </td><td class="rblock"><span class="insert">       float initX = x + xshift*cosr - yshift*sinr;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               qPainter-&gt;translate(xshift, -yshift);</span></td><td> </td><td class="rblock"><span class="insert">       float initY = y + yshift*sinr + yshift*cosr;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       }</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       else</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       {</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               qPainter-&gt;translate(x, y);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               qPainter-&gt;rotate(-theta*180./M_PI);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               qPainter-&gt;translate(xshift, yshift);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               qPainter-&gt;scale(1, -1);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       }</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       for (int i=0;i&lt;ws.length();++i)</td><td> </td><td class="right">       for (int i=0;i&lt;ws.length();++i)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0004" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               <span class="delete">qPainter-&gt;drawText(0,0,ws[i]);</span></td><td> </td><td class="rblock">               <span class="insert">drawText(initX, initY, ws[i], -theta*180./M_PI+psi*i, 0., 0.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"><span class="insert">);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               // with typeface need to manually advance</span></td><td> </td><td class="rblock"><span class="insert">               xshift = (float)qPainter-&gt;fontMetrics().width(ws.mid(i,1))</span> *</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               // TODO, absolute rotation would be better than relative</span></td><td> </td><td class="rblock"> <span class="insert">1.05;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               // TODO: would look better with kerning information...</span></td><td> </td><td class="rblock"><span class="insert">               initX+=xshift*std::cos(-theta+psi*i * M_PI/180.);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               qPainter-&gt;translate((float)qPainter-&gt;fontMetrics().width(ws.</span></td><td> </td><td class="rblock"><span class="insert">               initY+=xshift*std::sin(-theta+psi*i * M_PI/180.);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">mid(i,1))</span> * <span class="delete">1.05, 0);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               qPainter-&gt;rotate(-psi);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0005" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">void StelPainter::drawText(const Vec3d&amp; v, const QString&amp; str, float angleD
eg, float xshift, float yshift, bool noGravity)<span class="delete"> const</span></td><td> </td><td class="rblock">void StelPainter::drawText(const Vec3d&amp; v, const QString&amp; str, float angleD
eg, float xshift, float yshift, bool noGravity)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Vec3d win;</td><td> </td><td class="right">       Vec3d win;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       prj-&gt;project(v, win);</td><td> </td><td class="right">       prj-&gt;project(v, win);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       drawText(win[0], win[1], str, angleDeg, xshift, yshift, noGravity);</td><td> </td><td class="right">       drawText(win[0], win[1], str, angleDeg, xshift, yshift, noGravity);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">/*************************************************************************</td><td> </td><td class="right">/*************************************************************************</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"> Draw the string at the given position and angle with the given font</td><td> </td><td class="right"> Draw the string at the given position and angle with the given font</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">*************************************************************************/</td><td> </td><td class="right">*************************************************************************/</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0006" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">void StelPainter::drawText(float x, float y, const QString&amp; str, float angl</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">eDeg, float xshift, float yshift, bool noGravity) const</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">{</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       Q_ASSERT(qPainter);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       float color[4];</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">#ifndef STELPAINTER_GL2</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       // Save openGL state</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       glPushClientAttrib(GL_CLIENT_ALL_ATTRIB_BITS);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       glPushAttrib(GL_ALL_ATTRIB_BITS);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       glMatrixMode(GL_TEXTURE);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       glPushMatrix();</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       glMatrixMode(GL_PROJECTION);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       glPushMatrix();</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       glMatrixMode(GL_MODELVIEW);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       glPushMatrix();</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       glGetFloatv(GL_CURRENT_COLOR, color);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">#else</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       color[0]=currentColor[0];</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       color[1]=currentColor[1];</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       color[2]=currentColor[2];</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       color[3]=currentColor[3];</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">#endif</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0007" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">qPainter-&gt;endNativePainting();</span></td><td> </td><td class="rblock"><span class="insert">// Container for one cached string texture</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">struct StringTexture</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">{</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       GLuint texture;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       int width;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       int height;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0008" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">qPainter-&gt;save();</span></td><td> </td><td class="rblock">       <span class="insert">StringTexture() : texture(0) {;}</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       qPainter-&gt;resetTransform();</span></td><td> </td><td class="rblock"><span class="insert">       ~StringTexture()</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       qPainter-&gt;resetMatrix();</span></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       qPainter-&gt;setRenderHints(QPainter::TextAntialiasing | QPainter::High</span></td><td> </td><td class="rblock"><span class="insert">               if (texture != 0)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">QualityAntialiasing);</span></td><td> </td><td class="rblock"><span class="insert">                       glDeleteTextures(1, &amp;texture);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       const QColor qCol=QColor::fromRgbF(qMax(qMin(1.f,color[0]),0.f), qMa</span></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">x(qMin(1.f,color[1]),0.f), qMax(qMin(1.f,color[2]),0.f), qMax(qMin(1.f,colo</span></td><td> </td><td class="rblock"><span class="insert">};</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">r[3]),0.f));</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       qPainter-&gt;setPen(qCol);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0009" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">void StelPainter::drawText(float x, float y, const QString&amp; str, float angl</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">eDeg, float xshift, float yshift, bool noGravity)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">{</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       Q_ASSERT(qPainter);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (prj-&gt;gravityLabels &amp;&amp; !noGravity)</td><td> </td><td class="right">       if (prj-&gt;gravityLabels &amp;&amp; !noGravity)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               drawTextGravity180(x, y, str, xshift, yshift);</td><td> </td><td class="right">               drawTextGravity180(x, y, str, xshift, yshift);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       else</td><td> </td><td class="right">       else</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0010" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               // <span class="delete">There are 2 version here depending on the OpenGL engine</span></td><td> </td><td class="rblock">               <span class="insert">static const int cacheLimitByte = 7000000;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               // OpenGL 1</span> need to <span class="delete">reverse the</span> text <span class="delete">vertically, not OpenGL </span></td><td> </td><td class="rblock"><span class="insert">               static QCache&lt;QByteArray,StringTexture&gt; texCache(cacheLimitB</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">2...</span></td><td> </td><td class="rblock"><span class="insert">yte);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               // <span class="delete">This sounds like a Qt bug</span></td><td> </td><td class="rblock"><span class="insert">               int pixelSize = qPainter-&gt;font().pixelSize();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               if (qPainter-&gt;paintEngine()-&gt;type()==QPaintEngine::OpenGL2)</span></td><td> </td><td class="rblock"><span class="insert">               QByteArray hash = str.toUtf8() + QByteArray::number(pixelSiz</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               {</span></td><td> </td><td class="rblock"><span class="insert">e);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       qPainter-&gt;translate(x, prj-&gt;viewportXywh[3]-y);</span></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       qPainter-&gt;rotate(-angleDeg);</span></td><td> </td><td class="rblock"><span class="insert">               const StringTexture* cachedTex = texCache.object(hash);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       qPainter-&gt;translate(xshift, -yshift);</span></td><td> </td><td class="rblock"><span class="insert">               if (cachedTex == NULL)</span>  // need to <span class="insert">create texture</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       // Create temp image and render</span> text <span class="insert">into it</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       QRect strRect = getFontMetrics().boundingRect(str);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                        QPixmap strImage(strRect.width()+1+(int)(0.02f*strR</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ect.width()), strRect.height());</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       strImage.fill(Qt::transparent);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       QPainter painter(&amp;strImage);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       painter.setFont(qPainter-&gt;font());</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       painter.setRenderHints(QPainter::TextAntialiasing);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       painter.setPen(Qt::white);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       painter.drawText(-strRect.x(), -strRect.y(), str);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                       // <span class="insert">Create and bind texture, and add it to the list o</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">f cached textures</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       StringTexture* newTex = new StringTexture();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       newTex-&gt;texture = StelPainter::glContext-&gt;bindTextur</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">e(strImage, GL_TEXTURE_2D, GL_RGBA, QGLContext::NoBindOption);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       newTex-&gt;width = strImage.width();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       newTex-&gt;height = strImage.height();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       texCache.insert(hash, newTex, 3*newTex-&gt;width*newTex</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">-&gt;height);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       cachedTex=newTex;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               else</td><td> </td><td class="right">               else</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0011" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       <span class="delete">qPainter-&gt;translate(round(x), round(y));</span></td><td> </td><td class="rblock">                       <span class="insert">// The texture was found in the cache</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       qPainter-&gt;scale(1, -1);</span></td><td> </td><td class="rblock"><span class="insert">                       glBindTexture(GL_TEXTURE_2D, cachedTex-&gt;texture);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       qPainter-&gt;rotate(-angleDeg);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       qPainter-&gt;translate(round(xshift), round(-yshift));</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0012" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               <span class="delete">qPainter-&gt;drawText(0, 0, str);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       }</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       qPainter-&gt;restore();</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0013" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">qPainter-&gt;beginNativePainting();</span></td><td> </td><td class="rblock">               <span class="insert">// Translate/rotate</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               if (!noGravity)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       angleDeg += prj-&gt;defautAngleForGravityText;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               enableTexture2d(true);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               static float vertexData[8];</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               static const float texCoordData[] = {0.,1., 1.,1., 0.,0., 1.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">,0.};</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               // compute the vertex coordinates applying the translation a</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">nd the rotation</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               static const float vertexBase[] = {0., 0., 1., 0., 0., 1., 1</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">., 1.};</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               if (std::fabs(angleDeg)&gt;1.f*M_PI/180.f)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">, GL_LINEAR);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">, GL_LINEAR);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       const float cosr = std::cos(angleDeg * M_PI/180.);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       const float sinr = std::sin(angleDeg * M_PI/180.);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       for (int i = 0; i &lt; 8; i+=2)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               vertexData[i] = int(x + (cachedTex-&gt;width*ve</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">rtexBase[i]+xshift) * cosr - (cachedTex-&gt;height*vertexBase[i+1]+yshift) * s</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">inr);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               vertexData[i+1] = int(y  + (cachedTex-&gt;width</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">*vertexBase[i]+xshift) * sinr + (cachedTex-&gt;height*vertexBase[i+1]+yshift) </span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">* cosr);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               else</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">, GL_NEAREST);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">, GL_NEAREST);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       for (int i = 0; i &lt; 8; i+=2)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               vertexData[i] = int(x + cachedTex-&gt;width*ver</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">texBase[i]+xshift);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               vertexData[i+1] = int(y  + cachedTex-&gt;height</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">*vertexBase[i+1]+yshift);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0014" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">#ifndef STELPAINTER_GL2</span></td><td> </td><td class="rblock">               <span class="insert">glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       glMatrixMode(GL_TEXTURE);</span></td><td> </td><td class="rblock"><span class="insert">               glEnable(GL_BLEND);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       glPopMatrix();</span></td><td> </td><td class="rblock"><span class="insert">               enableClientStates(true, true);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       glMatrixMode(GL_PROJECTION);</span></td><td> </td><td class="rblock"><span class="insert">               setVertexPointer(2, GL_FLOAT, vertexData);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       glPopMatrix();</span></td><td> </td><td class="rblock"><span class="insert">               setTexCoordPointer(2, GL_FLOAT, texCoordData);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       glMatrixMode(GL_MODELVIEW);</span></td><td> </td><td class="rblock"><span class="insert">               drawFromArray(TriangleStrip, 4, 0, false);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       glPopMatrix();</span></td><td> </td><td class="rblock"><span class="insert">               enableClientStates(false);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       glPopClientAttrib();</span></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       glPopAttrib();</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">#endif</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// Recursive method cutting a small circle in small segments</td><td> </td><td class="right">// Recursive method cutting a small circle in small segments</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">inline void fIter(const StelProjectorP&amp; prj, const Vec3d&amp; p1, const Vec3d&amp; 
p2, Vec3d&amp; win1, Vec3d&amp; win2, QLinkedList&lt;Vec3d&gt;&amp; vertexList, const QLinked
List&lt;Vec3d&gt;::iterator&amp; iter, double radius, const Vec3d&amp; center, int nbI=0,
 bool checkCrossDiscontinuity=true)</td><td> </td><td class="right">inline void fIter(const StelProjectorP&amp; prj, const Vec3d&amp; p1, const Vec3d&amp; 
p2, Vec3d&amp; win1, Vec3d&amp; win2, QLinkedList&lt;Vec3d&gt;&amp; vertexList, const QLinked
List&lt;Vec3d&gt;::iterator&amp; iter, double radius, const Vec3d&amp; center, int nbI=0,
 bool checkCrossDiscontinuity=true)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const bool crossDiscontinuity = checkCrossDiscontinuity &amp;&amp; prj-&gt;inte
rsectViewportDiscontinuity(p1+center, p2+center);</td><td> </td><td class="right">       const bool crossDiscontinuity = checkCrossDiscontinuity &amp;&amp; prj-&gt;inte
rsectViewportDiscontinuity(p1+center, p2+center);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (crossDiscontinuity &amp;&amp; nbI&gt;=10)</td><td> </td><td class="right">       if (crossDiscontinuity &amp;&amp; nbI&gt;=10)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               win1[2]=-2.;</td><td> </td><td class="right">               win1[2]=-2.;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               win2[2]=-2.;</td><td> </td><td class="right">               win2[2]=-2.;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l3" /><small>skipping to change at</small><em> line 834</em></th><th> </th><th><a name="part-r3" /><small>skipping to change at</small><em> line 874</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       drawSmallCircleVertexArray();</td><td> </td><td class="right">                       drawSmallCircleVertexArray();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Q_ASSERT(smallCircleVertexArray.isEmpty());</td><td> </td><td class="right">       Q_ASSERT(smallCircleVertexArray.isEmpty());</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// Project the passed triangle on the screen ensuring that it will look smo
oth, even for non linear distortion</td><td> </td><td class="right">// Project the passed triangle on the screen ensuring that it will look smo
oth, even for non linear distortion</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// by splitting it into subtriangles.</td><td> </td><td class="right">// by splitting it into subtriangles.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void StelPainter::projectSphericalTriangle(const SphericalCap* clippingCap,
 const Vec3d* vertices, QVarLengthArray&lt;Vec3f, 4096&gt;* outVertices,</td><td> </td><td class="right">void StelPainter::projectSphericalTriangle(const SphericalCap* clippingCap,
 const Vec3d* vertices, QVarLengthArray&lt;Vec3f, 4096&gt;* outVertices,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               const Vec2f* texturePos, QVarLengthArray&lt;Vec2f, 4096&gt;* outTe
xturePos,</td><td> </td><td class="right">               const Vec2f* texturePos, QVarLengthArray&lt;Vec2f, 4096&gt;* outTe
xturePos,</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0015" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               <span class="delete">int nbI, bool checkDisc1, bool checkDisc2, bool checkDisc3) 
</span>const</td><td> </td><td class="rblock">               <span class="insert">double maxSqDistortion, int nbI, bool checkDisc1, bool check
Disc2, bool checkDisc3) </span>const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Q_ASSERT(fabs(vertices[0].length()-1.)&lt;0.00001);</td><td> </td><td class="right">       Q_ASSERT(fabs(vertices[0].length()-1.)&lt;0.00001);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Q_ASSERT(fabs(vertices[1].length()-1.)&lt;0.00001);</td><td> </td><td class="right">       Q_ASSERT(fabs(vertices[1].length()-1.)&lt;0.00001);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Q_ASSERT(fabs(vertices[2].length()-1.)&lt;0.00001);</td><td> </td><td class="right">       Q_ASSERT(fabs(vertices[2].length()-1.)&lt;0.00001);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (clippingCap &amp;&amp; clippingCap-&gt;containsTriangle(vertices))</td><td> </td><td class="right">       if (clippingCap &amp;&amp; clippingCap-&gt;containsTriangle(vertices))</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               clippingCap = NULL;</td><td> </td><td class="right">               clippingCap = NULL;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (clippingCap &amp;&amp; !clippingCap-&gt;intersectsTriangle(vertices))</td><td> </td><td class="right">       if (clippingCap &amp;&amp; !clippingCap-&gt;intersectsTriangle(vertices))</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return;</td><td> </td><td class="right">               return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       bool cDiscontinuity1 = checkDisc1 &amp;&amp; prj-&gt;intersectViewportDiscontin
uity(vertices[0], vertices[1]);</td><td> </td><td class="right">       bool cDiscontinuity1 = checkDisc1 &amp;&amp; prj-&gt;intersectViewportDiscontin
uity(vertices[0], vertices[1]);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       bool cDiscontinuity2 = checkDisc2 &amp;&amp; prj-&gt;intersectViewportDiscontin
uity(vertices[1], vertices[2]);</td><td> </td><td class="right">       bool cDiscontinuity2 = checkDisc2 &amp;&amp; prj-&gt;intersectViewportDiscontin
uity(vertices[1], vertices[2]);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l4" /><small>skipping to change at</small><em> line 860</em></th><th> </th><th><a name="part-r4" /><small>skipping to change at</small><em> line 900</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Vec3d e0=vertices[0];</td><td> </td><td class="right">       Vec3d e0=vertices[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Vec3d e1=vertices[1];</td><td> </td><td class="right">       Vec3d e1=vertices[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Vec3d e2=vertices[2];</td><td> </td><td class="right">       Vec3d e2=vertices[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       bool valid = prj-&gt;projectInPlace(e0);</td><td> </td><td class="right">       bool valid = prj-&gt;projectInPlace(e0);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       valid = prj-&gt;projectInPlace(e1) || valid;</td><td> </td><td class="right">       valid = prj-&gt;projectInPlace(e1) || valid;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       valid = prj-&gt;projectInPlace(e2) || valid;</td><td> </td><td class="right">       valid = prj-&gt;projectInPlace(e2) || valid;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Clip polygons behind the viewer</td><td> </td><td class="right">       // Clip polygons behind the viewer</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (!valid)</td><td> </td><td class="right">       if (!valid)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return;</td><td> </td><td class="right">               return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0016" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       static const double maxSqDistortion = 5.;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (checkDisc1 &amp;&amp; cDiscontinuity1==false)</td><td> </td><td class="right">       if (checkDisc1 &amp;&amp; cDiscontinuity1==false)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               // If the distortion at segment e0,e1 is too big, flags it f
or subdivision</td><td> </td><td class="right">               // If the distortion at segment e0,e1 is too big, flags it f
or subdivision</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               Vec3d win3 = vertices[0]; win3+=vertices[1];</td><td> </td><td class="right">               Vec3d win3 = vertices[0]; win3+=vertices[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               prj-&gt;projectInPlace(win3);</td><td> </td><td class="right">               prj-&gt;projectInPlace(win3);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               win3[0]-=(e0[0]+e1[0])*0.5; win3[1]-=(e0[1]+e1[1])*0.5;</td><td> </td><td class="right">               win3[0]-=(e0[0]+e1[0])*0.5; win3[1]-=(e0[1]+e1[1])*0.5;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               cDiscontinuity1 = (win3[0]*win3[0]+win3[1]*win3[1])&gt;maxSqDis
tortion;</td><td> </td><td class="right">               cDiscontinuity1 = (win3[0]*win3[0]+win3[1]*win3[1])&gt;maxSqDis
tortion;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (checkDisc2 &amp;&amp; cDiscontinuity2==false)</td><td> </td><td class="right">       if (checkDisc2 &amp;&amp; cDiscontinuity2==false)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l5" /><small>skipping to change at</small><em> line 927</em></th><th> </th><th><a name="part-r5" /><small>skipping to change at</small><em> line 966</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[0]=vertices[0];</td><td> </td><td class="right">               va[0]=vertices[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[1]=vertices[0];va[1]+=vertices[1];</td><td> </td><td class="right">               va[1]=vertices[0];va[1]+=vertices[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[1].normalize();</td><td> </td><td class="right">               va[1].normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[2]=vertices[2];</td><td> </td><td class="right">               va[2]=vertices[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               if (outTexturePos)</td><td> </td><td class="right">               if (outTexturePos)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[0]=texturePos[0];</td><td> </td><td class="right">                       ta[0]=texturePos[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[1]=(texturePos[0]+texturePos[1])*0.5;</td><td> </td><td class="right">                       ta[1]=(texturePos[0]+texturePos[1])*0.5;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[2]=texturePos[2];</td><td> </td><td class="right">                       ta[2]=texturePos[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0017" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               projectSphericalTriangle(clippingCap, va, outVertices, ta, o
utTexturePos, nbI+1, true, true, false);</td><td> </td><td class="rblock">               projectSphericalTriangle(clippingCap, va, outVertices, ta, o
utTexturePos, <span class="insert">maxSqDistortion, </span>nbI+1, true, true, false);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               //va[0]=vertices[0]+vertices[1];</td><td> </td><td class="right">               //va[0]=vertices[0]+vertices[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               //va[0].normalize();</td><td> </td><td class="right">               //va[0].normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[0]=va[1];</td><td> </td><td class="right">               va[0]=va[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[1]=vertices[1];</td><td> </td><td class="right">               va[1]=vertices[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[2]=vertices[2];</td><td> </td><td class="right">               va[2]=vertices[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               if (outTexturePos)</td><td> </td><td class="right">               if (outTexturePos)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[0]=(texturePos[0]+texturePos[1])*0.5;</td><td> </td><td class="right">                       ta[0]=(texturePos[0]+texturePos[1])*0.5;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[1]=texturePos[1];</td><td> </td><td class="right">                       ta[1]=texturePos[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[2]=texturePos[2];</td><td> </td><td class="right">                       ta[2]=texturePos[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0018" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               projectSphericalTriangle(clippingCap, va, outVertices, ta, o
utTexturePos, nbI+1, true, false, true);</td><td> </td><td class="rblock">               projectSphericalTriangle(clippingCap, va, outVertices, ta, o
utTexturePos, <span class="insert">maxSqDistortion, </span>nbI+1, true, false, true);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return;</td><td> </td><td class="right">               return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (!cDiscontinuity1 &amp;&amp; cDiscontinuity2 &amp;&amp; !cDiscontinuity3)</td><td> </td><td class="right">       if (!cDiscontinuity1 &amp;&amp; cDiscontinuity2 &amp;&amp; !cDiscontinuity3)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[0]=vertices[0];</td><td> </td><td class="right">               va[0]=vertices[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[1]=vertices[1];</td><td> </td><td class="right">               va[1]=vertices[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[2]=vertices[1];va[2]+=vertices[2];</td><td> </td><td class="right">               va[2]=vertices[1];va[2]+=vertices[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[2].normalize();</td><td> </td><td class="right">               va[2].normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               if (outTexturePos)</td><td> </td><td class="right">               if (outTexturePos)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[0]=texturePos[0];</td><td> </td><td class="right">                       ta[0]=texturePos[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[1]=texturePos[1];</td><td> </td><td class="right">                       ta[1]=texturePos[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[2]=(texturePos[1]+texturePos[2])*0.5;</td><td> </td><td class="right">                       ta[2]=(texturePos[1]+texturePos[2])*0.5;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0019" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               projectSphericalTriangle(clippingCap, va, outVertices, ta, o
utTexturePos, nbI+1, false, true, true);</td><td> </td><td class="rblock">               projectSphericalTriangle(clippingCap, va, outVertices, ta, o
utTexturePos, <span class="insert">maxSqDistortion, </span>nbI+1, false, true, true);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[0]=vertices[0];</td><td> </td><td class="right">               va[0]=vertices[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               //va[1]=vertices[1]+vertices[2];</td><td> </td><td class="right">               //va[1]=vertices[1]+vertices[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               //va[1].normalize();</td><td> </td><td class="right">               //va[1].normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[1]=va[2];</td><td> </td><td class="right">               va[1]=va[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[2]=vertices[2];</td><td> </td><td class="right">               va[2]=vertices[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               if (outTexturePos)</td><td> </td><td class="right">               if (outTexturePos)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[0]=texturePos[0];</td><td> </td><td class="right">                       ta[0]=texturePos[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[1]=(texturePos[1]+texturePos[2])*0.5;</td><td> </td><td class="right">                       ta[1]=(texturePos[1]+texturePos[2])*0.5;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[2]=texturePos[2];</td><td> </td><td class="right">                       ta[2]=texturePos[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0020" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               projectSphericalTriangle(clippingCap, va, outVertices, ta, o
utTexturePos, nbI+1, true, true, false);</td><td> </td><td class="rblock">               projectSphericalTriangle(clippingCap, va, outVertices, ta, o
utTexturePos, <span class="insert">maxSqDistortion, </span>nbI+1, true, true, false);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return;</td><td> </td><td class="right">               return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (!cDiscontinuity1 &amp;&amp; !cDiscontinuity2 &amp;&amp; cDiscontinuity3)</td><td> </td><td class="right">       if (!cDiscontinuity1 &amp;&amp; !cDiscontinuity2 &amp;&amp; cDiscontinuity3)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[0]=vertices[0];</td><td> </td><td class="right">               va[0]=vertices[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[1]=vertices[1];</td><td> </td><td class="right">               va[1]=vertices[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[2]=vertices[0];va[2]+=vertices[2];</td><td> </td><td class="right">               va[2]=vertices[0];va[2]+=vertices[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[2].normalize();</td><td> </td><td class="right">               va[2].normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               if (outTexturePos)</td><td> </td><td class="right">               if (outTexturePos)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[0]=texturePos[0];</td><td> </td><td class="right">                       ta[0]=texturePos[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[1]=texturePos[1];</td><td> </td><td class="right">                       ta[1]=texturePos[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[2]=(texturePos[0]+texturePos[2])*0.5;</td><td> </td><td class="right">                       ta[2]=(texturePos[0]+texturePos[2])*0.5;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0021" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               projectSphericalTriangle(clippingCap, va, outVertices, ta, o
utTexturePos, nbI+1, false, true, true);</td><td> </td><td class="rblock">               projectSphericalTriangle(clippingCap, va, outVertices, ta, o
utTexturePos, <span class="insert">maxSqDistortion, </span>nbI+1, false, true, true);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               //va[0]=vertices[0]+vertices[2];</td><td> </td><td class="right">               //va[0]=vertices[0]+vertices[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               //va[0].normalize();</td><td> </td><td class="right">               //va[0].normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[0]=va[2];</td><td> </td><td class="right">               va[0]=va[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[1]=vertices[1];</td><td> </td><td class="right">               va[1]=vertices[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[2]=vertices[2];</td><td> </td><td class="right">               va[2]=vertices[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               if (outTexturePos)</td><td> </td><td class="right">               if (outTexturePos)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[0]=(texturePos[0]+texturePos[2])*0.5;</td><td> </td><td class="right">                       ta[0]=(texturePos[0]+texturePos[2])*0.5;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[1]=texturePos[1];</td><td> </td><td class="right">                       ta[1]=texturePos[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[2]=texturePos[2];</td><td> </td><td class="right">                       ta[2]=texturePos[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0022" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               projectSphericalTriangle(clippingCap, va, outVertices, ta, o
utTexturePos, nbI+1, true, false, true);</td><td> </td><td class="rblock">               projectSphericalTriangle(clippingCap, va, outVertices, ta, o
utTexturePos, <span class="insert">maxSqDistortion, </span>nbI+1, true, false, true);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return;</td><td> </td><td class="right">               return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // 2 sides have to be split: split the triangle in 3</td><td> </td><td class="right">       // 2 sides have to be split: split the triangle in 3</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (cDiscontinuity1 &amp;&amp; cDiscontinuity2 &amp;&amp; !cDiscontinuity3)</td><td> </td><td class="right">       if (cDiscontinuity1 &amp;&amp; cDiscontinuity2 &amp;&amp; !cDiscontinuity3)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[0]=vertices[0];</td><td> </td><td class="right">               va[0]=vertices[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[1]=vertices[0];va[1]+=vertices[1];</td><td> </td><td class="right">               va[1]=vertices[0];va[1]+=vertices[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[1].normalize();</td><td> </td><td class="right">               va[1].normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[2]=vertices[1];va[2]+=vertices[2];</td><td> </td><td class="right">               va[2]=vertices[1];va[2]+=vertices[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[2].normalize();</td><td> </td><td class="right">               va[2].normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               if (outTexturePos)</td><td> </td><td class="right">               if (outTexturePos)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[0]=texturePos[0];</td><td> </td><td class="right">                       ta[0]=texturePos[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[1]=(texturePos[0]+texturePos[1])*0.5;</td><td> </td><td class="right">                       ta[1]=(texturePos[0]+texturePos[1])*0.5;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[2]=(texturePos[1]+texturePos[2])*0.5;</td><td> </td><td class="right">                       ta[2]=(texturePos[1]+texturePos[2])*0.5;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0023" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               projectSphericalTriangle(clippingCap, va, outVertices, ta, o
utTexturePos, nbI+1);</td><td> </td><td class="rblock">               projectSphericalTriangle(clippingCap, va, outVertices, ta, o
utTexturePos, <span class="insert">maxSqDistortion, </span>nbI+1);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               //va[0]=vertices[0]+vertices[1];</td><td> </td><td class="right">               //va[0]=vertices[0]+vertices[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               //va[0].normalize();</td><td> </td><td class="right">               //va[0].normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[0]=va[1];</td><td> </td><td class="right">               va[0]=va[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[1]=vertices[1];</td><td> </td><td class="right">               va[1]=vertices[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               //va[2]=vertices[1]+vertices[2];</td><td> </td><td class="right">               //va[2]=vertices[1]+vertices[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               //va[2].normalize();</td><td> </td><td class="right">               //va[2].normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               if (outTexturePos)</td><td> </td><td class="right">               if (outTexturePos)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[0]=(texturePos[0]+texturePos[1])*0.5;</td><td> </td><td class="right">                       ta[0]=(texturePos[0]+texturePos[1])*0.5;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[1]=texturePos[1];</td><td> </td><td class="right">                       ta[1]=texturePos[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[2]=(texturePos[1]+texturePos[2])*0.5;</td><td> </td><td class="right">                       ta[2]=(texturePos[1]+texturePos[2])*0.5;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0024" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               projectSphericalTriangle(clippingCap, va, outVertices, ta, o
utTexturePos, nbI+1);</td><td> </td><td class="rblock">               projectSphericalTriangle(clippingCap, va, outVertices, ta, o
utTexturePos, <span class="insert">maxSqDistortion, </span>nbI+1);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[0]=vertices[0];</td><td> </td><td class="right">               va[0]=vertices[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               //va[1]=vertices[1]+vertices[2];</td><td> </td><td class="right">               //va[1]=vertices[1]+vertices[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               //va[1].normalize();</td><td> </td><td class="right">               //va[1].normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[1]=va[2];</td><td> </td><td class="right">               va[1]=va[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[2]=vertices[2];</td><td> </td><td class="right">               va[2]=vertices[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               if (outTexturePos)</td><td> </td><td class="right">               if (outTexturePos)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[0]=texturePos[0];</td><td> </td><td class="right">                       ta[0]=texturePos[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[1]=(texturePos[1]+texturePos[2])*0.5;</td><td> </td><td class="right">                       ta[1]=(texturePos[1]+texturePos[2])*0.5;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[2]=texturePos[2];</td><td> </td><td class="right">                       ta[2]=texturePos[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0025" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               projectSphericalTriangle(clippingCap, va, outVertices, ta, o
utTexturePos, nbI+1, true, true, false);</td><td> </td><td class="rblock">               projectSphericalTriangle(clippingCap, va, outVertices, ta, o
utTexturePos, <span class="insert">maxSqDistortion, </span>nbI+1, true, true, false);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return;</td><td> </td><td class="right">               return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (cDiscontinuity1 &amp;&amp; !cDiscontinuity2 &amp;&amp; cDiscontinuity3)</td><td> </td><td class="right">       if (cDiscontinuity1 &amp;&amp; !cDiscontinuity2 &amp;&amp; cDiscontinuity3)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[0]=vertices[0];</td><td> </td><td class="right">               va[0]=vertices[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[1]=vertices[0];va[1]+=vertices[1];</td><td> </td><td class="right">               va[1]=vertices[0];va[1]+=vertices[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[1].normalize();</td><td> </td><td class="right">               va[1].normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[2]=vertices[0];va[2]+=vertices[2];</td><td> </td><td class="right">               va[2]=vertices[0];va[2]+=vertices[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[2].normalize();</td><td> </td><td class="right">               va[2].normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               if (outTexturePos)</td><td> </td><td class="right">               if (outTexturePos)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[0]=texturePos[0];</td><td> </td><td class="right">                       ta[0]=texturePos[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[1]=(texturePos[0]+texturePos[1])*0.5;</td><td> </td><td class="right">                       ta[1]=(texturePos[0]+texturePos[1])*0.5;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[2]=(texturePos[0]+texturePos[2])*0.5;</td><td> </td><td class="right">                       ta[2]=(texturePos[0]+texturePos[2])*0.5;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0026" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               projectSphericalTriangle(clippingCap, va, outVertices, ta, o
utTexturePos, nbI+1);</td><td> </td><td class="rblock">               projectSphericalTriangle(clippingCap, va, outVertices, ta, o
utTexturePos, <span class="insert">maxSqDistortion, </span>nbI+1);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               //va[0]=vertices[0]+vertices[1];</td><td> </td><td class="right">               //va[0]=vertices[0]+vertices[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               //va[0].normalize();</td><td> </td><td class="right">               //va[0].normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[0]=va[1];</td><td> </td><td class="right">               va[0]=va[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[1]=vertices[2];</td><td> </td><td class="right">               va[1]=vertices[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               //va[2]=vertices[0]+vertices[2];</td><td> </td><td class="right">               //va[2]=vertices[0]+vertices[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               //va[2].normalize();</td><td> </td><td class="right">               //va[2].normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               if (outTexturePos)</td><td> </td><td class="right">               if (outTexturePos)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[0]=(texturePos[0]+texturePos[1])*0.5;</td><td> </td><td class="right">                       ta[0]=(texturePos[0]+texturePos[1])*0.5;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[1]=texturePos[2];</td><td> </td><td class="right">                       ta[1]=texturePos[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[2]=(texturePos[0]+texturePos[2])*0.5;</td><td> </td><td class="right">                       ta[2]=(texturePos[0]+texturePos[2])*0.5;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0027" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               projectSphericalTriangle(clippingCap, va, outVertices, ta, o
utTexturePos, nbI+1);</td><td> </td><td class="rblock">               projectSphericalTriangle(clippingCap, va, outVertices, ta, o
utTexturePos, <span class="insert">maxSqDistortion, </span>nbI+1);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               //va[0]=vertices[0]+vertices[1];</td><td> </td><td class="right">               //va[0]=vertices[0]+vertices[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               //va[0].normalize();</td><td> </td><td class="right">               //va[0].normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[1]=vertices[1];</td><td> </td><td class="right">               va[1]=vertices[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[2]=vertices[2];</td><td> </td><td class="right">               va[2]=vertices[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               if (outTexturePos)</td><td> </td><td class="right">               if (outTexturePos)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[0]=(texturePos[0]+texturePos[1])*0.5;</td><td> </td><td class="right">                       ta[0]=(texturePos[0]+texturePos[1])*0.5;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[1]=texturePos[1];</td><td> </td><td class="right">                       ta[1]=texturePos[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[2]=texturePos[2];</td><td> </td><td class="right">                       ta[2]=texturePos[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0028" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               projectSphericalTriangle(clippingCap, va, outVertices, ta, o
utTexturePos, nbI+1, true, false, true);</td><td> </td><td class="rblock">               projectSphericalTriangle(clippingCap, va, outVertices, ta, o
utTexturePos, <span class="insert">maxSqDistortion, </span>nbI+1, true, false, true);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return;</td><td> </td><td class="right">               return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (!cDiscontinuity1 &amp;&amp; cDiscontinuity2 &amp;&amp; cDiscontinuity3)</td><td> </td><td class="right">       if (!cDiscontinuity1 &amp;&amp; cDiscontinuity2 &amp;&amp; cDiscontinuity3)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[0]=vertices[0];</td><td> </td><td class="right">               va[0]=vertices[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[1]=vertices[1];</td><td> </td><td class="right">               va[1]=vertices[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[2]=vertices[1];va[2]+=vertices[2];</td><td> </td><td class="right">               va[2]=vertices[1];va[2]+=vertices[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[2].normalize();</td><td> </td><td class="right">               va[2].normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               if (outTexturePos)</td><td> </td><td class="right">               if (outTexturePos)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[0]=texturePos[0];</td><td> </td><td class="right">                       ta[0]=texturePos[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[1]=texturePos[1];</td><td> </td><td class="right">                       ta[1]=texturePos[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[2]=(texturePos[1]+texturePos[2])*0.5;</td><td> </td><td class="right">                       ta[2]=(texturePos[1]+texturePos[2])*0.5;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0029" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               projectSphericalTriangle(clippingCap, va, outVertices, ta, o
utTexturePos, nbI+1, false, true, true);</td><td> </td><td class="rblock">               projectSphericalTriangle(clippingCap, va, outVertices, ta, o
utTexturePos, <span class="insert">maxSqDistortion, </span>nbI+1, false, true, true);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               //va[0]=vertices[1]+vertices[2];</td><td> </td><td class="right">               //va[0]=vertices[1]+vertices[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               //va[0].normalize();</td><td> </td><td class="right">               //va[0].normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[0]=va[2];</td><td> </td><td class="right">               va[0]=va[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[1]=vertices[2];</td><td> </td><td class="right">               va[1]=vertices[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[2]=vertices[0];va[2]+=vertices[2];</td><td> </td><td class="right">               va[2]=vertices[0];va[2]+=vertices[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[2].normalize();</td><td> </td><td class="right">               va[2].normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               if (outTexturePos)</td><td> </td><td class="right">               if (outTexturePos)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[0]=(texturePos[1]+texturePos[2])*0.5;</td><td> </td><td class="right">                       ta[0]=(texturePos[1]+texturePos[2])*0.5;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[1]=texturePos[2];</td><td> </td><td class="right">                       ta[1]=texturePos[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[2]=(texturePos[0]+texturePos[2])*0.5;</td><td> </td><td class="right">                       ta[2]=(texturePos[0]+texturePos[2])*0.5;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0030" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               projectSphericalTriangle(clippingCap, va, outVertices, ta, o
utTexturePos, nbI+1);</td><td> </td><td class="rblock">               projectSphericalTriangle(clippingCap, va, outVertices, ta, o
utTexturePos, <span class="insert">maxSqDistortion, </span>nbI+1);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[1]=va[0];</td><td> </td><td class="right">               va[1]=va[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[0]=vertices[0];</td><td> </td><td class="right">               va[0]=vertices[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               //va[1]=vertices[1]+vertices[2];</td><td> </td><td class="right">               //va[1]=vertices[1]+vertices[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               //va[1].normalize();</td><td> </td><td class="right">               //va[1].normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               //va[2]=vertices[0]+vertices[2];</td><td> </td><td class="right">               //va[2]=vertices[0]+vertices[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               //va[2].normalize();</td><td> </td><td class="right">               //va[2].normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               if (outTexturePos)</td><td> </td><td class="right">               if (outTexturePos)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[0]=texturePos[0];</td><td> </td><td class="right">                       ta[0]=texturePos[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[1]=(texturePos[1]+texturePos[2])*0.5;</td><td> </td><td class="right">                       ta[1]=(texturePos[1]+texturePos[2])*0.5;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[2]=(texturePos[0]+texturePos[2])*0.5;</td><td> </td><td class="right">                       ta[2]=(texturePos[0]+texturePos[2])*0.5;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0031" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               projectSphericalTriangle(clippingCap, va, outVertices, ta, o
utTexturePos, nbI+1);</td><td> </td><td class="rblock">               projectSphericalTriangle(clippingCap, va, outVertices, ta, o
utTexturePos, <span class="insert">maxSqDistortion, </span>nbI+1);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return;</td><td> </td><td class="right">               return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Last case: the 3 sides have to be split: cut in 4 triangles a' la
 HTM</td><td> </td><td class="right">       // Last case: the 3 sides have to be split: cut in 4 triangles a' la
 HTM</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       va[0]=vertices[0];va[0]+=vertices[1];</td><td> </td><td class="right">       va[0]=vertices[0];va[0]+=vertices[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       va[0].normalize();</td><td> </td><td class="right">       va[0].normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       va[1]=vertices[1];va[1]+=vertices[2];</td><td> </td><td class="right">       va[1]=vertices[1];va[1]+=vertices[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       va[1].normalize();</td><td> </td><td class="right">       va[1].normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       va[2]=vertices[0];va[2]+=vertices[2];</td><td> </td><td class="right">       va[2]=vertices[0];va[2]+=vertices[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       va[2].normalize();</td><td> </td><td class="right">       va[2].normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (outTexturePos)</td><td> </td><td class="right">       if (outTexturePos)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               ta[0]=(texturePos[0]+texturePos[1])*0.5;</td><td> </td><td class="right">               ta[0]=(texturePos[0]+texturePos[1])*0.5;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               ta[1]=(texturePos[1]+texturePos[2])*0.5;</td><td> </td><td class="right">               ta[1]=(texturePos[1]+texturePos[2])*0.5;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               ta[2]=(texturePos[0]+texturePos[2])*0.5;</td><td> </td><td class="right">               ta[2]=(texturePos[0]+texturePos[2])*0.5;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0032" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       projectSphericalTriangle(clippingCap, va, outVertices, ta, outTextur
ePos, nbI+1);</td><td> </td><td class="rblock">       projectSphericalTriangle(clippingCap, va, outVertices, ta, outTextur
ePos, <span class="insert">maxSqDistortion, </span>nbI+1);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       va[1]=va[0];</td><td> </td><td class="right">       va[1]=va[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       va[0]=vertices[0];</td><td> </td><td class="right">       va[0]=vertices[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //va[1]=vertices[0]+vertices[1];</td><td> </td><td class="right">       //va[1]=vertices[0]+vertices[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //va[1].normalize();</td><td> </td><td class="right">       //va[1].normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //va[2]=vertices[0]+vertices[2];</td><td> </td><td class="right">       //va[2]=vertices[0]+vertices[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //va[2].normalize();</td><td> </td><td class="right">       //va[2].normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (outTexturePos)</td><td> </td><td class="right">       if (outTexturePos)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               ta[0]=texturePos[0];</td><td> </td><td class="right">               ta[0]=texturePos[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               ta[1]=(texturePos[0]+texturePos[1])*0.5;</td><td> </td><td class="right">               ta[1]=(texturePos[0]+texturePos[1])*0.5;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               ta[2]=(texturePos[0]+texturePos[2])*0.5;</td><td> </td><td class="right">               ta[2]=(texturePos[0]+texturePos[2])*0.5;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0033" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       projectSphericalTriangle(clippingCap, va, outVertices, ta, outTextur
ePos, nbI+1);</td><td> </td><td class="rblock">       projectSphericalTriangle(clippingCap, va, outVertices, ta, outTextur
ePos, <span class="insert">maxSqDistortion, </span>nbI+1);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //va[0]=vertices[0]+vertices[1];</td><td> </td><td class="right">       //va[0]=vertices[0]+vertices[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //va[0].normalize();</td><td> </td><td class="right">       //va[0].normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       va[0]=va[1];</td><td> </td><td class="right">       va[0]=va[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       va[1]=vertices[1];</td><td> </td><td class="right">       va[1]=vertices[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       va[2]=vertices[1];va[2]+=vertices[2];</td><td> </td><td class="right">       va[2]=vertices[1];va[2]+=vertices[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       va[2].normalize();</td><td> </td><td class="right">       va[2].normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (outTexturePos)</td><td> </td><td class="right">       if (outTexturePos)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               ta[0]=(texturePos[0]+texturePos[1])*0.5;</td><td> </td><td class="right">               ta[0]=(texturePos[0]+texturePos[1])*0.5;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               ta[1]=texturePos[1];</td><td> </td><td class="right">               ta[1]=texturePos[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               ta[2]=(texturePos[1]+texturePos[2])*0.5;</td><td> </td><td class="right">               ta[2]=(texturePos[1]+texturePos[2])*0.5;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0034" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       projectSphericalTriangle(clippingCap, va, outVertices, ta, outTextur
ePos, nbI+1);</td><td> </td><td class="rblock">       projectSphericalTriangle(clippingCap, va, outVertices, ta, outTextur
ePos, <span class="insert">maxSqDistortion, </span>nbI+1);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       va[0]=vertices[0];va[0]+=vertices[2];</td><td> </td><td class="right">       va[0]=vertices[0];va[0]+=vertices[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       va[0].normalize();</td><td> </td><td class="right">       va[0].normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //va[1]=vertices[1]+vertices[2];</td><td> </td><td class="right">       //va[1]=vertices[1]+vertices[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //va[1].normalize();</td><td> </td><td class="right">       //va[1].normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       va[1]=va[2];</td><td> </td><td class="right">       va[1]=va[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       va[2]=vertices[2];</td><td> </td><td class="right">       va[2]=vertices[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (outTexturePos)</td><td> </td><td class="right">       if (outTexturePos)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               ta[0]=(texturePos[0]+texturePos[2])*0.5;</td><td> </td><td class="right">               ta[0]=(texturePos[0]+texturePos[2])*0.5;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               ta[1]=(texturePos[1]+texturePos[2])*0.5;</td><td> </td><td class="right">               ta[1]=(texturePos[1]+texturePos[2])*0.5;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               ta[2]=texturePos[2];</td><td> </td><td class="right">               ta[2]=texturePos[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0035" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       projectSphericalTriangle(clippingCap, va, outVertices, ta, outTextur
ePos, nbI+1);</td><td> </td><td class="rblock">       projectSphericalTriangle(clippingCap, va, outVertices, ta, outTextur
ePos, <span class="insert">maxSqDistortion, </span>nbI+1);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       return;</td><td> </td><td class="right">       return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">static QVarLengthArray&lt;Vec3f, 4096&gt; polygonVertexArray;</td><td> </td><td class="right">static QVarLengthArray&lt;Vec3f, 4096&gt; polygonVertexArray;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">static QVarLengthArray&lt;Vec2f, 4096&gt; polygonTextureCoordArray;</td><td> </td><td class="right">static QVarLengthArray&lt;Vec2f, 4096&gt; polygonTextureCoordArray;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">static QVarLengthArray&lt;unsigned int, 4096&gt; indexArray;</td><td> </td><td class="right">static QVarLengthArray&lt;unsigned int, 4096&gt; indexArray;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void StelPainter::drawGreatCircleArcs(const StelVertexArray&amp; va, const Sphe
ricalCap* clippingCap)</td><td> </td><td class="right">void StelPainter::drawGreatCircleArcs(const StelVertexArray&amp; va, const Sphe
ricalCap* clippingCap)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l6" /><small>skipping to change at</small><em> line 1231</em></th><th> </th><th><a name="part-r6" /><small>skipping to change at</small><em> line 1270</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// The function object that we use as an interface between VertexArray::for
eachTriangle and</td><td> </td><td class="right">// The function object that we use as an interface between VertexArray::for
eachTriangle and</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// StelPainter::projectSphericalTriangle.</td><td> </td><td class="right">// StelPainter::projectSphericalTriangle.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//</td><td> </td><td class="right">//</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// This is used by drawSphericalTriangles to project all the triangles coor
dinates in a StelVertexArray into our global</td><td> </td><td class="right">// This is used by drawSphericalTriangles to project all the triangles coor
dinates in a StelVertexArray into our global</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// vertex array buffer.</td><td> </td><td class="right">// vertex array buffer.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">class VertexArrayProjector</td><td> </td><td class="right">class VertexArrayProjector</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">public:</td><td> </td><td class="right">public:</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       VertexArrayProjector(const StelVertexArray&amp; ar, StelPainter* apainte
r, const SphericalCap* aclippingCap,</td><td> </td><td class="right">       VertexArrayProjector(const StelVertexArray&amp; ar, StelPainter* apainte
r, const SphericalCap* aclippingCap,</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0036" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                                QVarLengthArray&lt;Vec3f, 4096
&gt;* aoutVertices, QVarLengthArray&lt;Vec2f, 4096&gt;* aoutTexturePos=NULL)</td><td> </td><td class="rblock">                                                QVarLengthArray&lt;Vec3f, 4096
&gt;* aoutVertices, QVarLengthArray&lt;Vec2f, 4096&gt;* aoutTexturePos=NULL<span class="insert">, double 
amaxSqDistortion=5.</span>)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                  : vertexArray(ar), painter(apainter), clippingCap(aclippi
ngCap), outVertices(aoutVertices),</td><td> </td><td class="right">                  : vertexArray(ar), painter(apainter), clippingCap(aclippi
ngCap), outVertices(aoutVertices),</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0037" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                        outTexturePos(aoutTexturePos)</td><td> </td><td class="rblock">                        outTexturePos(aoutTexturePos)<span class="insert">, maxSqDistortion(amax
SqDistortion)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Project a single triangle and add it into the output arrays</td><td> </td><td class="right">       // Project a single triangle and add it into the output arrays</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       inline void operator()(const Vec3d* v0, const Vec3d* v1, const Vec3d
* v2,</td><td> </td><td class="right">       inline void operator()(const Vec3d* v0, const Vec3d* v1, const Vec3d
* v2,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                                                  const Vec2f* t0, const Ve
c2f* t1, const Vec2f* t2,</td><td> </td><td class="right">                                                  const Vec2f* t0, const Ve
c2f* t1, const Vec2f* t2,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                                                  unsigned int, unsigned in
t, unsigned)</td><td> </td><td class="right">                                                  unsigned int, unsigned in
t, unsigned)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               // XXX: we may optimize more by putting the declaration and 
the test outside of this method.</td><td> </td><td class="right">               // XXX: we may optimize more by putting the declaration and 
the test outside of this method.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               const Vec3d tmpVertex[3] = {*v0, *v1, *v2};</td><td> </td><td class="right">               const Vec3d tmpVertex[3] = {*v0, *v1, *v2};</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               if (outTexturePos)</td><td> </td><td class="right">               if (outTexturePos)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       const Vec2f tmpTexture[3] = {*t0, *t1, *t2};</td><td> </td><td class="right">                       const Vec2f tmpTexture[3] = {*t0, *t1, *t2};</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0038" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       painter-&gt;projectSphericalTriangle(clippingCap, tmpVe
rtex, outVertices, tmpTexture, outTexturePos);</td><td> </td><td class="rblock">                       painter-&gt;projectSphericalTriangle(clippingCap, tmpVe
rtex, outVertices, tmpTexture, outTexturePos<span class="insert">, maxSqDistortion</span>);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               else</td><td> </td><td class="right">               else</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0039" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       painter-&gt;projectSphericalTriangle(clippingCap, tmpVe
rtex, outVertices, NULL, NULL);</td><td> </td><td class="rblock">                       painter-&gt;projectSphericalTriangle(clippingCap, tmpVe
rtex, outVertices, NULL, NULL<span class="insert">, maxSqDistortion</span>);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Draw the resulting arrays</td><td> </td><td class="right">       // Draw the resulting arrays</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       void drawResult()</td><td> </td><td class="right">       void drawResult()</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               painter-&gt;setVertexPointer(3, GL_FLOAT, outVertices-&gt;constDat
a());</td><td> </td><td class="right">               painter-&gt;setVertexPointer(3, GL_FLOAT, outVertices-&gt;constDat
a());</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               if (outTexturePos)</td><td> </td><td class="right">               if (outTexturePos)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       painter-&gt;setTexCoordPointer(2, GL_FLOAT, outTextureP
os-&gt;constData());</td><td> </td><td class="right">                       painter-&gt;setTexCoordPointer(2, GL_FLOAT, outTextureP
os-&gt;constData());</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               painter-&gt;enableClientStates(true, outTexturePos != NULL);</td><td> </td><td class="right">               painter-&gt;enableClientStates(true, outTexturePos != NULL);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               painter-&gt;drawFromArray(StelPainter::Triangles, outVertices-&gt;
size(), 0, false);</td><td> </td><td class="right">               painter-&gt;drawFromArray(StelPainter::Triangles, outVertices-&gt;
size(), 0, false);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               painter-&gt;enableClientStates(false);</td><td> </td><td class="right">               painter-&gt;enableClientStates(false);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">private:</td><td> </td><td class="right">private:</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const StelVertexArray&amp; vertexArray;</td><td> </td><td class="right">       const StelVertexArray&amp; vertexArray;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       StelPainter* painter;</td><td> </td><td class="right">       StelPainter* painter;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const SphericalCap* clippingCap;</td><td> </td><td class="right">       const SphericalCap* clippingCap;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       QVarLengthArray&lt;Vec3f, 4096&gt;* outVertices;</td><td> </td><td class="right">       QVarLengthArray&lt;Vec3f, 4096&gt;* outVertices;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       QVarLengthArray&lt;Vec2f, 4096&gt;* outTexturePos;</td><td> </td><td class="right">       QVarLengthArray&lt;Vec2f, 4096&gt;* outTexturePos;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0040" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       double maxSqDistortion;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">};</td><td> </td><td class="right">};</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0041" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">void StelPainter::drawStelVertexArray(const StelVertexArray&amp; arr)</td><td> </td><td class="rblock">void StelPainter::drawStelVertexArray(const StelVertexArray&amp; arr<span class="insert">, bool chec
kDiscontinuity</span>)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0042" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">if (checkDiscontinuity &amp;&amp; prj-&gt;hasDiscontinuity())</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               // The projection has discontinuities, so we need to make su</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">re that no triangle is crossing them.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               drawStelVertexArray(arr.removeDiscontinuousTriangles(this-&gt;g</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">etProjector().data()), false);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               return;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       setVertexPointer(3, GL_DOUBLE, arr.vertex.constData());</td><td> </td><td class="right">       setVertexPointer(3, GL_DOUBLE, arr.vertex.constData());</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (arr.isTextured())</td><td> </td><td class="right">       if (arr.isTextured())</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               setTexCoordPointer(2, GL_FLOAT, arr.texCoords.constData());</td><td> </td><td class="right">               setTexCoordPointer(2, GL_FLOAT, arr.texCoords.constData());</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               enableClientStates(true, true);</td><td> </td><td class="right">               enableClientStates(true, true);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       else</td><td> </td><td class="right">       else</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               enableClientStates(true, false);</td><td> </td><td class="right">               enableClientStates(true, false);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (arr.isIndexed())</td><td> </td><td class="right">       if (arr.isIndexed())</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               drawFromArray((StelPainter::DrawingMode)arr.primitiveType, a
rr.indices.size(), 0, true, arr.indices.constData());</td><td> </td><td class="right">               drawFromArray((StelPainter::DrawingMode)arr.primitiveType, a
rr.indices.size(), 0, true, arr.indices.constData());</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       else</td><td> </td><td class="right">       else</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               drawFromArray((StelPainter::DrawingMode)arr.primitiveType, a
rr.vertex.size());</td><td> </td><td class="right">               drawFromArray((StelPainter::DrawingMode)arr.primitiveType, a
rr.vertex.size());</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       enableClientStates(false);</td><td> </td><td class="right">       enableClientStates(false);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0043" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">void StelPainter::drawSphericalTriangles(const StelVertexArray&amp; va, bool te
xtured, const SphericalCap* clippingCap, bool doSubDivide)</td><td> </td><td class="rblock">void StelPainter::drawSphericalTriangles(const StelVertexArray&amp; va, bool te
xtured, const SphericalCap* clippingCap, bool doSubDivide<span class="insert">, double maxSqDist
ortion</span>)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (va.vertex.isEmpty())</td><td> </td><td class="right">       if (va.vertex.isEmpty())</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return;</td><td> </td><td class="right">               return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Q_ASSERT(va.vertex.size()&gt;2);</td><td> </td><td class="right">       Q_ASSERT(va.vertex.size()&gt;2);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#ifndef STELPAINTER_GL2</td><td> </td><td class="right">#ifndef STELPAINTER_GL2</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);</td><td> </td><td class="right">       glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#endif</td><td> </td><td class="right">#endif</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       polygonVertexArray.clear();</td><td> </td><td class="right">       polygonVertexArray.clear();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       polygonTextureCoordArray.clear();</td><td> </td><td class="right">       polygonTextureCoordArray.clear();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       indexArray.clear();</td><td> </td><td class="right">       indexArray.clear();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (!doSubDivide)</td><td> </td><td class="right">       if (!doSubDivide)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0044" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               <span class="delete">if (prj-&gt;hasDiscontinuity())</span></td><td> </td><td class="rblock">               // The simplest case, we don't need to iterate <span class="insert">through</span> the <span class="insert">t</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               {</span></td><td> </td><td class="rblock"><span class="insert">riangles</span> at all.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       // We don't want to subdivise the triangles, but the</span></td><td> </td><td class="rblock">               drawStelVertexArray(va);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"> projection has discontinuities,</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       // so we need to make sure that no triangle is cross</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">ing them.</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       const StelVertexArray&amp; cleanVa = va.removeDiscontinu</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">ousTriangles(this-&gt;getProjector().data());</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       drawStelVertexArray(cleanVa);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               }</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               else</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               {</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       // The simplest case, we don't need to iterate <span class="delete">throu</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">gh</span> the <span class="delete">triangles</span> at all.</td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       drawStelVertexArray(va);</td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               <span class="delete">}</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return;</td><td> </td><td class="right">               return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // the last case.  It is the slowest, it process the triangles one b
y one.</td><td> </td><td class="right">       // the last case.  It is the slowest, it process the triangles one b
y one.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               // Project all the triangles of the VertexArray into our buf
fer arrays.</td><td> </td><td class="right">               // Project all the triangles of the VertexArray into our buf
fer arrays.</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0045" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               VertexArrayProjector result = va.foreachTriangle(VertexArray
Projector(va, this, clippingCap, &amp;polygonVertexArray, textured ? &amp;polygonTe
xtureCoordArray : NULL));</td><td> </td><td class="rblock">               VertexArrayProjector result = va.foreachTriangle(VertexArray
Projector(va, this, clippingCap, &amp;polygonVertexArray, textured ? &amp;polygonTe
xtureCoordArray : NULL<span class="insert">, maxSqDistortion</span>));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               result.drawResult();</td><td> </td><td class="right">               result.drawResult();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return;</td><td> </td><td class="right">               return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// Draw the given SphericalPolygon.</td><td> </td><td class="right">// Draw the given SphericalPolygon.</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0046" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">void StelPainter::drawSphericalRegion(const SphericalRegion* poly, Spherica
lPolygonDrawMode drawMode, const SphericalCap* clippingCap, bool doSubDivis
e)</td><td> </td><td class="rblock">void StelPainter::drawSphericalRegion(const SphericalRegion* poly, Spherica
lPolygonDrawMode drawMode, const SphericalCap* clippingCap, bool doSubDivis
e<span class="insert">, double maxSqDistortion</span>)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (!prj-&gt;getBoundingCap().intersects(poly-&gt;getBoundingCap()))</td><td> </td><td class="right">       if (!prj-&gt;getBoundingCap().intersects(poly-&gt;getBoundingCap()))</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return;</td><td> </td><td class="right">               return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       switch (drawMode)</td><td> </td><td class="right">       switch (drawMode)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               case SphericalPolygonDrawModeBoundary:</td><td> </td><td class="right">               case SphericalPolygonDrawModeBoundary:</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       if (doSubDivise || prj-&gt;intersectViewportDiscontinui
ty(poly-&gt;getBoundingCap()))</td><td> </td><td class="right">                       if (doSubDivise || prj-&gt;intersectViewportDiscontinui
ty(poly-&gt;getBoundingCap()))</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               drawGreatCircleArcs(poly-&gt;getOutlineVertexAr
ray(), clippingCap);</td><td> </td><td class="right">                               drawGreatCircleArcs(poly-&gt;getOutlineVertexAr
ray(), clippingCap);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       else</td><td> </td><td class="right">                       else</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0047" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                               drawStelVertexArray(poly-&gt;getOutlineVertexAr
ray());</td><td> </td><td class="rblock">                               drawStelVertexArray(poly-&gt;getOutlineVertexAr
ray()<span class="insert">, false</span>);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       break;</td><td> </td><td class="right">                       break;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               case SphericalPolygonDrawModeFill:</td><td> </td><td class="right">               case SphericalPolygonDrawModeFill:</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               case SphericalPolygonDrawModeTextureFill:</td><td> </td><td class="right">               case SphericalPolygonDrawModeTextureFill:</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       glEnable(GL_CULL_FACE);</td><td> </td><td class="right">                       glEnable(GL_CULL_FACE);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       // The polygon is already tesselated as triangles</td><td> </td><td class="right">                       // The polygon is already tesselated as triangles</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       if (doSubDivise || prj-&gt;intersectViewportDiscontinui
ty(poly-&gt;getBoundingCap()))</td><td> </td><td class="right">                       if (doSubDivise || prj-&gt;intersectViewportDiscontinui
ty(poly-&gt;getBoundingCap()))</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0048" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                               drawSphericalTriangles(poly-&gt;getFillVertexAr
ray(), drawMode==SphericalPolygonDrawModeTextureFill, clippingCap, doSubDiv
ise);</td><td> </td><td class="rblock">                               drawSphericalTriangles(poly-&gt;getFillVertexAr
ray(), drawMode==SphericalPolygonDrawModeTextureFill, clippingCap, doSubDiv
ise<span class="insert">, maxSqDistortion</span>);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       else</td><td> </td><td class="right">                       else</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0049" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                               drawStelVertexArray(poly-&gt;getFillVertexArray
());</td><td> </td><td class="rblock">                               drawStelVertexArray(poly-&gt;getFillVertexArray
()<span class="insert">, false</span>);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       glDisable(GL_CULL_FACE);</td><td> </td><td class="right">                       glDisable(GL_CULL_FACE);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       break;</td><td> </td><td class="right">                       break;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               default:</td><td> </td><td class="right">               default:</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       Q_ASSERT(0);</td><td> </td><td class="right">                       Q_ASSERT(0);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">/*************************************************************************</td><td> </td><td class="right">/*************************************************************************</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"> draw a simple circle, 2d viewport coordinates in pixel</td><td> </td><td class="right"> draw a simple circle, 2d viewport coordinates in pixel</td><td class="lineno" valign="top"></td></tr>

     <tr><td></td><td class="left"></td><td> </td><td class="right"></td><td></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 49 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><td></td><th><i>145 lines changed or deleted</i></th><th><i> </i></th><th><i>197 lines changed or added</i></th><td></td></tr>
     <tr><td colspan="5" align="center" class="small"><br/>This html diff was produced by rfcdiff 1.41. The latest version is available from <a href="http://www.tools.ietf.org/tools/rfcdiff/" >http://tools.ietf.org/tools/rfcdiff/</a> </td></tr>
   </table>
   </body>
   </html>
