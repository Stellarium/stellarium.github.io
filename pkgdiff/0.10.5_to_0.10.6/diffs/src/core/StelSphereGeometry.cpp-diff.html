<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"> 
<!-- Generated by rfcdiff 1.41: rfcdiff  --> 
<!-- <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional" > -->
<!-- System: Linux fomalhaut.local 3.13.0-38-generic #65-Ubuntu SMP Thu Oct 9 11:36:50 UTC 2014 x86_64 x86_64 x86_64 GNU/Linux --> 
<!-- Using awk: /usr/bin/gawk: GNU Awk 4.0.1 --> 
<!-- Using diff: /usr/bin/diff: diff (GNU diffutils) 3.3 --> 
<!-- Using wdiff: /usr/bin/wdiff: wdiff (GNU wdiff) 1.2.1 --> 
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"> 
<head> 
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /> 
  <meta http-equiv="Content-Style-Type" content="text/css" /> 
  <title>Diff: StelSphereGeometry.cpp - StelSphereGeometry.cpp</title> 
  <style type="text/css"> 
    body    { font-size:16px; margin: 0.4ex; margin-right: auto; } 
    tr      { } 
    td      { white-space: pre; font-family: Consolas, "DejaVu Sans Mono", "Droid Sans Mono", Monaco, Monospace; vertical-align: top; font-size: 0.86em;} 
    th      { font-size: 0.86em; } 
    .small  { font-size: 0.6em; font-style: italic; font-family: Verdana, Helvetica, sans-serif; } 
    .left   { background-color: #EEE; } 
    .right  { background-color: #FFF; } 
    .diff   { background-color: #CCF; } 
    .lblock { background-color: #BFB; } 
    .rblock { background-color: #FF8; } 
    .insert { background-color: #8FF; } 
    .delete { background-color: #ACF; } 
    .void   { background-color: #FFB; } 
    .cont   { background-color: #EEE; } 
    .linebr { background-color: #AAA; } 
    .lineno { color: red; background-color: #FFF; font-size: 0.7em; text-align: right; padding: 0 2px; } 
    .elipsis{ background-color: #AAA; } 
    .left .cont { background-color: #DDD; } 
    .right .cont { background-color: #EEE; } 
    .lblock .cont { background-color: #9D9; } 
    .rblock .cont { background-color: #DD6; } 
    .insert .cont { background-color: #0DD; } 
    .delete .cont { background-color: #8AD; } 
    .stats, .stats td, .stats th { background-color: #EEE; padding: 2px 0; } 
  </style> 
</head> 
<body > 
  <table border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th></th><th>&nbsp;StelSphereGeometry.cpp&nbsp;</th><th> </th><th>&nbsp;StelSphereGeometry.cpp&nbsp;</th><th></th></tr> 
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l1" /><small>skipping to change at</small><em> line 29</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 29</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#include &lt;QDebug&gt;</td><td> </td><td class="right">#include &lt;QDebug&gt;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#include &lt;QBuffer&gt;</td><td> </td><td class="right">#include &lt;QBuffer&gt;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#include &lt;stdexcept&gt;</td><td> </td><td class="right">#include &lt;stdexcept&gt;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#include "StelSphereGeometry.hpp"</td><td> </td><td class="right">#include "StelSphereGeometry.hpp"</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#include "StelUtils.hpp"</td><td> </td><td class="right">#include "StelUtils.hpp"</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#include "StelJsonParser.hpp"</td><td> </td><td class="right">#include "StelJsonParser.hpp"</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// Definition of static constants.</td><td> </td><td class="right">// Definition of static constants.</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">const QVariant::Type SphericalRegionP::qVariantType = (QVariant::Type)(QVar
iant::UserType+1);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">int SphericalRegionP::metaTypeId = SphericalRegionP::initialize();</td><td> </td><td class="right">int SphericalRegionP::metaTypeId = SphericalRegionP::initialize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0002" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                                                                           </span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">int SphericalRegionP::initialize()</td><td> </td><td class="right">int SphericalRegionP::initialize()</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0003" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       int id = qRegisterMetaType&lt;SphericalRegionP&gt;();</td><td> </td><td class="rblock">       int id = qRegisterMetaType&lt;SphericalRegionP&gt;(<span class="insert">"SphericalRegionP"</span>);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       qRegisterMetaTypeStreamOperators&lt;SphericalRegionP&gt;("SphericalRegionP
");</td><td> </td><td class="right">       qRegisterMetaTypeStreamOperators&lt;SphericalRegionP&gt;("SphericalRegionP
");</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       return id;</td><td> </td><td class="right">       return id;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">QDataStream&amp; operator&lt;&lt;(QDataStream&amp; out, const SphericalRegionP&amp; region)</td><td> </td><td class="right">QDataStream&amp; operator&lt;&lt;(QDataStream&amp; out, const SphericalRegionP&amp; region)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       out &lt;&lt; (quint8)region-&gt;getType();</td><td> </td><td class="right">       out &lt;&lt; (quint8)region-&gt;getType();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       region-&gt;serialize(out);</td><td> </td><td class="right">       region-&gt;serialize(out);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       return out;</td><td> </td><td class="right">       return out;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l2" /><small>skipping to change at</small><em> line 568</em></th><th> </th><th><a name="part-r2" /><small>skipping to change at</small><em> line 566</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">double SphericalCap::relativeDiameterOverlap(const SphericalCap&amp; c1, const 
SphericalCap&amp; c2)</td><td> </td><td class="right">double SphericalCap::relativeDiameterOverlap(const SphericalCap&amp; c1, const 
SphericalCap&amp; c2)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (!c1.intersects(c2))</td><td> </td><td class="right">       if (!c1.intersects(c2))</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return 0.;</td><td> </td><td class="right">               return 0.;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (c1.contains(c2))</td><td> </td><td class="right">       if (c1.contains(c2))</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return c2.getRadius()/c1.getRadius();</td><td> </td><td class="right">               return c2.getRadius()/c1.getRadius();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (c2.contains(c1))</td><td> </td><td class="right">       if (c2.contains(c1))</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return c1.getRadius()/c2.getRadius();</td><td> </td><td class="right">               return c1.getRadius()/c2.getRadius();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const double r1 = c1.getRadius();</td><td> </td><td class="right">       const double r1 = c1.getRadius();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const double r2 = c2.getRadius();</td><td> </td><td class="right">       const double r2 = c2.getRadius();</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0004" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       const double a = c1.n.angle(c2.n);</td><td> </td><td class="rblock">       const double a = c1.n.angle<span class="insert">Normalized</span>(c2.n);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const double overlapDist = (a-r1-r2)/(std::fabs(r1-r2)-r1-r2);</td><td> </td><td class="right">       const double overlapDist = (a-r1-r2)/(std::fabs(r1-r2)-r1-r2);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Q_ASSERT(overlapDist&gt;=0);</td><td> </td><td class="right">       Q_ASSERT(overlapDist&gt;=0);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       return overlapDist*qMin(r1/r2, r2/r1);</td><td> </td><td class="right">       return overlapDist*qMin(r1/r2, r2/r1);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">QVector&lt;Vec3d&gt; SphericalCap::getClosedOutlineContour() const</td><td> </td><td class="right">QVector&lt;Vec3d&gt; SphericalCap::getClosedOutlineContour() const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       static const int nbStep = 40;</td><td> </td><td class="right">       static const int nbStep = 40;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       QVector&lt;Vec3d&gt; contour;</td><td> </td><td class="right">       QVector&lt;Vec3d&gt; contour;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Vec3d p(n);</td><td> </td><td class="right">       Vec3d p(n);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l3" /><small>skipping to change at</small><em> line 594</em></th><th> </th><th><a name="part-r3" /><small>skipping to change at</small><em> line 592</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       for (int i=0;i&lt;nbStep;++i)</td><td> </td><td class="right">       for (int i=0;i&lt;nbStep;++i)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               contour.append(p);</td><td> </td><td class="right">               contour.append(p);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               p.transfo4d(rot);</td><td> </td><td class="right">               p.transfo4d(rot);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       return contour;</td><td> </td><td class="right">       return contour;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">OctahedronPolygon SphericalCap::getOctahedronPolygon() const</td><td> </td><td class="right">OctahedronPolygon SphericalCap::getOctahedronPolygon() const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0005" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       return OctahedronPolygon(getClosedOutlineContour());</td><td> </td><td class="rblock">       <span class="insert">if (d&gt;=0)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">               return OctahedronPolygon(getClosedOutlineContour());</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">else</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               SphericalCap cap(-n, -d);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               AllSkySphericalRegion allSky;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               OctahedronPolygon poly = allSky.getOctahedronPolygon();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               poly.inPlaceSubtraction(cap.getOctahedronPolygon());</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               return poly;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0006" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">QVariant<span class="delete">Map</span> SphericalCap::toQVariant() const</td><td> </td><td class="rblock">QVariant<span class="insert">List</span> SphericalCap::toQVariant() const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0007" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">QVariantMap</span> res;</td><td> </td><td class="rblock">       <span class="insert">QVariantList</span> res;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">res.insert("type", "CAP");</span></td><td> </td><td class="rblock">       <span class="insert">res &lt;&lt; "CAP";</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       double ra, dec;</td><td> </td><td class="right">       double ra, dec;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       StelUtils::rectToSphe(&amp;ra, &amp;dec, n);</td><td> </td><td class="right">       StelUtils::rectToSphe(&amp;ra, &amp;dec, n);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       QVariantList l;</td><td> </td><td class="right">       QVariantList l;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       l &lt;&lt; ra*180./M_PI &lt;&lt; dec*180./M_PI;</td><td> </td><td class="right">       l &lt;&lt; ra*180./M_PI &lt;&lt; dec*180./M_PI;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0008" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">res.insert("center", l);</span></td><td> </td><td class="rblock">       <span class="insert">res &lt;&lt; QVariant(l);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       res.insert("radius", std::acos(d)*180./M_PI);</span></td><td> </td><td class="rblock"><span class="insert">       res &lt;&lt; std::acos(d)*180./M_PI;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       return res;</td><td> </td><td class="right">       return res;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">SphericalRegionP SphericalCap::deserialize(QDataStream&amp; in)</td><td> </td><td class="right">SphericalRegionP SphericalCap::deserialize(QDataStream&amp; in)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Vec3d nn;</td><td> </td><td class="right">       Vec3d nn;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       double dd;</td><td> </td><td class="right">       double dd;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       in &gt;&gt; nn &gt;&gt; dd;</td><td> </td><td class="right">       in &gt;&gt; nn &gt;&gt; dd;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       return SphericalRegionP(new SphericalCap(nn, dd));</td><td> </td><td class="right">       return SphericalRegionP(new SphericalCap(nn, dd));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l4" /><small>skipping to change at</small><em> line 638</em></th><th> </th><th><a name="part-r4" /><small>skipping to change at</small><em> line 645</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       return r.contains(n);</td><td> </td><td class="right">       return r.contains(n);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">OctahedronPolygon SphericalPoint::getOctahedronPolygon() const</td><td> </td><td class="right">OctahedronPolygon SphericalPoint::getOctahedronPolygon() const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       QVector&lt;Vec3d&gt; contour;</td><td> </td><td class="right">       QVector&lt;Vec3d&gt; contour;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       contour &lt;&lt; n &lt;&lt; n &lt;&lt; n;</td><td> </td><td class="right">       contour &lt;&lt; n &lt;&lt; n &lt;&lt; n;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       return OctahedronPolygon(contour);</td><td> </td><td class="right">       return OctahedronPolygon(contour);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0009" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">QVariant<span class="delete">Map</span> SphericalPoint::toQVariant() const</td><td> </td><td class="rblock">QVariant<span class="insert">List</span> SphericalPoint::toQVariant() const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0010" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">QVariantMap</span> res;</td><td> </td><td class="rblock">       <span class="insert">QVariantList</span> res;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">res.insert("type", "POINT");</span></td><td> </td><td class="rblock">       <span class="insert">res &lt;&lt; "POINT";</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       double ra, dec;</td><td> </td><td class="right">       double ra, dec;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       StelUtils::rectToSphe(&amp;ra, &amp;dec, n);</td><td> </td><td class="right">       StelUtils::rectToSphe(&amp;ra, &amp;dec, n);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       QVariantList l;</td><td> </td><td class="right">       QVariantList l;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       l &lt;&lt; ra*180./M_PI &lt;&lt; dec*180./M_PI;</td><td> </td><td class="right">       l &lt;&lt; ra*180./M_PI &lt;&lt; dec*180./M_PI;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0011" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       res<span class="delete">.insert("pos", l)</span>;</td><td> </td><td class="rblock">       res<span class="insert"> &lt;&lt; l</span>;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       return res;</td><td> </td><td class="right">       return res;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">SphericalRegionP SphericalPoint::deserialize(QDataStream&amp; in)</td><td> </td><td class="right">SphericalRegionP SphericalPoint::deserialize(QDataStream&amp; in)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Vec3d nn;</td><td> </td><td class="right">       Vec3d nn;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       in &gt;&gt; nn;</td><td> </td><td class="right">       in &gt;&gt; nn;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       return SphericalRegionP(new SphericalPoint(nn));</td><td> </td><td class="right">       return SphericalRegionP(new SphericalPoint(nn));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">///////////////////////////////////////////////////////////////////////////
/</td><td> </td><td class="right">///////////////////////////////////////////////////////////////////////////
/</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// Methods for AllSkySphericalRegion</td><td> </td><td class="right">// Methods for AllSkySphericalRegion</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">///////////////////////////////////////////////////////////////////////////
/</td><td> </td><td class="right">///////////////////////////////////////////////////////////////////////////
/</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">const SphericalRegionP AllSkySphericalRegion::staticInstance = SphericalReg
ionP(new AllSkySphericalRegion());</td><td> </td><td class="right">const SphericalRegionP AllSkySphericalRegion::staticInstance = SphericalReg
ionP(new AllSkySphericalRegion());</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0012" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">QVariant<span class="delete">Map</span> AllSkySphericalRegion::toQVariant() const</td><td> </td><td class="rblock">QVariant<span class="insert">List</span> AllSkySphericalRegion::toQVariant() const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0013" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">QVariantMap</span> res;</td><td> </td><td class="rblock">       <span class="insert">QVariantList</span> res;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">res.insert("type", "ALLSKY");</span></td><td> </td><td class="rblock">       <span class="insert">res &lt;&lt; "ALLSKY";</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       return res;</td><td> </td><td class="right">       return res;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">///////////////////////////////////////////////////////////////////////////
/</td><td> </td><td class="right">///////////////////////////////////////////////////////////////////////////
/</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// Methods for EmptySphericalRegion</td><td> </td><td class="right">// Methods for EmptySphericalRegion</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">///////////////////////////////////////////////////////////////////////////
/</td><td> </td><td class="right">///////////////////////////////////////////////////////////////////////////
/</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">const SphericalRegionP EmptySphericalRegion::staticInstance = SphericalRegi
onP(new EmptySphericalRegion());</td><td> </td><td class="right">const SphericalRegionP EmptySphericalRegion::staticInstance = SphericalRegi
onP(new EmptySphericalRegion());</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0014" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">QVariant<span class="delete">Map</span> EmptySphericalRegion::toQVariant() const</td><td> </td><td class="rblock">QVariant<span class="insert">List</span> EmptySphericalRegion::toQVariant() const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0015" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">QVariantMap</span> res;</td><td> </td><td class="rblock">       <span class="insert">QVariantList</span> res;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">res.insert("type", "EMPTY");</span></td><td> </td><td class="rblock">       <span class="insert">res &lt;&lt; "EMPTY";</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       return res;</td><td> </td><td class="right">       return res;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">///////////////////////////////////////////////////////////////////////////
////</td><td> </td><td class="right">///////////////////////////////////////////////////////////////////////////
////</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// Methods for SphericalPolygon</td><td> </td><td class="right">// Methods for SphericalPolygon</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">///////////////////////////////////////////////////////////////////////////
////</td><td> </td><td class="right">///////////////////////////////////////////////////////////////////////////
////</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">SphericalCap SphericalPolygon::getBoundingCap() const</td><td> </td><td class="right">SphericalCap SphericalPolygon::getBoundingCap() const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       SphericalCap res;</td><td> </td><td class="right">       SphericalCap res;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       octahedronPolygon.getBoundingCap(res.n, res.d);</td><td> </td><td class="right">       octahedronPolygon.getBoundingCap(res.n, res.d);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       return res;</td><td> </td><td class="right">       return res;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0016" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">QVariantMap SphericalPolygon::toQVariant() const</span></td><td> </td><td class="rblock"><span class="insert">struct TriangleSerializer</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0017" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">QVariantMap res;</span></td><td> </td><td class="rblock">       <span class="insert">TriangleSerializer(const TriangleSerializer&amp; ts) : triangleList(ts.t</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//</span>     QVariantList <span class="delete">worldCoordinates;</span></td><td> </td><td class="rblock"><span class="insert">riangleList) {}</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//</span>     double ra, dec;</td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">Q_ASSERT(0);</span></td><td> </td><td class="rblock"><span class="insert">       TriangleSerializer() {}</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//     foreach (const QVector&lt;Vec3d&gt;&amp; contour, getFillVertexArray().vertex)</span></td><td> </td><td class="rblock"><span class="insert">       inline void operator()(const Vec3d* v1, const Vec3d* v2, const Vec3d</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//     {</span></td><td> </td><td class="rblock"><span class="insert">* v3,</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//</span>             QVariantList <span class="delete">cv;</span></td><td> </td><td class="rblock"><span class="insert">                                                  const Vec2f* , const Vec2</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//             foreach (const Vec3d&amp; v, contour)</span></td><td> </td><td class="rblock"><span class="insert">f* , const Vec2f* ,</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//             {</span></td><td> </td><td class="rblock"><span class="insert">                                                  unsigned int , unsigned i</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//</span>                     StelUtils::rectToSphe(&amp;ra, &amp;dec, <span class="delete">v);</span></td><td> </td><td class="rblock"><span class="insert">nt , unsigned int )</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//                     QVariantList vv;</span></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//                     vv</span> &lt;&lt; ra*180./M_PI &lt;&lt; dec*180./M_PI;</td><td> </td><td class="rblock">               QVariantList <span class="insert">triangle;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//                     cv.append((QVariant)vv);</span></td><td> </td><td class="rblock">               double ra, dec;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//             }</span></td><td> </td><td class="rblock">               QVariantList <span class="insert">l;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//             worldCoordinates.append((QVariant)cv);</span></td><td> </td><td class="rblock">               StelUtils::rectToSphe(&amp;ra, &amp;dec, <span class="insert">*v1);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//</span>     }</td><td> </td><td class="rblock"><span class="insert">               l</span> &lt;&lt; ra*180./M_PI &lt;&lt; dec*180./M_PI;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//     res.insert("worldCoords", worldCoordinates);</span></td><td> </td><td class="rblock">               <span class="insert">triangle &lt;&lt; QVariant(l);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       return <span class="delete">res;</span></td><td> </td><td class="rblock"><span class="insert">               l.clear();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               StelUtils::rectToSphe(&amp;ra, &amp;dec, *v2);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               l &lt;&lt; ra*180./M_PI &lt;&lt; dec*180./M_PI;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               triangle &lt;&lt; QVariant(l);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               l.clear();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               StelUtils::rectToSphe(&amp;ra, &amp;dec, *v3);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               l &lt;&lt; ra*180./M_PI &lt;&lt; dec*180./M_PI;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               triangle &lt;&lt; QVariant(l);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               Q_ASSERT(triangle.size()==3);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               triangleList &lt;&lt; QVariant(triangle);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">QVariantList triangleList;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">};</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">QVariantList SphericalPolygon::toQVariant() const</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">{</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       TriangleSerializer result = getFillVertexArray().foreachTriangle(Tri</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">angleSerializer());</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       return <span class="insert">result.triangleList;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void SphericalPolygon::serialize(QDataStream&amp; out) const</td><td> </td><td class="right">void SphericalPolygon::serialize(QDataStream&amp; out) const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       out &lt;&lt; octahedronPolygon;</td><td> </td><td class="right">       out &lt;&lt; octahedronPolygon;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">SphericalRegionP SphericalPolygon::deserialize(QDataStream&amp; in)</td><td> </td><td class="right">SphericalRegionP SphericalPolygon::deserialize(QDataStream&amp; in)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       OctahedronPolygon p;</td><td> </td><td class="right">       OctahedronPolygon p;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       in &gt;&gt; p;</td><td> </td><td class="right">       in &gt;&gt; p;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       return SphericalRegionP(new SphericalPolygon(p));</td><td> </td><td class="right">       return SphericalRegionP(new SphericalPolygon(p));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">bool SphericalPolygon::contains(const SphericalConvexPolygon&amp; r) const {ret
urn octahedronPolygon.contains(r.getOctahedronPolygon());}</td><td> </td><td class="right">bool SphericalPolygon::contains(const SphericalConvexPolygon&amp; r) const {ret
urn octahedronPolygon.contains(r.getOctahedronPolygon());}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">bool SphericalPolygon::intersects(const SphericalConvexPolygon&amp; r) const {r
eturn r.intersects(*this);}</td><td> </td><td class="right">bool SphericalPolygon::intersects(const SphericalConvexPolygon&amp; r) const {r
eturn r.intersects(*this);}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0018" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">SphericalRegionP SphericalPolygon::multiUnion(const QList&lt;SphericalRegionP&gt;
&amp; regions)</td><td> </td><td class="rblock">SphericalRegionP SphericalPolygon::multiUnion(const QList&lt;SphericalRegionP&gt;
&amp; regions<span class="insert">, bool optimizeByPreGrouping</span>)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0019" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       QList&lt;OctahedronPolygon&gt; l;</td><td> </td><td class="rblock">       <span class="insert">if (regions.size()==1)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       foreach (const SphericalRegionP&amp; r, regions)</td><td> </td><td class="rblock"><span class="insert">               return regions.at(0);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               l.append(r-&gt;getOctahedronPolygon());</td><td> </td><td class="rblock"><span class="insert">       if (optimizeByPreGrouping)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       return SphericalRegionP(new SphericalPolygon(l));</td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               static const double minOverlap = 0.2;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               // Try to first split the set of regions into groups of inte</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">rsecting regions</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               QList&lt;QList&lt;SphericalRegionP&gt; &gt; res;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               QList&lt;SphericalCap&gt; groupReferenceCap;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               foreach (const SphericalRegionP&amp; newReg, regions)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       bool createNewGroup = true;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       const SphericalCap&amp; newRegBoundingCap = newReg-&gt;getB</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">oundingCap();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       for (int i=0;i&lt;res.size();++i)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               // Make sure not to group full sky regions b</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ecause it is usually not what we want.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               if (SphericalCap::relativeDiameterOverlap(ne</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">wRegBoundingCap, groupReferenceCap.at(i))&gt;minOverlap &amp;&amp; newRegBoundingCap.d</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">&gt;-0.9)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                       // It intersects with the reference </span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">element of the group</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                       res[i].append(newReg);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                       createNewGroup = false;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                       break;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       if (createNewGroup)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               QList&lt;SphericalRegionP&gt; newGroup;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               newGroup.append(newReg);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               res.append(newGroup);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               // The reference element of the group is def</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ined as the first element</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               groupReferenceCap.append(newRegBoundingCap);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               // res now contains n list of regions to union together</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               QList&lt;SphericalRegionP&gt; mappedRegions;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               foreach (const QList&lt;SphericalRegionP&gt;&amp; l, res)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       mappedRegions.append(SphericalPolygon::multiUnion(l)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               return SphericalPolygon::multiUnion(mappedRegions);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       else</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               // Just add all contours to one polygon</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">               QList&lt;OctahedronPolygon&gt; l;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">               foreach (const SphericalRegionP&amp; r, regions)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                       l.append(r-&gt;getOctahedronPolygon());</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">               return SphericalRegionP(new SphericalPolygon(l));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">}</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">}</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">SphericalRegionP SphericalPolygon::multiIntersection(const QList&lt;SphericalR</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">egionP&gt;&amp; regions)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">{</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       if (regions.isEmpty())</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               return EmptySphericalRegion::staticInstance;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       SphericalRegionP reg = regions.at(0);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       for (int i=1;i&lt;regions.size();++i)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               reg = reg-&gt;getIntersection(regions.at(i));</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       return reg;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">///////////////////////////////////////////////////////////////////////////
////</td><td> </td><td class="right">///////////////////////////////////////////////////////////////////////////
////</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// Methods for SphericalTexturedPolygon</td><td> </td><td class="right">// Methods for SphericalTexturedPolygon</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">///////////////////////////////////////////////////////////////////////////
////</td><td> </td><td class="right">///////////////////////////////////////////////////////////////////////////
////</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">///////////////////////////////////////////////////////////////////////////
////</td><td> </td><td class="right">///////////////////////////////////////////////////////////////////////////
////</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// Methods for SphericalConvexPolygon</td><td> </td><td class="right">// Methods for SphericalConvexPolygon</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">///////////////////////////////////////////////////////////////////////////
////</td><td> </td><td class="right">///////////////////////////////////////////////////////////////////////////
////</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l5" /><small>skipping to change at</small><em> line 932</em></th><th> </th><th><a name="part-r5" /><small>skipping to change at</small><em> line 1007</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               if (cachedBoundingCap.n*v&lt;cachedBoundingCap.d)</td><td> </td><td class="right">               if (cachedBoundingCap.n*v&lt;cachedBoundingCap.d)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       cachedBoundingCap.d = cachedBoundingCap.n*v;</td><td> </td><td class="right">                       cachedBoundingCap.d = cachedBoundingCap.n*v;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       cachedBoundingCap.d*=cachedBoundingCap.d&gt;0 ? 0.9999999 : 1.0000001;</td><td> </td><td class="right">       cachedBoundingCap.d*=cachedBoundingCap.d&gt;0 ? 0.9999999 : 1.0000001;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#ifndef NDEBUG</td><td> </td><td class="right">#ifndef NDEBUG</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       foreach (const Vec3d&amp; v, contour)</td><td> </td><td class="right">       foreach (const Vec3d&amp; v, contour)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               Q_ASSERT(cachedBoundingCap.contains(v));</td><td> </td><td class="right">               Q_ASSERT(cachedBoundingCap.contains(v));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#endif</td><td> </td><td class="right">#endif</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0020" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">QVariant<span class="delete">Map</span> SphericalConvexPolygon::toQVariant() const</td><td> </td><td class="rblock">QVariant<span class="insert">List</span> SphericalConvexPolygon::toQVariant() const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0021" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">QVariantMap</span> res;</td><td> </td><td class="rblock">       <span class="insert">QVariantList</span> res;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">res.insert("type", "CVXPOLYGON");</span></td><td> </td><td class="rblock">       <span class="insert">res &lt;&lt; "CONVEX_POLYGON";</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       QVariantList cv;</td><td> </td><td class="right">       QVariantList cv;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       double ra, dec;</td><td> </td><td class="right">       double ra, dec;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       foreach (const Vec3d&amp; v, contour)</td><td> </td><td class="right">       foreach (const Vec3d&amp; v, contour)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               StelUtils::rectToSphe(&amp;ra, &amp;dec, v);</td><td> </td><td class="right">               StelUtils::rectToSphe(&amp;ra, &amp;dec, v);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               QVariantList vv;</td><td> </td><td class="right">               QVariantList vv;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               vv &lt;&lt; ra*180./M_PI &lt;&lt; dec*180./M_PI;</td><td> </td><td class="right">               vv &lt;&lt; ra*180./M_PI &lt;&lt; dec*180./M_PI;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               cv.append((QVariant)vv);</td><td> </td><td class="right">               cv.append((QVariant)vv);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0022" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       res<span class="delete">.insert("worldCoords", cv)</span>;</td><td> </td><td class="rblock">       res<span class="insert"> &lt;&lt; cv</span>;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       return res;</td><td> </td><td class="right">       return res;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">SphericalRegionP SphericalConvexPolygon::deserialize(QDataStream&amp; in)</td><td> </td><td class="right">SphericalRegionP SphericalConvexPolygon::deserialize(QDataStream&amp; in)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       QVector&lt;Vec3d&gt; contour;</td><td> </td><td class="right">       QVector&lt;Vec3d&gt; contour;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       in &gt;&gt; contour;</td><td> </td><td class="right">       in &gt;&gt; contour;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       return SphericalRegionP(new SphericalConvexPolygon(contour));</td><td> </td><td class="right">       return SphericalRegionP(new SphericalConvexPolygon(contour));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">///////////////////////////////////////////////////////////////////////////
////</td><td> </td><td class="right">///////////////////////////////////////////////////////////////////////////
////</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// Methods for SphericalTexturedConvexPolygon</td><td> </td><td class="right">// Methods for SphericalTexturedConvexPolygon</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">///////////////////////////////////////////////////////////////////////////
////</td><td> </td><td class="right">///////////////////////////////////////////////////////////////////////////
////</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0023" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">QVariant<span class="delete">Map</span> SphericalTexturedConvexPolygon::toQVariant() const</td><td> </td><td class="rblock">QVariant<span class="insert">List</span> SphericalTexturedConvexPolygon::toQVariant() const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0024" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       QVariant<span class="delete">Map</span> res = SphericalConvexPolygon::toQVariant();</td><td> </td><td class="rblock">       QVariant<span class="insert">List</span> res = SphericalConvexPolygon::toQVariant();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       QVariantList cv;</td><td> </td><td class="right">       QVariantList cv;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       foreach (const Vec2f&amp; v, textureCoords)</td><td> </td><td class="right">       foreach (const Vec2f&amp; v, textureCoords)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               QVariantList vv;</td><td> </td><td class="right">               QVariantList vv;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               vv &lt;&lt; v[0] &lt;&lt; v[1];</td><td> </td><td class="right">               vv &lt;&lt; v[0] &lt;&lt; v[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               cv.append((QVariant)vv);</td><td> </td><td class="right">               cv.append((QVariant)vv);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0025" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       res<span class="delete">.insert("textureCoords", cv)</span>;</td><td> </td><td class="rblock">       res<span class="insert"> &lt;&lt; cv</span>;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       return res;</td><td> </td><td class="right">       return res;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">///////////////////////////////////////////////////////////////////////////
////</td><td> </td><td class="right">///////////////////////////////////////////////////////////////////////////
////</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// Methods for SphericalTexturedPolygon</td><td> </td><td class="right">// Methods for SphericalTexturedPolygon</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">///////////////////////////////////////////////////////////////////////////
////</td><td> </td><td class="right">///////////////////////////////////////////////////////////////////////////
////</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0026" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">QVariant<span class="delete">Map</span> SphericalTexturedPolygon::toQVariant() const</td><td> </td><td class="rblock">QVariant<span class="insert">List</span> SphericalTexturedPolygon::toQVariant() const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Q_ASSERT(0);</td><td> </td><td class="right">       Q_ASSERT(0);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // TODO store a tesselated polygon?, including edge flags?</td><td> </td><td class="right">       // TODO store a tesselated polygon?, including edge flags?</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0027" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       return QVariant<span class="delete">Map</span>();</td><td> </td><td class="rblock">       return QVariant<span class="insert">List</span>();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">///////////////////////////////////////////////////////////////////////////
////</td><td> </td><td class="right">///////////////////////////////////////////////////////////////////////////
////</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// Utility methods</td><td> </td><td class="right">// Utility methods</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">///////////////////////////////////////////////////////////////////////////
////</td><td> </td><td class="right">///////////////////////////////////////////////////////////////////////////
////</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">Vec3d greatCircleIntersection(const Vec3d&amp; p1, const Vec3d&amp; p2, const Vec3d
&amp; p3, const Vec3d&amp; p4, bool&amp; ok)</td><td> </td><td class="right">Vec3d greatCircleIntersection(const Vec3d&amp; p1, const Vec3d&amp; p2, const Vec3d
&amp; p3, const Vec3d&amp; p4, bool&amp; ok)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (p3*p4&gt;1.-1E-10)</td><td> </td><td class="right">       if (p3*p4&gt;1.-1E-10)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l6" /><small>skipping to change at</small><em> line 1060</em></th><th> </th><th><a name="part-r6" /><small>skipping to change at</small><em> line 1135</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const QVariantList&amp; vl = vRaDec.toList();</td><td> </td><td class="right">       const QVariantList&amp; vl = vRaDec.toList();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       bool ok;</td><td> </td><td class="right">       bool ok;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (vl.size()!=2)</td><td> </td><td class="right">       if (vl.size()!=2)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               throw std::runtime_error(qPrintable(QString("invalid Ra,Dec 
pair: \"%1\" (expect 2 double values in degree, got %2)").arg(vRaDec.toStri
ng()).arg(vl.size())));</td><td> </td><td class="right">               throw std::runtime_error(qPrintable(QString("invalid Ra,Dec 
pair: \"%1\" (expect 2 double values in degree, got %2)").arg(vRaDec.toStri
ng()).arg(vl.size())));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       StelUtils::spheToRect(vl.at(0).toDouble(&amp;ok)*M_PI/180., vl.at(1).toD
ouble(&amp;ok)*M_PI/180., v);</td><td> </td><td class="right">       StelUtils::spheToRect(vl.at(0).toDouble(&amp;ok)*M_PI/180., vl.at(1).toD
ouble(&amp;ok)*M_PI/180., v);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (!ok)</td><td> </td><td class="right">       if (!ok)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               throw std::runtime_error(qPrintable(QString("invalid Ra,Dec 
pair: \"%1\" (expect 2 double values in degree)").arg(vRaDec.toString())));</td><td> </td><td class="right">               throw std::runtime_error(qPrintable(QString("invalid Ra,Dec 
pair: \"%1\" (expect 2 double values in degree)").arg(vRaDec.toString())));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0028" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">QVector&lt;QVector&lt;Vec3d&gt; &gt; SphericalRegionP::loadContourFromQVariant(const QV
ariantList&amp; contoursList)</span></td><td> </td><td class="rblock"><span class="insert">struct TriangleDumper</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0029" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">QVector&lt;QVector&lt;Vec3d&gt; &gt; contours;</span></td><td> </td><td class="rblock">       <span class="insert">TriangleDumper(const TriangleDumper&amp; ts) : triangleList(ts.triangleL</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       QVector&lt;Vec3d&gt; vertices;</span></td><td> </td><td class="rblock"><span class="insert">ist) {}</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       bool ok;</span></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       for (int i=0;i&lt;contoursList.size();++i)</span></td><td> </td><td class="rblock"><span class="insert">       TriangleDumper() {}</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       inline void operator()(const Vec3d* v1, const Vec3d* v2, const Vec3d</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">* v3,</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                                  const Vec2f* , const Vec2</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">f* , const Vec2f* ,</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                                  unsigned int , unsigned i</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">nt , unsigned int )</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0030" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               const QVariantList&amp; <span class="delete">contourToList</span> = <span class="delete">contoursList.at(i).toLis</span></td><td> </td><td class="rblock">               <span class="insert">QVector&lt;Vec3d&gt; triangle;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">t();</span></td><td> </td><td class="rblock"><span class="insert">               triangle &lt;&lt; *v1 &lt;&lt; *v2 &lt;&lt; *v3;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               if <span class="delete">(contourToList.size()&lt;1)</span></td><td> </td><td class="rblock"><span class="insert">               triangleList.append(triangle);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       throw std::runtime_error(qPrintable(QString("invalid</td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"> <span class="delete">contour definition: %1").arg(contoursList.at(i).toString())));</span></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               if <span class="delete">(contourToList.at(0).toString()=="CAP")</span></td><td> </td><td class="rblock"><span class="insert">       QVector&lt;QVector&lt;Vec3d &gt; &gt; triangleList;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">};</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">QVector&lt;QVector&lt;Vec3d &gt; &gt; SphericalRegion::getSimplifiedContours() const</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">{</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       TriangleDumper result = getFillVertexArray().foreachTriangle(Triangl</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">eDumper());</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       return result.triangleList;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">}</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">SphericalRegionP capFromQVariantList(const QVariantList&amp; l)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">{</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       Q_ASSERT(l.at(0).toString()=="CAP");</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       // We now parse a cap, the format is "CAP",[ra, dec],aperture</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       if (l.size()!=3)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               throw std::runtime_error(qPrintable(QString("invalid CAP des</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">cription: %1 (expect \"CAP\",[ra, dec],aperture)").arg(QString::fromUtf8(St</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">elJsonParser::write(l)))));</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       Vec3d v;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       parseRaDec(l.at(1), v);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       bool ok;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       double d = l.at(2).toDouble(&amp;ok)*M_PI/180.;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       if (!ok)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               throw std::runtime_error(qPrintable(QString("invalid apertur</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">e angle: \"%1\" (expect a double value in degree)").arg(l.at(2).toString())</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">));</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       return SphericalRegionP(new SphericalCap(v,std::cos(d)));</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">}</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">QVector&lt;Vec3d&gt; pathFromQVariantList(const QVariantList&amp; l)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">{</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       Q_ASSERT(l.at(0).toString()=="PATH");</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       // We now parse a path single contour, the format is:</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       // "PATH",[ra, dec],["greatCircleTo", [ra, dec]], ["smallCircle", [r</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">aAxis, decAxis], angle], [etc..]</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       QVector&lt;Vec3d&gt; vertices;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       Vec3d v;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       parseRaDec(l.at(1), v);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       vertices.append(v);     // Starting point</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       for (int k=2;k&lt;l.size();++k)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">               const QVariantList&amp; <span class="insert">elemList</span> = <span class="insert">l.at(k).toList();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">               if <span class="insert">(elemList.size()&lt;1)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                       throw std::runtime_error(qPrintable(QString("invalid</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">PATH description: \"%1\" (expect a list of greatCircleTo or smallCircle").</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">arg(l.at(2).toString())));</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">               if <span class="insert">(elemList.at(0)=="greatCircleTo")</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0031" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       <span class="delete">// We now parse a cap, the format is "CAP",[ra, dec]</span></td><td> </td><td class="rblock">                       <span class="insert">parseRaDec(elemList.at(1),</span> v);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">,aperture</span></td><td> </td><td class="rblock">                       <span class="insert">vertices.append(v);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       if (contourToList.size()!=3)</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                               throw std::runtime_error(qPrintable(QString(</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">"invalid CAP description: %1 (expect \"CAP\",[ra, dec],aperture)").arg(cont</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">oursList.at(i).toString())));</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       Vec3d v;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       parseRaDec(contourToList.at(1),</span> v);</td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       <span class="delete">double d = contourToList.at(2).toDouble(&amp;ok)*M_PI/18</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">0.;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       if (!ok)</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                               throw std::runtime_error(qPrintable(QString(</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">"invalid aperture angle: \"%1\" (expect a double value in degree)").arg(con</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">tourToList.at(2).toString())));</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       SphericalCap cap(v,std::cos(d));</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       contours.append(cap.getClosedOutlineContour());</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       continue;</td><td> </td><td class="right">                       continue;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0032" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               if (<span class="delete">contourToList.at(0).toString()=="PATH</span>")</td><td> </td><td class="rblock">               if (<span class="insert">elemList.at(0)=="smallCircle</span>")</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0033" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       // <span class="delete">We now parse</span> a <span class="delete">path,</span> the <span class="delete">format is</span></td><td> </td><td class="rblock">                       <span class="insert">Vec3d axis;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       // <span class="delete">"PATH",[ra, dec],[["greatCircleTo", [ra, dec]], [</span></td><td> </td><td class="rblock"><span class="insert">                       parseRaDec(elemList.at(1), axis);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">"smallCircle", [raAxis, decAxis], angle], [etc..]]</span></td><td> </td><td class="rblock"><span class="insert">                       bool ok;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       Q_ASSERT(vertices.isEmpty());</span></td><td> </td><td class="rblock"><span class="insert">                       double angle = elemList.at(2).toDouble(&amp;ok)*M_PI/180</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">.;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       if (!ok || std::fabs(angle)&gt;2.*M_PI)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               throw std::runtime_error(qPrintable(QString(</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">"invalid small circle rotation angle: \"%1\" (expect a double value in degr</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ee betwwen -2pi and 2pi)").arg(elemList.at(2).toString())));</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       int nbStep = 1+(int)(std::fabs(angle)/(2.*M_PI)*75);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       Q_ASSERT(nbStep&gt;0);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       v = vertices.last();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       const Mat4d&amp; rotMat = Mat4d::rotation(axis, angle/nb</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">Step);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       for (int step=0; step&lt;nbStep;++step)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               v.transfo4d(rotMat);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               vertices.append(v);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       continue;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               throw std::runtime_error(qPrintable(QString("invalid PATH de</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">scription: \"%1\" (expect a list of greatCircleTo or smallCircle").arg(l.at</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">(2).toString())));</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       Q_ASSERT(vertices.size()&gt;2);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       return vertices;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">}</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">QVector&lt;Vec3d&gt; singleContourFromQVariantList(const QVariantList&amp; l)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">{</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       if (l.size()&lt;3)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               throw std::runtime_error("a polygon contour must have at lea</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">st 3 vertices");</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       QVector&lt;Vec3d&gt; vertices;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       Vec3d v;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       foreach (const QVariant&amp; vRaDec, l)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               parseRaDec(vRaDec, v);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               vertices.append(v);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       Q_ASSERT(vertices.size()&gt;2);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       return vertices;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">}</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">SphericalRegionP SphericalRegionP::loadFromQVariant(const QVariantList&amp; l)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">{</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       if (l.isEmpty())</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               return EmptySphericalRegion::staticInstance;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       if (l.at(0).type()==QVariant::List)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               // The region is composed of either:</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">               // <span class="insert">-</span> a <span class="insert">list of regions, which are assumed to be combined usi</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ng</span> the <span class="insert">positive winding rule.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">               // <span class="insert">- or a single contour</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               QVector&lt;QVector&lt;Vec3d&gt; &gt; contours;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               try {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       Vec3d v;</td><td> </td><td class="right">                       Vec3d v;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0034" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       <span class="delete">parseRaDec(contourToList.at(1),</span> v);</td><td> </td><td class="rblock">                       <span class="insert">parseRaDec(l.at(0),</span> v);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       <span class="delete">vertices.append(v);</span>     // <span class="delete">Starting point</span></td><td> </td><td class="rblock">                       // <span class="insert">No exception was thrown, we are parsing a single </span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       foreach (const QVariant&amp; elem, contourToList.at(2).t</span></td><td> </td><td class="rblock"><span class="insert">contour</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">oList())</span></td><td> </td><td class="rblock"><span class="insert">                       contours.append(singleContourFromQVariantList(l));</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               catch (std::runtime_error&amp;)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       // We are parsing a list of regions.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       for (int i=0;i&lt;l.size();++i)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       {</td><td> </td><td class="right">                       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0035" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                               const QVariantList&amp; <span class="delete">elemList</span> = <span class="delete">elem.toList()</span></td><td> </td><td class="rblock">                               const QVariantList&amp; <span class="insert">subL</span> = <span class="insert">l.at(i).toList();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">;</span></td><td> </td><td class="rblock">                               if <span class="insert">(subL.isEmpty())</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                               if <span class="delete">(elemList.size()&lt;1)</span></td><td> </td><td class="rblock">                                       throw std::runtime_error(qPrintable(</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                       throw std::runtime_error(qPrintable(</td><td> </td><td class="rblock">QString("invalid <span class="insert">region definition: %1").arg(l.at(i).toString())));</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">QString("invalid <span class="delete">PATH description: \"%1\" (expect a list of greatCircleTo o</span></td><td> </td><td class="rblock">                               if <span class="insert">(subL.at(0).type()==QVariant::List)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">r smallCircle").arg(contourToList.at(2).toString())));</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                               if <span class="delete">(elemList.at(0)=="greatCircleTo")</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               {</td><td> </td><td class="right">                               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0036" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                       <span class="delete">parseRaDec(elemList.at(1), v);</span></td><td> </td><td class="rblock">                                       <span class="insert">// Special optimization for basic co</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                                       vertices.append(v);</span></td><td> </td><td class="rblock"><span class="insert">ntours (if no type is provided, assume a polygon)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                       contours.append(singleContourFromQVa</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">riantList(subL));</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                                       continue;</td><td> </td><td class="right">                                       continue;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               }</td><td> </td><td class="right">                               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0037" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                               <span class="delete">if (elemList.at(0)=="smallCircle")</span></td><td> </td><td class="rblock">                               <span class="insert">Q_ASSERT(subL.at(0).type()==QVariant::String</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                               {</span></td><td> </td><td class="rblock"> || <span class="insert">subL.at(0).type()==QVariant::ByteArray);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                                       Vec3d axis;</span></td><td> </td><td class="rblock">                               const <span class="insert">SphericalRegionP&amp; reg</span> = <span class="insert">loadFromQVaria</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                                       parseRaDec(elemList.at(1), axis);</span></td><td> </td><td class="rblock"><span class="insert">nt(subL);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                                       double angle = elemList.at(2).toDoub</span></td><td> </td><td class="rblock"><span class="insert">                               if (!reg-&gt;isEmpty())</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">le(&amp;ok)*M_PI/180.;</span></td><td> </td><td class="rblock"><span class="insert">                                       contours &lt;&lt; reg-&gt;getSimplifiedContou</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                                       if (!ok</span> || <span class="delete">std::fabs(angle)&gt;2.*M_PI)</span></td><td> </td><td class="rblock"><span class="insert">rs();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                                               throw std::runtime_error(qPr</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">intable(QString("invalid small circle rotation angle: \"%1\" (expect a doub</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">le value in degree betwwen -2pi and 2pi)").arg(elemList.at(2).toString())))</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                                       int nbStep = 1+(int)(std::fabs(angle</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">)/(2.*M_PI)*50);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                                       Q_ASSERT(nbStep&gt;0);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                                       v = vertices.last();</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                       const <span class="delete">Mat4d&amp; rotMat</span> = <span class="delete">Mat4d::rotatio</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">n(axis, angle/nbStep);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                                       for (int step=0; step&lt;nbStep;++step)</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                                       {</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                                               v.transfo4d(rotMat);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                                               vertices.append(v);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                                       }</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                                       continue;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                               }</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                               throw std::runtime_error(qPrintable(QString(</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">"invalid PATH description: \"%1\" (expect a list of greatCircleTo or smallC</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">ircle").arg(contourToList.at(2).toString())));</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       }</td><td> </td><td class="right">                       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0038" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       <span class="delete">Q_ASSERT(vertices.size()&gt;2);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       contours.append(vertices);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       vertices.clear();</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       continue;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0039" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               <span class="delete">// If no type is provided, assume a polygon</span></td><td> </td><td class="rblock">               <span class="insert">return SphericalRegionP(new SphericalPolygon(contours));</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               if <span class="delete">(contourToList.size()&lt;3)</span></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       throw std::runtime_error("a polygon contour must hav</span></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">e at least 3 vertices");</span></td><td> </td><td class="rblock"><span class="insert">       Q_ASSERT(l.at(0).type()==QVariant::String || l.at(0).type()==QVarian</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               Q_ASSERT(vertices.isEmpty());</span></td><td> </td><td class="rblock"><span class="insert">t::ByteArray);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               Vec3d v;</span></td><td> </td><td class="rblock"><span class="insert">       const QString&amp; code=l.at(0).toString();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               foreach (const QVariant&amp; vRaDec, contourToList)</span></td><td> </td><td class="rblock">       if <span class="insert">(code=="CAP")</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               return capFromQVariantList(l);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       else if (code=="INTERSECTION")</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               Q_ASSERT(l.size()&gt;2);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               SphericalRegionP reg1 = loadFromQVariant(l.at(1).toList());</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               for (int n=2;n&lt;l.size();++n)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0040" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       <span class="delete">parseRaDec(vRaDec, v);</span></td><td> </td><td class="rblock">                       <span class="insert">SphericalRegionP reg2 = loadFromQVariant(l.at(n).toL</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       vertices.append(v);</span></td><td> </td><td class="rblock"><span class="insert">ist());</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       reg1 = reg1-&gt;getIntersection(reg2.data());</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0041" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               <span class="delete">Q_ASSERT(vertices.size()&gt;2);</span></td><td> </td><td class="rblock">               <span class="insert">return reg1;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               contours.append(vertices);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               vertices.clear();</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0042" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       return <span class="delete">contours;</span></td><td> </td><td class="rblock">       <span class="insert">else if (code=="SUBTRACTION")</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">}</td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                                                           </td><td> </td><td class="rblock"><span class="insert">               Q_ASSERT(l.size()==3);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">SphericalRegionP SphericalRegionP::loadFromQVariant(const QVariantList&amp; con</span></td><td> </td><td class="rblock"><span class="insert">               SphericalRegionP reg1 = loadFromQVariant(l.at(1).toList());</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">toursList)</span></td><td> </td><td class="rblock"><span class="insert">               SphericalRegionP reg2 = loadFromQVariant(l.at(2).toList());</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">{</td><td> </td><td class="rblock"><span class="insert">               SphericalRegionP regIntersection = reg1-&gt;getIntersection(reg</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">// It can only be a pure shape definition, without texture coords</span></td><td> </td><td class="rblock"><span class="insert">2.data());</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       const QVector&lt;QVector&lt;Vec3d&gt; &gt;&amp; contours = loadContourFromQVariant(c</span></td><td> </td><td class="rblock"><span class="insert">               reg1 = reg1-&gt;getSubtraction(regIntersection.data());</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">ontoursList);</span></td><td> </td><td class="rblock">               return <span class="insert">reg1;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       return SphericalRegionP(new <span class="delete">SphericalPolygon(contours));</span></td><td> </td><td class="rblock">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">else if (code=="PATH")</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">               return SphericalRegionP(new <span class="insert">SphericalPolygon(pathFromQVarian</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">tList(l)));</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       Q_ASSERT(0);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       return EmptySphericalRegion::staticInstance;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">SphericalRegionP SphericalRegionP::loadFromQVariant(const QVariantMap&amp; map)</td><td> </td><td class="right">SphericalRegionP SphericalRegionP::loadFromQVariant(const QVariantMap&amp; map)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       QVariantList contoursList = map.value("skyConvexPolygons").toList();</td><td> </td><td class="right">       QVariantList contoursList = map.value("skyConvexPolygons").toList();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (contoursList.empty())</td><td> </td><td class="right">       if (contoursList.empty())</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               contoursList = map.value("worldCoords").toList();</td><td> </td><td class="right">               contoursList = map.value("worldCoords").toList();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       else</td><td> </td><td class="right">       else</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               qWarning() &lt;&lt; "skyConvexPolygons in preview JSON files is de
precated. Replace with worldCoords.";</td><td> </td><td class="right">               qWarning() &lt;&lt; "skyConvexPolygons in preview JSON files is de
precated. Replace with worldCoords.";</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l7" /><small>skipping to change at</small><em> line 1172</em></th><th> </th><th><a name="part-r7" /><small>skipping to change at</small><em> line 1324</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Load the matching textures positions (if any)</td><td> </td><td class="right">       // Load the matching textures positions (if any)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       QVariantList texCoordList = map.value("textureCoords").toList();</td><td> </td><td class="right">       QVariantList texCoordList = map.value("textureCoords").toList();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (!texCoordList.isEmpty() &amp;&amp; contoursList.size()!=texCoordList.siz
e())</td><td> </td><td class="right">       if (!texCoordList.isEmpty() &amp;&amp; contoursList.size()!=texCoordList.siz
e())</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               throw std::runtime_error(qPrintable(QString("the number of s
ky contours (%1) does not match the number of texture space contours (%2)")
.arg( contoursList.size()).arg(texCoordList.size())));</td><td> </td><td class="right">               throw std::runtime_error(qPrintable(QString("the number of s
ky contours (%1) does not match the number of texture space contours (%2)")
.arg( contoursList.size()).arg(texCoordList.size())));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       bool ok;</td><td> </td><td class="right">       bool ok;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (texCoordList.isEmpty())</td><td> </td><td class="right">       if (texCoordList.isEmpty())</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               // No texture coordinates</td><td> </td><td class="right">               // No texture coordinates</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0043" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               <span class="delete">const QVector&lt;QVector&lt;Vec3d&gt; &gt;&amp; contours = loadContourFromQV</span></td><td> </td><td class="rblock">               return <span class="insert">loadFromQVariant(contoursList);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">ariant(contoursList);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               return <span class="delete">SphericalRegionP(new SphericalPolygon(contours));</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       else</td><td> </td><td class="right">       else</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               // With texture coordinates</td><td> </td><td class="right">               // With texture coordinates</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               QVector&lt;QVector&lt;SphericalTexturedPolygon::TextureVertex&gt; &gt; c
ontours;</td><td> </td><td class="right">               QVector&lt;QVector&lt;SphericalTexturedPolygon::TextureVertex&gt; &gt; c
ontours;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               QVector&lt;SphericalTexturedPolygon::TextureVertex&gt; vertices;</td><td> </td><td class="right">               QVector&lt;SphericalTexturedPolygon::TextureVertex&gt; vertices;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               for (int i=0;i&lt;contoursList.size();++i)</td><td> </td><td class="right">               for (int i=0;i&lt;contoursList.size();++i)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       // Load vertices</td><td> </td><td class="right">                       // Load vertices</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       const QVariantList&amp; polyRaDecToList = contoursList.a
t(i).toList();</td><td> </td><td class="right">                       const QVariantList&amp; polyRaDecToList = contoursList.a
t(i).toList();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l8" /><small>skipping to change at</small><em> line 1215</em></th><th> </th><th><a name="part-r8" /><small>skipping to change at</small><em> line 1366</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                                       throw std::runtime_error("invalid te
xture coordinate pair (expect 2 double values in degree)");</td><td> </td><td class="right">                                       throw std::runtime_error("invalid te
xture coordinate pair (expect 2 double values in degree)");</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       }</td><td> </td><td class="right">                       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       contours.append(vertices);</td><td> </td><td class="right">                       contours.append(vertices);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       vertices.clear();</td><td> </td><td class="right">                       vertices.clear();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return SphericalRegionP(new SphericalTexturedPolygon(contour
s));</td><td> </td><td class="right">               return SphericalRegionP(new SphericalTexturedPolygon(contour
s));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Q_ASSERT(0);</td><td> </td><td class="right">       Q_ASSERT(0);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       return SphericalRegionP(new SphericalCap());</td><td> </td><td class="right">       return SphericalRegionP(new SphericalCap());</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0044" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">void SphericalRegionP::serializeToJson(const QVariant&amp; jsonObject, QIODevic</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">e* output, int indentLevel)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">{</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       const SphericalRegionP&amp; reg = jsonObject.value&lt;SphericalRegionP&gt;();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       StelJsonParser::write(reg-&gt;toQVariant(), output, indentLevel);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">}</span></td><td class="lineno" valign="top"></td></tr>

     <tr><td></td><td class="left"></td><td> </td><td class="right"></td><td></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 44 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><td></td><th><i>154 lines changed or deleted</i></th><th><i> </i></th><th><i>325 lines changed or added</i></th><td></td></tr>
     <tr><td colspan="5" align="center" class="small"><br/>This html diff was produced by rfcdiff 1.41. The latest version is available from <a href="http://www.tools.ietf.org/tools/rfcdiff/" >http://tools.ietf.org/tools/rfcdiff/</a> </td></tr>
   </table>
   </body>
   </html>
