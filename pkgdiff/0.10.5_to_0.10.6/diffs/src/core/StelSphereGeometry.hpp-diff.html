<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"> 
<!-- Generated by rfcdiff 1.41: rfcdiff  --> 
<!-- <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional" > -->
<!-- System: Linux fomalhaut.local 3.13.0-38-generic #65-Ubuntu SMP Thu Oct 9 11:36:50 UTC 2014 x86_64 x86_64 x86_64 GNU/Linux --> 
<!-- Using awk: /usr/bin/gawk: GNU Awk 4.0.1 --> 
<!-- Using diff: /usr/bin/diff: diff (GNU diffutils) 3.3 --> 
<!-- Using wdiff: /usr/bin/wdiff: wdiff (GNU wdiff) 1.2.1 --> 
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"> 
<head> 
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /> 
  <meta http-equiv="Content-Style-Type" content="text/css" /> 
  <title>Diff: StelSphereGeometry.hpp - StelSphereGeometry.hpp</title> 
  <style type="text/css"> 
    body    { font-size:16px; margin: 0.4ex; margin-right: auto; } 
    tr      { } 
    td      { white-space: pre; font-family: Consolas, "DejaVu Sans Mono", "Droid Sans Mono", Monaco, Monospace; vertical-align: top; font-size: 0.86em;} 
    th      { font-size: 0.86em; } 
    .small  { font-size: 0.6em; font-style: italic; font-family: Verdana, Helvetica, sans-serif; } 
    .left   { background-color: #EEE; } 
    .right  { background-color: #FFF; } 
    .diff   { background-color: #CCF; } 
    .lblock { background-color: #BFB; } 
    .rblock { background-color: #FF8; } 
    .insert { background-color: #8FF; } 
    .delete { background-color: #ACF; } 
    .void   { background-color: #FFB; } 
    .cont   { background-color: #EEE; } 
    .linebr { background-color: #AAA; } 
    .lineno { color: red; background-color: #FFF; font-size: 0.7em; text-align: right; padding: 0 2px; } 
    .elipsis{ background-color: #AAA; } 
    .left .cont { background-color: #DDD; } 
    .right .cont { background-color: #EEE; } 
    .lblock .cont { background-color: #9D9; } 
    .rblock .cont { background-color: #DD6; } 
    .insert .cont { background-color: #0DD; } 
    .delete .cont { background-color: #8AD; } 
    .stats, .stats td, .stats th { background-color: #EEE; padding: 2px 0; } 
  </style> 
</head> 
<body > 
  <table border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th></th><th>&nbsp;StelSphereGeometry.hpp&nbsp;</th><th> </th><th>&nbsp;StelSphereGeometry.hpp&nbsp;</th><th></th></tr> 
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l1" /><small>skipping to change at</small><em> line 102</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 102</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! @throws std::runtime_error when there was an error while parsing
 the file.</td><td> </td><td class="right">       //! @throws std::runtime_error when there was an error while parsing
 the file.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       static SphericalRegionP loadFromJson(QIODevice* in);</td><td> </td><td class="right">       static SphericalRegionP loadFromJson(QIODevice* in);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Create a SphericalRegion from the given QByteArray containing th
e JSON data.</td><td> </td><td class="right">       //! Create a SphericalRegion from the given QByteArray containing th
e JSON data.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! @see loadFromJson(QIODevice* in) for format info.</td><td> </td><td class="right">       //! @see loadFromJson(QIODevice* in) for format info.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       static SphericalRegionP loadFromJson(const QByteArray&amp; a);</td><td> </td><td class="right">       static SphericalRegionP loadFromJson(const QByteArray&amp; a);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Create a SphericalRegion from the given QVariantMap with a forma
t matching the JSON file parsed in loadFromJson().</td><td> </td><td class="right">       //! Create a SphericalRegion from the given QVariantMap with a forma
t matching the JSON file parsed in loadFromJson().</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! @param map a valid QVariantMap which can be created e.g. from pa
rsing a JSON file with the StelJsonParser class.</td><td> </td><td class="right">       //! @param map a valid QVariantMap which can be created e.g. from pa
rsing a JSON file with the StelJsonParser class.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       static SphericalRegionP loadFromQVariant(const QVariantMap&amp; map);</td><td> </td><td class="right">       static SphericalRegionP loadFromQVariant(const QVariantMap&amp; map);</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       // It can only be a pure shape definition, without texture coords</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       static SphericalRegionP loadFromQVariant(const QVariantList&amp; list);</td><td> </td><td class="right">       static SphericalRegionP loadFromQVariant(const QVariantList&amp; list);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0002" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       //! <span class="delete">The QVariant type associated</span> to <span class="delete">a SphericalRegionP.</span></td><td> </td><td class="rblock">       //! <span class="insert">Method registered</span> to <span class="insert">JSON serializer.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       static <span class="delete">const QVariant::Type qVariantType;</span></td><td> </td><td class="rblock">       static <span class="insert">void serializeToJson(const QVariant&amp; jsonObject, QIODevice* o</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">utput, int indentLevel=0);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! The meta type ID associated to a SphericalRegionP.</td><td> </td><td class="right">       //! The meta type ID associated to a SphericalRegionP.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       static int metaTypeId;</td><td> </td><td class="right">       static int metaTypeId;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">private:</td><td> </td><td class="right">private:</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0003" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       static QVector&lt;QVector&lt;Vec3d&gt; &gt; loadContourFromQVariant(const QVaria
ntList&amp; contoursList);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Initialize stuff to allow SphericalRegionP to be used with Qt me
ta type system.</td><td> </td><td class="right">       //! Initialize stuff to allow SphericalRegionP to be used with Qt me
ta type system.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       static int initialize();</td><td> </td><td class="right">       static int initialize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">};</td><td> </td><td class="right">};</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// Allow to use SphericalRegionP with the Qt MetaType system.</td><td> </td><td class="right">// Allow to use SphericalRegionP with the Qt MetaType system.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">Q_DECLARE_METATYPE(SphericalRegionP);</td><td> </td><td class="right">Q_DECLARE_METATYPE(SphericalRegionP);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! Serialize the passed SphericalRegionP into a binary blob.</td><td> </td><td class="right">//! Serialize the passed SphericalRegionP into a binary blob.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">QDataStream&amp; operator&lt;&lt;(QDataStream&amp; out, const SphericalRegionP&amp; region);</td><td> </td><td class="right">QDataStream&amp; operator&lt;&lt;(QDataStream&amp; out, const SphericalRegionP&amp; region);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l2" /><small>skipping to change at</small><em> line 183</em></th><th> </th><th><a name="part-r2" /><small>skipping to change at</small><em> line 183</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! @param margin the minimum enlargement margin in radian.</td><td> </td><td class="right">       //! @param margin the minimum enlargement margin in radian.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual SphericalRegionP getEnlarged(double margin) const;</td><td> </td><td class="right">       virtual SphericalRegionP getEnlarged(double margin) const;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Return an openGL compatible array to be displayed using vertex a
rrays.</td><td> </td><td class="right">       //! Return an openGL compatible array to be displayed using vertex a
rrays.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual StelVertexArray getFillVertexArray() const {return getOctahe
dronPolygon().getFillVertexArray();}</td><td> </td><td class="right">       virtual StelVertexArray getFillVertexArray() const {return getOctahe
dronPolygon().getFillVertexArray();}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Get the outline of the contours defining the SphericalPolygon.</td><td> </td><td class="right">       //! Get the outline of the contours defining the SphericalPolygon.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! @return a list of vertex which taken 2 by 2 define the contours 
of the polygon.</td><td> </td><td class="right">       //! @return a list of vertex which taken 2 by 2 define the contours 
of the polygon.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual StelVertexArray getOutlineVertexArray() const {return getOct
ahedronPolygon().getOutlineVertexArray();}</td><td> </td><td class="right">       virtual StelVertexArray getOutlineVertexArray() const {return getOct
ahedronPolygon().getOutlineVertexArray();}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0004" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       //! Serialize the region into a QVariant <span class="delete">map</span> matching the JSON <span class="delete">forma</span></td><td> </td><td class="rblock">       //! <span class="insert">Get the contours defining the SphericalPolygon when combined usi</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">t.</span></td><td> </td><td class="rblock"><span class="insert">ng a positive winding rule.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       virtual <span class="delete">QVariantMap</span> toQVariant() const = 0;</td><td> </td><td class="rblock"><span class="insert">       //! The default implementation return a list of tesselated triangles</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> derived from the OctahedronPolygon.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       virtual QVector&lt;QVector&lt;Vec3d &gt; &gt; getSimplifiedContours() const;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //!</span> Serialize the region into a QVariant <span class="insert">list</span> matching the JSON <span class="insert">form</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">at.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       virtual <span class="insert">QVariantList</span> toQVariant() const = 0;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Serialize the region. This method must allow as fast as possible
 serialization and work with deserialize().</td><td> </td><td class="right">       //! Serialize the region. This method must allow as fast as possible
 serialization and work with deserialize().</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual void serialize(QDataStream&amp; out) const = 0;</td><td> </td><td class="right">       virtual void serialize(QDataStream&amp; out) const = 0;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Output a JSON string representing the polygon.</td><td> </td><td class="right">       //! Output a JSON string representing the polygon.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! This method is convenient for debugging.</td><td> </td><td class="right">       //! This method is convenient for debugging.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       QByteArray toJSON() const;</td><td> </td><td class="right">       QByteArray toJSON() const;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Returns whether a SphericalRegion is contained into this region.</td><td> </td><td class="right">       //! Returns whether a SphericalRegion is contained into this region.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! A default potentially very slow implementation is provided for e
ach cases.</td><td> </td><td class="right">       //! A default potentially very slow implementation is provided for e
ach cases.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l3" /><small>skipping to change at</small><em> line 317</em></th><th> </th><th><a name="part-r3" /><small>skipping to change at</small><em> line 321</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! I managed to make it without sqrt or acos, so it is very fast!</td><td> </td><td class="right">       //! I managed to make it without sqrt or acos, so it is very fast!</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! @see http://f4bien.blogspot.com/2009/05/spherical-geometry-optim
isations.html for detailed explanations.</td><td> </td><td class="right">       //! @see http://f4bien.blogspot.com/2009/05/spherical-geometry-optim
isations.html for detailed explanations.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual bool intersects(const SphericalCap&amp; h) const</td><td> </td><td class="right">       virtual bool intersects(const SphericalCap&amp; h) const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               const double a = d*h.d - n*h.n;</td><td> </td><td class="right">               const double a = d*h.d - n*h.n;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return d+h.d&lt;=0. || a&lt;=0. || (a&lt;=1. &amp;&amp; a*a &lt;= (1.-d*d)*(1.-h
.d*h.d));</td><td> </td><td class="right">               return d+h.d&lt;=0. || a&lt;=0. || (a&lt;=1. &amp;&amp; a*a &lt;= (1.-d*d)*(1.-h
.d*h.d));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual bool intersects(const AllSkySphericalRegion&amp;) const {return 
d&lt;=1.;}</td><td> </td><td class="right">       virtual bool intersects(const AllSkySphericalRegion&amp;) const {return 
d&lt;=1.;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Serialize the region into a QVariant map matching the JSON forma
t.</td><td> </td><td class="right">       //! Serialize the region into a QVariant map matching the JSON forma
t.</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0005" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       //! The format is <span class="delete">{"type": "CAP", "center": [ra, dec], "radius": rad
ius}, with ra dec in degree </span>in ICRS frame</td><td> </td><td class="rblock">       //! The format is <span class="insert">["CAP", [ra, dec], radius], with ra dec in degree 
</span>in ICRS frame</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! and radius in degree (between 0 and 180 deg)</td><td> </td><td class="right">       //! and radius in degree (between 0 and 180 deg)</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0006" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       virtual QVariant<span class="delete">Map</span> toQVariant() const;</td><td> </td><td class="rblock">       virtual QVariant<span class="insert">List</span> toQVariant() const;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual void serialize(QDataStream&amp; out) const {out &lt;&lt; n &lt;&lt; d;}</td><td> </td><td class="right">       virtual void serialize(QDataStream&amp; out) const {out &lt;&lt; n &lt;&lt; d;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       ////////////////////////////////////////////////////////////////////</td><td> </td><td class="right">       ////////////////////////////////////////////////////////////////////</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Methods specific to SphericalCap</td><td> </td><td class="right">       // Methods specific to SphericalCap</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Return the radiusof the cap  in radian</td><td> </td><td class="right">       //! Return the radiusof the cap  in radian</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       double getRadius() const {return std::acos(d);}</td><td> </td><td class="right">       double getRadius() const {return std::acos(d);}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Returns whether a HalfSpace (like a SphericalCap with d=0) inter
sects with this SphericalCap.</td><td> </td><td class="right">       //! Returns whether a HalfSpace (like a SphericalCap with d=0) inter
sects with this SphericalCap.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l4" /><small>skipping to change at</small><em> line 421</em></th><th> </th><th><a name="part-r4" /><small>skipping to change at</small><em> line 425</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       SphericalPoint(const Vec3d&amp; an) : n(an) {Q_ASSERT(std::fabs(1.-n.len
gth())&lt;0.0000001);}</td><td> </td><td class="right">       SphericalPoint(const Vec3d&amp; an) : n(an) {Q_ASSERT(std::fabs(1.-n.len
gth())&lt;0.0000001);}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual ~SphericalPoint() {;}</td><td> </td><td class="right">       virtual ~SphericalPoint() {;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual SphericalRegionType getType() const {return SphericalRegion:
:Point;}</td><td> </td><td class="right">       virtual SphericalRegionType getType() const {return SphericalRegion:
:Point;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual OctahedronPolygon getOctahedronPolygon() const;</td><td> </td><td class="right">       virtual OctahedronPolygon getOctahedronPolygon() const;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual double getArea() const {return 0.;}</td><td> </td><td class="right">       virtual double getArea() const {return 0.;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual bool isEmpty() const {return false;}</td><td> </td><td class="right">       virtual bool isEmpty() const {return false;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual Vec3d getPointInside() const {return n;}</td><td> </td><td class="right">       virtual Vec3d getPointInside() const {return n;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual SphericalCap getBoundingCap() const {return SphericalCap(n, 
1);}</td><td> </td><td class="right">       virtual SphericalCap getBoundingCap() const {return SphericalCap(n, 
1);}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Serialize the region into a QVariant map matching the JSON forma
t.</td><td> </td><td class="right">       //! Serialize the region into a QVariant map matching the JSON forma
t.</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0007" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       //! The format is <span class="delete">{"type": "POINT", "pos":</span> [ra, <span class="delete">dec]},</span> with ra dec <span class="delete">i</span></td><td> </td><td class="rblock">       //! The format is <span class="insert">["POINT",</span> [ra, <span class="insert">dec]],</span> with ra dec <span class="insert">in</span> degree in <span class="insert">ICR</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">n</span> degree in <span class="delete">ICRS</span> frame.</td><td> </td><td class="rblock"><span class="insert">S</span> frame.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       virtual <span class="delete">QVariantMap</span> toQVariant() const;</td><td> </td><td class="rblock">       virtual <span class="insert">QVariantList</span> toQVariant() const;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual void serialize(QDataStream&amp; out) const {out &lt;&lt; n;}</td><td> </td><td class="right">       virtual void serialize(QDataStream&amp; out) const {out &lt;&lt; n;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Contain and intersect</td><td> </td><td class="right">       // Contain and intersect</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual bool contains(const Vec3d&amp; p) const {return n==p;}</td><td> </td><td class="right">       virtual bool contains(const Vec3d&amp; p) const {return n==p;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual bool contains(const SphericalPolygon&amp;) const {return false;}</td><td> </td><td class="right">       virtual bool contains(const SphericalPolygon&amp;) const {return false;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual bool contains(const SphericalConvexPolygon&amp;) const {return f
alse;}</td><td> </td><td class="right">       virtual bool contains(const SphericalConvexPolygon&amp;) const {return f
alse;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual bool contains(const SphericalCap&amp;) const {return false;}</td><td> </td><td class="right">       virtual bool contains(const SphericalCap&amp;) const {return false;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual bool contains(const SphericalPoint&amp; r) const {return n==r.n;
}</td><td> </td><td class="right">       virtual bool contains(const SphericalPoint&amp; r) const {return n==r.n;
}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual bool contains(const AllSkySphericalRegion&amp;) const {return fa
lse;}</td><td> </td><td class="right">       virtual bool contains(const AllSkySphericalRegion&amp;) const {return fa
lse;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual bool intersects(const SphericalPolygon&amp;) const;</td><td> </td><td class="right">       virtual bool intersects(const SphericalPolygon&amp;) const;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l5" /><small>skipping to change at</small><em> line 459</em></th><th> </th><th><a name="part-r5" /><small>skipping to change at</small><em> line 463</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">public:</td><td> </td><td class="right">public:</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual ~AllSkySphericalRegion() {;}</td><td> </td><td class="right">       virtual ~AllSkySphericalRegion() {;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual SphericalRegionType getType() const {return SphericalRegion:
:AllSky;}</td><td> </td><td class="right">       virtual SphericalRegionType getType() const {return SphericalRegion:
:AllSky;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual OctahedronPolygon getOctahedronPolygon() const {return Octah
edronPolygon::getAllSkyOctahedronPolygon();}</td><td> </td><td class="right">       virtual OctahedronPolygon getOctahedronPolygon() const {return Octah
edronPolygon::getAllSkyOctahedronPolygon();}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual double getArea() const {return 4.*M_PI;}</td><td> </td><td class="right">       virtual double getArea() const {return 4.*M_PI;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual bool isEmpty() const {return false;}</td><td> </td><td class="right">       virtual bool isEmpty() const {return false;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual Vec3d getPointInside() const {return Vec3d(1,0,0);}</td><td> </td><td class="right">       virtual Vec3d getPointInside() const {return Vec3d(1,0,0);}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual SphericalCap getBoundingCap() const {return SphericalCap(Vec
3d(1,0,0), -2);}</td><td> </td><td class="right">       virtual SphericalCap getBoundingCap() const {return SphericalCap(Vec
3d(1,0,0), -2);}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Serialize the region into a QVariant map matching the JSON forma
t.</td><td> </td><td class="right">       //! Serialize the region into a QVariant map matching the JSON forma
t.</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0008" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       //! The format is <span class="delete">{"type": "ALLSKY"}</span></td><td> </td><td class="rblock">       //! The format is <span class="insert">["ALLSKY"]</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       virtual <span class="delete">QVariantMap</span> toQVariant() const;</td><td> </td><td class="rblock">       virtual <span class="insert">QVariantList</span> toQVariant() const;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual void serialize(QDataStream&amp;) const {;}</td><td> </td><td class="right">       virtual void serialize(QDataStream&amp;) const {;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Contain and intersect</td><td> </td><td class="right">       // Contain and intersect</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual bool contains(const Vec3d&amp;) const {return true;}</td><td> </td><td class="right">       virtual bool contains(const Vec3d&amp;) const {return true;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual bool contains(const SphericalPolygon&amp;) const {return true;}</td><td> </td><td class="right">       virtual bool contains(const SphericalPolygon&amp;) const {return true;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual bool contains(const SphericalConvexPolygon&amp;) const {return t
rue;}</td><td> </td><td class="right">       virtual bool contains(const SphericalConvexPolygon&amp;) const {return t
rue;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual bool contains(const SphericalCap&amp;) const {return true;}</td><td> </td><td class="right">       virtual bool contains(const SphericalCap&amp;) const {return true;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual bool contains(const SphericalPoint&amp;) const {return true;}</td><td> </td><td class="right">       virtual bool contains(const SphericalPoint&amp;) const {return true;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual bool contains(const AllSkySphericalRegion&amp;) const {return tr
ue;}</td><td> </td><td class="right">       virtual bool contains(const AllSkySphericalRegion&amp;) const {return tr
ue;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual bool intersects(const SphericalPolygon&amp;) const {return true;
}</td><td> </td><td class="right">       virtual bool intersects(const SphericalPolygon&amp;) const {return true;
}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l6" /><small>skipping to change at</small><em> line 501</em></th><th> </th><th><a name="part-r6" /><small>skipping to change at</small><em> line 505</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       EmptySphericalRegion() {;}</td><td> </td><td class="right">       EmptySphericalRegion() {;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual ~EmptySphericalRegion() {;}</td><td> </td><td class="right">       virtual ~EmptySphericalRegion() {;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual SphericalRegionType getType() const {return SphericalRegion:
:Empty;}</td><td> </td><td class="right">       virtual SphericalRegionType getType() const {return SphericalRegion:
:Empty;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual OctahedronPolygon getOctahedronPolygon() const {return Octah
edronPolygon::getEmptyOctahedronPolygon();}</td><td> </td><td class="right">       virtual OctahedronPolygon getOctahedronPolygon() const {return Octah
edronPolygon::getEmptyOctahedronPolygon();}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual double getArea() const {return 0.;}</td><td> </td><td class="right">       virtual double getArea() const {return 0.;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual bool isEmpty() const {return true;}</td><td> </td><td class="right">       virtual bool isEmpty() const {return true;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual Vec3d getPointInside() const {return Vec3d(1,0,0);}</td><td> </td><td class="right">       virtual Vec3d getPointInside() const {return Vec3d(1,0,0);}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual SphericalCap getBoundingCap() const {return SphericalCap(Vec
3d(1,0,0), 2);}</td><td> </td><td class="right">       virtual SphericalCap getBoundingCap() const {return SphericalCap(Vec
3d(1,0,0), 2);}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Serialize the region into a QVariant map matching the JSON forma
t.</td><td> </td><td class="right">       //! Serialize the region into a QVariant map matching the JSON forma
t.</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0009" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       //! The format is <span class="delete">{"type": "EMPTY"}</span></td><td> </td><td class="rblock">       //! The format is <span class="insert">["EMPTY"]</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       virtual <span class="delete">QVariantMap</span> toQVariant() const;</td><td> </td><td class="rblock">       virtual <span class="insert">QVariantList</span> toQVariant() const;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual void serialize(QDataStream&amp;) const {;}</td><td> </td><td class="right">       virtual void serialize(QDataStream&amp;) const {;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Contain and intersect</td><td> </td><td class="right">       // Contain and intersect</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual bool contains(const Vec3d&amp;) const {return false;}</td><td> </td><td class="right">       virtual bool contains(const Vec3d&amp;) const {return false;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual bool contains(const SphericalPolygon&amp;) const {return false;}</td><td> </td><td class="right">       virtual bool contains(const SphericalPolygon&amp;) const {return false;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual bool contains(const SphericalConvexPolygon&amp;) const {return f
alse;}</td><td> </td><td class="right">       virtual bool contains(const SphericalConvexPolygon&amp;) const {return f
alse;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual bool contains(const SphericalCap&amp;) const {return false;}</td><td> </td><td class="right">       virtual bool contains(const SphericalCap&amp;) const {return false;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual bool contains(const SphericalPoint&amp;) const {return false;}</td><td> </td><td class="right">       virtual bool contains(const SphericalPoint&amp;) const {return false;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual bool contains(const AllSkySphericalRegion&amp;) const {return fa
lse;}</td><td> </td><td class="right">       virtual bool contains(const AllSkySphericalRegion&amp;) const {return fa
lse;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual bool intersects(const SphericalPolygon&amp;) const {return false
;}</td><td> </td><td class="right">       virtual bool intersects(const SphericalPolygon&amp;) const {return false
;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l7" /><small>skipping to change at</small><em> line 546</em></th><th> </th><th><a name="part-r7" /><small>skipping to change at</small><em> line 550</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       SphericalPolygon(const QVector&lt;QVector&lt;Vec3d&gt; &gt;&amp; contours) : octahed
ronPolygon(contours) {;}</td><td> </td><td class="right">       SphericalPolygon(const QVector&lt;QVector&lt;Vec3d&gt; &gt;&amp; contours) : octahed
ronPolygon(contours) {;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Constructor from one contour.</td><td> </td><td class="right">       //! Constructor from one contour.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       SphericalPolygon(const QVector&lt;Vec3d&gt;&amp; contour) : octahedronPolygon(
contour) {;}</td><td> </td><td class="right">       SphericalPolygon(const QVector&lt;Vec3d&gt;&amp; contour) : octahedronPolygon(
contour) {;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       SphericalPolygon(const OctahedronPolygon&amp; octContour) : octahedronPo
lygon(octContour) {;}</td><td> </td><td class="right">       SphericalPolygon(const OctahedronPolygon&amp; octContour) : octahedronPo
lygon(octContour) {;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       SphericalPolygon(const QList&lt;OctahedronPolygon&gt;&amp; octContours) : octa
hedronPolygon(octContours) {;}</td><td> </td><td class="right">       SphericalPolygon(const QList&lt;OctahedronPolygon&gt;&amp; octContours) : octa
hedronPolygon(octContours) {;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual SphericalRegionType getType() const {return SphericalRegion:
:Polygon;}</td><td> </td><td class="right">       virtual SphericalRegionType getType() const {return SphericalRegion:
:Polygon;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual OctahedronPolygon getOctahedronPolygon() const {return octah
edronPolygon;}</td><td> </td><td class="right">       virtual OctahedronPolygon getOctahedronPolygon() const {return octah
edronPolygon;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Serialize the region into a QVariant map matching the JSON forma
t.</td><td> </td><td class="right">       //! Serialize the region into a QVariant map matching the JSON forma
t.</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0010" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       //! The format <span class="delete">is</span></td><td> </td><td class="rblock">       //! The format <span class="insert">is:</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       //! <span class="delete">@code["worldCoords": [[[ra,dec],</span> [ra,dec], [ra,dec], [ra,dec]], </td><td> </td><td class="rblock">       //! <span class="insert">@code[[[ra,dec],</span> [ra,dec], [ra,dec], [ra,dec]], [[ra,dec], <span class="insert">[ra,d</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">[[ra,dec], <span class="delete">[ra,dec], [ra,dec]],[...]]]@endcode</span></td><td> </td><td class="rblock"><span class="insert">ec], [ra,dec]],[...]]@endcode</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       //! <span class="delete">worldCoords</span> is a list of closed contours, with each points <span class="delete">defin</span></td><td> </td><td class="rblock">       //! <span class="insert">it</span> is a list of closed contours, with each points <span class="insert">defined</span> by ra </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">ed</span> by ra dec in degree in the ICRS frame.</td><td> </td><td class="rblock">dec in degree in the ICRS frame.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       virtual <span class="delete">QVariantMap</span> toQVariant() const;</td><td> </td><td class="rblock">       virtual <span class="insert">QVariantList</span> toQVariant() const;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual void serialize(QDataStream&amp; out) const;</td><td> </td><td class="right">       virtual void serialize(QDataStream&amp; out) const;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual SphericalCap getBoundingCap() const;</td><td> </td><td class="right">       virtual SphericalCap getBoundingCap() const;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual bool contains(const Vec3d&amp; p) const {return octahedronPolygo
n.contains(p);}</td><td> </td><td class="right">       virtual bool contains(const Vec3d&amp; p) const {return octahedronPolygo
n.contains(p);}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual bool contains(const SphericalPolygon&amp; r) const {return octah
edronPolygon.contains(r.octahedronPolygon);}</td><td> </td><td class="right">       virtual bool contains(const SphericalPolygon&amp; r) const {return octah
edronPolygon.contains(r.octahedronPolygon);}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual bool contains(const SphericalConvexPolygon&amp; r) const;</td><td> </td><td class="right">       virtual bool contains(const SphericalConvexPolygon&amp; r) const;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual bool contains(const SphericalCap&amp; r) const {return octahedro
nPolygon.contains(r.getOctahedronPolygon());}</td><td> </td><td class="right">       virtual bool contains(const SphericalCap&amp; r) const {return octahedro
nPolygon.contains(r.getOctahedronPolygon());}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual bool contains(const SphericalPoint&amp; r) const {return octahed
ronPolygon.contains(r.n);}</td><td> </td><td class="right">       virtual bool contains(const SphericalPoint&amp; r) const {return octahed
ronPolygon.contains(r.n);}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual bool contains(const AllSkySphericalRegion&amp; r) const {return 
octahedronPolygon.contains(r.getOctahedronPolygon());}</td><td> </td><td class="right">       virtual bool contains(const AllSkySphericalRegion&amp; r) const {return 
octahedronPolygon.contains(r.getOctahedronPolygon());}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l8" /><small>skipping to change at</small><em> line 594</em></th><th> </th><th><a name="part-r8" /><small>skipping to change at</small><em> line 598</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! @param contour a contour defining the polygon area.</td><td> </td><td class="right">       //! @param contour a contour defining the polygon area.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       void setContour(const QVector&lt;Vec3d&gt;&amp; contour) {octahedronPolygon = 
OctahedronPolygon(contour);}</td><td> </td><td class="right">       void setContour(const QVector&lt;Vec3d&gt;&amp; contour) {octahedronPolygon = 
OctahedronPolygon(contour);}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Return the list of closed contours defining the polygon boundari
es.</td><td> </td><td class="right">       //! Return the list of closed contours defining the polygon boundari
es.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       QVector&lt;QVector&lt;Vec3d&gt; &gt; getClosedOutlineContours() const {Q_ASSERT(
0); return QVector&lt;QVector&lt;Vec3d&gt; &gt;();}</td><td> </td><td class="right">       QVector&lt;QVector&lt;Vec3d&gt; &gt; getClosedOutlineContours() const {Q_ASSERT(
0); return QVector&lt;QVector&lt;Vec3d&gt; &gt;();}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Deserialize the region. This method must allow as fast as possib
le deserialization.</td><td> </td><td class="right">       //! Deserialize the region. This method must allow as fast as possib
le deserialization.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       static SphericalRegionP deserialize(QDataStream&amp; in);</td><td> </td><td class="right">       static SphericalRegionP deserialize(QDataStream&amp; in);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Create a new SphericalRegionP which is the union of all the pass
ed ones.</td><td> </td><td class="right">       //! Create a new SphericalRegionP which is the union of all the pass
ed ones.</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0011" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       static SphericalRegionP multiUnion(const QList&lt;SphericalRegionP&gt;&amp; re</td><td> </td><td class="rblock">       static SphericalRegionP multiUnion(const QList&lt;SphericalRegionP&gt;&amp; re</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">gions);</span></td><td> </td><td class="rblock"><span class="insert">gions, bool optimizeByPreGrouping=false);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //! Create a new SphericalRegionP which is the intersection of all t</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">he passed ones.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       static SphericalRegionP multiIntersection(const QList&lt;SphericalRegio</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">nP&gt;&amp; regions);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">private:</td><td> </td><td class="right">private:</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       OctahedronPolygon octahedronPolygon;</td><td> </td><td class="right">       OctahedronPolygon octahedronPolygon;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">};</td><td> </td><td class="right">};</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! @class SphericalConvexPolygon</td><td> </td><td class="right">//! @class SphericalConvexPolygon</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! A special case of SphericalPolygon for which the polygon is convex.</td><td> </td><td class="right">//! A special case of SphericalPolygon for which the polygon is convex.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">class SphericalConvexPolygon : public SphericalRegion</td><td> </td><td class="right">class SphericalConvexPolygon : public SphericalRegion</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">public:</td><td> </td><td class="right">public:</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l9" /><small>skipping to change at</small><em> line 632</em></th><th> </th><th><a name="part-r9" /><small>skipping to change at</small><em> line 639</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual OctahedronPolygon getOctahedronPolygon() const {return Octah
edronPolygon(contour);}</td><td> </td><td class="right">       virtual OctahedronPolygon getOctahedronPolygon() const {return Octah
edronPolygon(contour);}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual StelVertexArray getFillVertexArray() const {return StelVerte
xArray(contour, StelVertexArray::TriangleFan);}</td><td> </td><td class="right">       virtual StelVertexArray getFillVertexArray() const {return StelVerte
xArray(contour, StelVertexArray::TriangleFan);}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual StelVertexArray getOutlineVertexArray() const {return StelVe
rtexArray(contour, StelVertexArray::LineLoop);}</td><td> </td><td class="right">       virtual StelVertexArray getOutlineVertexArray() const {return StelVe
rtexArray(contour, StelVertexArray::LineLoop);}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual double getArea() const;</td><td> </td><td class="right">       virtual double getArea() const;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual bool isEmpty() const {return contour.isEmpty();}</td><td> </td><td class="right">       virtual bool isEmpty() const {return contour.isEmpty();}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual Vec3d getPointInside() const;</td><td> </td><td class="right">       virtual Vec3d getPointInside() const;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual SphericalCap getBoundingCap() const {return cachedBoundingCa
p;}</td><td> </td><td class="right">       virtual SphericalCap getBoundingCap() const {return cachedBoundingCa
p;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       QVector&lt;SphericalCap&gt; getBoundingSphericalCaps() const;</td><td> </td><td class="right">       QVector&lt;SphericalCap&gt; getBoundingSphericalCaps() const;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Serialize the region into a QVariant map matching the JSON forma
t.</td><td> </td><td class="right">       //! Serialize the region into a QVariant map matching the JSON forma
t.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! The format is</td><td> </td><td class="right">       //! The format is</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0012" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       //! <span class="delete">@code{"type": "CVXPOLYGON", "worldCoords": [[[ra,dec], [ra,dec],</span></td><td> </td><td class="rblock">       //! <span class="insert">@code["CONVEX_POLYGON",</span> [[ra,dec], [ra,dec], <span class="insert">[ra,dec], [ra,dec]]</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"> [ra,dec], [ra,dec]],</span> [[ra,dec], [ra,dec], <span class="delete">[ra,dec]],[...]]}@endcode</span></td><td> </td><td class="rblock"><span class="insert">]@endcode</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       //! <span class="delete">worldCoords is</span> a <span class="delete">list of</span> closed <span class="delete">contours,</span> with each points <span class="delete">defin</span></td><td> </td><td class="rblock">       //! <span class="insert">where the coords are</span> a closed <span class="insert">convex contour,</span> with each points <span class="insert">d</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">ed</span> by ra dec in degree in the ICRS frame.</td><td> </td><td class="rblock"><span class="insert">efined</span> by ra dec in degree in the ICRS frame.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       virtual <span class="delete">QVariantMap</span> toQVariant() const;</td><td> </td><td class="rblock">       virtual <span class="insert">QVariantList</span> toQVariant() const;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual void serialize(QDataStream&amp; out) const {out &lt;&lt; contour;}</td><td> </td><td class="right">       virtual void serialize(QDataStream&amp; out) const {out &lt;&lt; contour;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Contain and intersect</td><td> </td><td class="right">       // Contain and intersect</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual bool contains(const Vec3d&amp; p) const;</td><td> </td><td class="right">       virtual bool contains(const Vec3d&amp; p) const;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual bool contains(const SphericalPolygon&amp; r) const;</td><td> </td><td class="right">       virtual bool contains(const SphericalPolygon&amp; r) const;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual bool contains(const SphericalConvexPolygon&amp; r) const;</td><td> </td><td class="right">       virtual bool contains(const SphericalConvexPolygon&amp; r) const;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual bool contains(const SphericalCap&amp; r) const;</td><td> </td><td class="right">       virtual bool contains(const SphericalCap&amp; r) const;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual bool contains(const SphericalPoint&amp; r) const {return contain
s(r.n);}</td><td> </td><td class="right">       virtual bool contains(const SphericalPoint&amp; r) const {return contain
s(r.n);}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual bool contains(const AllSkySphericalRegion&amp;) const {return fa
lse;}</td><td> </td><td class="right">       virtual bool contains(const AllSkySphericalRegion&amp;) const {return fa
lse;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual bool intersects(const SphericalCap&amp; r) const {if (!cachedBou
ndingCap.intersects(r)) return false; return r.intersects(*this);}</td><td> </td><td class="right">       virtual bool intersects(const SphericalCap&amp; r) const {if (!cachedBou
ndingCap.intersects(r)) return false; return r.intersects(*this);}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l10" /><small>skipping to change at</small><em> line 712</em></th><th> </th><th><a name="part-r10" /><small>skipping to change at</small><em> line 719</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Computes whether the passed points are all outside of at least o
ne SphericalCap defining the polygon boundary.</td><td> </td><td class="right">       //! Computes whether the passed points are all outside of at least o
ne SphericalCap defining the polygon boundary.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       bool areAllPointsOutsideOneSide(const QVector&lt;Vec3d&gt;&amp; points) const</td><td> </td><td class="right">       bool areAllPointsOutsideOneSide(const QVector&lt;Vec3d&gt;&amp; points) const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return areAllPointsOutsideOneSide(contour.constData(), conto
ur.size(), points.constData(), points.size());</td><td> </td><td class="right">               return areAllPointsOutsideOneSide(contour.constData(), conto
ur.size(), points.constData(), points.size());</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       bool containsConvexContour(const Vec3d* vertice, int nbVertex) const
;</td><td> </td><td class="right">       bool containsConvexContour(const Vec3d* vertice, int nbVertex) const
;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">};</td><td> </td><td class="right">};</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0013" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//! @class SphericalConvexPolygonSet</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//! A special case of SphericalPolygon for which the polygon is composed of</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> disjoint convex polygons.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//class SphericalConvexPolygonSet : public SphericalRegion</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//{</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//public:</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//     // Avoid name hiding when overloading the virtual methods.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//     using SphericalRegion::intersects;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//     using SphericalRegion::contains;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//     //! Default constructor.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//     SphericalConvexPolygonSet() {;}</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//     //! Constructor from a list of contours.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//     SphericalConvexPolygonSet(const QVector&lt;QVector&lt;Vec3d&gt; &gt;&amp; contours);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//     virtual SphericalRegionType getType() const {return SphericalRegion:</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">:ConvexPolygonSet;}</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//     virtual OctahedronPolygon getOctahedronPolygon() const;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//     virtual StelVertexArray getFillVertexArray() const;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//     virtual StelVertexArray getOutlineVertexArray() const;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//     virtual double getArea() const;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//     virtual bool isEmpty() const;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//     virtual Vec3d getPointInside() const;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//     virtual SphericalCap getBoundingCap() const {return cachedBoundingCa</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">p;}</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//     QVector&lt;SphericalCap&gt; getBoundingSphericalCaps() const;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//     //! Serialize the region into a QVariant map matching the JSON forma</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">t.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//     //! The format is</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//     //! @code["CONVEX_POLYGON_SET", [[ra,dec], [ra,dec], [ra,dec], [ra,d</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ec]], [[ra,dec], [ra,dec], [ra,dec], [ra,dec]]]@endcode</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//     //! where the coords from a list of closed convex contour, with each</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> points defined by ra dec in degree in the ICRS frame.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//     virtual QVariantList toQVariant() const;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//     virtual void serialize(QDataStream&amp; out) const;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//     // Contain and intersect</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//     virtual bool contains(const Vec3d&amp; p) const;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//     virtual bool contains(const SphericalPolygon&amp; r) const;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//     virtual bool contains(const SphericalConvexPolygon&amp; r) const;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//     virtual bool contains(const SphericalCap&amp; r) const;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//     virtual bool contains(const SphericalPoint&amp; r) const {return contain</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">s(r.n);}</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//     virtual bool contains(const AllSkySphericalRegion&amp;) const {return fa</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">lse;}</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//     virtual bool intersects(const SphericalCap&amp; r) const {if (!cachedBou</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ndingCap.intersects(r)) return false; return r.intersects(*this);}</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//     virtual bool intersects(const SphericalPolygon&amp; r) const;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//     virtual bool intersects(const SphericalConvexPolygon&amp; r) const;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//     virtual bool intersects(const SphericalPoint&amp; r) const {return conta</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ins(r.n);}</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//     virtual bool intersects(const AllSkySphericalRegion&amp;) const {return </span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">true;}</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//     ////////////////////////////////////////////////////////////////////</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//     // Methods specific to SphericalConvexPolygonSet</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//     ////////////////////////////////////////////////////////////////////</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//     //! Deserialize the region. This method must allow as fast as possib</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">le deserialization.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//     static SphericalRegionP deserialize(QDataStream&amp; in);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//protected:</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//     QVector&lt;SphericalConvexPolygon&gt; contours;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//     //! Cache the bounding cap.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//     SphericalCap cachedBoundingCap;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//     //! Update the bounding cap from the vertex list.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//     void updateBoundingCap();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//};</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! @class SphericalTexturedPolygon</td><td> </td><td class="right">//! @class SphericalTexturedPolygon</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! An extension of SphericalPolygon with addition of texture coordinates.</td><td> </td><td class="right">//! An extension of SphericalPolygon with addition of texture coordinates.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">class SphericalTexturedPolygon : public SphericalPolygon</td><td> </td><td class="right">class SphericalTexturedPolygon : public SphericalPolygon</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">public:</td><td> </td><td class="right">public:</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! @struct TextureVertex</td><td> </td><td class="right">       //! @struct TextureVertex</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! A container for 3D vertex + associated texture coordinates</td><td> </td><td class="right">       //! A container for 3D vertex + associated texture coordinates</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       struct TextureVertex</td><td> </td><td class="right">       struct TextureVertex</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               Vec3d vertex;</td><td> </td><td class="right">               Vec3d vertex;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l11" /><small>skipping to change at</small><em> line 735</em></th><th> </th><th><a name="part-r11" /><small>skipping to change at</small><em> line 802</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       SphericalTexturedPolygon() {;}</td><td> </td><td class="right">       SphericalTexturedPolygon() {;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Constructor from a list of contours.</td><td> </td><td class="right">       //! Constructor from a list of contours.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       SphericalTexturedPolygon(const QVector&lt;QVector&lt;TextureVertex&gt; &gt;&amp; con
tours) {Q_UNUSED(contours); Q_ASSERT(0);}</td><td> </td><td class="right">       SphericalTexturedPolygon(const QVector&lt;QVector&lt;TextureVertex&gt; &gt;&amp; con
tours) {Q_UNUSED(contours); Q_ASSERT(0);}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Constructor from one contour.</td><td> </td><td class="right">       //! Constructor from one contour.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       SphericalTexturedPolygon(const QVector&lt;TextureVertex&gt;&amp; contour) {Q_U
NUSED(contour); Q_ASSERT(0);}</td><td> </td><td class="right">       SphericalTexturedPolygon(const QVector&lt;TextureVertex&gt;&amp; contour) {Q_U
NUSED(contour); Q_ASSERT(0);}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Return an openGL compatible array of texture coords to be used u
sing vertex arrays.</td><td> </td><td class="right">       //! Return an openGL compatible array of texture coords to be used u
sing vertex arrays.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual StelVertexArray getFillVertexArray() const {Q_ASSERT(0); ret
urn StelVertexArray();}</td><td> </td><td class="right">       virtual StelVertexArray getFillVertexArray() const {Q_ASSERT(0); ret
urn StelVertexArray();}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Serialize the region into a QVariant map matching the JSON forma
t.</td><td> </td><td class="right">       //! Serialize the region into a QVariant map matching the JSON forma
t.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! The format is:</td><td> </td><td class="right">       //! The format is:</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0014" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       //! <span class="delete">@code{"worldCoords":</span> [[[ra,dec], [ra,dec], [ra,dec], <span class="delete">[ra,dec]],</span> </td><td> </td><td class="rblock">       //! <span class="insert">@code["TEXTURED_POLYGON",</span> [[[ra,dec], [ra,dec], [ra,dec], <span class="insert">[ra,de</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">[[ra,dec], [ra,dec], [ra,dec]],[...]],</td><td> </td><td class="rblock"><span class="insert">c]],</span> [[ra,dec], [ra,dec], [ra,dec]],[...]],</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       //! <span class="delete">"textureCoords":</span> [[[u,v],[u,v],[u,v],[u,v]], <span class="delete">[[u,v],[u,v],[u,v]]</span></td><td> </td><td class="rblock">       //! [[[u,v],[u,v],[u,v],[u,v]], <span class="insert">[[u,v],[u,v],[u,v]], [...]]]@endcode</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">, [...]]</span></td><td> </td><td class="rblock">       //! <span class="insert">where</span> the <span class="insert">two lists are</span> a list of closed contours, with each <span class="insert">poi</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       //! <span class="delete">}@endcode</span></td><td> </td><td class="rblock"><span class="insert">nts defined</span> by ra dec in degree in the ICRS <span class="insert">frame</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       //! textureCoords is a list of texture coordinates in</span> the <span class="delete">u,v textur</span></td><td> </td><td class="rblock"><span class="insert">       //! followed by a list of texture coordinates in the u,v texture spa</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">e space (between 0 and 1).</span></td><td> </td><td class="rblock"><span class="insert">ce (between 0 and 1).</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       //! worldCoords is</span> a list of closed contours, with each <span class="delete">points defin</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">ed</span> by ra dec in degree in the ICRS <span class="delete">frame.</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! There must be one texture coordinate for each vertex.</td><td> </td><td class="right">       //! There must be one texture coordinate for each vertex.</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0015" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       virtual QVariant<span class="delete">Map</span> toQVariant() const;</td><td> </td><td class="rblock">       virtual QVariant<span class="insert">List</span> toQVariant() const;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual void serialize(QDataStream&amp; out) const {Q_UNUSED(out); Q_ASS
ERT(0);}</td><td> </td><td class="right">       virtual void serialize(QDataStream&amp; out) const {Q_UNUSED(out); Q_ASS
ERT(0);}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       ////////////////////////////////////////////////////////////////////</td><td> </td><td class="right">       ////////////////////////////////////////////////////////////////////</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Methods specific to SphericalTexturedPolygon</td><td> </td><td class="right">       // Methods specific to SphericalTexturedPolygon</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Set the contours defining the SphericalPolygon.</td><td> </td><td class="right">       //! Set the contours defining the SphericalPolygon.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! @param contours the list of contours defining the polygon area u
sing the WindingPositive winding rule.</td><td> </td><td class="right">       //! @param contours the list of contours defining the polygon area u
sing the WindingPositive winding rule.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       void setContours(const QVector&lt;QVector&lt;TextureVertex&gt; &gt;&amp; contours) {
Q_UNUSED(contours); Q_ASSERT(0);}</td><td> </td><td class="right">       void setContours(const QVector&lt;QVector&lt;TextureVertex&gt; &gt;&amp; contours) {
Q_UNUSED(contours); Q_ASSERT(0);}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Set a single contour defining the SphericalPolygon.</td><td> </td><td class="right">       //! Set a single contour defining the SphericalPolygon.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! @param contour a contour defining the polygon area.</td><td> </td><td class="right">       //! @param contour a contour defining the polygon area.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l12" /><small>skipping to change at</small><em> line 791</em></th><th> </th><th><a name="part-r12" /><small>skipping to change at</small><em> line 857</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! This method is not optimized for SphericalConvexPolygon instance
s.</td><td> </td><td class="right">       //! This method is not optimized for SphericalConvexPolygon instance
s.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual StelVertexArray getFillVertexArray() const {return StelVerte
xArray(contour, StelVertexArray::TriangleFan, textureCoords);}</td><td> </td><td class="right">       virtual StelVertexArray getFillVertexArray() const {return StelVerte
xArray(contour, StelVertexArray::TriangleFan, textureCoords);}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Set a single contour defining the SphericalPolygon.</td><td> </td><td class="right">       //! Set a single contour defining the SphericalPolygon.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! @param acontour a contour defining the polygon area.</td><td> </td><td class="right">       //! @param acontour a contour defining the polygon area.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! @param texCoord a list of texture coordinates matching the verti
ces of the contour.</td><td> </td><td class="right">       //! @param texCoord a list of texture coordinates matching the verti
ces of the contour.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual void setContour(const QVector&lt;Vec3d&gt;&amp; acontour, const QVecto
r&lt;Vec2f&gt;&amp; texCoord) {SphericalConvexPolygon::setContour(acontour); textureC
oords=texCoord;}</td><td> </td><td class="right">       virtual void setContour(const QVector&lt;Vec3d&gt;&amp; acontour, const QVecto
r&lt;Vec2f&gt;&amp; texCoord) {SphericalConvexPolygon::setContour(acontour); textureC
oords=texCoord;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Serialize the region into a QVariant map matching the JSON forma
t.</td><td> </td><td class="right">       //! Serialize the region into a QVariant map matching the JSON forma
t.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! The format is:</td><td> </td><td class="right">       //! The format is:</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0016" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       //! <span class="delete">@code{"type": "CVXPOLYGON", "worldCoords": [[[ra,dec],</span> [ra,dec],</td><td> </td><td class="rblock">       //! <span class="insert">@code["TEXTURED_CONVEX_POLYGON", [[ra,dec],</span> [ra,dec], [ra,dec], </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"> [ra,dec], [ra,dec]], <span class="delete">[[ra,dec], [ra,dec], [ra,dec]],[...]],</span></td><td> </td><td class="rblock">[ra,dec]], <span class="insert">[[u,v],[u,v],[u,v],[u,v]]]@endcode</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       //! "textureCoords": [[[u,v],[u,v],[u,v],[u,v]], [[u,v],[u,v],[u,v]]</span></td><td> </td><td class="rblock">       //! <span class="insert">where</span> the <span class="insert">two lists are</span> a closed <span class="insert">convex</span> contours, with each <span class="insert">poin</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">, [...]]</span></td><td> </td><td class="rblock"><span class="insert">ts defined</span> by ra dec in degree in the ICRS <span class="insert">frame</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       //! }@endcode</span></td><td> </td><td class="rblock"><span class="insert">       //! followed by a list of texture coordinates in the u,v texture spa</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       //! <span class="delete">textureCoords is a list of texture coordinates in</span> the <span class="delete">u,v textur</span></td><td> </td><td class="rblock"><span class="insert">ce (between 0 and 1).</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">e space (between 0 and 1).</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       //! worldCoords is</span> a <span class="delete">list of</span> closed contours, with each <span class="delete">points defin</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">ed</span> by ra dec in degree in the ICRS <span class="delete">frame.</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! There must be one texture coordinate for each vertex.</td><td> </td><td class="right">       //! There must be one texture coordinate for each vertex.</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0017" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       virtual QVariant<span class="delete">Map</span> toQVariant() const;</td><td> </td><td class="rblock">       virtual QVariant<span class="insert">List</span> toQVariant() const;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual void serialize(QDataStream&amp; out) const {out &lt;&lt; contour &lt;&lt; te
xtureCoords;}</td><td> </td><td class="right">       virtual void serialize(QDataStream&amp; out) const {out &lt;&lt; contour &lt;&lt; te
xtureCoords;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">protected:</td><td> </td><td class="right">protected:</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! A list of uv textures coordinates corresponding to the triangle 
vertices.</td><td> </td><td class="right">       //! A list of uv textures coordinates corresponding to the triangle 
vertices.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! There should be 1 uv position per vertex.</td><td> </td><td class="right">       //! There should be 1 uv position per vertex.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       QVector&lt;Vec2f&gt; textureCoords;</td><td> </td><td class="right">       QVector&lt;Vec2f&gt; textureCoords;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">};</td><td> </td><td class="right">};</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! Compute the intersection of 2 great circles segments.</td><td> </td><td class="right">//! Compute the intersection of 2 great circles segments.</td><td class="lineno" valign="top"></td></tr>

     <tr><td></td><td class="left"></td><td> </td><td class="right"></td><td></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 17 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><td></td><th><i>48 lines changed or deleted</i></th><th><i> </i></th><th><i>127 lines changed or added</i></th><td></td></tr>
     <tr><td colspan="5" align="center" class="small"><br/>This html diff was produced by rfcdiff 1.41. The latest version is available from <a href="http://www.tools.ietf.org/tools/rfcdiff/" >http://tools.ietf.org/tools/rfcdiff/</a> </td></tr>
   </table>
   </body>
   </html>
