<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"> 
<!-- Generated by rfcdiff 1.41: rfcdiff  --> 
<!-- <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional" > -->
<!-- System: Linux fomalhaut.local 3.13.0-45-generic #74-Ubuntu SMP Tue Jan 13 19:36:28 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux --> 
<!-- Using awk: /usr/bin/gawk: GNU Awk 4.0.1 --> 
<!-- Using diff: /usr/bin/diff: diff (GNU diffutils) 3.3 --> 
<!-- Using wdiff: /usr/bin/wdiff: wdiff (GNU wdiff) 1.2.1 --> 
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"> 
<head> 
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /> 
  <meta http-equiv="Content-Style-Type" content="text/css" /> 
  <title>Diff: StelPainter.cpp - StelPainter.cpp</title> 
  <style type="text/css"> 
    body    { font-size:16px; margin: 0.4ex; margin-right: auto; } 
    tr      { } 
    td      { white-space: pre; font-family: Consolas, "DejaVu Sans Mono", "Droid Sans Mono", Monaco, Monospace; vertical-align: top; font-size: 0.86em;} 
    th      { font-size: 0.86em; } 
    .small  { font-size: 0.6em; font-style: italic; font-family: Verdana, Helvetica, sans-serif; } 
    .left   { background-color: #EEE; } 
    .right  { background-color: #FFF; } 
    .diff   { background-color: #CCF; } 
    .lblock { background-color: #BFB; } 
    .rblock { background-color: #FF8; } 
    .insert { background-color: #8FF; } 
    .delete { background-color: #ACF; } 
    .void   { background-color: #FFB; } 
    .cont   { background-color: #EEE; } 
    .linebr { background-color: #AAA; } 
    .lineno { color: red; background-color: #FFF; font-size: 0.7em; text-align: right; padding: 0 2px; } 
    .elipsis{ background-color: #AAA; } 
    .left .cont { background-color: #DDD; } 
    .right .cont { background-color: #EEE; } 
    .lblock .cont { background-color: #9D9; } 
    .rblock .cont { background-color: #DD6; } 
    .insert .cont { background-color: #0DD; } 
    .delete .cont { background-color: #8AD; } 
    .stats, .stats td, .stats th { background-color: #EEE; padding: 2px 0; } 
  </style> 
</head> 
<body > 
  <table border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th></th><th>&nbsp;StelPainter.cpp&nbsp;</th><th> </th><th>&nbsp;StelPainter.cpp&nbsp;</th><th></th></tr> 
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l1" /><small>skipping to change at</small><em> line 163</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 163</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">QFontMetrics StelPainter::getFontMetrics() const</td><td> </td><td class="right">QFontMetrics StelPainter::getFontMetrics() const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       return QFontMetrics(currentFont);</td><td> </td><td class="right">       return QFontMetrics(currentFont);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">///////////////////////////////////////////////////////////////////////////</td><td> </td><td class="right">///////////////////////////////////////////////////////////////////////////</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// Standard methods for drawing primitives</td><td> </td><td class="right">// Standard methods for drawing primitives</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// Fill with black around the circle</td><td> </td><td class="right">// Fill with black around the circle</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">void StelPainter::drawViewportShape(<span class="delete">void</span>)</td><td> </td><td class="rblock">void StelPainter::drawViewportShape(<span class="insert">const GLfloat innerRadius</span>)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (prj-&gt;maskType != StelProjector::MaskDisk)</td><td> </td><td class="right">       if (prj-&gt;maskType != StelProjector::MaskDisk)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return;</td><td> </td><td class="right">               return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       glDisable(GL_BLEND);</td><td> </td><td class="right">       glDisable(GL_BLEND);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       setColor(0.f,0.f,0.f);</td><td> </td><td class="right">       setColor(0.f,0.f,0.f);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0002" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       GLfloat innerRadius = 0.5*prj-&gt;viewportFovDiameter;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       GLfloat outerRadius = prj-&gt;getViewportWidth()+prj-&gt;getViewportHeight
();</td><td> </td><td class="right">       GLfloat outerRadius = prj-&gt;getViewportWidth()+prj-&gt;getViewportHeight
();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       GLint slices = 256;</td><td> </td><td class="right">       GLint slices = 256;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       GLfloat sweepAngle = 360.;</td><td> </td><td class="right">       GLfloat sweepAngle = 360.;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       GLfloat sinCache[240];</td><td> </td><td class="right">       GLfloat sinCache[240];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       GLfloat cosCache[240];</td><td> </td><td class="right">       GLfloat cosCache[240];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       GLfloat vertices[(240+1)*2][3];</td><td> </td><td class="right">       GLfloat vertices[(240+1)*2][3];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       GLfloat deltaRadius;</td><td> </td><td class="right">       GLfloat deltaRadius;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       GLfloat radiusHigh;</td><td> </td><td class="right">       GLfloat radiusHigh;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l2" /><small>skipping to change at</small><em> line 225</em></th><th> </th><th><a name="part-r2" /><small>skipping to change at</small><em> line 224</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               vertices[i*2][1]= prj-&gt;viewportCenter[1] + outerRadius*cosCa
che[i];</td><td> </td><td class="right">               vertices[i*2][1]= prj-&gt;viewportCenter[1] + outerRadius*cosCa
che[i];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               vertices[i*2][2] = 0.0;</td><td> </td><td class="right">               vertices[i*2][2] = 0.0;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               vertices[i*2+1][0]= prj-&gt;viewportCenter[0] + radiusHigh*sinC
ache[i];</td><td> </td><td class="right">               vertices[i*2+1][0]= prj-&gt;viewportCenter[0] + radiusHigh*sinC
ache[i];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               vertices[i*2+1][1]= prj-&gt;viewportCenter[1] + radiusHigh*cosC
ache[i];</td><td> </td><td class="right">               vertices[i*2+1][1]= prj-&gt;viewportCenter[1] + radiusHigh*cosC
ache[i];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               vertices[i*2+1][2] = 0.0;</td><td> </td><td class="right">               vertices[i*2+1][2] = 0.0;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       drawFromArray(TriangleStrip, (slices+1)*2, 0, false);</td><td> </td><td class="right">       drawFromArray(TriangleStrip, (slices+1)*2, 0, false);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       enableClientStates(false);</td><td> </td><td class="right">       enableClientStates(false);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0003" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">void StelPainter::drawViewportShape(void)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">{</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       this-&gt;drawViewportShape(0.5*prj-&gt;viewportFovDiameter);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">}</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void StelPainter::computeFanDisk(float radius, int innerFanSlices, int leve
l, QVector&lt;double&gt;&amp; vertexArr, QVector&lt;float&gt;&amp; texCoordArr)</td><td> </td><td class="right">void StelPainter::computeFanDisk(float radius, int innerFanSlices, int leve
l, QVector&lt;double&gt;&amp; vertexArr, QVector&lt;float&gt;&amp; texCoordArr)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Q_ASSERT(level&lt;64);</td><td> </td><td class="right">       Q_ASSERT(level&lt;64);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       float rad[64];</td><td> </td><td class="right">       float rad[64];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       int i,j;</td><td> </td><td class="right">       int i,j;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       rad[level] = radius;</td><td> </td><td class="right">       rad[level] = radius;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       for (i=level-1;i&gt;=0;--i)</td><td> </td><td class="right">       for (i=level-1;i&gt;=0;--i)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               rad[i] = rad[i+1]*(1.f-M_PI/(innerFanSlices&lt;&lt;(i+1)))*2.f/3.f
;</td><td> </td><td class="right">               rad[i] = rad[i+1]*(1.f-M_PI/(innerFanSlices&lt;&lt;(i+1)))*2.f/3.f
;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l3" /><small>skipping to change at</small><em> line 334</em></th><th> </th><th><a name="part-r3" /><small>skipping to change at</small><em> line 338</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">static void sSphereMapTexCoordFast(float rho_div_fov, const float costheta,
 const float sintheta, QVector&lt;float&gt;&amp; out)</td><td> </td><td class="right">static void sSphereMapTexCoordFast(float rho_div_fov, const float costheta,
 const float sintheta, QVector&lt;float&gt;&amp; out)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (rho_div_fov&gt;0.5f)</td><td> </td><td class="right">       if (rho_div_fov&gt;0.5f)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               rho_div_fov=0.5f;</td><td> </td><td class="right">               rho_div_fov=0.5f;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       out &lt;&lt; 0.5f + rho_div_fov * costheta &lt;&lt; 0.5f + rho_div_fov * sinthet
a;</td><td> </td><td class="right">       out &lt;&lt; 0.5f + rho_div_fov * costheta &lt;&lt; 0.5f + rho_div_fov * sinthet
a;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0004" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">void StelPainter::sSphereMap(<span class="delete">const float radius, const int slices, const in
t stacks, const float textureFov, const</span> int orientInside)</td><td> </td><td class="rblock">void StelPainter::sSphereMap(<span class="insert">float radius, int slices, int stacks, float te
xtureFov,</span> int orientInside)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       float rho,x,y,z;</td><td> </td><td class="right">       float rho,x,y,z;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       int i, j;</td><td> </td><td class="right">       int i, j;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const float* cos_sin_rho = StelUtils::ComputeCosSinRho(stacks);</td><td> </td><td class="right">       const float* cos_sin_rho = StelUtils::ComputeCosSinRho(stacks);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const float* cos_sin_rho_p;</td><td> </td><td class="right">       const float* cos_sin_rho_p;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const float* cos_sin_theta = StelUtils::ComputeCosSinTheta(slices);</td><td> </td><td class="right">       const float* cos_sin_theta = StelUtils::ComputeCosSinTheta(slices);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const float* cos_sin_theta_p;</td><td> </td><td class="right">       const float* cos_sin_theta_p;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       float drho = M_PI / stacks;</td><td> </td><td class="right">       float drho = M_PI / stacks;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l4" /><small>skipping to change at</small><em> line 407</em></th><th> </th><th><a name="part-r4" /><small>skipping to change at</small><em> line 411</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               z = cos_sin_rho_p[0];</td><td> </td><td class="right">                               z = cos_sin_rho_p[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               sSphereMapTexCoordFast(rho, cos_sin_theta_p[
0], -cos_sin_theta_p[1], texCoordArr);</td><td> </td><td class="right">                               sSphereMapTexCoordFast(rho, cos_sin_theta_p[
0], -cos_sin_theta_p[1], texCoordArr);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               vertexArr &lt;&lt; x*radius &lt;&lt; y*radius &lt;&lt; z*radiu
s;</td><td> </td><td class="right">                               vertexArr &lt;&lt; x*radius &lt;&lt; y*radius &lt;&lt; z*radiu
s;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       }</td><td> </td><td class="right">                       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       setArrays((Vec3d*)vertexArr.constData(), (Vec2f*)tex
CoordArr.constData());</td><td> </td><td class="right">                       setArrays((Vec3d*)vertexArr.constData(), (Vec2f*)tex
CoordArr.constData());</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       drawFromArray(TriangleStrip, vertexArr.size()/3);</td><td> </td><td class="right">                       drawFromArray(TriangleStrip, vertexArr.size()/3);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0005" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">void StelPainter::drawTextGravity180(float x, float y, const QString&amp; ws, <span class="delete">c
onst float xshift, const</span> float yshift)</td><td> </td><td class="rblock">void StelPainter::drawTextGravity180(float x, float y, const QString&amp; ws, <span class="insert">f
loat xshift,</span> float yshift)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       float dx, dy, d, theta, theta_o, psi;</td><td> </td><td class="right">       float dx, dy, d, theta, theta_o, psi;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       dx = x - prj-&gt;viewportCenter[0];</td><td> </td><td class="right">       dx = x - prj-&gt;viewportCenter[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       dy = y - prj-&gt;viewportCenter[1];</td><td> </td><td class="right">       dy = y - prj-&gt;viewportCenter[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       d = std::sqrt(dx*dx + dy*dy);</td><td> </td><td class="right">       d = std::sqrt(dx*dx + dy*dy);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       float limit = 120.;</td><td> </td><td class="right">       float limit = 120.;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // If the text is too far away to be visible in the screen return</td><td> </td><td class="right">       // If the text is too far away to be visible in the screen return</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (d&gt;qMax(prj-&gt;viewportXywh[3], prj-&gt;viewportXywh[2])*2)</td><td> </td><td class="right">       if (d&gt;qMax(prj-&gt;viewportXywh[3], prj-&gt;viewportXywh[2])*2)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return;</td><td> </td><td class="right">               return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l5" /><small>skipping to change at</small><em> line 476</em></th><th> </th><th><a name="part-r5" /><small>skipping to change at</small><em> line 480</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       {</td><td> </td><td class="right">                       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               x = d * std::cos (theta) + xVc;</td><td> </td><td class="right">                               x = d * std::cos (theta) + xVc;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               y = d * std::sin (theta) + yVc;</td><td> </td><td class="right">                               y = d * std::sin (theta) + yVc;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               drawText(x, y, ws[slen-1-i], 90. + theta*180
./M_PI, 0., 0.);</td><td> </td><td class="right">                               drawText(x, y, ws[slen-1-i], 90. + theta*180
./M_PI, 0., 0.);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               theta += psi * M_PI/180. * (1 + ((float)getF
ontMetrics().width(ws[slen-1-i]) - cWidth)/ cWidth);</td><td> </td><td class="right">                               theta += psi * M_PI/180. * (1 + ((float)getF
ontMetrics().width(ws[slen-1-i]) - cWidth)/ cWidth);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       }</td><td> </td><td class="right">                       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0006" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">void StelPainter::drawText(const Vec3d&amp; v, const QString&amp; str, <span class="delete">const float 
angleDeg, const float xshift, const float yshift, const</span> bool noGravity)</td><td> </td><td class="rblock">void StelPainter::drawText(const Vec3d&amp; v, const QString&amp; str, <span class="insert">float angleD
eg, float xshift, float yshift,</span> bool noGravity)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Vec3d win;</td><td> </td><td class="right">       Vec3d win;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (prj-&gt;project(v, win))</td><td> </td><td class="right">       if (prj-&gt;project(v, win))</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               drawText(win[0], win[1], str, angleDeg, xshift, yshift, noGr
avity);</td><td> </td><td class="right">               drawText(win[0], win[1], str, angleDeg, xshift, yshift, noGr
avity);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">/*************************************************************************</td><td> </td><td class="right">/*************************************************************************</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"> Draw the string at the given position and angle with the given font</td><td> </td><td class="right"> Draw the string at the given position and angle with the given font</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">*************************************************************************/</td><td> </td><td class="right">*************************************************************************/</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l6" /><small>skipping to change at</small><em> line 509</em></th><th> </th><th><a name="part-r6" /><small>skipping to change at</small><em> line 513</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                 height(0),</td><td> </td><td class="right">                 height(0),</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                 subTexWidth(0),</td><td> </td><td class="right">                 subTexWidth(0),</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                 subTexHeight(0) {;}</td><td> </td><td class="right">                 subTexHeight(0) {;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       ~StringTexture()</td><td> </td><td class="right">       ~StringTexture()</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               if (texture != 0)</td><td> </td><td class="right">               if (texture != 0)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       glDeleteTextures(1, &amp;texture);</td><td> </td><td class="right">                       glDeleteTextures(1, &amp;texture);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">};</td><td> </td><td class="right">};</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0007" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">void StelPainter::drawText(float x, float y, const QString&amp; str, float angl
eDeg, float xshift, float yshift, <span class="delete">const </span>bool noGravity)</td><td> </td><td class="rblock">void StelPainter::drawText(float x, float y, const QString&amp; str, float angl
eDeg, float xshift, float yshift, bool noGravity)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       StelPainter::GLState state; // Will restore the opengl state at the 
end of the function.</td><td> </td><td class="right">       StelPainter::GLState state; // Will restore the opengl state at the 
end of the function.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (prj-&gt;gravityLabels &amp;&amp; !noGravity)</td><td> </td><td class="right">       if (prj-&gt;gravityLabels &amp;&amp; !noGravity)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               drawTextGravity180(x, y, str, xshift, yshift);</td><td> </td><td class="right">               drawTextGravity180(x, y, str, xshift, yshift);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       else</td><td> </td><td class="right">       else</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               QOpenGLPaintDevice device;</td><td> </td><td class="right">               QOpenGLPaintDevice device;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               device.setSize(QSize(prj-&gt;getViewportWidth(), prj-&gt;getViewpo
rtHeight()));</td><td> </td><td class="right">               device.setSize(QSize(prj-&gt;getViewportWidth(), prj-&gt;getViewpo
rtHeight()));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l7" /><small>skipping to change at</small><em> line 541</em></th><th> </th><th><a name="part-r7" /><small>skipping to change at</small><em> line 545</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               painter.setPen(QColor(currentColor[0]*255, currentColor[1]*2
55, currentColor[2]*255, currentColor[3]*255));</td><td> </td><td class="right">               painter.setPen(QColor(currentColor[0]*255, currentColor[1]*2
55, currentColor[2]*255, currentColor[3]*255));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               xshift*=StelApp::getInstance().getGlobalScalingRatio();</td><td> </td><td class="right">               xshift*=StelApp::getInstance().getGlobalScalingRatio();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               yshift*=StelApp::getInstance().getGlobalScalingRatio();</td><td> </td><td class="right">               yshift*=StelApp::getInstance().getGlobalScalingRatio();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               y = prj-&gt;getViewportHeight()-y;</td><td> </td><td class="right">               y = prj-&gt;getViewportHeight()-y;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               yshift = -yshift;</td><td> </td><td class="right">               yshift = -yshift;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               // Translate/rotate</td><td> </td><td class="right">               // Translate/rotate</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               if (!noGravity)</td><td> </td><td class="right">               if (!noGravity)</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0008" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       angleDeg += prj-&gt;defautAngleForGravityText;</td><td> </td><td class="rblock">                       angleDeg += prj-&gt;defau<span class="insert">l</span>tAngleForGravityText;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               if (std::fabs(angleDeg)&gt;1.f)</td><td> </td><td class="right">               if (std::fabs(angleDeg)&gt;1.f)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       QTransform m;</td><td> </td><td class="right">                       QTransform m;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       m.translate(x, y);</td><td> </td><td class="right">                       m.translate(x, y);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       m.rotate(-angleDeg);</td><td> </td><td class="right">                       m.rotate(-angleDeg);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       painter.setTransform(m);</td><td> </td><td class="right">                       painter.setTransform(m);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       painter.drawText(xshift, yshift, str);</td><td> </td><td class="right">                       painter.drawText(xshift, yshift, str);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               else</td><td> </td><td class="right">               else</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l8" /><small>skipping to change at</small><em> line 642</em></th><th> </th><th><a name="part-r8" /><small>skipping to change at</small><em> line 646</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void StelPainter::drawSmallCircleArc(const Vec3d&amp; start, const Vec3d&amp; stop,
 const Vec3d&amp; rotCenter, void (*viewportEdgeIntersectCallback)(const Vec3d&amp;
 screenPos, const Vec3d&amp; direction, void* userData), void* userData)</td><td> </td><td class="right">void StelPainter::drawSmallCircleArc(const Vec3d&amp; start, const Vec3d&amp; stop,
 const Vec3d&amp; rotCenter, void (*viewportEdgeIntersectCallback)(const Vec3d&amp;
 screenPos, const Vec3d&amp; direction, void* userData), void* userData)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Q_ASSERT(smallCircleVertexArray.empty());</td><td> </td><td class="right">       Q_ASSERT(smallCircleVertexArray.empty());</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       QLinkedList&lt;Vec3d&gt; tessArc;     // Contains the list of projected po
ints from the tesselated arc</td><td> </td><td class="right">       QLinkedList&lt;Vec3d&gt; tessArc;     // Contains the list of projected po
ints from the tesselated arc</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Vec3d win1, win2;</td><td> </td><td class="right">       Vec3d win1, win2;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       win1[2] = prj-&gt;project(start, win1) ? 1.0 : -1.;</td><td> </td><td class="right">       win1[2] = prj-&gt;project(start, win1) ? 1.0 : -1.;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       win2[2] = prj-&gt;project(stop, win2) ? 1.0 : -1.;</td><td> </td><td class="right">       win2[2] = prj-&gt;project(stop, win2) ? 1.0 : -1.;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       tessArc.append(win1);</td><td> </td><td class="right">       tessArc.append(win1);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0009" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       if (rotCenter.lengthSquared()&lt;<span class="delete">0.0000000</span>1)</td><td> </td><td class="rblock">       if (rotCenter.lengthSquared()&lt;<span class="insert">1e-1</span>1)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               // Great circle</td><td> </td><td class="right">               // Great circle</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               // Perform the tesselation of the arc in small segments in a
 way so that the lines look smooth</td><td> </td><td class="right">               // Perform the tesselation of the arc in small segments in a
 way so that the lines look smooth</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               fIter(prj, start, stop, win1, win2, tessArc, tessArc.insert(
tessArc.end(), win2), 1, rotCenter);</td><td> </td><td class="right">               fIter(prj, start, stop, win1, win2, tessArc, tessArc.insert(
tessArc.end(), win2), 1, rotCenter);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       else</td><td> </td><td class="right">       else</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               Vec3d tmp = (rotCenter^start)/rotCenter.length();</td><td> </td><td class="right">               Vec3d tmp = (rotCenter^start)/rotCenter.length();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               const double radius = fabs(tmp.length());</td><td> </td><td class="right">               const double radius = fabs(tmp.length());</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               // Perform the tesselation of the arc in small segments in a
 way so that the lines look smooth</td><td> </td><td class="right">               // Perform the tesselation of the arc in small segments in a
 way so that the lines look smooth</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l9" /><small>skipping to change at</small><em> line 695</em></th><th> </th><th><a name="part-r9" /><small>skipping to change at</small><em> line 699</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               smallCircleVertexArray.append(Vec2f(p1[0], p
1[1]));</td><td> </td><td class="right">                               smallCircleVertexArray.append(Vec2f(p1[0], p
1[1]));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       drawSmallCircleVertexArray();</td><td> </td><td class="right">                       drawSmallCircleVertexArray();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Q_ASSERT(smallCircleVertexArray.isEmpty());</td><td> </td><td class="right">       Q_ASSERT(smallCircleVertexArray.isEmpty());</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// Project the passed triangle on the screen ensuring that it will look smo
oth, even for non linear distortion</td><td> </td><td class="right">// Project the passed triangle on the screen ensuring that it will look smo
oth, even for non linear distortion</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// by splitting it into subtriangles.</td><td> </td><td class="right">// by splitting it into subtriangles.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void StelPainter::projectSphericalTriangle(const SphericalCap* clippingCap,
 const Vec3d* vertices, QVarLengthArray&lt;Vec3f, 4096&gt;* outVertices,</td><td> </td><td class="right">void StelPainter::projectSphericalTriangle(const SphericalCap* clippingCap,
 const Vec3d* vertices, QVarLengthArray&lt;Vec3f, 4096&gt;* outVertices,</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0010" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               const Vec2f* texturePos, QVarLengthArray&lt;Vec2f, 4096&gt;* <span class="delete">outTe</span></td><td> </td><td class="rblock">        const Vec2f* texturePos, QVarLengthArray&lt;Vec2f, 4096&gt;* <span class="insert">outTexturePo</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">xturePos,</span></td><td> </td><td class="rblock"><span class="insert">s,</span> const <span class="insert">Vec3f *colors, QVarLengthArray&lt;Vec3f, 4096&gt; *outColors,</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               const double maxSqDistortion, <span class="delete">const</span> int nbI, <span class="delete">const</span> bool <span class="delete">chec</span></td><td> </td><td class="rblock">        double maxSqDistortion, int nbI, bool <span class="insert">checkDisc1,</span> bool checkDisc2, </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">kDisc1, const</span> bool checkDisc2, <span class="delete">const</span> bool checkDisc3) const</td><td> </td><td class="rblock">bool checkDisc3) const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Q_ASSERT(fabs(vertices[0].length()-1.)&lt;0.00001);</td><td> </td><td class="right">       Q_ASSERT(fabs(vertices[0].length()-1.)&lt;0.00001);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Q_ASSERT(fabs(vertices[1].length()-1.)&lt;0.00001);</td><td> </td><td class="right">       Q_ASSERT(fabs(vertices[1].length()-1.)&lt;0.00001);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Q_ASSERT(fabs(vertices[2].length()-1.)&lt;0.00001);</td><td> </td><td class="right">       Q_ASSERT(fabs(vertices[2].length()-1.)&lt;0.00001);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (clippingCap &amp;&amp; clippingCap-&gt;containsTriangle(vertices))</td><td> </td><td class="right">       if (clippingCap &amp;&amp; clippingCap-&gt;containsTriangle(vertices))</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               clippingCap = NULL;</td><td> </td><td class="right">               clippingCap = NULL;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (clippingCap &amp;&amp; !clippingCap-&gt;intersectsTriangle(vertices))</td><td> </td><td class="right">       if (clippingCap &amp;&amp; !clippingCap-&gt;intersectsTriangle(vertices))</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return;</td><td> </td><td class="right">               return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       bool cDiscontinuity1 = checkDisc1 &amp;&amp; prj-&gt;intersectViewportDiscontin
uity(vertices[0], vertices[1]);</td><td> </td><td class="right">       bool cDiscontinuity1 = checkDisc1 &amp;&amp; prj-&gt;intersectViewportDiscontin
uity(vertices[0], vertices[1]);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       bool cDiscontinuity2 = checkDisc2 &amp;&amp; prj-&gt;intersectViewportDiscontin
uity(vertices[1], vertices[2]);</td><td> </td><td class="right">       bool cDiscontinuity2 = checkDisc2 &amp;&amp; prj-&gt;intersectViewportDiscontin
uity(vertices[1], vertices[2]);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l10" /><small>skipping to change at</small><em> line 754</em></th><th> </th><th><a name="part-r10" /><small>skipping to change at</small><em> line 758</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               win3[1] -= (e0[1]+e2[1])*0.5;</td><td> </td><td class="right">               win3[1] -= (e0[1]+e2[1])*0.5;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               cDiscontinuity3 = (win3[0]*win3[0]+win3[1]*win3[1])&gt;maxSqDis
tortion;</td><td> </td><td class="right">               cDiscontinuity3 = (win3[0]*win3[0]+win3[1]*win3[1])&gt;maxSqDis
tortion;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (!cDiscontinuity1 &amp;&amp; !cDiscontinuity2 &amp;&amp; !cDiscontinuity3)</td><td> </td><td class="right">       if (!cDiscontinuity1 &amp;&amp; !cDiscontinuity2 &amp;&amp; !cDiscontinuity3)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               // The triangle is clean, appends it</td><td> </td><td class="right">               // The triangle is clean, appends it</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               outVertices-&gt;append(Vec3f(e0[0], e0[1], e0[2])); outVertices
-&gt;append(Vec3f(e1[0], e1[1], e1[2])); outVertices-&gt;append(Vec3f(e2[0], e2[1
], e2[2]));</td><td> </td><td class="right">               outVertices-&gt;append(Vec3f(e0[0], e0[1], e0[2])); outVertices
-&gt;append(Vec3f(e1[0], e1[1], e1[2])); outVertices-&gt;append(Vec3f(e2[0], e2[1
], e2[2]));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               if (outTexturePos)</td><td> </td><td class="right">               if (outTexturePos)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       outTexturePos-&gt;append(texturePos,3);</td><td> </td><td class="right">                       outTexturePos-&gt;append(texturePos,3);</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0011" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">               <span class="insert">if (outColors)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       outColors-&gt;append(colors,3);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return;</td><td> </td><td class="right">               return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (nbI &gt; 4)</td><td> </td><td class="right">       if (nbI &gt; 4)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               // If we reached the limit number of iterations and still ha
ve a discontinuity,</td><td> </td><td class="right">               // If we reached the limit number of iterations and still ha
ve a discontinuity,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               // discards the triangle.</td><td> </td><td class="right">               // discards the triangle.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               if (cd1 || cd2 || cd3)</td><td> </td><td class="right">               if (cd1 || cd2 || cd3)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       return;</td><td> </td><td class="right">                       return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               // Else display it, it will be suboptimal though.</td><td> </td><td class="right">               // Else display it, it will be suboptimal though.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               outVertices-&gt;append(Vec3f(e0[0], e0[1], e0[2])); outVertices
-&gt;append(Vec3f(e1[0], e1[1], e2[2])); outVertices-&gt;append(Vec3f(e2[0], e2[1
], e2[2]));</td><td> </td><td class="right">               outVertices-&gt;append(Vec3f(e0[0], e0[1], e0[2])); outVertices
-&gt;append(Vec3f(e1[0], e1[1], e2[2])); outVertices-&gt;append(Vec3f(e2[0], e2[1
], e2[2]));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               if (outTexturePos)</td><td> </td><td class="right">               if (outTexturePos)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       outTexturePos-&gt;append(texturePos,3);</td><td> </td><td class="right">                       outTexturePos-&gt;append(texturePos,3);</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0012" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">               <span class="insert">if (outColors)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       outColors-&gt;append(colors,3);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return;</td><td> </td><td class="right">               return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Recursively splits the triangle into sub triangles.</td><td> </td><td class="right">       // Recursively splits the triangle into sub triangles.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Depending on which combination of sides of the triangle has to be
 split a different strategy is used.</td><td> </td><td class="right">       // Depending on which combination of sides of the triangle has to be
 split a different strategy is used.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Vec3d va[3];</td><td> </td><td class="right">       Vec3d va[3];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Vec2f ta[3];</td><td> </td><td class="right">       Vec2f ta[3];</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0013" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       Vec3f ca[3];</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Only 1 side has to be split: split the triangle in 2</td><td> </td><td class="right">       // Only 1 side has to be split: split the triangle in 2</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (cDiscontinuity1 &amp;&amp; !cDiscontinuity2 &amp;&amp; !cDiscontinuity3)</td><td> </td><td class="right">       if (cDiscontinuity1 &amp;&amp; !cDiscontinuity2 &amp;&amp; !cDiscontinuity3)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[0]=vertices[0];</td><td> </td><td class="right">               va[0]=vertices[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[1]=vertices[0];va[1]+=vertices[1];</td><td> </td><td class="right">               va[1]=vertices[0];va[1]+=vertices[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[1].normalize();</td><td> </td><td class="right">               va[1].normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[2]=vertices[2];</td><td> </td><td class="right">               va[2]=vertices[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               if (outTexturePos)</td><td> </td><td class="right">               if (outTexturePos)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[0]=texturePos[0];</td><td> </td><td class="right">                       ta[0]=texturePos[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[1]=(texturePos[0]+texturePos[1])*0.5;</td><td> </td><td class="right">                       ta[1]=(texturePos[0]+texturePos[1])*0.5;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[2]=texturePos[2];</td><td> </td><td class="right">                       ta[2]=texturePos[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0014" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               projectSphericalTriangle(clippingCap, va, outVertices, ta, o</td><td> </td><td class="rblock">               <span class="insert">if (outColors)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">utTexturePos, maxSqDistortion, nbI+1, true, true, false);</td><td> </td><td class="rblock"><span class="insert">               {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       ca[0]=colors[0];</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       ca[1]=(colors[0]+colors[1])*0.5;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       ca[2]=colors[2];</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">               projectSphericalTriangle(clippingCap, va, outVertices, ta, o</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">utTexturePos, <span class="insert">ca, outColors,</span> maxSqDistortion, nbI+1, true, true, false);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               //va[0]=vertices[0]+vertices[1];</td><td> </td><td class="right">               //va[0]=vertices[0]+vertices[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               //va[0].normalize();</td><td> </td><td class="right">               //va[0].normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[0]=va[1];</td><td> </td><td class="right">               va[0]=va[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[1]=vertices[1];</td><td> </td><td class="right">               va[1]=vertices[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[2]=vertices[2];</td><td> </td><td class="right">               va[2]=vertices[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               if (outTexturePos)</td><td> </td><td class="right">               if (outTexturePos)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[0]=(texturePos[0]+texturePos[1])*0.5;</td><td> </td><td class="right">                       ta[0]=(texturePos[0]+texturePos[1])*0.5;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[1]=texturePos[1];</td><td> </td><td class="right">                       ta[1]=texturePos[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[2]=texturePos[2];</td><td> </td><td class="right">                       ta[2]=texturePos[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0015" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               projectSphericalTriangle(clippingCap, va, outVertices, ta, o</td><td> </td><td class="rblock">               <span class="insert">if (outColors)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">utTexturePos, maxSqDistortion, nbI+1, true, false, true);</td><td> </td><td class="rblock"><span class="insert">               {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       ca[0]=(colors[0]+colors[1])*0.5;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       ca[1]=colors[1];</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       ca[2]=colors[2];</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">               projectSphericalTriangle(clippingCap, va, outVertices, ta, o</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">utTexturePos, <span class="insert">ca, outColors,</span> maxSqDistortion, nbI+1, true, false, true);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return;</td><td> </td><td class="right">               return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (!cDiscontinuity1 &amp;&amp; cDiscontinuity2 &amp;&amp; !cDiscontinuity3)</td><td> </td><td class="right">       if (!cDiscontinuity1 &amp;&amp; cDiscontinuity2 &amp;&amp; !cDiscontinuity3)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[0]=vertices[0];</td><td> </td><td class="right">               va[0]=vertices[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[1]=vertices[1];</td><td> </td><td class="right">               va[1]=vertices[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[2]=vertices[1];va[2]+=vertices[2];</td><td> </td><td class="right">               va[2]=vertices[1];va[2]+=vertices[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[2].normalize();</td><td> </td><td class="right">               va[2].normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               if (outTexturePos)</td><td> </td><td class="right">               if (outTexturePos)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[0]=texturePos[0];</td><td> </td><td class="right">                       ta[0]=texturePos[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[1]=texturePos[1];</td><td> </td><td class="right">                       ta[1]=texturePos[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[2]=(texturePos[1]+texturePos[2])*0.5;</td><td> </td><td class="right">                       ta[2]=(texturePos[1]+texturePos[2])*0.5;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0016" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               projectSphericalTriangle(clippingCap, va, outVertices, ta, o</td><td> </td><td class="rblock">               <span class="insert">if (outColors)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">utTexturePos, maxSqDistortion, nbI+1, false, true, true);</td><td> </td><td class="rblock"><span class="insert">               {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       ca[0]=colors[0];</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       ca[1]=colors[1];</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       ca[2]=(colors[1]+colors[2])*0.5;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">               projectSphericalTriangle(clippingCap, va, outVertices, ta, o</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">utTexturePos, <span class="insert">ca, outColors,</span> maxSqDistortion, nbI+1, false, true, true);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[0]=vertices[0];</td><td> </td><td class="right">               va[0]=vertices[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               //va[1]=vertices[1]+vertices[2];</td><td> </td><td class="right">               //va[1]=vertices[1]+vertices[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               //va[1].normalize();</td><td> </td><td class="right">               //va[1].normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[1]=va[2];</td><td> </td><td class="right">               va[1]=va[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[2]=vertices[2];</td><td> </td><td class="right">               va[2]=vertices[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               if (outTexturePos)</td><td> </td><td class="right">               if (outTexturePos)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[0]=texturePos[0];</td><td> </td><td class="right">                       ta[0]=texturePos[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[1]=(texturePos[1]+texturePos[2])*0.5;</td><td> </td><td class="right">                       ta[1]=(texturePos[1]+texturePos[2])*0.5;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[2]=texturePos[2];</td><td> </td><td class="right">                       ta[2]=texturePos[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0017" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               projectSphericalTriangle(clippingCap, va, outVertices, ta, o</td><td> </td><td class="rblock">               <span class="insert">if (outColors)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">utTexturePos, maxSqDistortion, nbI+1, true, true, false);</td><td> </td><td class="rblock"><span class="insert">               {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       ca[0]=colors[0];</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       ca[1]=(colors[1]+colors[2])*0.5;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       ca[2]=colors[2];</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">               projectSphericalTriangle(clippingCap, va, outVertices, ta, o</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">utTexturePos, <span class="insert">ca, outColors,</span> maxSqDistortion, nbI+1, true, true, false);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return;</td><td> </td><td class="right">               return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (!cDiscontinuity1 &amp;&amp; !cDiscontinuity2 &amp;&amp; cDiscontinuity3)</td><td> </td><td class="right">       if (!cDiscontinuity1 &amp;&amp; !cDiscontinuity2 &amp;&amp; cDiscontinuity3)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[0]=vertices[0];</td><td> </td><td class="right">               va[0]=vertices[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[1]=vertices[1];</td><td> </td><td class="right">               va[1]=vertices[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[2]=vertices[0];va[2]+=vertices[2];</td><td> </td><td class="right">               va[2]=vertices[0];va[2]+=vertices[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[2].normalize();</td><td> </td><td class="right">               va[2].normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               if (outTexturePos)</td><td> </td><td class="right">               if (outTexturePos)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[0]=texturePos[0];</td><td> </td><td class="right">                       ta[0]=texturePos[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[1]=texturePos[1];</td><td> </td><td class="right">                       ta[1]=texturePos[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[2]=(texturePos[0]+texturePos[2])*0.5;</td><td> </td><td class="right">                       ta[2]=(texturePos[0]+texturePos[2])*0.5;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0018" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               projectSphericalTriangle(clippingCap, va, outVertices, ta, o</td><td> </td><td class="rblock">               <span class="insert">if (outColors)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">utTexturePos, maxSqDistortion, nbI+1, false, true, true);</td><td> </td><td class="rblock"><span class="insert">               {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       ca[0]=colors[0];</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       ca[1]=colors[1];</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       ca[2]=(colors[0]+colors[2])*0.5;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">               projectSphericalTriangle(clippingCap, va, outVertices, ta, o</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">utTexturePos, <span class="insert">ca, outColors,</span> maxSqDistortion, nbI+1, false, true, true);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               //va[0]=vertices[0]+vertices[2];</td><td> </td><td class="right">               //va[0]=vertices[0]+vertices[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               //va[0].normalize();</td><td> </td><td class="right">               //va[0].normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[0]=va[2];</td><td> </td><td class="right">               va[0]=va[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[1]=vertices[1];</td><td> </td><td class="right">               va[1]=vertices[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[2]=vertices[2];</td><td> </td><td class="right">               va[2]=vertices[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               if (outTexturePos)</td><td> </td><td class="right">               if (outTexturePos)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[0]=(texturePos[0]+texturePos[2])*0.5;</td><td> </td><td class="right">                       ta[0]=(texturePos[0]+texturePos[2])*0.5;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[1]=texturePos[1];</td><td> </td><td class="right">                       ta[1]=texturePos[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[2]=texturePos[2];</td><td> </td><td class="right">                       ta[2]=texturePos[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0019" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               projectSphericalTriangle(clippingCap, va, outVertices, ta, o</td><td> </td><td class="rblock">               <span class="insert">if (outColors)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">utTexturePos, maxSqDistortion, nbI+1, true, false, true);</td><td> </td><td class="rblock"><span class="insert">               {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       ca[0]=(colors[0]+colors[2])*0.5;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       ca[1]=colors[1];</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       ca[2]=colors[2];</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">               projectSphericalTriangle(clippingCap, va, outVertices, ta, o</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">utTexturePos, <span class="insert">ca, outColors,</span> maxSqDistortion, nbI+1, true, false, true);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return;</td><td> </td><td class="right">               return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // 2 sides have to be split: split the triangle in 3</td><td> </td><td class="right">       // 2 sides have to be split: split the triangle in 3</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (cDiscontinuity1 &amp;&amp; cDiscontinuity2 &amp;&amp; !cDiscontinuity3)</td><td> </td><td class="right">       if (cDiscontinuity1 &amp;&amp; cDiscontinuity2 &amp;&amp; !cDiscontinuity3)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[0]=vertices[0];</td><td> </td><td class="right">               va[0]=vertices[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[1]=vertices[0];va[1]+=vertices[1];</td><td> </td><td class="right">               va[1]=vertices[0];va[1]+=vertices[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[1].normalize();</td><td> </td><td class="right">               va[1].normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[2]=vertices[1];va[2]+=vertices[2];</td><td> </td><td class="right">               va[2]=vertices[1];va[2]+=vertices[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[2].normalize();</td><td> </td><td class="right">               va[2].normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               if (outTexturePos)</td><td> </td><td class="right">               if (outTexturePos)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[0]=texturePos[0];</td><td> </td><td class="right">                       ta[0]=texturePos[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[1]=(texturePos[0]+texturePos[1])*0.5;</td><td> </td><td class="right">                       ta[1]=(texturePos[0]+texturePos[1])*0.5;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[2]=(texturePos[1]+texturePos[2])*0.5;</td><td> </td><td class="right">                       ta[2]=(texturePos[1]+texturePos[2])*0.5;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0020" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               projectSphericalTriangle(clippingCap, va, outVertices, ta, o</td><td> </td><td class="rblock">               <span class="insert">if (outColors)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">utTexturePos, maxSqDistortion, nbI+1);</td><td> </td><td class="rblock"><span class="insert">               {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       ca[0]=colors[0];</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       ca[1]=(colors[0]+colors[1])*0.5;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       ca[2]=(colors[1]+colors[2])*0.5;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">               projectSphericalTriangle(clippingCap, va, outVertices, ta, o</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">utTexturePos, <span class="insert">ca, outColors,</span> maxSqDistortion, nbI+1);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               //va[0]=vertices[0]+vertices[1];</td><td> </td><td class="right">               //va[0]=vertices[0]+vertices[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               //va[0].normalize();</td><td> </td><td class="right">               //va[0].normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[0]=va[1];</td><td> </td><td class="right">               va[0]=va[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[1]=vertices[1];</td><td> </td><td class="right">               va[1]=vertices[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               //va[2]=vertices[1]+vertices[2];</td><td> </td><td class="right">               //va[2]=vertices[1]+vertices[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               //va[2].normalize();</td><td> </td><td class="right">               //va[2].normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               if (outTexturePos)</td><td> </td><td class="right">               if (outTexturePos)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[0]=(texturePos[0]+texturePos[1])*0.5;</td><td> </td><td class="right">                       ta[0]=(texturePos[0]+texturePos[1])*0.5;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[1]=texturePos[1];</td><td> </td><td class="right">                       ta[1]=texturePos[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[2]=(texturePos[1]+texturePos[2])*0.5;</td><td> </td><td class="right">                       ta[2]=(texturePos[1]+texturePos[2])*0.5;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0021" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               projectSphericalTriangle(clippingCap, va, outVertices, ta, o</td><td> </td><td class="rblock">               <span class="insert">if (outColors)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">utTexturePos, maxSqDistortion, nbI+1);</td><td> </td><td class="rblock"><span class="insert">               {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       ca[0]=(colors[0]+colors[1])*0.5;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       ca[1]=colors[1];</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       ca[2]=(colors[1]+colors[2])*0.5;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">               projectSphericalTriangle(clippingCap, va, outVertices, ta, o</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">utTexturePos, <span class="insert">ca, outColors,</span> maxSqDistortion, nbI+1);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[0]=vertices[0];</td><td> </td><td class="right">               va[0]=vertices[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               //va[1]=vertices[1]+vertices[2];</td><td> </td><td class="right">               //va[1]=vertices[1]+vertices[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               //va[1].normalize();</td><td> </td><td class="right">               //va[1].normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[1]=va[2];</td><td> </td><td class="right">               va[1]=va[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[2]=vertices[2];</td><td> </td><td class="right">               va[2]=vertices[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               if (outTexturePos)</td><td> </td><td class="right">               if (outTexturePos)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[0]=texturePos[0];</td><td> </td><td class="right">                       ta[0]=texturePos[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[1]=(texturePos[1]+texturePos[2])*0.5;</td><td> </td><td class="right">                       ta[1]=(texturePos[1]+texturePos[2])*0.5;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[2]=texturePos[2];</td><td> </td><td class="right">                       ta[2]=texturePos[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0022" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               projectSphericalTriangle(clippingCap, va, outVertices, ta, o</td><td> </td><td class="rblock">               <span class="insert">if (outColors)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">utTexturePos, maxSqDistortion, nbI+1, true, true, false);</td><td> </td><td class="rblock"><span class="insert">               {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       ca[0]=colors[0];</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       ca[1]=(colors[1]+colors[2])*0.5;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       ca[2]=colors[2];</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">               projectSphericalTriangle(clippingCap, va, outVertices, ta, o</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">utTexturePos, <span class="insert">ca, outColors,</span> maxSqDistortion, nbI+1, true, true, false);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return;</td><td> </td><td class="right">               return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (cDiscontinuity1 &amp;&amp; !cDiscontinuity2 &amp;&amp; cDiscontinuity3)</td><td> </td><td class="right">       if (cDiscontinuity1 &amp;&amp; !cDiscontinuity2 &amp;&amp; cDiscontinuity3)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[0]=vertices[0];</td><td> </td><td class="right">               va[0]=vertices[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[1]=vertices[0];va[1]+=vertices[1];</td><td> </td><td class="right">               va[1]=vertices[0];va[1]+=vertices[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[1].normalize();</td><td> </td><td class="right">               va[1].normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[2]=vertices[0];va[2]+=vertices[2];</td><td> </td><td class="right">               va[2]=vertices[0];va[2]+=vertices[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[2].normalize();</td><td> </td><td class="right">               va[2].normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               if (outTexturePos)</td><td> </td><td class="right">               if (outTexturePos)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[0]=texturePos[0];</td><td> </td><td class="right">                       ta[0]=texturePos[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[1]=(texturePos[0]+texturePos[1])*0.5;</td><td> </td><td class="right">                       ta[1]=(texturePos[0]+texturePos[1])*0.5;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[2]=(texturePos[0]+texturePos[2])*0.5;</td><td> </td><td class="right">                       ta[2]=(texturePos[0]+texturePos[2])*0.5;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0023" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               projectSphericalTriangle(clippingCap, va, outVertices, ta, o</td><td> </td><td class="rblock">               <span class="insert">if (outColors)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">utTexturePos, maxSqDistortion, nbI+1);</td><td> </td><td class="rblock"><span class="insert">               {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       ca[0]=colors[0];</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       ca[1]=(colors[0]+colors[1])*0.5;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       ca[2]=(colors[0]+colors[2])*0.5;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">               projectSphericalTriangle(clippingCap, va, outVertices, ta, o</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">utTexturePos, <span class="insert">ca, outColors,</span> maxSqDistortion, nbI+1);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               //va[0]=vertices[0]+vertices[1];</td><td> </td><td class="right">               //va[0]=vertices[0]+vertices[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               //va[0].normalize();</td><td> </td><td class="right">               //va[0].normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[0]=va[1];</td><td> </td><td class="right">               va[0]=va[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[1]=vertices[2];</td><td> </td><td class="right">               va[1]=vertices[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               //va[2]=vertices[0]+vertices[2];</td><td> </td><td class="right">               //va[2]=vertices[0]+vertices[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               //va[2].normalize();</td><td> </td><td class="right">               //va[2].normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               if (outTexturePos)</td><td> </td><td class="right">               if (outTexturePos)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[0]=(texturePos[0]+texturePos[1])*0.5;</td><td> </td><td class="right">                       ta[0]=(texturePos[0]+texturePos[1])*0.5;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[1]=texturePos[2];</td><td> </td><td class="right">                       ta[1]=texturePos[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[2]=(texturePos[0]+texturePos[2])*0.5;</td><td> </td><td class="right">                       ta[2]=(texturePos[0]+texturePos[2])*0.5;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0024" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               projectSphericalTriangle(clippingCap, va, outVertices, ta, o</td><td> </td><td class="rblock">               <span class="insert">if (outColors)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">utTexturePos, maxSqDistortion, nbI+1);</td><td> </td><td class="rblock"><span class="insert">               {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       ca[0]=(colors[0]+colors[1])*0.5;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       ca[1]=colors[2];</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       ca[2]=(colors[0]+colors[2])*0.5;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">               projectSphericalTriangle(clippingCap, va, outVertices, ta, o</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">utTexturePos, <span class="insert">ca, outColors,</span> maxSqDistortion, nbI+1);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               //va[0]=vertices[0]+vertices[1];</td><td> </td><td class="right">               //va[0]=vertices[0]+vertices[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               //va[0].normalize();</td><td> </td><td class="right">               //va[0].normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[1]=vertices[1];</td><td> </td><td class="right">               va[1]=vertices[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[2]=vertices[2];</td><td> </td><td class="right">               va[2]=vertices[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               if (outTexturePos)</td><td> </td><td class="right">               if (outTexturePos)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[0]=(texturePos[0]+texturePos[1])*0.5;</td><td> </td><td class="right">                       ta[0]=(texturePos[0]+texturePos[1])*0.5;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[1]=texturePos[1];</td><td> </td><td class="right">                       ta[1]=texturePos[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[2]=texturePos[2];</td><td> </td><td class="right">                       ta[2]=texturePos[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0025" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               projectSphericalTriangle(clippingCap, va, outVertices, ta, o</td><td> </td><td class="rblock">               <span class="insert">if (outColors)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">utTexturePos, maxSqDistortion, nbI+1, true, false, true);</td><td> </td><td class="rblock"><span class="insert">               {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       ca[0]=(colors[0]+colors[1])*0.5;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       ca[1]=colors[1];</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       ca[2]=colors[2];</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">               projectSphericalTriangle(clippingCap, va, outVertices, ta, o</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">utTexturePos, <span class="insert">ca, outColors,</span> maxSqDistortion, nbI+1, true, false, true);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return;</td><td> </td><td class="right">               return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (!cDiscontinuity1 &amp;&amp; cDiscontinuity2 &amp;&amp; cDiscontinuity3)</td><td> </td><td class="right">       if (!cDiscontinuity1 &amp;&amp; cDiscontinuity2 &amp;&amp; cDiscontinuity3)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[0]=vertices[0];</td><td> </td><td class="right">               va[0]=vertices[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[1]=vertices[1];</td><td> </td><td class="right">               va[1]=vertices[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[2]=vertices[1];va[2]+=vertices[2];</td><td> </td><td class="right">               va[2]=vertices[1];va[2]+=vertices[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[2].normalize();</td><td> </td><td class="right">               va[2].normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               if (outTexturePos)</td><td> </td><td class="right">               if (outTexturePos)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[0]=texturePos[0];</td><td> </td><td class="right">                       ta[0]=texturePos[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[1]=texturePos[1];</td><td> </td><td class="right">                       ta[1]=texturePos[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[2]=(texturePos[1]+texturePos[2])*0.5;</td><td> </td><td class="right">                       ta[2]=(texturePos[1]+texturePos[2])*0.5;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0026" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               projectSphericalTriangle(clippingCap, va, outVertices, ta, o</td><td> </td><td class="rblock">               <span class="insert">if (outColors)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">utTexturePos, maxSqDistortion, nbI+1, false, true, true);</td><td> </td><td class="rblock"><span class="insert">               {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       ca[0]=colors[0];</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       ca[1]=colors[1];</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       ca[2]=(colors[1]+colors[2])*0.5;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">               projectSphericalTriangle(clippingCap, va, outVertices, ta, o</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">utTexturePos, <span class="insert">ca, outColors,</span> maxSqDistortion, nbI+1, false, true, true);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               //va[0]=vertices[1]+vertices[2];</td><td> </td><td class="right">               //va[0]=vertices[1]+vertices[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               //va[0].normalize();</td><td> </td><td class="right">               //va[0].normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[0]=va[2];</td><td> </td><td class="right">               va[0]=va[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[1]=vertices[2];</td><td> </td><td class="right">               va[1]=vertices[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[2]=vertices[0];va[2]+=vertices[2];</td><td> </td><td class="right">               va[2]=vertices[0];va[2]+=vertices[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[2].normalize();</td><td> </td><td class="right">               va[2].normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               if (outTexturePos)</td><td> </td><td class="right">               if (outTexturePos)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[0]=(texturePos[1]+texturePos[2])*0.5;</td><td> </td><td class="right">                       ta[0]=(texturePos[1]+texturePos[2])*0.5;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[1]=texturePos[2];</td><td> </td><td class="right">                       ta[1]=texturePos[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[2]=(texturePos[0]+texturePos[2])*0.5;</td><td> </td><td class="right">                       ta[2]=(texturePos[0]+texturePos[2])*0.5;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0027" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               projectSphericalTriangle(clippingCap, va, outVertices, ta, o</td><td> </td><td class="rblock">               <span class="insert">if (outColors)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">utTexturePos, maxSqDistortion, nbI+1);</td><td> </td><td class="rblock"><span class="insert">               {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       ca[0]=(colors[1]+colors[2])*0.5;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       ca[1]=colors[2];</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       ca[2]=(colors[0]+colors[2])*0.5;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">               projectSphericalTriangle(clippingCap, va, outVertices, ta, o</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">utTexturePos, <span class="insert">ca, outColors,</span> maxSqDistortion, nbI+1);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[1]=va[0];</td><td> </td><td class="right">               va[1]=va[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               va[0]=vertices[0];</td><td> </td><td class="right">               va[0]=vertices[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               //va[1]=vertices[1]+vertices[2];</td><td> </td><td class="right">               //va[1]=vertices[1]+vertices[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               //va[1].normalize();</td><td> </td><td class="right">               //va[1].normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               //va[2]=vertices[0]+vertices[2];</td><td> </td><td class="right">               //va[2]=vertices[0]+vertices[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               //va[2].normalize();</td><td> </td><td class="right">               //va[2].normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               if (outTexturePos)</td><td> </td><td class="right">               if (outTexturePos)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[0]=texturePos[0];</td><td> </td><td class="right">                       ta[0]=texturePos[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[1]=(texturePos[1]+texturePos[2])*0.5;</td><td> </td><td class="right">                       ta[1]=(texturePos[1]+texturePos[2])*0.5;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       ta[2]=(texturePos[0]+texturePos[2])*0.5;</td><td> </td><td class="right">                       ta[2]=(texturePos[0]+texturePos[2])*0.5;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0028" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               projectSphericalTriangle(clippingCap, va, outVertices, ta, o</td><td> </td><td class="rblock">               <span class="insert">if (outColors)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">utTexturePos, maxSqDistortion, nbI+1);</td><td> </td><td class="rblock"><span class="insert">               {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       ca[0]=colors[0];</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       ca[1]=(colors[1]+colors[2])*0.5;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       ca[2]=(colors[0]+colors[2])*0.5;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">               projectSphericalTriangle(clippingCap, va, outVertices, ta, o</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">utTexturePos, <span class="insert">ca, outColors,</span> maxSqDistortion, nbI+1);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return;</td><td> </td><td class="right">               return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Last case: the 3 sides have to be split: cut in 4 triangles a' la
 HTM</td><td> </td><td class="right">       // Last case: the 3 sides have to be split: cut in 4 triangles a' la
 HTM</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       va[0]=vertices[0];va[0]+=vertices[1];</td><td> </td><td class="right">       va[0]=vertices[0];va[0]+=vertices[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       va[0].normalize();</td><td> </td><td class="right">       va[0].normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       va[1]=vertices[1];va[1]+=vertices[2];</td><td> </td><td class="right">       va[1]=vertices[1];va[1]+=vertices[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       va[1].normalize();</td><td> </td><td class="right">       va[1].normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       va[2]=vertices[0];va[2]+=vertices[2];</td><td> </td><td class="right">       va[2]=vertices[0];va[2]+=vertices[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       va[2].normalize();</td><td> </td><td class="right">       va[2].normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (outTexturePos)</td><td> </td><td class="right">       if (outTexturePos)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               ta[0]=(texturePos[0]+texturePos[1])*0.5;</td><td> </td><td class="right">               ta[0]=(texturePos[0]+texturePos[1])*0.5;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               ta[1]=(texturePos[1]+texturePos[2])*0.5;</td><td> </td><td class="right">               ta[1]=(texturePos[1]+texturePos[2])*0.5;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               ta[2]=(texturePos[0]+texturePos[2])*0.5;</td><td> </td><td class="right">               ta[2]=(texturePos[0]+texturePos[2])*0.5;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0029" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       projectSphericalTriangle(clippingCap, va, outVertices, ta, outTextur</td><td> </td><td class="rblock">       <span class="insert">if (outColors)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">ePos, maxSqDistortion, nbI+1);</td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               ca[0]=(colors[0]+colors[1])*0.5;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               ca[1]=(colors[1]+colors[2])*0.5;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               ca[2]=(colors[0]+colors[2])*0.5;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       projectSphericalTriangle(clippingCap, va, outVertices, ta, outTextur</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">ePos, <span class="insert">ca, outColors,</span> maxSqDistortion, nbI+1);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       va[1]=va[0];</td><td> </td><td class="right">       va[1]=va[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       va[0]=vertices[0];</td><td> </td><td class="right">       va[0]=vertices[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //va[1]=vertices[0]+vertices[1];</td><td> </td><td class="right">       //va[1]=vertices[0]+vertices[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //va[1].normalize();</td><td> </td><td class="right">       //va[1].normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //va[2]=vertices[0]+vertices[2];</td><td> </td><td class="right">       //va[2]=vertices[0]+vertices[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //va[2].normalize();</td><td> </td><td class="right">       //va[2].normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (outTexturePos)</td><td> </td><td class="right">       if (outTexturePos)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               ta[0]=texturePos[0];</td><td> </td><td class="right">               ta[0]=texturePos[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               ta[1]=(texturePos[0]+texturePos[1])*0.5;</td><td> </td><td class="right">               ta[1]=(texturePos[0]+texturePos[1])*0.5;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               ta[2]=(texturePos[0]+texturePos[2])*0.5;</td><td> </td><td class="right">               ta[2]=(texturePos[0]+texturePos[2])*0.5;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0030" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       projectSphericalTriangle(clippingCap, va, outVertices, ta, outTextur</td><td> </td><td class="rblock">       <span class="insert">if (outColors)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">ePos, maxSqDistortion, nbI+1);</td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               ca[0]=colors[0];</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               ca[1]=(colors[0]+colors[1])*0.5;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               ca[2]=(colors[0]+colors[2])*0.5;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       projectSphericalTriangle(clippingCap, va, outVertices, ta, outTextur</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">ePos, <span class="insert">ca, outColors,</span> maxSqDistortion, nbI+1);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //va[0]=vertices[0]+vertices[1];</td><td> </td><td class="right">       //va[0]=vertices[0]+vertices[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //va[0].normalize();</td><td> </td><td class="right">       //va[0].normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       va[0]=va[1];</td><td> </td><td class="right">       va[0]=va[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       va[1]=vertices[1];</td><td> </td><td class="right">       va[1]=vertices[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       va[2]=vertices[1];va[2]+=vertices[2];</td><td> </td><td class="right">       va[2]=vertices[1];va[2]+=vertices[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       va[2].normalize();</td><td> </td><td class="right">       va[2].normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (outTexturePos)</td><td> </td><td class="right">       if (outTexturePos)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               ta[0]=(texturePos[0]+texturePos[1])*0.5;</td><td> </td><td class="right">               ta[0]=(texturePos[0]+texturePos[1])*0.5;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               ta[1]=texturePos[1];</td><td> </td><td class="right">               ta[1]=texturePos[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               ta[2]=(texturePos[1]+texturePos[2])*0.5;</td><td> </td><td class="right">               ta[2]=(texturePos[1]+texturePos[2])*0.5;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0031" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       projectSphericalTriangle(clippingCap, va, outVertices, ta, outTextur</td><td> </td><td class="rblock">       <span class="insert">if (outColors)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">ePos, maxSqDistortion, nbI+1);</td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               ca[0]=(colors[0]+colors[1])*0.5;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               ca[1]=colors[1];</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               ca[2]=(colors[1]+colors[2])*0.5;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       projectSphericalTriangle(clippingCap, va, outVertices, ta, outTextur</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">ePos, <span class="insert">ca, outColors,</span> maxSqDistortion, nbI+1);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       va[0]=vertices[0];va[0]+=vertices[2];</td><td> </td><td class="right">       va[0]=vertices[0];va[0]+=vertices[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       va[0].normalize();</td><td> </td><td class="right">       va[0].normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //va[1]=vertices[1]+vertices[2];</td><td> </td><td class="right">       //va[1]=vertices[1]+vertices[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //va[1].normalize();</td><td> </td><td class="right">       //va[1].normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       va[1]=va[2];</td><td> </td><td class="right">       va[1]=va[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       va[2]=vertices[2];</td><td> </td><td class="right">       va[2]=vertices[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (outTexturePos)</td><td> </td><td class="right">       if (outTexturePos)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               ta[0]=(texturePos[0]+texturePos[2])*0.5;</td><td> </td><td class="right">               ta[0]=(texturePos[0]+texturePos[2])*0.5;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               ta[1]=(texturePos[1]+texturePos[2])*0.5;</td><td> </td><td class="right">               ta[1]=(texturePos[1]+texturePos[2])*0.5;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               ta[2]=texturePos[2];</td><td> </td><td class="right">               ta[2]=texturePos[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0032" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       projectSphericalTriangle(clippingCap, va, outVertices, ta, outTextur</td><td> </td><td class="rblock">       <span class="insert">if (outColors)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">ePos, maxSqDistortion, nbI+1);</td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               ca[0]=(colors[0]+colors[2])*0.5;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               ca[1]=(colors[1]+colors[2])*0.5;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               ca[2]=colors[2];</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       projectSphericalTriangle(clippingCap, va, outVertices, ta, outTextur</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">ePos, <span class="insert">ca, outColors,</span> maxSqDistortion, nbI+1);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       return;</td><td> </td><td class="right">       return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">static QVarLengthArray&lt;Vec3f, 4096&gt; polygonVertexArray;</td><td> </td><td class="right">static QVarLengthArray&lt;Vec3f, 4096&gt; polygonVertexArray;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">static QVarLengthArray&lt;Vec2f, 4096&gt; polygonTextureCoordArray;</td><td> </td><td class="right">static QVarLengthArray&lt;Vec2f, 4096&gt; polygonTextureCoordArray;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0033" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">static QVarLengthArray&lt;Vec3f, 4096&gt; polygonColorArray;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">static QVarLengthArray&lt;unsigned int, 4096&gt; indexArray;</td><td> </td><td class="right">static QVarLengthArray&lt;unsigned int, 4096&gt; indexArray;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void StelPainter::drawGreatCircleArcs(const StelVertexArray&amp; va, const Sphe
ricalCap* clippingCap)</td><td> </td><td class="right">void StelPainter::drawGreatCircleArcs(const StelVertexArray&amp; va, const Sphe
ricalCap* clippingCap)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Q_ASSERT(va.vertex.size()!=1);</td><td> </td><td class="right">       Q_ASSERT(va.vertex.size()!=1);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Q_ASSERT(!va.isIndexed());      // Indexed unsupported yet</td><td> </td><td class="right">       Q_ASSERT(!va.isIndexed());      // Indexed unsupported yet</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       switch (va.primitiveType)</td><td> </td><td class="right">       switch (va.primitiveType)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               case StelVertexArray::Lines:</td><td> </td><td class="right">               case StelVertexArray::Lines:</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       Q_ASSERT(va.vertex.size()%2==0);</td><td> </td><td class="right">                       Q_ASSERT(va.vertex.size()%2==0);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l11" /><small>skipping to change at</small><em> line 1092</em></th><th> </th><th><a name="part-r11" /><small>skipping to change at</small><em> line 1216</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// The function object that we use as an interface between VertexArray::for
eachTriangle and</td><td> </td><td class="right">// The function object that we use as an interface between VertexArray::for
eachTriangle and</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// StelPainter::projectSphericalTriangle.</td><td> </td><td class="right">// StelPainter::projectSphericalTriangle.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//</td><td> </td><td class="right">//</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// This is used by drawSphericalTriangles to project all the triangles coor
dinates in a StelVertexArray into our global</td><td> </td><td class="right">// This is used by drawSphericalTriangles to project all the triangles coor
dinates in a StelVertexArray into our global</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// vertex array buffer.</td><td> </td><td class="right">// vertex array buffer.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">class VertexArrayProjector</td><td> </td><td class="right">class VertexArrayProjector</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">public:</td><td> </td><td class="right">public:</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       VertexArrayProjector(const StelVertexArray&amp; ar, StelPainter* apainte
r, const SphericalCap* aclippingCap,</td><td> </td><td class="right">       VertexArrayProjector(const StelVertexArray&amp; ar, StelPainter* apainte
r, const SphericalCap* aclippingCap,</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0034" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                                QVarLengthArray&lt;Vec3f, 4096
&gt;* aoutVertices, QVarLengthArray&lt;Vec2f, 4096&gt;* aoutTexturePos=NULL, <span class="delete">double 
</span>amaxSqDistortion=5.)</td><td> </td><td class="rblock">                                                QVarLengthArray&lt;Vec3f, 4096
&gt;* aoutVertices, QVarLengthArray&lt;Vec2f, 4096&gt;* aoutTexturePos=NULL, <span class="insert">QVarLen
gthArray&lt;Vec3f, 4096&gt;* aoutColors=NULL, double </span>amaxSqDistortion=5.)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                  : vertexArray(ar), painter(apainter), clippingCap(aclippi
ngCap), outVertices(aoutVertices),</td><td> </td><td class="right">                  : vertexArray(ar), painter(apainter), clippingCap(aclippi
ngCap), outVertices(aoutVertices),</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0035" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                        out<span class="delete">TexturePos(aoutTexturePos), maxSqDistortion(amax
</span>SqDistortion)</td><td> </td><td class="rblock">                        out<span class="insert">Colors(aoutColors), outTexturePos(aoutTexturePos
), maxSqDistortion(amax</span>SqDistortion)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Project a single triangle and add it into the output arrays</td><td> </td><td class="right">       // Project a single triangle and add it into the output arrays</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       inline void operator()(const Vec3d* v0, const Vec3d* v1, const Vec3d
* v2,</td><td> </td><td class="right">       inline void operator()(const Vec3d* v0, const Vec3d* v1, const Vec3d
* v2,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                                                  const Vec2f* t0, const Ve
c2f* t1, const Vec2f* t2,</td><td> </td><td class="right">                                                  const Vec2f* t0, const Ve
c2f* t1, const Vec2f* t2,</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0036" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                                  const Vec3f* c0, const Ve
c3f* c1, const Vec3f* c2,</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                                                  unsigned int, unsigned in
t, unsigned)</td><td> </td><td class="right">                                                  unsigned int, unsigned in
t, unsigned)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               // XXX: we may optimize more by putting the declaration and 
the test outside of this method.</td><td> </td><td class="right">               // XXX: we may optimize more by putting the declaration and 
the test outside of this method.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               const Vec3d tmpVertex[3] = {*v0, *v1, *v2};</td><td> </td><td class="right">               const Vec3d tmpVertex[3] = {*v0, *v1, *v2};</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0037" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               if (outTexturePos)</td><td> </td><td class="rblock">               if <span class="insert">( (outTexturePos) &amp;&amp; (outColors))</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       const Vec2f tmpTexture[3] = {*t0, *t1, *t2};</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       const Vec3f tmpColor[3] = {*c0, *c1, *c2};</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       painter-&gt;projectSphericalTriangle(clippingCap, tmpVe</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">rtex, outVertices, tmpTexture, outTexturePos, tmpColor, outColors, maxSqDis</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">tortion);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               else if</span> (outTexturePos)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       const Vec2f tmpTexture[3] = {*t0, *t1, *t2};</td><td> </td><td class="right">                       const Vec2f tmpTexture[3] = {*t0, *t1, *t2};</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0038" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       painter-&gt;projectSphericalTriangle(clippingCap, tmpVe</td><td> </td><td class="rblock">                       painter-&gt;projectSphericalTriangle(clippingCap, tmpVe</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">rtex, outVertices, tmpTexture, outTexturePos, maxSqDistortion);</td><td> </td><td class="rblock">rtex, outVertices, tmpTexture, outTexturePos, <span class="insert">NULL, NULL, maxSqDistortion);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               else if (outColors)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       const Vec3f tmpColor[3] = {*c0, *c1, *c2};</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       painter-&gt;projectSphericalTriangle(clippingCap, tmpVe</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">rtex, outVertices, NULL, NULL, tmpColor, outColors,</span> maxSqDistortion);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               else</td><td> </td><td class="right">               else</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0039" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       painter-&gt;projectSphericalTriangle(clippingCap, tmpVe
rtex, outVertices, NULL, NULL, maxSqDistortion);</td><td> </td><td class="rblock">                       painter-&gt;projectSphericalTriangle(clippingCap, tmpVe
rtex, outVertices, NULL, NULL, <span class="insert">NULL, NULL, </span>maxSqDistortion);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Draw the resulting arrays</td><td> </td><td class="right">       // Draw the resulting arrays</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       void drawResult()</td><td> </td><td class="right">       void drawResult()</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               painter-&gt;setVertexPointer(3, GL_FLOAT, outVertices-&gt;constDat
a());</td><td> </td><td class="right">               painter-&gt;setVertexPointer(3, GL_FLOAT, outVertices-&gt;constDat
a());</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               if (outTexturePos)</td><td> </td><td class="right">               if (outTexturePos)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       painter-&gt;setTexCoordPointer(2, GL_FLOAT, outTextureP
os-&gt;constData());</td><td> </td><td class="right">                       painter-&gt;setTexCoordPointer(2, GL_FLOAT, outTextureP
os-&gt;constData());</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0040" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               painter-&gt;enableClientStates(true, outTexturePos != NULL);</td><td> </td><td class="rblock">               <span class="insert">if (outColors)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       painter-&gt;setColorPointer(3, GL_FLOAT, outColors-&gt;con</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">stData());</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">               painter-&gt;enableClientStates(true, outTexturePos <span class="insert">!= NULL, out</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">Colors</span> != NULL);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               painter-&gt;drawFromArray(StelPainter::Triangles, outVertices-&gt;
size(), 0, false);</td><td> </td><td class="right">               painter-&gt;drawFromArray(StelPainter::Triangles, outVertices-&gt;
size(), 0, false);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               painter-&gt;enableClientStates(false);</td><td> </td><td class="right">               painter-&gt;enableClientStates(false);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">private:</td><td> </td><td class="right">private:</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const StelVertexArray&amp; vertexArray;</td><td> </td><td class="right">       const StelVertexArray&amp; vertexArray;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       StelPainter* painter;</td><td> </td><td class="right">       StelPainter* painter;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const SphericalCap* clippingCap;</td><td> </td><td class="right">       const SphericalCap* clippingCap;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       QVarLengthArray&lt;Vec3f, 4096&gt;* outVertices;</td><td> </td><td class="right">       QVarLengthArray&lt;Vec3f, 4096&gt;* outVertices;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0041" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       QVarLengthArray&lt;Vec3f, 4096&gt;* outColors;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       QVarLengthArray&lt;Vec2f, 4096&gt;* outTexturePos;</td><td> </td><td class="right">       QVarLengthArray&lt;Vec2f, 4096&gt;* outTexturePos;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       double maxSqDistortion;</td><td> </td><td class="right">       double maxSqDistortion;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">};</td><td> </td><td class="right">};</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0042" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">void StelPainter::drawStelVertexArray(const StelVertexArray&amp; arr, <span class="delete">const boo
l chec</span>kDiscontinuity)</td><td> </td><td class="rblock">void StelPainter::drawStelVertexArray(const StelVertexArray&amp; arr, <span class="insert">bool chec
</span>kDiscontinuity)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (checkDiscontinuity &amp;&amp; prj-&gt;hasDiscontinuity())</td><td> </td><td class="right">       if (checkDiscontinuity &amp;&amp; prj-&gt;hasDiscontinuity())</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               // The projection has discontinuities, so we need to make su
re that no triangle is crossing them.</td><td> </td><td class="right">               // The projection has discontinuities, so we need to make su
re that no triangle is crossing them.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               drawStelVertexArray(arr.removeDiscontinuousTriangles(this-&gt;g
etProjector().data()), false);</td><td> </td><td class="right">               drawStelVertexArray(arr.removeDiscontinuousTriangles(this-&gt;g
etProjector().data()), false);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return;</td><td> </td><td class="right">               return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       setVertexPointer(3, GL_DOUBLE, arr.vertex.constData());</td><td> </td><td class="right">       setVertexPointer(3, GL_DOUBLE, arr.vertex.constData());</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (arr.isTextured())</td><td> </td><td class="right">       if (arr.isTextured())</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               setTexCoordPointer(2, GL_FLOAT, arr.texCoords.constData());</td><td> </td><td class="right">               setTexCoordPointer(2, GL_FLOAT, arr.texCoords.constData());</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0043" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               enableClientStates(true, true);</td><td> </td><td class="rblock">               <span class="insert">if (arr.isColored())</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       setColorPointer(3, GL_FLOAT, arr.colors.constData())</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                       enableClientStates(true, <span class="insert">true,</span> true);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">               <span class="insert">}</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               else</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       enableClientStates(true, true, false);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       else</td><td> </td><td class="right">       else</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0044" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               enableClientStates(true, false);</td><td> </td><td class="rblock">               <span class="insert">if (arr.isColored())</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       setColorPointer(3, GL_FLOAT, arr.colors.constData())</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                       enableClientStates(true, <span class="insert">false, true);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               else</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       enableClientStates(true, false,</span> false);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (arr.isIndexed())</td><td> </td><td class="right">       if (arr.isIndexed())</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               drawFromArray((StelPainter::DrawingMode)arr.primitiveType, a
rr.indices.size(), 0, true, arr.indices.constData());</td><td> </td><td class="right">               drawFromArray((StelPainter::DrawingMode)arr.primitiveType, a
rr.indices.size(), 0, true, arr.indices.constData());</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       else</td><td> </td><td class="right">       else</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               drawFromArray((StelPainter::DrawingMode)arr.primitiveType, a
rr.vertex.size());</td><td> </td><td class="right">               drawFromArray((StelPainter::DrawingMode)arr.primitiveType, a
rr.vertex.size());</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       enableClientStates(false);</td><td> </td><td class="right">       enableClientStates(false);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0045" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">void StelPainter::drawSphericalTriangles(const StelVertexArray&amp; va, <span class="delete">const b
ool textured, const SphericalCap* clippingCap, const bool doSubDivide, cons
t do</span>uble maxSqDistortion)</td><td> </td><td class="rblock">void StelPainter::drawSphericalTriangles(const StelVertexArray&amp; va, <span class="insert">bool te
xtured, bool colored, const SphericalCap* clippingCap, bool doSubDivide, do
</span>uble maxSqDistortion)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (va.vertex.isEmpty())</td><td> </td><td class="right">       if (va.vertex.isEmpty())</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return;</td><td> </td><td class="right">               return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Q_ASSERT(va.vertex.size()&gt;2);</td><td> </td><td class="right">       Q_ASSERT(va.vertex.size()&gt;2);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       polygonVertexArray.clear();</td><td> </td><td class="right">       polygonVertexArray.clear();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       polygonTextureCoordArray.clear();</td><td> </td><td class="right">       polygonTextureCoordArray.clear();</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0046" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                                                           </span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       indexArray.clear();</td><td> </td><td class="right">       indexArray.clear();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (!doSubDivide)</td><td> </td><td class="right">       if (!doSubDivide)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               // The simplest case, we don't need to iterate through the t
riangles at all.</td><td> </td><td class="right">               // The simplest case, we don't need to iterate through the t
riangles at all.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               drawStelVertexArray(va);</td><td> </td><td class="right">               drawStelVertexArray(va);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return;</td><td> </td><td class="right">               return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // the last case.  It is the slowest, it process the triangles one b
y one.</td><td> </td><td class="right">       // the last case.  It is the slowest, it process the triangles one b
y one.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               // Project all the triangles of the VertexArray into our buf
fer arrays.</td><td> </td><td class="right">               // Project all the triangles of the VertexArray into our buf
fer arrays.</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0047" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               VertexArrayProjector result = va.foreachTriangle(VertexArray
Projector(va, this, clippingCap, &amp;polygonVertexArray, textured ? &amp;polygonTe
xtureCoordArray : NULL, <span class="delete">maxSqDistortio</span>n));</td><td> </td><td class="rblock">               VertexArrayProjector result = va.foreachTriangle(VertexArray
Projector(va, this, clippingCap, &amp;polygonVertexArray, textured ? &amp;polygonTe
xtureCoordArray : NULL, <span class="insert">colored ? &amp;polygonColorArray : NULL, maxSqDistortio
</span>n));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               result.drawResult();</td><td> </td><td class="right">               result.drawResult();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return;</td><td> </td><td class="right">               return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// Draw the given SphericalPolygon.</td><td> </td><td class="right">// Draw the given SphericalPolygon.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void StelPainter::drawSphericalRegion(const SphericalRegion* poly, Spherica
lPolygonDrawMode drawMode, const SphericalCap* clippingCap, const bool doSu
bDivise, const double maxSqDistortion)</td><td> </td><td class="right">void StelPainter::drawSphericalRegion(const SphericalRegion* poly, Spherica
lPolygonDrawMode drawMode, const SphericalCap* clippingCap, const bool doSu
bDivise, const double maxSqDistortion)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (!prj-&gt;getBoundingCap().intersects(poly-&gt;getBoundingCap()))</td><td> </td><td class="right">       if (!prj-&gt;getBoundingCap().intersects(poly-&gt;getBoundingCap()))</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return;</td><td> </td><td class="right">               return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l12" /><small>skipping to change at</small><em> line 1203</em></th><th> </th><th><a name="part-r12" /><small>skipping to change at</small><em> line 1356</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       switch (drawMode)</td><td> </td><td class="right">       switch (drawMode)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               case SphericalPolygonDrawModeBoundary:</td><td> </td><td class="right">               case SphericalPolygonDrawModeBoundary:</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       if (doSubDivise || prj-&gt;intersectViewportDiscontinui
ty(poly-&gt;getBoundingCap()))</td><td> </td><td class="right">                       if (doSubDivise || prj-&gt;intersectViewportDiscontinui
ty(poly-&gt;getBoundingCap()))</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               drawGreatCircleArcs(poly-&gt;getOutlineVertexAr
ray(), clippingCap);</td><td> </td><td class="right">                               drawGreatCircleArcs(poly-&gt;getOutlineVertexAr
ray(), clippingCap);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       else</td><td> </td><td class="right">                       else</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               drawStelVertexArray(poly-&gt;getOutlineVertexAr
ray(), false);</td><td> </td><td class="right">                               drawStelVertexArray(poly-&gt;getOutlineVertexAr
ray(), false);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       break;</td><td> </td><td class="right">                       break;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               case SphericalPolygonDrawModeFill:</td><td> </td><td class="right">               case SphericalPolygonDrawModeFill:</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               case SphericalPolygonDrawModeTextureFill:</td><td> </td><td class="right">               case SphericalPolygonDrawModeTextureFill:</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0048" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               case SphericalPolygonDrawModeTextureFillColormodulated:</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       glEnable(GL_CULL_FACE);</td><td> </td><td class="right">                       glEnable(GL_CULL_FACE);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       // The polygon is already tesselated as triangles</td><td> </td><td class="right">                       // The polygon is already tesselated as triangles</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       if (doSubDivise || prj-&gt;intersectViewportDiscontinui
ty(poly-&gt;getBoundingCap()))</td><td> </td><td class="right">                       if (doSubDivise || prj-&gt;intersectViewportDiscontinui
ty(poly-&gt;getBoundingCap()))</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0049" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                               drawSphericalTriangles(poly-&gt;getFillVertexAr</td><td> </td><td class="rblock">                               <span class="insert">// flag for color-modulated textured mode (e</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">ray(), <span class="delete">drawMode==SphericalPolygonDrawModeTextureFill,</span> clippingCap, <span class="delete">doSubDiv</span></td><td> </td><td class="rblock"><span class="insert">.g. for Milky Way/extincted)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">ise, maxSqDistortion);</span></td><td> </td><td class="rblock">                               drawSphericalTriangles(poly-&gt;getFillVertexAr</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">ray(), <span class="insert">drawMode&gt;=SphericalPolygonDrawModeTextureFill, drawMode==SphericalPo</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">lygonDrawModeTextureFillColormodulated,</span> clippingCap, <span class="insert">doSubDivise, maxSqDist</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ortion);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       else</td><td> </td><td class="right">                       else</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               drawStelVertexArray(poly-&gt;getFillVertexArray
(), false);</td><td> </td><td class="right">                               drawStelVertexArray(poly-&gt;getFillVertexArray
(), false);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       glDisable(GL_CULL_FACE);</td><td> </td><td class="right">                       glDisable(GL_CULL_FACE);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       break;</td><td> </td><td class="right">                       break;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               default:</td><td> </td><td class="right">               default:</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       Q_ASSERT(0);</td><td> </td><td class="right">                       Q_ASSERT(0);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">/*************************************************************************</td><td> </td><td class="right">/*************************************************************************</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"> draw a simple circle, 2d viewport coordinates in pixel</td><td> </td><td class="right"> draw a simple circle, 2d viewport coordinates in pixel</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">*************************************************************************/</td><td> </td><td class="right">*************************************************************************/</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0050" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">void StelPainter::drawCircle(<span class="delete">const float x, const</span> float y, float r)</td><td> </td><td class="rblock">void StelPainter::drawCircle(<span class="insert">float x,</span> float y, float r)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (r &lt;= 1.0)</td><td> </td><td class="right">       if (r &lt;= 1.0)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return;</td><td> </td><td class="right">               return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const Vec2f center(x,y);</td><td> </td><td class="right">       const Vec2f center(x,y);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const Vec2f v_center(0.5f*prj-&gt;viewportXywh[2],0.5f*prj-&gt;viewportXyw
h[3]);</td><td> </td><td class="right">       const Vec2f v_center(0.5f*prj-&gt;viewportXywh[2],0.5f*prj-&gt;viewportXyw
h[3]);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const float R = v_center.length();</td><td> </td><td class="right">       const float R = v_center.length();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const float d = (v_center-center).length();</td><td> </td><td class="right">       const float d = (v_center-center).length();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (d &gt; r+R || d &lt; r-R)</td><td> </td><td class="right">       if (d &gt; r+R || d &lt; r-R)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return;</td><td> </td><td class="right">               return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const int segments = 180;</td><td> </td><td class="right">       const int segments = 180;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l13" /><small>skipping to change at</small><em> line 1251</em></th><th> </th><th><a name="part-r13" /><small>skipping to change at</small><em> line 1406</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               r = dx*cp-dy*sp;</td><td> </td><td class="right">               r = dx*cp-dy*sp;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               dy = dx*sp+dy*cp;</td><td> </td><td class="right">               dy = dx*sp+dy*cp;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               dx = r;</td><td> </td><td class="right">               dx = r;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       enableClientStates(true);</td><td> </td><td class="right">       enableClientStates(true);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       setVertexPointer(3, GL_FLOAT, circleVertexArray.data());</td><td> </td><td class="right">       setVertexPointer(3, GL_FLOAT, circleVertexArray.data());</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       drawFromArray(LineLoop, 180, 0, false);</td><td> </td><td class="right">       drawFromArray(LineLoop, 180, 0, false);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       enableClientStates(false);</td><td> </td><td class="right">       enableClientStates(false);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0051" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">void StelPainter::drawSprite2dMode(<span class="delete">const float x, const float y, float radi
</span>us)</td><td> </td><td class="rblock">void StelPainter::drawSprite2dMode(<span class="insert">float x, float y, float radi</span>us)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       static float vertexData[] = {-10.,-10.,10.,-10., 10.,10., -10.,10.};</td><td> </td><td class="right">       static float vertexData[] = {-10.,-10.,10.,-10., 10.,10., -10.,10.};</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       static const float texCoordData[] = {0.,0., 1.,0., 0.,1., 1.,1.};</td><td> </td><td class="right">       static const float texCoordData[] = {0.,0., 1.,0., 0.,1., 1.,1.};</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Takes into account device pixel density and global scale ratio, a
s we are drawing 2D stuff.</td><td> </td><td class="right">       // Takes into account device pixel density and global scale ratio, a
s we are drawing 2D stuff.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       radius *= prj-&gt;getDevicePixelsPerPixel()*StelApp::getInstance().getG
lobalScalingRatio();</td><td> </td><td class="right">       radius *= prj-&gt;getDevicePixelsPerPixel()*StelApp::getInstance().getG
lobalScalingRatio();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       vertexData[0]=x-radius; vertexData[1]=y-radius;</td><td> </td><td class="right">       vertexData[0]=x-radius; vertexData[1]=y-radius;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       vertexData[2]=x+radius; vertexData[3]=y-radius;</td><td> </td><td class="right">       vertexData[2]=x+radius; vertexData[3]=y-radius;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       vertexData[4]=x-radius; vertexData[5]=y+radius;</td><td> </td><td class="right">       vertexData[4]=x-radius; vertexData[5]=y+radius;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       vertexData[6]=x+radius; vertexData[7]=y+radius;</td><td> </td><td class="right">       vertexData[6]=x+radius; vertexData[7]=y+radius;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       enableClientStates(true, true);</td><td> </td><td class="right">       enableClientStates(true, true);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       setVertexPointer(2, GL_FLOAT, vertexData);</td><td> </td><td class="right">       setVertexPointer(2, GL_FLOAT, vertexData);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       setTexCoordPointer(2, GL_FLOAT, texCoordData);</td><td> </td><td class="right">       setTexCoordPointer(2, GL_FLOAT, texCoordData);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       drawFromArray(TriangleStrip, 4, 0, false);</td><td> </td><td class="right">       drawFromArray(TriangleStrip, 4, 0, false);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       enableClientStates(false);</td><td> </td><td class="right">       enableClientStates(false);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0052" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">void StelPainter::drawSprite2dModeNoDeviceScale(<span class="delete">const float x, const float 
y, const float rad</span>ius)</td><td> </td><td class="rblock">void StelPainter::drawSprite2dModeNoDeviceScale(<span class="insert">float x, float y, float rad
</span>ius)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       drawSprite2dMode(x, y, radius/(prj-&gt;getDevicePixelsPerPixel()*StelAp
p::getInstance().getGlobalScalingRatio()));</td><td> </td><td class="right">       drawSprite2dMode(x, y, radius/(prj-&gt;getDevicePixelsPerPixel()*StelAp
p::getInstance().getGlobalScalingRatio()));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0053" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">void StelPainter::drawSprite2dMode(const Vec3d&amp; v, <span class="delete">const </span>float radius)</td><td> </td><td class="rblock">void StelPainter::drawSprite2dMode(const Vec3d&amp; v, float radius)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Vec3d win;</td><td> </td><td class="right">       Vec3d win;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (prj-&gt;project(v, win))</td><td> </td><td class="right">       if (prj-&gt;project(v, win))</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               drawSprite2dMode(win[0], win[1], radius);</td><td> </td><td class="right">               drawSprite2dMode(win[0], win[1], radius);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0054" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">void StelPainter::drawSprite2dMode(<span class="delete">const float x, const float y, float radi
us, const float ro</span>tation)</td><td> </td><td class="rblock">void StelPainter::drawSprite2dMode(<span class="insert">float x, float y, float radius, float ro
</span>tation)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       static float vertexData[8];</td><td> </td><td class="right">       static float vertexData[8];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       static const float texCoordData[] = {0.,0., 1.,0., 0.,1., 1.,1.};</td><td> </td><td class="right">       static const float texCoordData[] = {0.,0., 1.,0., 0.,1., 1.,1.};</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // compute the vertex coordinates applying the translation and the r
otation</td><td> </td><td class="right">       // compute the vertex coordinates applying the translation and the r
otation</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       static const float vertexBase[] = {-1., -1., 1., -1., -1., 1., 1., 1
.};</td><td> </td><td class="right">       static const float vertexBase[] = {-1., -1., 1., -1., -1., 1., 1., 1
.};</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const float cosr = std::cos(rotation / 180 * M_PI);</td><td> </td><td class="right">       const float cosr = std::cos(rotation / 180 * M_PI);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const float sinr = std::sin(rotation / 180 * M_PI);</td><td> </td><td class="right">       const float sinr = std::sin(rotation / 180 * M_PI);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Takes into account device pixel density and global scale ratio, a
s we are drawing 2D stuff.</td><td> </td><td class="right">       // Takes into account device pixel density and global scale ratio, a
s we are drawing 2D stuff.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l14" /><small>skipping to change at</small><em> line 1308</em></th><th> </th><th><a name="part-r14" /><small>skipping to change at</small><em> line 1463</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               vertexData[i+1] = y + radius * vertexBase[i] * sinr + radius
 * vertexBase[i+1] * cosr;</td><td> </td><td class="right">               vertexData[i+1] = y + radius * vertexBase[i] * sinr + radius
 * vertexBase[i+1] * cosr;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       enableClientStates(true, true);</td><td> </td><td class="right">       enableClientStates(true, true);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       setVertexPointer(2, GL_FLOAT, vertexData);</td><td> </td><td class="right">       setVertexPointer(2, GL_FLOAT, vertexData);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       setTexCoordPointer(2, GL_FLOAT, texCoordData);</td><td> </td><td class="right">       setTexCoordPointer(2, GL_FLOAT, texCoordData);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       drawFromArray(TriangleStrip, 4, 0, false);</td><td> </td><td class="right">       drawFromArray(TriangleStrip, 4, 0, false);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       enableClientStates(false);</td><td> </td><td class="right">       enableClientStates(false);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0055" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">void StelPainter::drawRect2d(<span class="delete">const float x, const float y, const float widt
h, const float height, const b</span>ool textured)</td><td> </td><td class="rblock">void StelPainter::drawRect2d(<span class="insert">float x, float y, float width, float height, b
</span>ool textured)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       static float vertexData[] = {-10.,-10.,10.,-10., 10.,10., -10.,10.};</td><td> </td><td class="right">       static float vertexData[] = {-10.,-10.,10.,-10., 10.,10., -10.,10.};</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       static const float texCoordData[] = {0.,0., 1.,0., 0.,1., 1.,1.};</td><td> </td><td class="right">       static const float texCoordData[] = {0.,0., 1.,0., 0.,1., 1.,1.};</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       vertexData[0]=x; vertexData[1]=y;</td><td> </td><td class="right">       vertexData[0]=x; vertexData[1]=y;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       vertexData[2]=x+width; vertexData[3]=y;</td><td> </td><td class="right">       vertexData[2]=x+width; vertexData[3]=y;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       vertexData[4]=x; vertexData[5]=y+height;</td><td> </td><td class="right">       vertexData[4]=x; vertexData[5]=y+height;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       vertexData[6]=x+width; vertexData[7]=y+height;</td><td> </td><td class="right">       vertexData[6]=x+width; vertexData[7]=y+height;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (textured)</td><td> </td><td class="right">       if (textured)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               enableClientStates(true, true);</td><td> </td><td class="right">               enableClientStates(true, true);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l15" /><small>skipping to change at</small><em> line 1334</em></th><th> </th><th><a name="part-r15" /><small>skipping to change at</small><em> line 1489</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               enableClientStates(true);</td><td> </td><td class="right">               enableClientStates(true);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               setVertexPointer(2, GL_FLOAT, vertexData);</td><td> </td><td class="right">               setVertexPointer(2, GL_FLOAT, vertexData);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       drawFromArray(TriangleStrip, 4, 0, false);</td><td> </td><td class="right">       drawFromArray(TriangleStrip, 4, 0, false);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       enableClientStates(false);</td><td> </td><td class="right">       enableClientStates(false);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">/*************************************************************************</td><td> </td><td class="right">/*************************************************************************</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"> Draw a GL_POINT at the given position</td><td> </td><td class="right"> Draw a GL_POINT at the given position</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">*************************************************************************/</td><td> </td><td class="right">*************************************************************************/</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0056" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">void StelPainter::drawPoint2d(<span class="delete">const float x, const</span> float y)</td><td> </td><td class="rblock">void StelPainter::drawPoint2d(<span class="insert">float x,</span> float y)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       static float vertexData[] = {0.,0.};</td><td> </td><td class="right">       static float vertexData[] = {0.,0.};</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       vertexData[0]=x;</td><td> </td><td class="right">       vertexData[0]=x;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       vertexData[1]=y;</td><td> </td><td class="right">       vertexData[1]=y;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       enableClientStates(true);</td><td> </td><td class="right">       enableClientStates(true);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       setVertexPointer(2, GL_FLOAT, vertexData);</td><td> </td><td class="right">       setVertexPointer(2, GL_FLOAT, vertexData);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       drawFromArray(Points, 1, 0, false);</td><td> </td><td class="right">       drawFromArray(Points, 1, 0, false);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       enableClientStates(false);</td><td> </td><td class="right">       enableClientStates(false);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l16" /><small>skipping to change at</small><em> line 1365</em></th><th> </th><th><a name="part-r16" /><small>skipping to change at</small><em> line 1520</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       vertexData[3]=y2;</td><td> </td><td class="right">       vertexData[3]=y2;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       enableClientStates(true);</td><td> </td><td class="right">       enableClientStates(true);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       setVertexPointer(2, GL_FLOAT, vertexData);</td><td> </td><td class="right">       setVertexPointer(2, GL_FLOAT, vertexData);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       drawFromArray(Lines, 2, 0, false);</td><td> </td><td class="right">       drawFromArray(Lines, 2, 0, false);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       enableClientStates(false);</td><td> </td><td class="right">       enableClientStates(false);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">///////////////////////////////////////////////////////////////////////////</td><td> </td><td class="right">///////////////////////////////////////////////////////////////////////////</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// Drawing methods for general (non-linear) mode.</td><td> </td><td class="right">// Drawing methods for general (non-linear) mode.</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0057" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">// <span class="delete">GZ This used to draw a full sphere. Now it's possible to have a spherica
</span>l zone only.</td><td> </td><td class="rblock">// <span class="insert">This used to draw a full sphere. Since 0.13 it's possible to have a sphe
rica</span>l zone only.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void StelPainter::sSphere(const float radius, const float oneMinusOblatenes
s, const int slices, const int stacks, const int orientInside, const bool f
lipTexture, const float topAngle, const float bottomAngle)</td><td> </td><td class="right">void StelPainter::sSphere(const float radius, const float oneMinusOblatenes
s, const int slices, const int stacks, const int orientInside, const bool f
lipTexture, const float topAngle, const float bottomAngle)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       GLfloat x, y, z;</td><td> </td><td class="right">       GLfloat x, y, z;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       GLfloat s=0.f, t=0.f;</td><td> </td><td class="right">       GLfloat s=0.f, t=0.f;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       GLint i, j;</td><td> </td><td class="right">       GLint i, j;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       GLfloat nsign;</td><td> </td><td class="right">       GLfloat nsign;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (orientInside)</td><td> </td><td class="right">       if (orientInside)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               nsign = -1.f;</td><td> </td><td class="right">               nsign = -1.f;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               t=0.f; // from inside texture is reversed</td><td> </td><td class="right">               t=0.f; // from inside texture is reversed</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       else</td><td> </td><td class="right">       else</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               nsign = 1.f;</td><td> </td><td class="right">               nsign = 1.f;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               t=1.f;</td><td> </td><td class="right">               t=1.f;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const float* cos_sin_rho = NULL;</td><td> </td><td class="right">       const float* cos_sin_rho = NULL;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Q_ASSERT(topAngle&lt;bottomAngle); // don't forget: These are opening a
ngles counted from top.</td><td> </td><td class="right">       Q_ASSERT(topAngle&lt;bottomAngle); // don't forget: These are opening a
ngles counted from top.</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0058" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       if ((bottomAngle&gt;3.1415<span class="delete">) &amp;&amp; (topAngle&lt;0.0001</span>)) // safety margin.</td><td> </td><td class="rblock">       if ((bottomAngle&gt;3.1415<span class="insert">f) &amp;&amp; (topAngle&lt;0.0001f</span>)) // safety margin.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               cos_sin_rho = StelUtils::ComputeCosSinRho(stacks);</td><td> </td><td class="right">               cos_sin_rho = StelUtils::ComputeCosSinRho(stacks);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       else</td><td> </td><td class="right">       else</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               const float drho = (bottomAngle-topAngle) / stacks; // delta
Rho:  originally just 180degrees/stacks, now the range clamped.</td><td> </td><td class="right">               const float drho = (bottomAngle-topAngle) / stacks; // delta
Rho:  originally just 180degrees/stacks, now the range clamped.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               cos_sin_rho = StelUtils::ComputeCosSinRhoZone(drho, stacks, 
M_PI-bottomAngle);</td><td> </td><td class="right">               cos_sin_rho = StelUtils::ComputeCosSinRhoZone(drho, stacks, 
M_PI-bottomAngle);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0059" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       // <span class="delete">GZ: </span>Allow parameters so that pole regions may remain free.</td><td> </td><td class="rblock">       // Allow parameters so that pole regions may remain free.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const float* cos_sin_rho_p;</td><td> </td><td class="right">       const float* cos_sin_rho_p;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const float* cos_sin_theta = StelUtils::ComputeCosSinTheta(slices);</td><td> </td><td class="right">       const float* cos_sin_theta = StelUtils::ComputeCosSinTheta(slices);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const float *cos_sin_theta_p;</td><td> </td><td class="right">       const float *cos_sin_theta_p;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // texturing: s goes from 0.0/0.25/0.5/0.75/1.0 at +y/+x/-y/-x/+y ax
is</td><td> </td><td class="right">       // texturing: s goes from 0.0/0.25/0.5/0.75/1.0 at +y/+x/-y/-x/+y ax
is</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // t goes from -1.0/+1.0 at z = -radius/+radius (linear along longit
udes)</td><td> </td><td class="right">       // t goes from -1.0/+1.0 at z = -radius/+radius (linear along longit
udes)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // cannot use triangle fan on texturing (s coord. at top/bottom tip 
varies)</td><td> </td><td class="right">       // cannot use triangle fan on texturing (s coord. at top/bottom tip 
varies)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // If the texture is flipped, we iterate the coordinates backward.</td><td> </td><td class="right">       // If the texture is flipped, we iterate the coordinates backward.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const GLfloat ds = (flipTexture ? -1.f : 1.f) / slices;</td><td> </td><td class="right">       const GLfloat ds = (flipTexture ? -1.f : 1.f) / slices;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const GLfloat dt = nsign / stacks; // from inside texture is reverse
d</td><td> </td><td class="right">       const GLfloat dt = nsign / stacks; // from inside texture is reverse
d</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0060" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       // draw intermediate <span class="delete"> </span>as quad strips</td><td> </td><td class="rblock">       // draw intermediate as quad strips</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       static QVector&lt;double&gt; vertexArr;</td><td> </td><td class="right">       static QVector&lt;double&gt; vertexArr;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       static QVector&lt;float&gt; texCoordArr;</td><td> </td><td class="right">       static QVector&lt;float&gt; texCoordArr;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       static QVector&lt;float&gt; colorArr;</td><td> </td><td class="right">       static QVector&lt;float&gt; colorArr;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       static QVector&lt;unsigned short&gt; indiceArr;</td><td> </td><td class="right">       static QVector&lt;unsigned short&gt; indiceArr;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       texCoordArr.resize(0);</td><td> </td><td class="right">       texCoordArr.resize(0);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       vertexArr.resize(0);</td><td> </td><td class="right">       vertexArr.resize(0);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       colorArr.resize(0);</td><td> </td><td class="right">       colorArr.resize(0);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       indiceArr.resize(0);</td><td> </td><td class="right">       indiceArr.resize(0);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l17" /><small>skipping to change at</small><em> line 1448</em></th><th> </th><th><a name="part-r17" /><small>skipping to change at</small><em> line 1603</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       indiceArr &lt;&lt; offset+j &lt;&lt; offset+j-1 &lt;&lt; offset+j+1;</td><td> </td><td class="right">                       indiceArr &lt;&lt; offset+j &lt;&lt; offset+j-1 &lt;&lt; offset+j+1;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               t -= dt;</td><td> </td><td class="right">               t -= dt;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Draw the array now</td><td> </td><td class="right">       // Draw the array now</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       setArrays((Vec3d*)vertexArr.constData(), (Vec2f*)texCoordArr.constDa
ta());</td><td> </td><td class="right">       setArrays((Vec3d*)vertexArr.constData(), (Vec2f*)texCoordArr.constDa
ta());</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       drawFromArray(Triangles, indiceArr.size(), 0, true, indiceArr.constD
ata());</td><td> </td><td class="right">       drawFromArray(Triangles, indiceArr.size(), 0, true, indiceArr.constD
ata());</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0061" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">StelVertexArray <span class="delete">StelPainter::computeSphereNoLight(const float</span> radius, <span class="delete">const</span></td><td> </td><td class="rblock">StelVertexArray <span class="insert">StelPainter::computeSphereNoLight(float</span> radius, float <span class="insert">oneMi</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"> float <span class="delete">oneMinusOblateness, const</span> int slices, <span class="delete">const</span> int stacks, <span class="delete">const</span> int <span class="delete">or</span></td><td> </td><td class="rblock"><span class="insert">nusOblateness,</span> int slices, int stacks,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">ientInside, const</span> bool <span class="delete">flipTexture)</span></td><td> </td><td class="rblock">                          int <span class="insert">orientInside,</span> bool <span class="insert">flipTexture, float topAngl</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">e, float bottomAngle)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       StelVertexArray result(StelVertexArray::Triangles);</td><td> </td><td class="right">       StelVertexArray result(StelVertexArray::Triangles);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       GLfloat x, y, z;</td><td> </td><td class="right">       GLfloat x, y, z;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       GLfloat s=0.f, t=0.f;</td><td> </td><td class="right">       GLfloat s=0.f, t=0.f;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       GLint i, j;</td><td> </td><td class="right">       GLint i, j;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       GLfloat nsign;</td><td> </td><td class="right">       GLfloat nsign;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (orientInside)</td><td> </td><td class="right">       if (orientInside)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               nsign = -1.f;</td><td> </td><td class="right">               nsign = -1.f;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               t=0.f; // from inside texture is reversed</td><td> </td><td class="right">               t=0.f; // from inside texture is reversed</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       else</td><td> </td><td class="right">       else</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               nsign = 1.f;</td><td> </td><td class="right">               nsign = 1.f;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               t=1.f;</td><td> </td><td class="right">               t=1.f;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0062" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       const float* cos_sin_rho = StelUtils::ComputeCosSinRho(stacks);</td><td> </td><td class="rblock">       const float* cos_sin_rho = <span class="insert">NULL; //StelUtils::ComputeCosSinRho(stack</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">s);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       Q_ASSERT(topAngle&lt;bottomAngle); // don't forget: These are opening a</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ngles counted from top.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       if ((bottomAngle&gt;3.1415f) &amp;&amp; (topAngle&lt;0.0001f)) // safety margin.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               cos_sin_rho =</span> StelUtils::ComputeCosSinRho(stacks);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">else</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               const float drho = (bottomAngle-topAngle) / stacks; // delta</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">Rho:  originally just 180degrees/stacks, now the range clamped.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               cos_sin_rho = StelUtils::ComputeCosSinRhoZone(drho, stacks, </span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">M_PI-bottomAngle);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       // Allow parameters so that pole regions may remain free.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const float* cos_sin_rho_p;</td><td> </td><td class="right">       const float* cos_sin_rho_p;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const float* cos_sin_theta = StelUtils::ComputeCosSinTheta(slices);</td><td> </td><td class="right">       const float* cos_sin_theta = StelUtils::ComputeCosSinTheta(slices);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const float *cos_sin_theta_p;</td><td> </td><td class="right">       const float *cos_sin_theta_p;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // texturing: s goes from 0.0/0.25/0.5/0.75/1.0 at +y/+x/-y/-x/+y ax
is</td><td> </td><td class="right">       // texturing: s goes from 0.0/0.25/0.5/0.75/1.0 at +y/+x/-y/-x/+y ax
is</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // t goes from -1.0/+1.0 at z = -radius/+radius (linear along longit
udes)</td><td> </td><td class="right">       // t goes from -1.0/+1.0 at z = -radius/+radius (linear along longit
udes)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // cannot use triangle fan on texturing (s coord. at top/bottom tip 
varies)</td><td> </td><td class="right">       // cannot use triangle fan on texturing (s coord. at top/bottom tip 
varies)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // If the texture is flipped, we iterate the coordinates backward.</td><td> </td><td class="right">       // If the texture is flipped, we iterate the coordinates backward.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const GLfloat ds = (flipTexture ? -1.f : 1.f) / slices;</td><td> </td><td class="right">       const GLfloat ds = (flipTexture ? -1.f : 1.f) / slices;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const GLfloat dt = nsign / stacks; // from inside texture is reverse
d</td><td> </td><td class="right">       const GLfloat dt = nsign / stacks; // from inside texture is reverse
d</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0063" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       // draw intermediate <span class="delete"> </span>as quad strips</td><td> </td><td class="rblock">       // draw intermediate as quad strips</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       for (i = 0,cos_sin_rho_p = cos_sin_rho; i &lt; stacks; ++i,cos_sin_rho_
p+=2)</td><td> </td><td class="right">       for (i = 0,cos_sin_rho_p = cos_sin_rho; i &lt; stacks; ++i,cos_sin_rho_
p+=2)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               s = !flipTexture ? 0.f : 1.f;</td><td> </td><td class="right">               s = !flipTexture ? 0.f : 1.f;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               for (j = 0,cos_sin_theta_p = cos_sin_theta; j&lt;=slices;++j,co
s_sin_theta_p+=2)</td><td> </td><td class="right">               for (j = 0,cos_sin_theta_p = cos_sin_theta; j&lt;=slices;++j,co
s_sin_theta_p+=2)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       x = -cos_sin_theta_p[1] * cos_sin_rho_p[1];</td><td> </td><td class="right">                       x = -cos_sin_theta_p[1] * cos_sin_rho_p[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       y = cos_sin_theta_p[0] * cos_sin_rho_p[1];</td><td> </td><td class="right">                       y = cos_sin_theta_p[0] * cos_sin_rho_p[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       z = nsign * cos_sin_rho_p[0];</td><td> </td><td class="right">                       z = nsign * cos_sin_rho_p[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       result.texCoords &lt;&lt; Vec2f(s,t);</td><td> </td><td class="right">                       result.texCoords &lt;&lt; Vec2f(s,t);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       result.vertex &lt;&lt; Vec3d(x*radius, y*radius, z*oneMinu
sOblateness*radius);</td><td> </td><td class="right">                       result.vertex &lt;&lt; Vec3d(x*radius, y*radius, z*oneMinu
sOblateness*radius);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l18" /><small>skipping to change at</small><em> line 1509</em></th><th> </th><th><a name="part-r18" /><small>skipping to change at</small><em> line 1674</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       result.indices &lt;&lt; offset+j-2 &lt;&lt; offset+j-1 &lt;&lt; offset
+j;</td><td> </td><td class="right">                       result.indices &lt;&lt; offset+j-2 &lt;&lt; offset+j-1 &lt;&lt; offset
+j;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       result.indices &lt;&lt; offset+j &lt;&lt; offset+j-1 &lt;&lt; offset+j
+1;</td><td> </td><td class="right">                       result.indices &lt;&lt; offset+j &lt;&lt; offset+j-1 &lt;&lt; offset+j
+1;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               t -= dt;</td><td> </td><td class="right">               t -= dt;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       return result;</td><td> </td><td class="right">       return result;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// Reimplementation of gluCylinder : glu is overrided for non standard proj
ection</td><td> </td><td class="right">// Reimplementation of gluCylinder : glu is overrided for non standard proj
ection</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0064" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">void StelPainter::sCylinder(<span class="delete">const float radius, const float height, const i
nt slices, const int ori</span>entInside)</td><td> </td><td class="rblock">void StelPainter::sCylinder(<span class="insert">float radius, float height, int slices, int ori
</span>entInside)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (orientInside)</td><td> </td><td class="right">       if (orientInside)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               glCullFace(GL_FRONT);</td><td> </td><td class="right">               glCullFace(GL_FRONT);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       static QVarLengthArray&lt;Vec2f, 512&gt; texCoordArray;</td><td> </td><td class="right">       static QVarLengthArray&lt;Vec2f, 512&gt; texCoordArray;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       static QVarLengthArray&lt;Vec3d, 512&gt; vertexArray;</td><td> </td><td class="right">       static QVarLengthArray&lt;Vec3d, 512&gt; vertexArray;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       texCoordArray.clear();</td><td> </td><td class="right">       texCoordArray.clear();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       vertexArray.clear();</td><td> </td><td class="right">       vertexArray.clear();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       float s = 0.f;</td><td> </td><td class="right">       float s = 0.f;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       float x, y;</td><td> </td><td class="right">       float x, y;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l19" /><small>skipping to change at</small><em> line 1539</em></th><th> </th><th><a name="part-r19" /><small>skipping to change at</small><em> line 1704</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               vertexArray.append(Vec3d(x*radius, y*radius, height));</td><td> </td><td class="right">               vertexArray.append(Vec3d(x*radius, y*radius, height));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               s += ds;</td><td> </td><td class="right">               s += ds;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       setArrays(vertexArray.constData(), texCoordArray.constData());</td><td> </td><td class="right">       setArrays(vertexArray.constData(), texCoordArray.constData());</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       drawFromArray(TriangleStrip, vertexArray.size());</td><td> </td><td class="right">       drawFromArray(TriangleStrip, vertexArray.size());</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (orientInside)</td><td> </td><td class="right">       if (orientInside)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               glCullFace(GL_BACK);</td><td> </td><td class="right">               glCullFace(GL_BACK);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0065" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">void StelPainter::enableTexture2d(<span class="delete">const </span>bool b)</td><td> </td><td class="rblock">void StelPainter::enableTexture2d(bool b)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       texture2dEnabled = b;</td><td> </td><td class="right">       texture2dEnabled = b;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void StelPainter::initGLShaders()</td><td> </td><td class="right">void StelPainter::initGLShaders()</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       qWarning() &lt;&lt; "Intializing basic GL shaders... ";</td><td> </td><td class="right">       qWarning() &lt;&lt; "Intializing basic GL shaders... ";</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Basic shader: just vertex filled with plain color</td><td> </td><td class="right">       // Basic shader: just vertex filled with plain color</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       QOpenGLShader vshader3(QOpenGLShader::Vertex);</td><td> </td><td class="right">       QOpenGLShader vshader3(QOpenGLShader::Vertex);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const char *vsrc3 =</td><td> </td><td class="right">       const char *vsrc3 =</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l20" /><small>skipping to change at</small><em> line 1718</em></th><th> </th><th><a name="part-r20" /><small>skipping to change at</small><em> line 1883</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void StelPainter::setArrays(const Vec3f* vertices, const Vec2f* texCoords, 
const Vec3f* colorArray, const Vec3f* normalArray)</td><td> </td><td class="right">void StelPainter::setArrays(const Vec3f* vertices, const Vec2f* texCoords, 
const Vec3f* colorArray, const Vec3f* normalArray)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       enableClientStates(vertices, texCoords, colorArray, normalArray);</td><td> </td><td class="right">       enableClientStates(vertices, texCoords, colorArray, normalArray);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       setVertexPointer(3, GL_FLOAT, vertices);</td><td> </td><td class="right">       setVertexPointer(3, GL_FLOAT, vertices);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       setTexCoordPointer(2, GL_FLOAT, texCoords);</td><td> </td><td class="right">       setTexCoordPointer(2, GL_FLOAT, texCoords);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       setColorPointer(3, GL_FLOAT, colorArray);</td><td> </td><td class="right">       setColorPointer(3, GL_FLOAT, colorArray);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       setNormalPointer(GL_FLOAT, normalArray);</td><td> </td><td class="right">       setNormalPointer(GL_FLOAT, normalArray);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0066" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">void StelPainter::enableClientStates(<span class="delete">const bool vertex, const bool texture,
 const bool color, const</span> bool normal)</td><td> </td><td class="rblock">void StelPainter::enableClientStates(<span class="insert">bool vertex, bool texture, bool color,
</span> bool normal)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       vertexArray.enabled = vertex;</td><td> </td><td class="right">       vertexArray.enabled = vertex;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       texCoordArray.enabled = texture;</td><td> </td><td class="right">       texCoordArray.enabled = texture;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       colorArray.enabled = color;</td><td> </td><td class="right">       colorArray.enabled = color;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       normalArray.enabled = normal;</td><td> </td><td class="right">       normalArray.enabled = normal;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0067" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">void StelPainter::drawFromArray(<span class="delete">const DrawingMode mode, const int count, co
nst int offset, const bo</span>ol doProj, const unsigned short* indices)</td><td> </td><td class="rblock">void StelPainter::drawFromArray(<span class="insert">DrawingMode mode, int count, int offset, bo
</span>ol doProj, const unsigned short* indices)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       ArrayDesc projectedVertexArray = vertexArray;</td><td> </td><td class="right">       ArrayDesc projectedVertexArray = vertexArray;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (doProj)</td><td> </td><td class="right">       if (doProj)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               // Project the vertex array using current projection</td><td> </td><td class="right">               // Project the vertex array using current projection</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               if (indices)</td><td> </td><td class="right">               if (indices)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       projectedVertexArray = projectArray(vertexArray, 0, 
count, indices + offset);</td><td> </td><td class="right">                       projectedVertexArray = projectArray(vertexArray, 0, 
count, indices + offset);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               else</td><td> </td><td class="right">               else</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       projectedVertexArray = projectArray(vertexArray, off
set, count, NULL);</td><td> </td><td class="right">                       projectedVertexArray = projectArray(vertexArray, off
set, count, NULL);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>

     <tr><td></td><td class="left"></td><td> </td><td class="right"></td><td></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 67 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><td></td><th><i>85 lines changed or deleted</i></th><th><i> </i></th><th><i>263 lines changed or added</i></th><td></td></tr>
     <tr><td colspan="5" align="center" class="small"><br/>This html diff was produced by rfcdiff 1.41. The latest version is available from <a href="http://www.tools.ietf.org/tools/rfcdiff/" >http://tools.ietf.org/tools/rfcdiff/</a> </td></tr>
   </table>
   </body>
   </html>
