<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"> 
<!-- Generated by rfcdiff 1.41: rfcdiff  --> 
<!-- <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional" > -->
<!-- System: Linux fomalhaut.local 3.13.0-38-generic #65-Ubuntu SMP Thu Oct 9 11:36:50 UTC 2014 x86_64 x86_64 x86_64 GNU/Linux --> 
<!-- Using awk: /usr/bin/gawk: GNU Awk 4.0.1 --> 
<!-- Using diff: /usr/bin/diff: diff (GNU diffutils) 3.3 --> 
<!-- Using wdiff: /usr/bin/wdiff: wdiff (GNU wdiff) 1.2.1 --> 
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"> 
<head> 
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /> 
  <meta http-equiv="Content-Style-Type" content="text/css" /> 
  <title>Diff: GridLinesMgr.cpp - GridLinesMgr.cpp</title> 
  <style type="text/css"> 
    body    { font-size:16px; margin: 0.4ex; margin-right: auto; } 
    tr      { } 
    td      { white-space: pre; font-family: Consolas, "DejaVu Sans Mono", "Droid Sans Mono", Monaco, Monospace; vertical-align: top; font-size: 0.86em;} 
    th      { font-size: 0.86em; } 
    .small  { font-size: 0.6em; font-style: italic; font-family: Verdana, Helvetica, sans-serif; } 
    .left   { background-color: #EEE; } 
    .right  { background-color: #FFF; } 
    .diff   { background-color: #CCF; } 
    .lblock { background-color: #BFB; } 
    .rblock { background-color: #FF8; } 
    .insert { background-color: #8FF; } 
    .delete { background-color: #ACF; } 
    .void   { background-color: #FFB; } 
    .cont   { background-color: #EEE; } 
    .linebr { background-color: #AAA; } 
    .lineno { color: red; background-color: #FFF; font-size: 0.7em; text-align: right; padding: 0 2px; } 
    .elipsis{ background-color: #AAA; } 
    .left .cont { background-color: #DDD; } 
    .right .cont { background-color: #EEE; } 
    .lblock .cont { background-color: #9D9; } 
    .rblock .cont { background-color: #DD6; } 
    .insert .cont { background-color: #0DD; } 
    .delete .cont { background-color: #8AD; } 
    .stats, .stats td, .stats th { background-color: #EEE; padding: 2px 0; } 
  </style> 
</head> 
<body > 
  <table border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th></th><th>&nbsp;GridLinesMgr.cpp&nbsp;</th><th> </th><th>&nbsp;GridLinesMgr.cpp&nbsp;</th><th></th></tr> 
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l1" /><small>skipping to change at</small><em> line 25</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 25</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"> * You should have received a copy of the GNU General Public License</td><td> </td><td class="right"> * You should have received a copy of the GNU General Public License</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"> * along with this program; if not, write to the Free Software</td><td> </td><td class="right"> * along with this program; if not, write to the Free Software</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"> * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, U
SA.</td><td> </td><td class="right"> * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, U
SA.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"> */</td><td> </td><td class="right"> */</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#include &lt;set&gt;</td><td> </td><td class="right">#include &lt;set&gt;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#include &lt;QSettings&gt;</td><td> </td><td class="right">#include &lt;QSettings&gt;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#include &lt;QDebug&gt;</td><td> </td><td class="right">#include &lt;QDebug&gt;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#include "GridLinesMgr.hpp"</td><td> </td><td class="right">#include "GridLinesMgr.hpp"</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                                                                           </span></td><td> </td><td class="rblock"><span class="insert">#include "StelMovementMgr.hpp"</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#include "StelApp.hpp"</td><td> </td><td class="right">#include "StelApp.hpp"</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0002" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">#include <span class="delete">"Navigator.hpp"</span></td><td> </td><td class="rblock">#include <span class="insert">"StelNavigator.hpp"</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">#include <span class="delete">"Translator.hpp"</span></td><td> </td><td class="rblock">#include <span class="insert">"StelTranslator.hpp"</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">#include <span class="delete">"Projector.hpp"</span></td><td> </td><td class="rblock">#include <span class="insert">"StelProjector.hpp"</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">#include <span class="delete">"LoadingBar.hpp"</span></td><td> </td><td class="rblock">#include <span class="insert">"StelLoadingBar.hpp"</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">#include <span class="delete">"Fader.hpp"</span></td><td> </td><td class="rblock">#include <span class="insert">"StelFader.hpp"</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#include "Planet.hpp"</td><td> </td><td class="right">#include "Planet.hpp"</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#include "StelFontMgr.hpp"</td><td> </td><td class="right">#include "StelFontMgr.hpp"</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#include "StelLocaleMgr.hpp"</td><td> </td><td class="right">#include "StelLocaleMgr.hpp"</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#include "StelModuleMgr.hpp"</td><td> </td><td class="right">#include "StelModuleMgr.hpp"</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#include "StelCore.hpp"</td><td> </td><td class="right">#include "StelCore.hpp"</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0003" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">#include "SFont.hpp"</td><td> </td><td class="rblock">#include "S<span class="insert">tel</span>Font.hpp"</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#include "StelStyle.hpp"</td><td> </td><td class="right">#include "StelStyle.hpp"</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0004" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#include "StelPainter.hpp"</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! @class SkyGrid</td><td> </td><td class="right">//! @class SkyGrid</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! Class which manages a grid to display in the sky.</td><td> </td><td class="right">//! Class which manages a grid to display in the sky.</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0005" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">//! <span class="delete">TODO: this class suffers a number of problems:</span></td><td> </td><td class="rblock">//! <span class="insert">TODO</span> needs support for DMS/DMS labelling, not only HMS/DMS</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//! 1- the algorithm used to find the points where the lines cross the edge</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"> of the screen</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//! is slow and very buggy at high latitudes</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//! 2-</span> needs support for DMS/DMS labelling, not only HMS/DMS</td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">class SkyGrid</td><td> </td><td class="right">class SkyGrid</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">public:</td><td> </td><td class="right">public:</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Create and precompute positions of a SkyGrid</td><td> </td><td class="right">       // Create and precompute positions of a SkyGrid</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0006" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       SkyGrid(<span class="delete">Projector</span>::FrameType frame);</td><td> </td><td class="rblock">       SkyGrid(<span class="insert">StelCore</span>::FrameType frame);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">    virtual ~SkyGrid();</td><td> </td><td class="right">    virtual ~SkyGrid();</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0007" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       void draw(const <span class="delete">Projector</span>* prj) const;</td><td> </td><td class="rblock">       void draw(const <span class="insert">StelCore</span>* prj) const;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       void setFontSize(double newFontSize);</td><td> </td><td class="right">       void setFontSize(double newFontSize);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       void setColor(const Vec3f&amp; c) {color = c;}</td><td> </td><td class="right">       void setColor(const Vec3f&amp; c) {color = c;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const Vec3f&amp; getColor() {return color;}</td><td> </td><td class="right">       const Vec3f&amp; getColor() {return color;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       void update(double deltaTime) {fader.update((int)(deltaTime*1000));}</td><td> </td><td class="right">       void update(double deltaTime) {fader.update((int)(deltaTime*1000));}</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0008" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       void set<span class="delete">_fade_duration(float duration) {fader.setDuration((int)(dura
ti</span>on*1000.f));}</td><td> </td><td class="rblock">       void set<span class="insert">FadeDuration(float duration) {fader.setDuration((int)(durati
</span>on*1000.f));}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       void setFlagshow(bool b){fader = b;}</td><td> </td><td class="right">       void setFlagshow(bool b){fader = b;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       bool getFlagshow(void) const {return fader;}</td><td> </td><td class="right">       bool getFlagshow(void) const {return fader;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0009" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       void set_top_transparancy(bool b) { transparent_top= b; }</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">private:</td><td> </td><td class="right">private:</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0010" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       bool transparent_top;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Vec3f color;</td><td> </td><td class="right">       Vec3f color;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0011" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">Projector</span>::FrameType frameType;</td><td> </td><td class="rblock">       <span class="insert">StelCore</span>::FrameType frameType;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       double fontSize;</td><td> </td><td class="right">       double fontSize;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0012" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       SFont&amp; font;</td><td> </td><td class="rblock">       S<span class="insert">tel</span>Font&amp; font;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       LinearFader fader;</td><td> </td><td class="right">       LinearFader fader;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">};</td><td> </td><td class="right">};</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! @class SkyLine</td><td> </td><td class="right">//! @class SkyLine</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! Class which manages a line to display around the sky like the ecliptic 
line.</td><td> </td><td class="right">//! Class which manages a line to display around the sky like the ecliptic 
line.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">class SkyLine</td><td> </td><td class="right">class SkyLine</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">public:</td><td> </td><td class="right">public:</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       enum SKY_LINE_TYPE</td><td> </td><td class="right">       enum SKY_LINE_TYPE</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               EQUATOR,</td><td> </td><td class="right">               EQUATOR,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               ECLIPTIC,</td><td> </td><td class="right">               ECLIPTIC,</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0013" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               LOCAL,</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               MERIDIAN</td><td> </td><td class="right">               MERIDIAN</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       };</td><td> </td><td class="right">       };</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Create and precompute positions of a SkyGrid</td><td> </td><td class="right">       // Create and precompute positions of a SkyGrid</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       SkyLine(SKY_LINE_TYPE _line_type = EQUATOR);</td><td> </td><td class="right">       SkyLine(SKY_LINE_TYPE _line_type = EQUATOR);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">    virtual ~SkyLine();</td><td> </td><td class="right">    virtual ~SkyLine();</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0014" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       void draw(<span class="delete">Projector *prj,const Navigator *nav</span>) const;</td><td> </td><td class="rblock">       void draw(<span class="insert">StelCore* core</span>) const;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       void setColor(const Vec3f&amp; c) {color = c;}</td><td> </td><td class="right">       void setColor(const Vec3f&amp; c) {color = c;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const Vec3f&amp; getColor() {return color;}</td><td> </td><td class="right">       const Vec3f&amp; getColor() {return color;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       void update(double deltaTime) {fader.update((int)(deltaTime*1000));}</td><td> </td><td class="right">       void update(double deltaTime) {fader.update((int)(deltaTime*1000));}</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0015" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       void set<span class="delete">_fade_duration(float duration) {fader.setDuration((int)(dura
ti</span>on*1000.f));}</td><td> </td><td class="rblock">       void set<span class="insert">FadeDuration(float duration) {fader.setDuration((int)(durati
</span>on*1000.f));}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       void setFlagshow(bool b){fader = b;}</td><td> </td><td class="right">       void setFlagshow(bool b){fader = b;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       bool getFlagshow(void) const {return fader;}</td><td> </td><td class="right">       bool getFlagshow(void) const {return fader;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       void setFontSize(double newSize);</td><td> </td><td class="right">       void setFontSize(double newSize);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">private:</td><td> </td><td class="right">private:</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       SKY_LINE_TYPE line_type;</td><td> </td><td class="right">       SKY_LINE_TYPE line_type;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Vec3f color;</td><td> </td><td class="right">       Vec3f color;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0016" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">Projector</span>::FrameType frameType;</td><td> </td><td class="rblock">       <span class="insert">StelCore</span>::FrameType frameType;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       LinearFader fader;</td><td> </td><td class="right">       LinearFader fader;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       double fontSize;</td><td> </td><td class="right">       double fontSize;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0017" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">SFont&amp;</span> font;</td><td> </td><td class="rblock">       <span class="insert">StelFont&amp;</span> font;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">QString label;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">};</td><td> </td><td class="right">};</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// rms added color as parameter</td><td> </td><td class="right">// rms added color as parameter</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0018" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">SkyGrid::SkyGrid(<span class="delete">Projector::FrameType frame) : color(0.2,0.2,0.2), frameTyp
e</span>(frame), fontSize(12),</td><td> </td><td class="rblock">SkyGrid::SkyGrid(<span class="insert">StelCore::FrameType frame) : color(0.2,0.2,0.2), frameType
</span>(frame), fontSize(12),</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       font(StelApp::getInstance().getFontManager().getStandardFont(StelApp
::getInstance().getLocaleMgr().getAppLanguage(), fontSize))</td><td> </td><td class="right">       font(StelApp::getInstance().getFontManager().getStandardFont(StelApp
::getInstance().getLocaleMgr().getAppLanguage(), fontSize))</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0019" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       transparent_top = true;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">SkyGrid::~SkyGrid()</td><td> </td><td class="right">SkyGrid::~SkyGrid()</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void SkyGrid::setFontSize(double newFontSize)</td><td> </td><td class="right">void SkyGrid::setFontSize(double newFontSize)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       fontSize = newFontSize;</td><td> </td><td class="right">       fontSize = newFontSize;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       font = StelApp::getInstance().getFontManager().getStandardFont(StelA
pp::getInstance().getLocaleMgr().getAppLanguage(), fontSize);</td><td> </td><td class="right">       font = StelApp::getInstance().getFontManager().getStandardFont(StelA
pp::getInstance().getLocaleMgr().getAppLanguage(), fontSize);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// Conversion into mas = milli arcsecond</td><td> </td><td class="right">// Conversion into mas = milli arcsecond</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">static const double RADIAN_MAS = 180./M_PI*1000.*60.*60.;</td><td> </td><td class="right">static const double RADIAN_MAS = 180./M_PI*1000.*60.*60.;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">static const double DEGREE_MAS = 1000.*60.*60.;</td><td> </td><td class="right">static const double DEGREE_MAS = 1000.*60.*60.;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0020" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//! Return the standard longitude in radian [-pi;+pi] for a position given </span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">in the viewport</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">static double getLonFrom2dPos(const Projector* prj, const Vec2d&amp; p)</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">{</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       Vec3d v;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       prj-&gt;unProject(p[0], p[1], v);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       return std::atan2(v[1],v[0]);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">}</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//! Return the standard latitude in radian [-pi/2;+pi/2] for a position giv</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">en in the viewport</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">static double getLatFrom2dPos(const Projector* prj, const Vec2d&amp; p)</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">{</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       Vec3d v;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       prj-&gt;unProject(p[0], p[1], v);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       return std::asin(v[2]);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">}</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//! Return a "longitude" between 0 and pi and "latitude" between 0 and 2*pi</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//! This is used to get rid of the longitude discontinuity in lon=0</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">void rectToSpheType2(double&amp; lon, double&amp; lat, const Vec3d&amp; v)</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">{</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       StelUtils::rectToSphe(&amp;lon, &amp;lat, v);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       // lon is now between -pi and pi, we want it between 0 and pi, like </span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">a latitude</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       // lat is now between -pi/2 and pi/2, we want it between 0 and 2*pi </span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">like a longitude</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       lat += M_PI/2;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       if (lon&lt;0.)</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       {</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               lat = 2.*M_PI-lat;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               lon = -lon;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       }</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       assert(lat&gt;=0. &amp;&amp; lat&lt;=2.*M_PI);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       assert(lon&gt;=0. &amp;&amp; lon&lt;=M_PI);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">}</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//! Create a vector from a "longitude" between 0 and pi and "latitude" betw</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">een 0 and 2*pi</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//! This is used to get rid of the longitude discontinuity in lon=0</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">void spheToRectType2(double lon, double lat, Vec3d&amp; v)</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">{</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       assert(lat&gt;=0. &amp;&amp; lat&lt;=2.*M_PI);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       assert(lon&gt;=0. &amp;&amp; lon&lt;=M_PI);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       if (lat&gt;M_PI)</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       {</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               lat = 2.*M_PI-lat;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               lon = -lon;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       }</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       lat -= M_PI/2;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       StelUtils::spheToRect(lon, lat, v);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">}</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">void spheToRectLat1802(double lon, double lat, Vec3d&amp; v)</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">{</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       assert(lat&gt;=0. &amp;&amp; lat&lt;=2.*M_PI);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       assert(lon&gt;=0. &amp;&amp; lon&lt;=M_PI);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       if (lat&gt;M_PI)</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       {</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               lat = 2.*M_PI-lat;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               lon += M_PI;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       }</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       lat -= M_PI/2;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       StelUtils::spheToRect(lon, lat, v);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">}</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//! Return a special latitude in radian [0;2*pi] for a position given in th</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">e viewport</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">static double getLatFrom2dPosType2(const Projector* prj, const Vec2d&amp; p)</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">{</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       Vec3d v;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       prj-&gt;unProject(p[0], p[1], v);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       double lon, lat;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       rectToSpheType2(lon, lat, v);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       return lat;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">}</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//! Return a special longitude in radian [0;pi] for a position given in the</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"> viewport</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">static double getLonFrom2dPosType2(const Projector* prj, const Vec2d&amp; p)</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">{</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       Vec3d v;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       prj-&gt;unProject(p[0], p[1], v);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       double lon, lat;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       rectToSpheType2(lon, lat, v);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       return lon;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">}</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//! Return the 2D position in the viewport from a longitude and latitude in</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"> radian</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">static Vec3d get2dPosFromSpherical(const Projector* prj, double lon, double</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"> lat)</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">{</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       Vec3d v;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       Vec3d win;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       StelUtils::spheToRect(lon, lat, v);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       prj-&gt;project(v, win);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       return win;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">}</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//! Return the 2D position in the viewport from special longitude and latit</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">ude in radian</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">static Vec3d get2dPosFromSpherical1802(const Projector* prj, double lon, do</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">uble lat)</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">{</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       Vec3d v;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       Vec3d win;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       spheToRectLat1802(lon, lat, v);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       prj-&gt;project(v, win);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       return win;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">}</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//! Check if the given point from the viewport side is the beginning of a p</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">arallel or not</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//! Beginning means that the direction of increasing longitude goes inside </span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">the viewport</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">static bool isParallelEntering(const Projector* prj, double lon, double lat</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">)</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">{</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       return prj-&gt;checkInViewport(get2dPosFromSpherical(prj, lon+0.0001*pr</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">j-&gt;getFov(), lat));</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">}</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//! Check if the given point from the viewport side is the beginning of a m</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">eridian or not</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//! Beginning means that the direction of increasing latitude goes inside t</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">he viewport</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//! @param lon180 Modified longitude in radian</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">static bool isMeridianEnteringLat180(const Projector* prj, double lon1802, </span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">double lat1802)</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">{</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       assert(lat1802&gt;=0. &amp;&amp; lat1802&lt;=2.*M_PI);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       assert(lon1802&gt;=0. &amp;&amp; lon1802&lt;=M_PI);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       double lat2 = lat1802+0.001*prj-&gt;getFov();</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       if (lat2&gt;2.*M_PI)</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               lat2-=2.*M_PI;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       return prj-&gt;checkInViewport(get2dPosFromSpherical1802(prj, lon1802, </span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">lat2));</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">}</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//! Return all the points p on the segment [p0 p1] for which the value of f</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">unc(p) == k*step</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//! For each value of k*step, the result is then sorted ordered according t</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">o the value of func2(p)</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//! @return a map associating all the values of k*step and their associated</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"> func2(p)</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">static void getPslow(std::map&lt;int, std::set&lt;double&gt; &gt; &amp; result, const Proje</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">ctor* prj,</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       const Vec2d&amp; p0, const Vec2d&amp; p1, double step,</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       double (*func)(const Projector* prj, const Vec2d&amp; p),</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       double (*func2)(const Projector* prj, const Vec2d&amp; p))</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">{</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       double precision = 0.1;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       const Vec2d deltaP(p1-p0);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       Vec2d p = p0;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       const double umax = deltaP.length();</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       const Vec2d dPix1 = deltaP/umax;        // 1 pixel step</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       double funcp, funcpDpix;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       funcp = func(prj, p);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       funcpDpix = func(prj, p+dPix1*precision);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       double u=0.;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       bool lastLoop=false;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       bool stop;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       do</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       {</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               stop = lastLoop;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               if (funcp&lt;funcpDpix) // func(p) increases over the segment [</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">p p+dPix]</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               {</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       // If targets are included inside the range, add the</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">m</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       double v = step*(std::ceil(funcp/step));</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       while (v&lt;=funcpDpix)</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       {</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                               result[(int)(v*RADIAN_MAS)].insert(func2(prj</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">, p-dPix1*precision*(funcpDpix-v)/(funcpDpix-funcp)));</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                               v+=step;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       }</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               }</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               else // func(p) descreases over the segment [p p+dPix]</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               {</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       // If targets are included inside the range, add the</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">m</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       double v = step*(std::floor(funcp/step));</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       while(v&gt;=funcpDpix)</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       {</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                               result[(int)(v*RADIAN_MAS)].insert(func2(prj</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">, p-dPix1*precision*(v-funcpDpix)/(funcp-funcpDpix)));</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                               v-=step;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       }</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               }</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               precision = step/(std::fabs(funcpDpix-funcp)/precision);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               if (precision&gt;2 || funcpDpix-funcp==0.)</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       precision = 2.;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               else if (precision&lt;0.5)</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       precision = 0.5;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               u+=precision;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               if (u&gt;umax)</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               {</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       precision-=u-umax;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       u=umax;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       lastLoop = true;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               }</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               p+=dPix1*precision;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               funcp = funcpDpix;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               funcpDpix = func(prj,p);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       }</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       while(stop==false);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">}</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                                                           </td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// Step sizes in arcsec</td><td> </td><td class="right">// Step sizes in arcsec</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0021" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">static const double STEP_SIZES_DMS[] = <span class="delete">{1.,</span> 5., 10., 60., 300., 600., <span class="delete">1200.</span></td><td> </td><td class="rblock">static const double STEP_SIZES_DMS[] = <span class="insert">{0.05, 0.2, 1.,</span> 5., 10., 60., 300., </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">,</span> 3600., 3600.*5., 3600.*10.};</td><td> </td><td class="rblock">600., <span class="insert">1200.,</span> 3600., 3600.*5., 3600.*10.};</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">static const double STEP_SIZES_HMS[] = <span class="delete">{1.5,</span> 7.5, 15., 15.*5., <span class="delete">15.*10., 15.</span></td><td> </td><td class="rblock">static const double STEP_SIZES_HMS[] = <span class="insert">{0.05, 0.2, 1.5,</span> 7.5, 15., 15.*5., <span class="insert">1</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">*60.,</span> 15.*60.*5., 15.*60*10., 15.*60*60};</td><td> </td><td class="rblock"><span class="insert">5.*10., 15.*60.,</span> 15.*60.*5., 15.*60*10., 15.*60*60};</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! Return the angular grid step in degree which best fits the given scale</td><td> </td><td class="right">//! Return the angular grid step in degree which best fits the given scale</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">static double getClosestResolutionDMS(double pixelPerRad)</td><td> </td><td class="right">static double getClosestResolutionDMS(double pixelPerRad)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       double minResolution = 80.;</td><td> </td><td class="right">       double minResolution = 80.;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       double minSizeArcsec = minResolution/pixelPerRad*180./M_PI*3600;</td><td> </td><td class="right">       double minSizeArcsec = minResolution/pixelPerRad*180./M_PI*3600;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0022" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       for (unsigned int i=0;i&lt;1<span class="delete">0</span>;++i)</td><td> </td><td class="rblock">       for (unsigned int i=0;i&lt;1<span class="insert">2</span>;++i)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               if (STEP_SIZES_DMS[i]&gt;minSizeArcsec)</td><td> </td><td class="right">               if (STEP_SIZES_DMS[i]&gt;minSizeArcsec)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       return STEP_SIZES_DMS[i]/3600.;</td><td> </td><td class="right">                       return STEP_SIZES_DMS[i]/3600.;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       return 10.;</td><td> </td><td class="right">       return 10.;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! Return the angular grid step in degree which best fits the given scale</td><td> </td><td class="right">//! Return the angular grid step in degree which best fits the given scale</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">static double getClosestResolutionHMS(double pixelPerRad)</td><td> </td><td class="right">static double getClosestResolutionHMS(double pixelPerRad)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       double minResolution = 80.;</td><td> </td><td class="right">       double minResolution = 80.;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       double minSizeArcsec = minResolution/pixelPerRad*180./M_PI*3600;</td><td> </td><td class="right">       double minSizeArcsec = minResolution/pixelPerRad*180./M_PI*3600;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0023" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       for (unsigned int i=0;i&lt;<span class="delete">9</span>;++i)</td><td> </td><td class="rblock">       for (unsigned int i=0;i&lt;<span class="insert">11</span>;++i)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               if (STEP_SIZES_HMS[i]&gt;minSizeArcsec)</td><td> </td><td class="right">               if (STEP_SIZES_HMS[i]&gt;minSizeArcsec)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       return STEP_SIZES_HMS[i]/3600.;</td><td> </td><td class="right">                       return STEP_SIZES_HMS[i]/3600.;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       return 15.;</td><td> </td><td class="right">       return 15.;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0024" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//! Draw the sky grid in the current frame</span></td><td> </td><td class="rblock"><span class="insert">struct ViewportEdgeIntersectCallbackData</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//! This method look for each point of the viewport's contour intersecting </span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">with a meridian/parallel</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//! The the intersecting points are matched 2 by 2 to find out where to dra</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">w the arc of meridian/parallel</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">void SkyGrid::draw(const Projector* prj) const</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0025" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">if (!fader.getInterstate()) return;</span></td><td> </td><td class="rblock">       <span class="insert">ViewportEdgeIntersectCallbackData(const StelPainter&amp; p) : sPainter(p</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       glDisable(GL_TEXTURE_2D);</span></td><td> </td><td class="rblock"><span class="insert">) {;}</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       glEnable(GL_BLEND);</span></td><td> </td><td class="rblock"><span class="insert">       const StelPainter&amp; sPainter;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); // Normal transpa</span></td><td> </td><td class="rblock"><span class="insert">       StelFont* font;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">rency mode</span></td><td> </td><td class="rblock">       Vec4f <span class="insert">textColor;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       Vec4f <span class="delete">textColor(color[0], color[1], color[2], 0);</span></td><td> </td><td class="rblock"><span class="insert">       QString text;           // Label to display at the intersection of t</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       float red;</span></td><td> </td><td class="rblock"><span class="insert">he lines and screen side</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       double raAngle;         // Used for meridians</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       StelCore::FrameType frameType;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">};</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0026" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">if (StelApp::getInstance().getVisionModeNight())</span></td><td> </td><td class="rblock">// <span class="insert">Callback</span> which <span class="insert">draws the label of</span> the <span class="insert">grid</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       {</span></td><td> </td><td class="rblock"><span class="insert">void viewportEdgeIntersectCallback(const Vec3d&amp; screenPos, const Vec3d&amp; dir</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               // <span class="delete">instead of a filter</span> which <span class="delete">just zeros G&amp;B, set</span> the <span class="delete">red</span></td><td> </td><td class="rblock"><span class="insert">ection, const void* userData)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               // <span class="delete">value to</span> the <span class="delete">mean brightness</span> of <span class="delete">RGB.</span></td><td> </td><td class="rblock"><span class="insert">{</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               red</span> = <span class="delete">(color[0] + color[1] + color[2]) / 3.0;</span></td><td> </td><td class="rblock"><span class="insert">       const ViewportEdgeIntersectCallbackData* d = static_cast&lt;const Viewp</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               textColor[0]</span> = <span class="delete">red;</span></td><td> </td><td class="rblock"><span class="insert">ortEdgeIntersectCallbackData*&gt;(userData);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               textColor[1]</span> = 0.; <span class="delete">textColor[2]</span> = 0.;</td><td> </td><td class="rblock"><span class="insert">       Vec3d direc(direction);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               <span class="delete">glColor4f(red, 0, 0, fader.getInterstate());</span></td><td> </td><td class="rblock"><span class="insert">       direc.normalize();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       GLfloat tmpColor[4];</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       glGetFloatv(GL_CURRENT_COLOR, tmpColor);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       glColor4fv(d-&gt;textColor);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       QString text;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       if (d-&gt;text.isEmpty())</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">               // <span class="insert">We are in</span> the <span class="insert">case of meridians, we need to determine whi</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ch</span> of <span class="insert">the 2 labels (3h or 15h to use)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               Vec3d tmpV;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               d-&gt;sPainter.getProjector()-&gt;unProject(screenPos, tmpV);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               double lon, lat;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               StelUtils::rectToSphe(&amp;lon, &amp;lat, tmpV);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               if (d-&gt;frameType==StelCore::FrameAltAz)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       double raAngle</span> = <span class="insert">M_PI-d-&gt;raAngle;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       lon</span> = <span class="insert">M_PI-lon;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       if (raAngle&lt;0)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               raAngle=+2.*M_PI;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       if (lon&lt;0)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               lon=+2.*M_PI;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       if (std::fabs(2.*M_PI-lon)&lt;0.01)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               // We are at meridian 0</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               lon</span> = 0.;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                       <span class="insert">}</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       if (std::fabs(lon-raAngle) &lt; 0.01)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               text = StelUtils::radToDmsStrAdapt(raAngle);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       else</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               const double delta = raAngle&lt;M_PI ? M_PI : -</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">M_PI;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               text = StelUtils::radToDmsStrAdapt(raAngle+d</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">elta);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               else</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       if (std::fabs(2.*M_PI-lon)&lt;0.01)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               // We are at meridian 0</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               lon</span> = 0.;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                       <span class="insert">}</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       if (std::fabs(lon-d-&gt;raAngle) &lt; 0.01)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               text = StelUtils::radToHmsStrAdapt(d-&gt;raAngl</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">e);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       else</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               const double delta = d-&gt;raAngle&lt;M_PI ? M_PI </span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">: -M_PI;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               text = StelUtils::radToHmsStrAdapt(d-&gt;raAngl</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">e+delta);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       else</td><td> </td><td class="right">       else</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0027" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">               <span class="insert">text = d-&gt;text;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       double angleDeg = std::atan2(-direc[1], -direc[0])*180./M_PI;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       float xshift=6.f;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       if (angleDeg&gt;90. || angleDeg&lt;-90.)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0028" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               <span class="delete">glColor4f(color[0],color[1],color[2], fader.getInterstate())</span></td><td> </td><td class="rblock">               <span class="insert">angleDeg+=180.;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">;</span></td><td> </td><td class="rblock"><span class="insert">               xshift=-d-&gt;font-&gt;getStrLen(text)-6.f;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0029" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">textColor*=2;</span></td><td> </td><td class="rblock">       <span class="insert">d-&gt;sPainter.drawText(d-&gt;font, screenPos[0], screenPos[1], text, angl</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       textColor[3]=fader.getInterstate();</span></td><td> </td><td class="rblock"><span class="insert">eDeg, xshift, 3);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       glColor4fv(tmpColor);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">}</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0030" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">prj-&gt;setCurrentFrame(frameType);        // set 2D coordinate</span></td><td> </td><td class="rblock"><span class="insert">//! Draw the sky grid in the current frame</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">void SkyGrid::draw(const StelCore* core) const</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">{</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       const StelProjectorP prj = core-&gt;getProjection(frameType);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       if (!fader.getInterstate())</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               return;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0031" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       // Look for all meridians and parallels intersecting with the disk b
ounding the viewport</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Check whether the pole are in the viewport</td><td> </td><td class="right">       // Check whether the pole are in the viewport</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       bool northPoleInViewport = false;</td><td> </td><td class="right">       bool northPoleInViewport = false;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       bool southPoleInViewport = false;</td><td> </td><td class="right">       bool southPoleInViewport = false;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Vec3d win;</td><td> </td><td class="right">       Vec3d win;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (prj-&gt;project(Vec3d(0,0,1), win) &amp;&amp; prj-&gt;checkInViewport(win))</td><td> </td><td class="right">       if (prj-&gt;project(Vec3d(0,0,1), win) &amp;&amp; prj-&gt;checkInViewport(win))</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               northPoleInViewport = true;</td><td> </td><td class="right">               northPoleInViewport = true;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (prj-&gt;project(Vec3d(0,0,-1), win) &amp;&amp; prj-&gt;checkInViewport(win))</td><td> </td><td class="right">       if (prj-&gt;project(Vec3d(0,0,-1), win) &amp;&amp; prj-&gt;checkInViewport(win))</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               southPoleInViewport = true;</td><td> </td><td class="right">               southPoleInViewport = true;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0032" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                                                                           </span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Get the longitude and latitude resolution at the center of the vi
ewport</td><td> </td><td class="right">       // Get the longitude and latitude resolution at the center of the vi
ewport</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Vec3d centerV;</td><td> </td><td class="right">       Vec3d centerV;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0033" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">double lon0, lat0, lon1, lat1, lon2, lat2;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       prj-&gt;unProject(prj-&gt;getViewportPosX()+prj-&gt;getViewportWidth()/2, prj</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">-&gt;getViewportPosY()+prj-&gt;getViewportHeight()/2, centerV);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       StelUtils::rectToSphe(&amp;lon0, &amp;lat0, centerV);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       prj-&gt;unProject(prj-&gt;getViewportPosX()+prj-&gt;getViewportWidth()/2+1, p</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">rj-&gt;getViewportPosY()+prj-&gt;getViewportHeight()/2, centerV);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       StelUtils::rectToSphe(&amp;lon1, &amp;lat1, centerV);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       prj-&gt;unProject(prj-&gt;getViewportPosX()+prj-&gt;getViewportWidth()/2, prj
-&gt;getViewportPosY()+prj-&gt;getViewportHeight()/2+1, centerV);</td><td> </td><td class="right">       prj-&gt;unProject(prj-&gt;getViewportPosX()+prj-&gt;getViewportWidth()/2, prj
-&gt;getViewportPosY()+prj-&gt;getViewportHeight()/2+1, centerV);</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0034" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       double lon2, lat2;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       StelUtils::rectToSphe(&amp;lon2, &amp;lat2, centerV);</td><td> </td><td class="right">       StelUtils::rectToSphe(&amp;lon2, &amp;lat2, centerV);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0035" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       const double gridStepParallelRad = M_PI/180.*getClosestResolutionDMS</td><td> </td><td class="rblock">       const double gridStepParallelRad = M_PI/180.*getClosestResolutionDMS</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">(1./std::sqrt((lat1-lat0)*(lat1-lat0)+(lat2-lat0)*(lat2-lat0)));</span></td><td> </td><td class="rblock"><span class="insert">(prj-&gt;getPixelPerRadAtCenter());</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       double gridStepMeridianRad;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       if (northPoleInViewport || southPoleInViewport)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               gridStepMeridianRad = M_PI/180.* 15.;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       else</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               const double closetResLon = (frameType==StelCore::FrameAltAz</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">) ? getClosestResolutionDMS(prj-&gt;getPixelPerRadAtCenter()*std::cos(lat2)) :</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> getClosestResolutionHMS(prj-&gt;getPixelPerRadAtCenter()*std::cos(lat2));</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               gridStepMeridianRad = M_PI/180.* ((northPoleInViewport || so</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">uthPoleInViewport) ? 15. : closetResLon);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       // Get the bounding halfspace</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       const StelGeom::HalfSpace viewPortHalfSpace = prj-&gt;getBoundingHalfSp</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ace();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       // Compute the first grid starting point. This point is close to the</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> center of the screen</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       // and lays at the intersection of a meridien and a parallel</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       lon2 = gridStepMeridianRad*((int)(lon2/gridStepMeridianRad));</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       lat2 = gridStepParallelRad*((int)(lat2/gridStepParallelRad));</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       Vec3d firstPoint;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       StelUtils::spheToRect(lon2, lat2, firstPoint);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       firstPoint.normalize();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0036" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">const double closetResLon = (frameType==Projector::FrameLocal) ? get</span></td><td> </td><td class="rblock">       <span class="insert">Q_ASSERT(viewPortHalfSpace.contains(firstPoint));</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">ClosestResolutionDMS(1./std::sqrt((lon1-lon0)*(lon1-lon0)+(lon2-lon0)*(lon2</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">-lon0))) : getClosestResolutionHMS(1./std::sqrt((lon1-lon0)*(lon1-lon0)+(lo</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">n2-lon0)*(lon2-lon0)));</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       const double gridStepMeridianRad = M_PI/180.* ((northPoleInViewport </span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">|| southPoleInViewport) ? 15. : closetResLon);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0037" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">std::map&lt;int, std::set&lt;double&gt; &gt; resultsParallels;</span></td><td> </td><td class="rblock">       <span class="insert">// Initialize a painter and set openGL state</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       std::map&lt;int, std::set&lt;double&gt; &gt; resultsMeridians;</span></td><td> </td><td class="rblock"><span class="insert">       StelPainter sPainter(prj);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       const QList&lt;Vec2d&gt; viewportVertices = prj-&gt;getViewportVertices2d();</span></td><td> </td><td class="rblock"><span class="insert">       glEnable(GL_LINE_SMOOTH);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       for (int i=0;i&lt;viewportVertices.size();++i)</span></td><td> </td><td class="rblock"><span class="insert">       glDisable(GL_TEXTURE_2D);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       glEnable(GL_BLEND);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); // Normal transpa</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">rency mode</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       Vec4f textColor(color[0], color[1], color[2], 0);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       if (StelApp::getInstance().getVisionModeNight())</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0038" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               // <span class="delete">The segment</span> of the <span class="delete">viewport is between v0 and v1</span></td><td> </td><td class="rblock">               // <span class="insert">instead</span> of <span class="insert">a filter which just zeros G&amp;B, set</span> the <span class="insert">red</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               Vec2d vertex0</span> = <span class="delete">viewportVertices[i];</span></td><td> </td><td class="rblock"><span class="insert">               // value to the mean brightness of RGB.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               Vec2d vertex1</span> = <span class="delete">viewportVertices[(i+1)%viewportVertices.size</span></td><td> </td><td class="rblock"><span class="insert">               float red = (color[0] + color[1] + color[2]) / 3.0;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">()];</span></td><td> </td><td class="rblock"><span class="insert">               textColor[0] = red;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               getPslow(resultsParallels, prj, vertex0, vertex1, gridStepPa</span></td><td> </td><td class="rblock"><span class="insert">               textColor[1]</span> = <span class="insert">0.; textColor[2]</span> = <span class="insert">0.;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">rallelRad, getLatFrom2dPos, getLonFrom2dPos);</span></td><td> </td><td class="rblock"><span class="insert">               glColor4f(red, 0, 0, fader.getInterstate());</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               getPslow(resultsMeridians, prj, vertex0, vertex1, gridStepMe</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">ridianRad, getLonFrom2dPosType2, getLatFrom2dPosType2);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0039" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                                                           </td><td> </td><td class="rblock">       <span class="insert">else</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">// Draw the parallels</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       for (std::map&lt;int, std::set&lt;double&gt; &gt;::const_iterator iter=resultsPa</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">rallels.begin(); iter!=resultsParallels.end(); ++iter)</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0040" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               <span class="delete">if (iter-&gt;second.size()%2!=0)</span></td><td> </td><td class="rblock">               <span class="insert">glColor4f(color[0],color[1],color[2], fader.getInterstate())</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               {</span></td><td> </td><td class="rblock"><span class="insert">;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       qWarning() &lt;&lt; "ERROR drawing skygrid - parallel "&lt;&lt; </span></td><td> </td><td class="rblock">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">(double)iter-&gt;first/DEGREE_MAS &lt;&lt; iter-&gt;second.size();</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               }</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               else</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               {</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       std::set&lt;double&gt;::const_iterator ii = iter-&gt;second.b</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">egin();</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       if (!isParallelEntering(prj, *iter-&gt;second.begin(), </span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">(double)iter-&gt;first/RADIAN_MAS))</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       {</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                               ++ii;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       }</td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0041" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       Vec3d <span class="delete">vv;</span></td><td> </td><td class="rblock">       <span class="insert">textColor*=2;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       double size;</span></td><td> </td><td class="rblock"><span class="insert">       textColor[3]=fader.getInterstate();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       for (unsigned</span> int <span class="delete">i=0;i&lt;iter-&gt;second.size()/2;++i)</span></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       ViewportEdgeIntersectCallbackData userData(sPainter);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       userData.font = &amp;font;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       userData.textColor = textColor;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       userData.frameType = frameType;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /////////////////////////////////////////////////</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       // Draw all the meridians (great circles)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       StelGeom::HalfSpace meridianHalfSpace(Vec3d(1,0,0), 0);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       Mat4d rotLon = Mat4d::zrotation(gridStepMeridianRad);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       Vec3d <span class="insert">fpt = firstPoint;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       Vec3d p1, p2;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       int <span class="insert">maxNbIter = (int)(M_PI/gridStepMeridianRad);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       int i;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       for (i=0; i&lt;maxNbIter; ++i)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               StelUtils::rectToSphe(&amp;lon2, &amp;lat2, fpt);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               userData.raAngle = lon2;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               meridianHalfSpace.n = fpt^Vec3d(0,0,1);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               meridianHalfSpace.n.normalize();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               if (!planeIntersect2(viewPortHalfSpace, meridianHalfSpace, p</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">1, p2))</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       if (viewPortHalfSpace.d&lt;meridianHalfSpace.d &amp;&amp; viewP</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ortHalfSpace.contains(meridianHalfSpace.n))</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       {</td><td> </td><td class="right">                       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0042" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                               <span class="delete">double lon</span> = <span class="delete">*ii;</span></td><td> </td><td class="rblock">                               <span class="insert">// The meridian is fully included in the vie</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                               StelUtils::spheToRect(lon, (double)iter-&gt;fir</span></td><td> </td><td class="rblock"><span class="insert">wport, draw it in 3 sub-arcs to avoid length &gt; 180.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">st/RADIAN_MAS, vv);</span></td><td> </td><td class="rblock"><span class="insert">                               Mat4d rotLon120</span> = <span class="insert">Mat4d::rotation(meridianHa</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                               ++ii;</span></td><td> </td><td class="rblock"><span class="insert">lfSpace.n, 120.*M_PI/180.);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                               if (ii==iter-&gt;second.end())</span></td><td> </td><td class="rblock"><span class="insert">                               Vec3d rotFpt=fpt;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                                       size = *iter-&gt;second.begin() - lon;</span></td><td> </td><td class="rblock"><span class="insert">                               rotFpt.transfo4d(rotLon120);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                               else</span></td><td> </td><td class="rblock"><span class="insert">                               Vec3d rotFpt2=rotFpt;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                                       size = *ii - lon;</span></td><td> </td><td class="rblock"><span class="insert">                               rotFpt2.transfo4d(rotLon120);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                               if (size&lt;0) size+=2.*M_PI;</span></td><td> </td><td class="rblock"><span class="insert">                               sPainter.drawSmallCircleArc(fpt, rotFpt, Vec</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                               prj-&gt;drawParallel(vv, size, true, &amp;font, &amp;te</span></td><td> </td><td class="rblock"><span class="insert">3d(0,0,0), viewportEdgeIntersectCallback, &amp;userData);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">xtColor);</span></td><td> </td><td class="rblock"><span class="insert">                               sPainter.drawSmallCircleArc(rotFpt, rotFpt2,</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                               ++ii;</span></td><td> </td><td class="rblock"><span class="insert"> Vec3d(0,0,0), viewportEdgeIntersectCallback, &amp;userData);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               sPainter.drawSmallCircleArc(rotFpt2, fpt, Ve</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">c3d(0,0,0), viewportEdgeIntersectCallback, &amp;userData);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               fpt.transfo4d(rotLon);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               continue;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       }</td><td> </td><td class="right">                       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0043" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                       <span class="insert">else</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               break;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0044" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">               <span class="insert">Vec3d middlePoint = p1+p2;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               middlePoint.normalize();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               if (!viewPortHalfSpace.contains(middlePoint))</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       middlePoint*=-1.;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               // Draw the arc in 2 sub-arcs to avoid lengths &gt; 180 deg</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               sPainter.drawSmallCircleArc(p1, middlePoint, Vec3d(0), viewp</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ortEdgeIntersectCallback, &amp;userData);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               sPainter.drawSmallCircleArc(p2, middlePoint, Vec3d(0), viewp</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ortEdgeIntersectCallback, &amp;userData);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               fpt.transfo4d(rotLon);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0045" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">// Draw the parallels which didn't intersect the viewport but are in</span></td><td> </td><td class="rblock">       if <span class="insert">(i!=maxNbIter)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"> the screen</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       // This can only happen for parallels around the poles fully include</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">d in the viewport (At least I hope!)</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       if <span class="delete">(northPoleInViewport &amp;&amp; !resultsParallels.empty())</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0046" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               <span class="delete">const double lastLat</span> = <span class="delete">(double)(--resultsParallels.end())-&gt;f</span></td><td> </td><td class="rblock">               <span class="insert">rotLon</span> = <span class="insert">Mat4d::rotation(Vec3d(0,0,1), -gridStepMeridianRad)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">irst/RADIAN_MAS;</span></td><td> </td><td class="rblock"><span class="insert">;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               for <span class="delete">(double lat=lastLat+gridStepParallelRad;lat&lt;M_PI/2-0.000</span></td><td> </td><td class="rblock"><span class="insert">               fpt = firstPoint;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">01;lat+=gridStepParallelRad)</span></td><td> </td><td class="rblock"><span class="insert">               fpt.transfo4d(rotLon);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">               for <span class="insert">(int j=0; j&lt;maxNbIter-i; ++j)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0047" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       Vec3d <span class="delete">vv(std::cos(lat), 0, std::sin(lat));</span></td><td> </td><td class="rblock">                       <span class="insert">StelUtils::rectToSphe(&amp;lon2, &amp;lat2, fpt);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       prj-&gt;drawParallel(vv, 2.*M_PI);</span></td><td> </td><td class="rblock"><span class="insert">                       userData.raAngle = lon2;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       meridianHalfSpace.n = fpt^Vec3d(0,0,1);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       meridianHalfSpace.n.normalize();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       if (!planeIntersect2(viewPortHalfSpace, meridianHalf</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">Space, p1, p2))</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               break;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                       Vec3d <span class="insert">middlePoint = p1+p2;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       middlePoint.normalize();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       if (!viewPortHalfSpace.contains(middlePoint))</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               middlePoint*=-1;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       sPainter.drawSmallCircleArc(p1, middlePoint, Vec3d(0</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">), viewportEdgeIntersectCallback, &amp;userData);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       sPainter.drawSmallCircleArc(p2, middlePoint, Vec3d(0</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">), viewportEdgeIntersectCallback, &amp;userData);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       fpt.transfo4d(rotLon);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0048" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">if (southPoleInViewport &amp;&amp; !resultsParallels.empty())</span></td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">/////////////////////////////////////////////////</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       // Draw all the parallels (small circles)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       StelGeom::HalfSpace parallelHalfSpace(Vec3d(0,0,1), 0);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       rotLon = Mat4d::rotation(firstPoint^Vec3d(0,0,1), gridStepParallelRa</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">d);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       fpt = firstPoint;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       maxNbIter = (int)(M_PI/gridStepParallelRad)-1;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       for (i=0; i&lt;maxNbIter; ++i)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0049" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               <span class="delete">const double lastLat</span> = <span class="delete">(double)resultsParallels.begin()-&gt;fir</span></td><td> </td><td class="rblock">               <span class="insert">StelUtils::rectToSphe(&amp;lon2, &amp;lat2, fpt);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">st/RADIAN_MAS;</span></td><td> </td><td class="rblock"><span class="insert">               userData.text</span> = <span class="insert">StelUtils::radToDmsStrAdapt(lat2);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               for (double lat=lastLat-gridStepParallelRad;lat&gt;-M_PI/2+0.00</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">001;lat-=gridStepParallelRad)</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               {</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       Vec3d vv(std::cos(lat), 0, std::sin(lat));</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       prj-&gt;drawParallel(vv, 2.*M_PI);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               }</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       }</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0050" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">// Draw meridians</span></td><td> </td><td class="rblock">               <span class="insert">parallelHalfSpace.d = fpt[2];</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               if (parallelHalfSpace.d&gt;0.9999999)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       break;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0051" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">// Discriminate meridian categories,</span> if <span class="delete">latitude is &gt; pi, the real l</span></td><td> </td><td class="rblock">               <span class="insert">const Vec3d rotCenter(0,0,parallelHalfSpace.d);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">ongitude180 is -longitude+pi</span></td><td> </td><td class="rblock">               if <span class="insert">(!planeIntersect2(viewPortHalfSpace, parallelHalfSpace, p</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       std::map&lt;int, std::set&lt;double&gt; &gt; resultsMeridiansOrdered;</span></td><td> </td><td class="rblock"><span class="insert">1, p2))</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       for (std::map&lt;int, std::set&lt;double&gt; &gt;::const_iterator iter=resultsMe</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">ridians.begin(); iter!=resultsMeridians.end(); ++iter)</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       {</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               for (std::set&lt;double&gt;::const_iterator k=iter-&gt;second.begin()</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">;k!=iter-&gt;second.end();++k)</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0052" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       <span class="delete">assert(*k&gt;=0.</span> &amp;&amp; <span class="delete">*k&lt;=2.*M_PI);</span></td><td> </td><td class="rblock">                       <span class="insert">if ((viewPortHalfSpace.d&lt;parallelHalfSpace.d</span> &amp;&amp; <span class="insert">view</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       assert((double)iter-&gt;first/RADIAN_MAS&gt;=0.</span> &amp;&amp; <span class="delete">(double</span></td><td> </td><td class="rblock"><span class="insert">PortHalfSpace.contains(parallelHalfSpace.n))</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">)iter-&gt;first/RADIAN_MAS&lt;=M_PI);</span></td><td> </td><td class="rblock"><span class="insert">                               || (viewPortHalfSpace.d&lt;-parallelHalfSpace.d</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       if (*k&gt;M_PI)</span></td><td> </td><td class="rblock"> &amp;&amp; <span class="insert">viewPortHalfSpace.contains(-parallelHalfSpace.n)))</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                               resultsMeridiansOrdered[(int)(10*std::floor(</span></td><td> </td><td class="rblock"><span class="insert">                       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">(M_PI*RADIAN_MAS-iter-&gt;first+5.0)/10.0))].insert(*k);</span></td><td> </td><td class="rblock"><span class="insert">                               // The parallel is fully included in the vie</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">wport, draw it in 3 sub-arcs to avoid lengths &gt;= 180 deg</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               Mat4d rotLon120 = Mat4d::rotation(Vec3d(0,0,</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">1), 120.*M_PI/180.);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               Vec3d rotFpt=fpt;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               rotFpt.transfo4d(rotLon120);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               Vec3d rotFpt2=rotFpt;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               rotFpt2.transfo4d(rotLon120);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               sPainter.drawSmallCircleArc(fpt, rotFpt, rot</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">Center, viewportEdgeIntersectCallback, &amp;userData);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               sPainter.drawSmallCircleArc(rotFpt, rotFpt2,</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> rotCenter, viewportEdgeIntersectCallback, &amp;userData);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               sPainter.drawSmallCircleArc(rotFpt2, fpt, ro</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">tCenter, viewportEdgeIntersectCallback, &amp;userData);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               fpt.transfo4d(rotLon);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               continue;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       else</td><td> </td><td class="right">                       else</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0053" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                               <span class="delete">resultsMeridiansOrdered[(int)(10*std::floor(
(iter-&gt;first+5.0)/10.0))].insert(*k)</span>;</td><td> </td><td class="rblock">                               <span class="insert">break</span>;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0054" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       }</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0055" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">for (std::map&lt;int, std::set&lt;double&gt; &gt;::const_iterator iter=resultsMe</span></td><td> </td><td class="rblock">               // <span class="insert">Draw the arc in 2 sub-arcs to avoid lengths &gt; 180 deg</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">ridiansOrdered.begin(); iter!=resultsMeridiansOrdered.end(); ++iter)</span></td><td> </td><td class="rblock">               Vec3d <span class="insert">middlePoint = p1-rotCenter+p2-rotCenter;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       {</span></td><td> </td><td class="rblock"><span class="insert">               middlePoint.normalize();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//             qDebug() &lt;&lt; "------- lon1802=" &lt;&lt; iter-&gt;first &lt;&lt; "--------";</span></td><td> </td><td class="rblock"><span class="insert">               middlePoint*=(p1-rotCenter).length();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//             for (map&lt;double, Vec2d&gt;::const_iterator k = iter-&gt;second.beg</span></td><td> </td><td class="rblock"><span class="insert">               middlePoint+=rotCenter;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">in();k!=iter-&gt;second.end();++k)</span></td><td> </td><td class="rblock">               if <span class="insert">(!viewPortHalfSpace.contains(middlePoint))</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//             {</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">//                     Vec3d <span class="delete">v;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//                     prj-&gt;unProject(k-&gt;second[0], k-&gt;second[1], v);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//                     double llon, llat;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//                     rectToSpheType2(llon, llat, v);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//                     qDebug() &lt;&lt; k-&gt;second &lt;&lt; " lat=" &lt;&lt; k-&gt;first*180./M_</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">PI &lt;&lt; " Llon="&lt;&lt; llon*180./M_PI &lt;&lt; " Llat=" &lt;&lt; llat*180./M_PI &lt;&lt; (isMeridia</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">nEnteringLat180(prj, (double)iter-&gt;first/RADIAN_MAS, k-&gt;first) ?" *":"");</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//             }</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                                                           </td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               if <span class="delete">(iter-&gt;second.size()%2!=0)</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0056" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       <span class="delete">//qDebug() &lt;&lt; "Error meridian " &lt;&lt; (double)iter-&gt;fir</span></td><td> </td><td class="rblock">                       <span class="insert">middlePoint-=rotCenter;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">st/DEGREE_MAS &lt;&lt; " " &lt;&lt; iter-&gt;second.size();</span></td><td> </td><td class="rblock"><span class="insert">                       middlePoint*=-1.;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       middlePoint+=rotCenter;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0057" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               <span class="delete">else</span></td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">               <span class="insert">sPainter.drawSmallCircleArc(p1, middlePoint, rotCenter, view</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">portEdgeIntersectCallback, &amp;userData);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               sPainter.drawSmallCircleArc(p2, middlePoint, rotCenter, view</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">portEdgeIntersectCallback, &amp;userData);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               fpt.transfo4d(rotLon);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       if (i!=maxNbIter)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               rotLon = Mat4d::rotation(firstPoint^Vec3d(0,0,1), -gridStepP</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">arallelRad);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               fpt = firstPoint;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               fpt.transfo4d(rotLon);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               for (int j=0; j&lt;maxNbIter-i; ++j)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0058" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       <span class="delete">// The content of the set iter-&gt;second is supposed t</span></td><td> </td><td class="rblock">                       <span class="insert">StelUtils::rectToSphe(&amp;lon2, &amp;lat2, fpt);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">o be the sorted list of the latitudeType2</span></td><td> </td><td class="rblock"><span class="insert">                       userData.text</span> = <span class="insert">StelUtils::radToDmsStrAdapt(lat2);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       // at which the meridian of longitude iter-&gt;first cr</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">osses the viewport</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       std::set&lt;double&gt;::const_iterator k</span> = <span class="delete">iter-&gt;second.be</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">gin();</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       if (!isMeridianEnteringLat180(prj, (double)iter-&gt;fir</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">st/RADIAN_MAS, *k))</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       {</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                               ++k;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       }</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0059" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       Vec3d <span class="delete">vv;</span></td><td> </td><td class="rblock">                       <span class="insert">parallelHalfSpace.d = fpt[2];</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       double size;</span></td><td> </td><td class="rblock"><span class="insert">                       const</span> Vec3d <span class="insert">rotCenter(0,0,parallelHalfSpace.d);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       for (unsigned int i=0;i&lt;iter-&gt;second.size()/2;++i)</span></td><td> </td><td class="rblock"><span class="insert">                       if (!planeIntersect2(viewPortHalfSpace, parallelHalf</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">Space, p1, p2))</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       {</td><td> </td><td class="right">                       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0060" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                               <span class="delete">double lat180 = *k;</span></td><td> </td><td class="rblock">                               if <span class="insert">((viewPortHalfSpace.d&lt;parallelHalfSpace.d</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                               spheToRectLat1802((double)iter-&gt;first/RADIAN</span></td><td> </td><td class="rblock"><span class="insert"> &amp;&amp; viewPortHalfSpace.contains(parallelHalfSpace.n))</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">_MAS, lat180, vv);</span></td><td> </td><td class="rblock"><span class="insert">                                        || (viewPortHalfSpace.d&lt;-parallelHa</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                               ++k;</span></td><td> </td><td class="rblock"><span class="insert">lfSpace.d &amp;&amp; viewPortHalfSpace.contains(-parallelHalfSpace.n)))</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                               if <span class="delete">(k==iter-&gt;second.end())</span></td><td> </td><td class="rblock"><span class="insert">                               {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                                       size</span> = <span class="delete">*iter-&gt;second.begin() - lat18</span></td><td> </td><td class="rblock"><span class="insert">                                       // The parallel is fully included in</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">0;</span></td><td> </td><td class="rblock"><span class="insert"> the viewport, draw it in 3 sub-arcs to avoid lengths &gt;= 180 deg</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                       Mat4d rotLon120</span> = <span class="insert">Mat4d::rotation(Ve</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">c3d(0,0,1), 120.*M_PI/180.);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                       Vec3d rotFpt=fpt;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                       rotFpt.transfo4d(rotLon120);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                       Vec3d rotFpt2=rotFpt;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                       rotFpt2.transfo4d(rotLon120);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                       sPainter.drawSmallCircleArc(fpt, rot</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">Fpt, rotCenter, viewportEdgeIntersectCallback, &amp;userData);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                       sPainter.drawSmallCircleArc(rotFpt, </span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">rotFpt2, rotCenter, viewportEdgeIntersectCallback, &amp;userData);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                       sPainter.drawSmallCircleArc(rotFpt2,</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> fpt, rotCenter, viewportEdgeIntersectCallback, &amp;userData);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                       fpt.transfo4d(rotLon);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                       continue;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               else</td><td> </td><td class="right">                               else</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0061" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                       <span class="delete">size = *k - lat180;</span></td><td> </td><td class="rblock">                                       <span class="insert">break;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                               if (size&lt;0.) size+=2.*M_PI;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                               prj-&gt;drawMeridian(vv, size, true, &amp;font, &amp;te</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">xtColor, -1, frameType==Projector::FrameLocal);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                               ++k;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       }</td><td> </td><td class="right">                       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0062" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               }</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0063" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">//             <span class="delete">// Debug, draw a cross for all the points</span></td><td> </td><td class="rblock">                       // Draw the <span class="insert">arc</span> in <span class="insert">2 sub-arcs to avoid lengths &gt; 180</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//             for (set&lt;double&gt;::const_iterator k=iter-&gt;second.begin();k!=i</span></td><td> </td><td class="rblock"><span class="insert"> deg</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">ter-&gt;second.end();++k)</span></td><td> </td><td class="rblock"><span class="insert">                       Vec3d middlePoint</span> = <span class="insert">p1-rotCenter+p2-rotCenter;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//             {</span></td><td> </td><td class="rblock"><span class="insert">                       middlePoint.normalize();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//                     //const double lon180 = k-&gt;first&gt;M_PI? (double)iter-</span></td><td> </td><td class="rblock"><span class="insert">                       middlePoint*=(p1-rotCenter).length();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">&gt;first/RADIAN_MAS-M_PI : (double)iter-&gt;first/RADIAN_MAS;</span></td><td> </td><td class="rblock"><span class="insert">                       middlePoint+=rotCenter;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//                     if (isMeridianEnteringLat180(prj, (double)iter-&gt;firs</span></td><td> </td><td class="rblock">                       if <span class="insert">(!viewPortHalfSpace.contains(middlePoint))</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">t/RADIAN_MAS, *k))</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//                     {</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//                             glColor3f(1,1,0);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//                     }</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//                     else</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//                     {</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//                             glColor3f(0,0,1);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//                     }</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//                     Vec3d vv, win;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//                     spheToRectLat1802((double)iter-&gt;first/RADIAN_MAS, *k</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">, vv);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//                     prj-&gt;project(vv, win);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//                     glBegin(GL_LINES);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//                             glVertex2f(win[0]-30,win[1]);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//                             glVertex2f(win[0]+30,win[1]);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//                             glVertex2f(win[0],win[1]-30);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//                             glVertex2f(win[0],win[1]+30);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//                     glEnd();</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//             }</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       }</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       // Draw meridian zero which can't be found by the normal algo..</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       const Vec3d vv(1,0,0);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       prj-&gt;drawMeridian(vv, 2.*M_PI, false, &amp;font, NULL, -1, frameType==Pr</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">ojector::FrameLocal);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       //</span> Draw the <span class="delete">meridians which are totally included</span> in <span class="delete">the viewport (an</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">d thus don't intersect with the edge of the screen)</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       if (northPoleInViewport &amp;&amp; southPoleInViewport)</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       {</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               int nbMeridian = (int)(2.*M_PI/gridStepMeridianRad);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               int dLatMas</span> = <span class="delete">360*60*60*1000/nbMeridian;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               // qDebug() &lt;&lt; resultsMeridiansOrdered.size()+1 &lt;&lt; "/" &lt;&lt; nb</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">Meridian/2 &lt;&lt; " dLatMas=" &lt;&lt; dLatMas/1000/60/60;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               for (int latMas=0;latMas&lt;360*60*60*1000/2;latMas+=dLatMas)</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               {</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       if <span class="delete">(resultsMeridiansOrdered.find(latMas)==resultsMer</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">idiansOrdered.end() &amp;&amp; latMas!=0)</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       {</td><td> </td><td class="right">                       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0064" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                               <span class="delete">Vec3d vvv;</span></td><td> </td><td class="rblock">                               <span class="insert">middlePoint-=rotCenter;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                               spheToRectLat1802((double)latMas/RADIAN_MAS,</span></td><td> </td><td class="rblock"><span class="insert">                               middlePoint*=-1.;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"> 0, vvv);</span></td><td> </td><td class="rblock"><span class="insert">                               middlePoint+=rotCenter;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                               prj-&gt;drawMeridian(vvv, 2.*M_PI, false, &amp;font</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">, &amp;textColor, -1, frameType==Projector::FrameLocal);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       }</td><td> </td><td class="right">                       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0065" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                       <span class="insert">sPainter.drawSmallCircleArc(p1, middlePoint, rotCent</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">er, viewportEdgeIntersectCallback, &amp;userData);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       sPainter.drawSmallCircleArc(p2, middlePoint, rotCent</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">er, viewportEdgeIntersectCallback, &amp;userData);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       fpt.transfo4d(rotLon);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0066" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">SkyLine::SkyLine(SKY_LINE_TYPE _line_type) : color(0.f, 0.f, 1.f), fontSize
(1.),</td><td> </td><td class="rblock">SkyLine::SkyLine(SKY_LINE_TYPE _line_type) : color(0.f, 0.f, 1.f), fontSize
(1<span class="insert">4</span>.),</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">font(StelApp::getInstance().getFontManager().getStandardFont(StelApp::getIn
stance().getLocaleMgr().getAppLanguage(), fontSize))</td><td> </td><td class="right">font(StelApp::getInstance().getFontManager().getStandardFont(StelApp::getIn
stance().getLocaleMgr().getAppLanguage(), fontSize))</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       line_type = _line_type;</td><td> </td><td class="right">       line_type = _line_type;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       switch (line_type)</td><td> </td><td class="right">       switch (line_type)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0067" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               case <span class="delete">LOCAL :</span> frameType = <span class="delete">Projector::FrameLocal; break;</span></td><td> </td><td class="rblock">               case <span class="insert">MERIDIAN:</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               case MERIDIAN : frameType</span> = <span class="delete">Projector::FrameLocal;</span> break;</td><td> </td><td class="rblock">                       frameType = <span class="insert">StelCore::FrameAltAz;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               case <span class="delete">ECLIPTIC :</span> frameType = <span class="delete">Projector::FrameHelio;</span> break;</td><td> </td><td class="rblock"><span class="insert">                       label</span> = <span class="insert">q_("Meridian");</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               case <span class="delete">EQUATOR :</span> frameType = <span class="delete">Projector::FrameEarthEqu; break;</span></td><td> </td><td class="rblock">                       break;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               default : frameType</span> = <span class="delete">Projector::FrameEarthEqu;</span></td><td> </td><td class="rblock">               case <span class="insert">ECLIPTIC:</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                       frameType = <span class="insert">StelCore::FrameObservercentricEcliptic;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       label = q_("Ecliptic");</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                       break;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">               case <span class="insert">EQUATOR:</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                       frameType = <span class="insert">StelCore::FrameEquinoxEqu;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       label</span> = <span class="insert">q_("Equator");</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       break;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">SkyLine::~SkyLine()</td><td> </td><td class="right">SkyLine::~SkyLine()</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void SkyLine::setFontSize(double newFontSize)</td><td> </td><td class="right">void SkyLine::setFontSize(double newFontSize)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       fontSize = newFontSize;</td><td> </td><td class="right">       fontSize = newFontSize;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       font = StelApp::getInstance().getFontManager().getStandardFont(StelA
pp::getInstance().getLocaleMgr().getAppLanguage(), fontSize);</td><td> </td><td class="right">       font = StelApp::getInstance().getFontManager().getStandardFont(StelA
pp::getInstance().getLocaleMgr().getAppLanguage(), fontSize);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0068" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">void SkyLine::draw(<span class="delete">Projector *prj,const Navigator *nav</span>) const</td><td> </td><td class="rblock">void SkyLine::draw(<span class="insert">StelCore *core</span>) const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0069" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       if (!fader.getInterstate()) return;</td><td> </td><td class="rblock">       if (!fader.getInterstate())</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">               return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">StelProjectorP prj = core-&gt;getProjection(frameType);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       // Get the bounding halfspace</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       const StelGeom::HalfSpace viewPortHalfSpace = prj-&gt;getBoundingHalfSp</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ace();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0070" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">// Initialize a painter and set openGL state</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       StelPainter sPainter(prj);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       glColor4f(color[0], color[1], color[2], fader.getInterstate());</td><td> </td><td class="right">       glColor4f(color[0], color[1], color[2], fader.getInterstate());</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       glDisable(GL_TEXTURE_2D);</td><td> </td><td class="right">       glDisable(GL_TEXTURE_2D);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       glEnable(GL_BLEND);</td><td> </td><td class="right">       glEnable(GL_BLEND);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); // Normal transpa
rency mode</td><td> </td><td class="right">       glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); // Normal transpa
rency mode</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0071" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       glEnable(GL_LINE_SMOOTH);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0072" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">prj-&gt;setCurrentFrame(frameType);</span></td><td> </td><td class="rblock">       <span class="insert">Vec4f textColor(color[0], color[1], color[2], 0);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       textColor*=2;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       textColor[3]=fader.getInterstate();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0073" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       // <span class="delete">Johannes: use a big radius as a dirty workaround for</span> the <span class="delete">bug that</span></td><td> </td><td class="rblock">       <span class="insert">ViewportEdgeIntersectCallbackData userData(sPainter);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"> the</span></td><td> </td><td class="rblock"><span class="insert">       userData.font = &amp;font;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       // ecliptic</span> line <span class="delete">is not drawn around the observer, but around the su</span></td><td> </td><td class="rblock"><span class="insert">       userData.textColor = textColor;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">n:</span></td><td> </td><td class="rblock"><span class="insert">       userData.text = label;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       const</span> Vec3d <span class="delete">vv(1000000,0,0);</span></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /////////////////////////////////////////////////</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       // <span class="insert">Draw</span> the line</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">StelGeom::HalfSpace meridianHalfSpace(Vec3d(0,0,1), 0);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       Vec3d <span class="insert">fpt(1,0,0);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (line_type==MERIDIAN)</td><td> </td><td class="right">       if (line_type==MERIDIAN)</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0074" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               <span class="delete">prj-&gt;drawMeridian(vv, 2.*M_PI, false, &amp;font);</span></td><td> </td><td class="rblock">       <span class="insert">{</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       else</td><td> </td><td class="rblock"><span class="insert">               meridianHalfSpace.n.set(0,1,0);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               <span class="delete">prj-&gt;drawParallel(vv, 2.*M_PI, false, &amp;font);</span></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       Vec3d p1, p2;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       if (!planeIntersect2(viewPortHalfSpace, meridianHalfSpace, p1, p2))</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               if ((viewPortHalfSpace.d&lt;meridianHalfSpace.d &amp;&amp; viewPortHalf</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">Space.contains(meridianHalfSpace.n))</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                   || (viewPortHalfSpace.d&lt;-meridianHalfSpace.d &amp;&amp; viewPort</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">HalfSpace.contains(-meridianHalfSpace.n)))</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       // The meridian is fully included in the viewport, d</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">raw it in 3 sub-arcs to avoid length &gt; 180.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       Mat4d rotLon120 = Mat4d::rotation(meridianHalfSpace.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">n, 120.*M_PI/180.);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       Vec3d rotFpt=fpt;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       rotFpt.transfo4d(rotLon120);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       Vec3d rotFpt2=rotFpt;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       rotFpt2.transfo4d(rotLon120);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       sPainter.drawSmallCircleArc(fpt, rotFpt, Vec3d(0,0,0</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">), viewportEdgeIntersectCallback, &amp;userData);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       sPainter.drawSmallCircleArc(rotFpt, rotFpt2, Vec3d(0</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">,0,0), viewportEdgeIntersectCallback, &amp;userData);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       sPainter.drawSmallCircleArc(rotFpt2, fpt, Vec3d(0,0,</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">0), viewportEdgeIntersectCallback, &amp;userData);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       return;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">               else</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                       <span class="insert">return;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       Vec3d middlePoint = p1+p2;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       middlePoint.normalize();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       if (!viewPortHalfSpace.contains(middlePoint))</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               middlePoint*=-1.;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       // Draw the arc in 2 sub-arcs to avoid lengths &gt; 180 deg</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       sPainter.drawSmallCircleArc(p1, middlePoint, Vec3d(0,0,0), viewportE</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">dgeIntersectCallback, &amp;userData);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       sPainter.drawSmallCircleArc(p2, middlePoint, Vec3d(0,0,0), viewportE</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">dgeIntersectCallback, &amp;userData);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//     // Johannes: use a big radius as a dirty workaround for the bug that</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> the</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//     // ecliptic line is not drawn around the observer, but around the su</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">n:</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//     const Vec3d vv(1000000,0,0);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">GridLinesMgr::GridLinesMgr()</td><td> </td><td class="right">GridLinesMgr::GridLinesMgr()</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       setObjectName("GridLinesMgr");</td><td> </td><td class="right">       setObjectName("GridLinesMgr");</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0075" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       equGrid = new <span class="delete">SkyGrid(Projector::FrameEarthEqu);</span></td><td> </td><td class="rblock">       equGrid = new <span class="insert">SkyGrid(StelCore::FrameEquinoxEqu);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       equJ2000Grid = new <span class="delete">SkyGrid(Projector::FrameJ2000);</span></td><td> </td><td class="rblock">       equJ2000Grid = new <span class="insert">SkyGrid(StelCore::FrameJ2000);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       aziGrid = new <span class="delete">SkyGrid(Projector::FrameLocal);</span></td><td> </td><td class="rblock">       aziGrid = new <span class="insert">SkyGrid(StelCore::FrameAltAz);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       equatorLine = new SkyLine(SkyLine::EQUATOR);</td><td> </td><td class="right">       equatorLine = new SkyLine(SkyLine::EQUATOR);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       eclipticLine = new SkyLine(SkyLine::ECLIPTIC);</td><td> </td><td class="right">       eclipticLine = new SkyLine(SkyLine::ECLIPTIC);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       meridianLine = new SkyLine(SkyLine::MERIDIAN);</td><td> </td><td class="right">       meridianLine = new SkyLine(SkyLine::MERIDIAN);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">GridLinesMgr::~GridLinesMgr()</td><td> </td><td class="right">GridLinesMgr::~GridLinesMgr()</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       delete equGrid;</td><td> </td><td class="right">       delete equGrid;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       delete equJ2000Grid;</td><td> </td><td class="right">       delete equJ2000Grid;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       delete aziGrid;</td><td> </td><td class="right">       delete aziGrid;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l2" /><small>skipping to change at</small><em> line 644</em></th><th> </th><th><a name="part-r2" /><small>skipping to change at</small><em> line 624</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">double GridLinesMgr::getCallOrder(StelModuleActionName actionName) const</td><td> </td><td class="right">double GridLinesMgr::getCallOrder(StelModuleActionName actionName) const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (actionName==StelModule::ActionDraw)</td><td> </td><td class="right">       if (actionName==StelModule::ActionDraw)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return StelApp::getInstance().getModuleMgr().getModule("Nebu
laMgr")-&gt;getCallOrder(actionName)+10;</td><td> </td><td class="right">               return StelApp::getInstance().getModuleMgr().getModule("Nebu
laMgr")-&gt;getCallOrder(actionName)+10;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       return 0;</td><td> </td><td class="right">       return 0;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void GridLinesMgr::init()</td><td> </td><td class="right">void GridLinesMgr::init()</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       QSettings* conf = StelApp::getInstance().getSettings();</td><td> </td><td class="right">       QSettings* conf = StelApp::getInstance().getSettings();</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0076" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">assert</span>(conf);</td><td> </td><td class="rblock">       <span class="insert">Q_ASSERT</span>(conf);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0077" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       setFlagAzimut<span class="delete">alGrid(conf-&gt;value("viewing/flag_azimutal_grid").toBool
</span>());</td><td> </td><td class="rblock">       setFlagAzimut<span class="insert">halGrid(conf-&gt;value("viewing/flag_azimuthal_grid").toBo
ol</span>());</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       setFlagEquatorGrid(conf-&gt;value("viewing/flag_equatorial_grid").toBoo
l());</td><td> </td><td class="right">       setFlagEquatorGrid(conf-&gt;value("viewing/flag_equatorial_grid").toBoo
l());</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       setFlagEquatorJ2000Grid(conf-&gt;value("viewing/flag_equatorial_J2000_g
rid").toBool());</td><td> </td><td class="right">       setFlagEquatorJ2000Grid(conf-&gt;value("viewing/flag_equatorial_J2000_g
rid").toBool());</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       setFlagEquatorLine(conf-&gt;value("viewing/flag_equator_line").toBool()
);</td><td> </td><td class="right">       setFlagEquatorLine(conf-&gt;value("viewing/flag_equator_line").toBool()
);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       setFlagEclipticLine(conf-&gt;value("viewing/flag_ecliptic_line").toBool
());</td><td> </td><td class="right">       setFlagEclipticLine(conf-&gt;value("viewing/flag_ecliptic_line").toBool
());</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       setFlagMeridianLine(conf-&gt;value("viewing/flag_meridian_line").toBool
());</td><td> </td><td class="right">       setFlagMeridianLine(conf-&gt;value("viewing/flag_meridian_line").toBool
());</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void GridLinesMgr::update(double deltaTime)</td><td> </td><td class="right">void GridLinesMgr::update(double deltaTime)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Update faders</td><td> </td><td class="right">       // Update faders</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       equGrid-&gt;update(deltaTime);</td><td> </td><td class="right">       equGrid-&gt;update(deltaTime);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       equJ2000Grid-&gt;update(deltaTime);</td><td> </td><td class="right">       equJ2000Grid-&gt;update(deltaTime);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       aziGrid-&gt;update(deltaTime);</td><td> </td><td class="right">       aziGrid-&gt;update(deltaTime);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       equatorLine-&gt;update(deltaTime);</td><td> </td><td class="right">       equatorLine-&gt;update(deltaTime);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       eclipticLine-&gt;update(deltaTime);</td><td> </td><td class="right">       eclipticLine-&gt;update(deltaTime);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       meridianLine-&gt;update(deltaTime);</td><td> </td><td class="right">       meridianLine-&gt;update(deltaTime);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void GridLinesMgr::draw(StelCore* core)</td><td> </td><td class="right">void GridLinesMgr::draw(StelCore* core)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0078" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">Navigator* nav = core-&gt;getNavigation();</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       Projector* prj = core-&gt;getProjection();</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       glEnable(GL_LINE_SMOOTH);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                                                           </td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Draw the equatorial grid</td><td> </td><td class="right">       // Draw the equatorial grid</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0079" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       equGrid-&gt;draw(<span class="delete">prj</span>);</td><td> </td><td class="rblock">       equGrid-&gt;draw(<span class="insert">core</span>);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Draw the equatorial grid</td><td> </td><td class="right">       // Draw the equatorial grid</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0080" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">equJ2000Grid-&gt;draw(prj);</span></td><td> </td><td class="rblock">       <span class="insert">equJ2000Grid-&gt;draw(core);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       // Draw the <span class="delete">altazimutal</span> grid</td><td> </td><td class="rblock">       // Draw the <span class="insert">altazimuthal</span> grid</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">aziGrid-&gt;draw(prj);</span></td><td> </td><td class="rblock">       <span class="insert">aziGrid-&gt;draw(core);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Draw the celestial equator line</td><td> </td><td class="right">       // Draw the celestial equator line</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0081" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       equatorLine-&gt;draw(<span class="delete">prj,nav</span>);</td><td> </td><td class="rblock">       equatorLine-&gt;draw(<span class="insert">core</span>);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Draw the ecliptic line</td><td> </td><td class="right">       // Draw the ecliptic line</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0082" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       eclipticLine-&gt;draw(<span class="delete">prj,nav</span>);</td><td> </td><td class="rblock">       eclipticLine-&gt;draw(<span class="insert">core</span>);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Draw the meridian line</td><td> </td><td class="right">       // Draw the meridian line</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0083" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">meridianLine-&gt;draw(prj,nav);</span></td><td> </td><td class="rblock">       <span class="insert">meridianLine-&gt;draw(core);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       glDisable(GL_LINE_SMOOTH);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void GridLinesMgr::setStelStyle(const StelStyle&amp; style)</td><td> </td><td class="right">void GridLinesMgr::setStelStyle(const StelStyle&amp; style)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       QSettings* conf = StelApp::getInstance().getSettings();</td><td> </td><td class="right">       QSettings* conf = StelApp::getInstance().getSettings();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       QString section = style.confSectionName;</td><td> </td><td class="right">       QString section = style.confSectionName;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Load colors from config file</td><td> </td><td class="right">       // Load colors from config file</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       QString defaultColor = conf-&gt;value(section+"/default_color").toStrin
g();</td><td> </td><td class="right">       QString defaultColor = conf-&gt;value(section+"/default_color").toStrin
g();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       setColorEquatorGrid(StelUtils::strToVec3f(conf-&gt;value(section+"/equa
torial_color", defaultColor).toString()));</td><td> </td><td class="right">       setColorEquatorGrid(StelUtils::strToVec3f(conf-&gt;value(section+"/equa
torial_color", defaultColor).toString()));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       setColorEquatorJ2000Grid(StelUtils::strToVec3f(conf-&gt;value(section+"
/equatorial_J2000_color", defaultColor).toString()));</td><td> </td><td class="right">       setColorEquatorJ2000Grid(StelUtils::strToVec3f(conf-&gt;value(section+"
/equatorial_J2000_color", defaultColor).toString()));</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0084" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       setColorAzimut<span class="delete">alGrid(StelUtils::strToVec3f(conf-&gt;value(section+"/azi
</span>muthal_color", defaultColor).toString()));</td><td> </td><td class="rblock">       setColorAzimut<span class="insert">halGrid(StelUtils::strToVec3f(conf-&gt;value(section+"/az
i</span>muthal_color", defaultColor).toString()));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       setColorEquatorLine(StelUtils::strToVec3f(conf-&gt;value(section+"/equa
tor_color", defaultColor).toString()));</td><td> </td><td class="right">       setColorEquatorLine(StelUtils::strToVec3f(conf-&gt;value(section+"/equa
tor_color", defaultColor).toString()));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       setColorEclipticLine(StelUtils::strToVec3f(conf-&gt;value(section+"/ecl
iptic_color", defaultColor).toString()));</td><td> </td><td class="right">       setColorEclipticLine(StelUtils::strToVec3f(conf-&gt;value(section+"/ecl
iptic_color", defaultColor).toString()));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       setColorMeridianLine(StelUtils::strToVec3f(conf-&gt;value(section+"/mer
idian_color", defaultColor).toString()));</td><td> </td><td class="right">       setColorMeridianLine(StelUtils::strToVec3f(conf-&gt;value(section+"/mer
idian_color", defaultColor).toString()));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0085" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">//! Set flag for displaying <span class="delete">Azimutal</span> Grid</td><td> </td><td class="rblock">//! Set flag for displaying <span class="insert">Azimuthal</span> Grid</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">void <span class="delete">GridLinesMgr::setFlagAzimutalGrid(bool</span> b) {aziGrid-&gt;setFlagshow(b);}</td><td> </td><td class="rblock">void <span class="insert">GridLinesMgr::setFlagAzimuthalGrid(bool</span> b) {aziGrid-&gt;setFlagshow(b);}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">//! Get flag for displaying <span class="delete">Azimutal</span> Grid</td><td> </td><td class="rblock">//! Get flag for displaying <span class="insert">Azimuthal</span> Grid</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">bool <span class="delete">GridLinesMgr::getFlagAzimutalGrid(void)</span> const {return <span class="delete">aziGrid-&gt;getFlag</span></td><td> </td><td class="rblock">bool <span class="insert">GridLinesMgr::getFlagAzimuthalGrid(void)</span> const {return <span class="insert">aziGrid-&gt;getFla</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">show();}</span></td><td> </td><td class="rblock"><span class="insert">gshow();}</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">Vec3f <span class="delete">GridLinesMgr::getColorAzimutalGrid(void)</span> const {return <span class="delete">aziGrid-&gt;getCo</span></td><td> </td><td class="rblock">Vec3f <span class="insert">GridLinesMgr::getColorAzimuthalGrid(void)</span> const {return <span class="insert">aziGrid-&gt;getC</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">lor();}</span></td><td> </td><td class="rblock"><span class="insert">olor();}</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! Set flag for displaying Equatorial Grid</td><td> </td><td class="right">//! Set flag for displaying Equatorial Grid</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void GridLinesMgr::setFlagEquatorGrid(bool b) {equGrid-&gt;setFlagshow(b);}</td><td> </td><td class="right">void GridLinesMgr::setFlagEquatorGrid(bool b) {equGrid-&gt;setFlagshow(b);}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! Get flag for displaying Equatorial Grid</td><td> </td><td class="right">//! Get flag for displaying Equatorial Grid</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">bool GridLinesMgr::getFlagEquatorGrid(void) const {return equGrid-&gt;getFlags
how();}</td><td> </td><td class="right">bool GridLinesMgr::getFlagEquatorGrid(void) const {return equGrid-&gt;getFlags
how();}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">Vec3f GridLinesMgr::getColorEquatorGrid(void) const {return equGrid-&gt;getCol
or();}</td><td> </td><td class="right">Vec3f GridLinesMgr::getColorEquatorGrid(void) const {return equGrid-&gt;getCol
or();}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! Set flag for displaying Equatorial J2000 Grid</td><td> </td><td class="right">//! Set flag for displaying Equatorial J2000 Grid</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void GridLinesMgr::setFlagEquatorJ2000Grid(bool b) {equJ2000Grid-&gt;setFlagsh
ow(b);}</td><td> </td><td class="right">void GridLinesMgr::setFlagEquatorJ2000Grid(bool b) {equJ2000Grid-&gt;setFlagsh
ow(b);}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! Get flag for displaying Equatorial J2000 Grid</td><td> </td><td class="right">//! Get flag for displaying Equatorial J2000 Grid</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l3" /><small>skipping to change at</small><em> line 739</em></th><th> </th><th><a name="part-r3" /><small>skipping to change at</small><em> line 712</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! Get flag for displaying Ecliptic Line</td><td> </td><td class="right">//! Get flag for displaying Ecliptic Line</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">bool GridLinesMgr::getFlagEclipticLine(void) const {return eclipticLine-&gt;ge
tFlagshow();}</td><td> </td><td class="right">bool GridLinesMgr::getFlagEclipticLine(void) const {return eclipticLine-&gt;ge
tFlagshow();}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">Vec3f GridLinesMgr::getColorEclipticLine(void) const {return eclipticLine-&gt;
getColor();}</td><td> </td><td class="right">Vec3f GridLinesMgr::getColorEclipticLine(void) const {return eclipticLine-&gt;
getColor();}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! Set flag for displaying Meridian Line</td><td> </td><td class="right">//! Set flag for displaying Meridian Line</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void GridLinesMgr::setFlagMeridianLine(bool b) {meridianLine-&gt;setFlagshow(b
);}</td><td> </td><td class="right">void GridLinesMgr::setFlagMeridianLine(bool b) {meridianLine-&gt;setFlagshow(b
);}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! Get flag for displaying Meridian Line</td><td> </td><td class="right">//! Get flag for displaying Meridian Line</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">bool GridLinesMgr::getFlagMeridianLine(void) const {return meridianLine-&gt;ge
tFlagshow();}</td><td> </td><td class="right">bool GridLinesMgr::getFlagMeridianLine(void) const {return meridianLine-&gt;ge
tFlagshow();}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">Vec3f GridLinesMgr::getColorMeridianLine(void) const {return meridianLine-&gt;
getColor();}</td><td> </td><td class="right">Vec3f GridLinesMgr::getColorMeridianLine(void) const {return meridianLine-&gt;
getColor();}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0086" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">void GridLinesMgr::setColorAzimut<span class="delete">alGrid(const Vec3f&amp; v) { aziGrid-&gt;setColor
</span>(v);}</td><td> </td><td class="rblock">void GridLinesMgr::setColorAzimut<span class="insert">halGrid(const Vec3f&amp; v) { aziGrid-&gt;setColo
r</span>(v);}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void GridLinesMgr::setColorEquatorGrid(const Vec3f&amp; v) { equGrid-&gt;setColor(
v);}</td><td> </td><td class="right">void GridLinesMgr::setColorEquatorGrid(const Vec3f&amp; v) { equGrid-&gt;setColor(
v);}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void GridLinesMgr::setColorEquatorJ2000Grid(const Vec3f&amp; v) { equJ2000Grid-
&gt;setColor(v);}</td><td> </td><td class="right">void GridLinesMgr::setColorEquatorJ2000Grid(const Vec3f&amp; v) { equJ2000Grid-
&gt;setColor(v);}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void GridLinesMgr::setColorEquatorLine(const Vec3f&amp; v) { equatorLine-&gt;setCo
lor(v);}</td><td> </td><td class="right">void GridLinesMgr::setColorEquatorLine(const Vec3f&amp; v) { equatorLine-&gt;setCo
lor(v);}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void GridLinesMgr::setColorEclipticLine(const Vec3f&amp; v) { eclipticLine-&gt;set
Color(v);}</td><td> </td><td class="right">void GridLinesMgr::setColorEclipticLine(const Vec3f&amp; v) { eclipticLine-&gt;set
Color(v);}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void GridLinesMgr::setColorMeridianLine(const Vec3f&amp; v) { meridianLine-&gt;set
Color(v);}</td><td> </td><td class="right">void GridLinesMgr::setColorMeridianLine(const Vec3f&amp; v) { meridianLine-&gt;set
Color(v);}</td><td class="lineno" valign="top"></td></tr>

     <tr><td></td><td class="left"></td><td> </td><td class="right"></td><td></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 86 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><td></td><th><i>512 lines changed or deleted</i></th><th><i> </i></th><th><i>468 lines changed or added</i></th><td></td></tr>
     <tr><td colspan="5" align="center" class="small"><br/>This html diff was produced by rfcdiff 1.41. The latest version is available from <a href="http://www.tools.ietf.org/tools/rfcdiff/" >http://tools.ietf.org/tools/rfcdiff/</a> </td></tr>
   </table>
   </body>
   </html>
