<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"> 
<!-- Generated by rfcdiff 1.41: rfcdiff  --> 
<!-- <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional" > -->
<!-- System: Linux fomalhaut.local 3.13.0-38-generic #65-Ubuntu SMP Thu Oct 9 11:36:50 UTC 2014 x86_64 x86_64 x86_64 GNU/Linux --> 
<!-- Using awk: /usr/bin/gawk: GNU Awk 4.0.1 --> 
<!-- Using diff: /usr/bin/diff: diff (GNU diffutils) 3.3 --> 
<!-- Using wdiff: /usr/bin/wdiff: wdiff (GNU wdiff) 1.2.1 --> 
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"> 
<head> 
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /> 
  <meta http-equiv="Content-Style-Type" content="text/css" /> 
  <title>Diff: StelSphereGeometry.hpp - StelSphereGeometry.hpp</title> 
  <style type="text/css"> 
    body    { font-size:16px; margin: 0.4ex; margin-right: auto; } 
    tr      { } 
    td      { white-space: pre; font-family: Consolas, "DejaVu Sans Mono", "Droid Sans Mono", Monaco, Monospace; vertical-align: top; font-size: 0.86em;} 
    th      { font-size: 0.86em; } 
    .small  { font-size: 0.6em; font-style: italic; font-family: Verdana, Helvetica, sans-serif; } 
    .left   { background-color: #EEE; } 
    .right  { background-color: #FFF; } 
    .diff   { background-color: #CCF; } 
    .lblock { background-color: #BFB; } 
    .rblock { background-color: #FF8; } 
    .insert { background-color: #8FF; } 
    .delete { background-color: #ACF; } 
    .void   { background-color: #FFB; } 
    .cont   { background-color: #EEE; } 
    .linebr { background-color: #AAA; } 
    .lineno { color: red; background-color: #FFF; font-size: 0.7em; text-align: right; padding: 0 2px; } 
    .elipsis{ background-color: #AAA; } 
    .left .cont { background-color: #DDD; } 
    .right .cont { background-color: #EEE; } 
    .lblock .cont { background-color: #9D9; } 
    .rblock .cont { background-color: #DD6; } 
    .insert .cont { background-color: #0DD; } 
    .delete .cont { background-color: #8AD; } 
    .stats, .stats td, .stats th { background-color: #EEE; padding: 2px 0; } 
  </style> 
</head> 
<body > 
  <table border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th></th><th>&nbsp;StelSphereGeometry.hpp&nbsp;</th><th> </th><th>&nbsp;StelSphereGeometry.hpp&nbsp;</th><th></th></tr> 
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l1" /><small>skipping to change at</small><em> line 23</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 23</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"> * GNU General Public License for more details.</td><td> </td><td class="right"> * GNU General Public License for more details.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"> *</td><td> </td><td class="right"> *</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"> * You should have received a copy of the GNU General Public License</td><td> </td><td class="right"> * You should have received a copy of the GNU General Public License</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"> * along with this program; if not, write to the Free Software</td><td> </td><td class="right"> * along with this program; if not, write to the Free Software</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"> * Foundation, Inc., 51 Franklin Street, Suite 500, Boston, MA  02110-1335,
 USA.</td><td> </td><td class="right"> * Foundation, Inc., 51 Franklin Street, Suite 500, Boston, MA  02110-1335,
 USA.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"> */</td><td> </td><td class="right"> */</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#ifndef _STELSPHEREGEOMETRY_HPP_</td><td> </td><td class="right">#ifndef _STELSPHEREGEOMETRY_HPP_</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#define _STELSPHEREGEOMETRY_HPP_</td><td> </td><td class="right">#define _STELSPHEREGEOMETRY_HPP_</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">#include &lt;QVector&gt;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">#include &lt;QVariant&gt;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#include &lt;QDebug&gt;</td><td> </td><td class="right">#include &lt;QDebug&gt;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#include &lt;QSharedPointer&gt;</td><td> </td><td class="right">#include &lt;QSharedPointer&gt;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0002" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#include &lt;QVariant&gt;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#include &lt;QVarLengthArray&gt;</td><td> </td><td class="right">#include &lt;QVarLengthArray&gt;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0003" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">#include <span class="delete">"VecMath.hpp"</span></td><td> </td><td class="rblock">#include <span class="insert">&lt;QVector&gt;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#include "OctahedronPolygon.hpp"</td><td> </td><td class="right">#include "OctahedronPolygon.hpp"</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0004" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">#include <span class="delete">"StelVertexArray.hpp"</span></td><td> </td><td class="rblock">#include <span class="insert">"renderer/StelVertexBuffer.hpp"</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#include "Triplet.hpp"</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#include "VecMath.hpp"</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">class SphericalRegion;</td><td> </td><td class="right">class SphericalRegion;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">class SphericalPolygon;</td><td> </td><td class="right">class SphericalPolygon;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">class SphericalConvexPolygon;</td><td> </td><td class="right">class SphericalConvexPolygon;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">class SphericalCap;</td><td> </td><td class="right">class SphericalCap;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">class SphericalPoint;</td><td> </td><td class="right">class SphericalPoint;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">class AllSkySphericalRegion;</td><td> </td><td class="right">class AllSkySphericalRegion;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">class EmptySphericalRegion;</td><td> </td><td class="right">class EmptySphericalRegion;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! @file StelSphereGeometry.hpp</td><td> </td><td class="right">//! @file StelSphereGeometry.hpp</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l2" /><small>skipping to change at</small><em> line 144</em></th><th> </th><th><a name="part-r2" /><small>skipping to change at</small><em> line 146</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               Point = 0,</td><td> </td><td class="right">               Point = 0,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               Cap = 1,</td><td> </td><td class="right">               Cap = 1,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               AllSky = 2,</td><td> </td><td class="right">               AllSky = 2,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               Polygon = 3,</td><td> </td><td class="right">               Polygon = 3,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               ConvexPolygon = 4,</td><td> </td><td class="right">               ConvexPolygon = 4,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               Empty = 5,</td><td> </td><td class="right">               Empty = 5,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               Invalid = 6</td><td> </td><td class="right">               Invalid = 6</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       };</td><td> </td><td class="right">       };</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0005" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       virtual ~SphericalRegion() <span class="delete">{;}</span></td><td> </td><td class="rblock">       <span class="insert">//! Parameters specifying how to draw a SphericalRegion.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //!</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //! Passed to e.g. drawFill().</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //!</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //! Also used to remember previously used draw parameters, which ena</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">bles</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //! vertex buffer caching.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //!</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //! This is a builder-style struct. Parameters can be specified like</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> this:</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //!</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //! @code</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //! // Default parameters. Projector is mandatory, so it is specifie</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">d in the constructor.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //! SphericalRegion::DrawParams a(someProjectorPointer);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //! // Do not subdivide the region into smaller triangles.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //! SphericalRegion::DrawParams b = SphericalRegion::DrawParams(some</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ProjectorPointer)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //!                                                 .doNotSubdivide(</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //! // Do not subdivide and clip the part of the region outside of s</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">pecified cap.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //! SphericalRegion::DrawParams c = SphericalRegion::DrawParams(some</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ProjectorPointer)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //!                                                 .doNotSubdivide(</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //!                                                 .clippingCap(som</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">eSphericalCapPointer);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //! @endcode</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //!</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //!</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       struct DrawParams</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               //! Construct DrawParams with default parameters and specifi</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ed projector.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               //!</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               //! @param projector Projector to use for drawing.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               //!</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               //! The default parameters are: no clipping cap, subdivide t</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">he region to</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               //! follow projection distortions, max distortion 5.0.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               DrawParams(class StelProjector* projector)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       : projector_(projector)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       , clippingCap_(NULL)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       , subdivide_(true)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       , maxSqDistortion_(5.0)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               {}</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               //! Only used to determine whether to update cached vertex b</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">uffers.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               //!</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               //! Compares parameters given in a previous drawXXX()</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               //! call with parameters given in the current call.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               //!</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               //! Projector is ignored - outside code needs to figure out </span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">if projector</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               //! affects vertex buffer generation. Clipping cap is only a</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ssumed to be</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               //! the same if both previos and current is NULL (which is u</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">sually the case).</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               bool operator != (const DrawParams&amp; rhs) const</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       // Projector is ignored, as even if the pointer poin</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ts to the same object,</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       // the objects' state might have changed, making com</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">parison useless.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       // Instead, we only cache in cases when projector is</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> not used used outside</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       // Renderer (i.e. not affecting vertex buffers that </span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">get cached) or NULL.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       // Clipping caps are only considered equal when NULL</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> (which is the</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       // most common case, anyway). There is no opportunit</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">y for special handling</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       // like projectors, since, when not NULL, clipping c</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">aps are always used</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       // in vertex buffer generation.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       return (clippingCap_ == NULL &amp;&amp; rhs.clippingCap_ == </span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">NULL) ||</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                              subdivide_ != rhs.subdivide_   ||</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                              //Fuzzy compare might be better here</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                              maxSqDistortion_ != rhs.maxSqDistortion_;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               //! If not NULL, used to clip the part of the region outside</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> the cap.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               DrawParams&amp; clippingCap(const SphericalCap* clippingCap)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       clippingCap_ = clippingCap;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       return *this;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               //! Do not subdivide the region to follow projection distort</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ions.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               //!</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               //! Improves drawing speed.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               //!</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               //! You can use this if you think that the region is fully c</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ontained in the viewport.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               DrawParams&amp; doNotSubdivide()</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       subdivide_ = false;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       return *this;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               //! Specify maximum distortion - we try to subdivide to be w</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ithil this limit.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               DrawParams&amp; maxSqDistortion(const double maxSqDistortion)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       maxSqDistortion_ = maxSqDistortion;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       return *this;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               //! Projector to use when drawing.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               class StelProjector* projector_;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               //! If specified, clips the part of the region outside of ca</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">p.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               const SphericalCap* clippingCap_;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               //! Subdivide triangles?</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               bool subdivide_;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               //! Maximum distortion.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               double maxSqDistortion_;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       };</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //! 3D vertex with only a position.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       struct PlainVertex</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               Vec3f position;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               PlainVertex(const Vec3f&amp; position) : position(position){}</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               PlainVertex(const Vec3d&amp; pos) : position(pos[0], pos[1], pos</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">[2]) {}</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        VERTEX_ATTRIBUTES(Vec3f Position)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       };</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //! 3D vertex with position and a texture coordinate.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       struct TexturedVertex</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               Vec3f position;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               Vec2f texCoord;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               TexturedVertex(const Vec3f&amp; position, const Vec2f&amp; texCoord)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       : position(position) , texCoord(texCoord) {}</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               TexturedVertex(const Vec3d&amp; pos, const Vec2f&amp; texCoord)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       : position(pos[0], pos[1], pos[2]) , texCoord(texCoo</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">rd) {}</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        VERTEX_ATTRIBUTES(Vec3f Position, Vec2f TexCoord)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       };</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //! Default constructor. Inializes with no vertex buffers.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       SphericalRegion()</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               : fillPlainVertexBuffer(NULL)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               , previousFillDrawParams(NULL)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               // Make sure previousFillDrawParams is invalid at start, so </span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">it gets replaced</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               // at first drawFill() call.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               previousFillDrawParams.maxSqDistortion_ = -42.0f;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //! Destructor. Cleans up vertex buffers, if any.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       virtual ~SphericalRegion()</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">{</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               if(NULL != fillPlainVertexBuffer)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       delete fillPlainVertexBuffer;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual SphericalRegionType getType() const = 0;</td><td> </td><td class="right">       virtual SphericalRegionType getType() const = 0;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Return the octahedron contour representation of the polygon.</td><td> </td><td class="right">       //! Return the octahedron contour representation of the polygon.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! It can be used for safe computation of intersection/union in the
 general case.</td><td> </td><td class="right">       //! It can be used for safe computation of intersection/union in the
 general case.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual OctahedronPolygon getOctahedronPolygon() const =0;</td><td> </td><td class="right">       virtual OctahedronPolygon getOctahedronPolygon() const =0;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Return the area of the region in steradians.</td><td> </td><td class="right">       //! Return the area of the region in steradians.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual double getArea() const {return getOctahedronPolygon().getAre
a();}</td><td> </td><td class="right">       virtual double getArea() const {return getOctahedronPolygon().getAre
a();}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l3" /><small>skipping to change at</small><em> line 176</em></th><th> </th><th><a name="part-r3" /><small>skipping to change at</small><em> line 317</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual SphericalCap getBoundingCap() const;</td><td> </td><td class="right">       virtual SphericalCap getBoundingCap() const;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Return an enlarged version of this SphericalRegion so that any p
oint distant of more</td><td> </td><td class="right">       //! Return an enlarged version of this SphericalRegion so that any p
oint distant of more</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! than the given margin now lays within the region.</td><td> </td><td class="right">       //! than the given margin now lays within the region.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! The returned region can be larger than the smallest enlarging re
gion, therefore returning</td><td> </td><td class="right">       //! The returned region can be larger than the smallest enlarging re
gion, therefore returning</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! false positive on subsequent intersection tests.</td><td> </td><td class="right">       //! false positive on subsequent intersection tests.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! The default implementation always return an enlarged bounding Sp
hericalCap.</td><td> </td><td class="right">       //! The default implementation always return an enlarged bounding Sp
hericalCap.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! @param margin the minimum enlargement margin in radian.</td><td> </td><td class="right">       //! @param margin the minimum enlargement margin in radian.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual SphericalRegionP getEnlarged(double margin) const;</td><td> </td><td class="right">       virtual SphericalRegionP getEnlarged(double margin) const;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0006" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       //! <span class="delete">Return an openGL compatible array to be displayed using vertex</span> a</td><td> </td><td class="rblock">       //! <span class="insert">Get</span> a <span class="insert">vector of vertex positions forming the region.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">rrays.</span></td><td> </td><td class="rblock"><span class="insert">       virtual const QVector&lt;Vec3d&gt;&amp; getFillVertexPositions() const</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       virtual <span class="delete">StelVertexArray getFillVertexArray()</span> const <span class="delete">{return getOctahe</span></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">dronPolygon().getFillVertexArray();}</span></td><td> </td><td class="rblock"><span class="insert">               return getOctahedronPolygon().fillVertices();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //! Get primitive type determining how vertices in vector returned b</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">y</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //! getFillVertexPositions() form triangles.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       virtual <span class="insert">PrimitiveType getFillPrimitiveType()</span> const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">{</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               return PrimitiveType_Triangles;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Get the outline of the contours defining the SphericalPolygon.</td><td> </td><td class="right">       //! Get the outline of the contours defining the SphericalPolygon.</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0007" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       //! @return a list of <span class="delete">vertex</span> which <span class="delete">taken 2 by 2</span> define the contours </td><td> </td><td class="rblock">       //! @return a list of <span class="insert">vertices</span> which define the contours of the <span class="insert">poly</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">of the <span class="delete">polygon.</span></td><td> </td><td class="rblock"><span class="insert">gon.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       virtual <span class="delete">StelVertexArray getOutlineVertexArray()</span> const <span class="delete">{return getOct</span></td><td> </td><td class="rblock">       virtual const <span class="insert">QVector&lt;Vec3d&gt;&amp; getOutlineVertexPositions() const</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">ahedronPolygon().getOutlineVertexArray();}</span></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               // This is a workaround around a compiler bug with Clang (as</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> of Clang 3.2).</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               // Returning the reference directly results in an uninitiali</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">zed</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               // reference which breaks calling code.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               const QVector&lt;Vec3d&gt;&amp; result(getOctahedronPolygon().outlineV</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ertices());</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               return result;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //! Get primitive type determining how vertices in vector returned b</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">y</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //! getOutlinePrimitiveType() form lines.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       virtual PrimitiveType getOutlinePrimitiveType() const</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               return PrimitiveType_Lines;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Get the contours defining the SphericalPolygon when combined usi
ng a positive winding rule.</td><td> </td><td class="right">       //! Get the contours defining the SphericalPolygon when combined usi
ng a positive winding rule.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! The default implementation return a list of tesselated triangles
 derived from the OctahedronPolygon.</td><td> </td><td class="right">       //! The default implementation return a list of tesselated triangles
 derived from the OctahedronPolygon.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual QVector&lt;QVector&lt;Vec3d &gt; &gt; getSimplifiedContours() const;</td><td> </td><td class="right">       virtual QVector&lt;QVector&lt;Vec3d &gt; &gt; getSimplifiedContours() const;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Serialize the region into a QVariant list matching the JSON form
at.</td><td> </td><td class="right">       //! Serialize the region into a QVariant list matching the JSON form
at.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual QVariantList toQVariant() const = 0;</td><td> </td><td class="right">       virtual QVariantList toQVariant() const = 0;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Serialize the region. This method must allow as fast as possible
 serialization and work with deserialize().</td><td> </td><td class="right">       //! Serialize the region. This method must allow as fast as possible
 serialization and work with deserialize().</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual void serialize(QDataStream&amp; out) const = 0;</td><td> </td><td class="right">       virtual void serialize(QDataStream&amp; out) const = 0;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l4" /><small>skipping to change at</small><em> line 254</em></th><th> </th><th><a name="part-r4" /><small>skipping to change at</small><em> line 419</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! A default potentially very slow implementation is provided for e
ach cases.</td><td> </td><td class="right">       //! A default potentially very slow implementation is provided for e
ach cases.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       SphericalRegionP getSubtraction(const SphericalRegion* r) const;</td><td> </td><td class="right">       SphericalRegionP getSubtraction(const SphericalRegion* r) const;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       SphericalRegionP getSubtraction(const SphericalRegionP r) const {ret
urn getSubtraction(r.data());}</td><td> </td><td class="right">       SphericalRegionP getSubtraction(const SphericalRegionP r) const {ret
urn getSubtraction(r.data());}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual SphericalRegionP getSubtraction(const SphericalPolygon&amp; r) c
onst;</td><td> </td><td class="right">       virtual SphericalRegionP getSubtraction(const SphericalPolygon&amp; r) c
onst;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual SphericalRegionP getSubtraction(const SphericalConvexPolygon
&amp; r) const;</td><td> </td><td class="right">       virtual SphericalRegionP getSubtraction(const SphericalConvexPolygon
&amp; r) const;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual SphericalRegionP getSubtraction(const SphericalCap&amp; r) const
;</td><td> </td><td class="right">       virtual SphericalRegionP getSubtraction(const SphericalCap&amp; r) const
;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual SphericalRegionP getSubtraction(const SphericalPoint&amp; r) con
st;</td><td> </td><td class="right">       virtual SphericalRegionP getSubtraction(const SphericalPoint&amp; r) con
st;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       SphericalRegionP getSubtraction(const AllSkySphericalRegion&amp; r) cons
t;</td><td> </td><td class="right">       SphericalRegionP getSubtraction(const AllSkySphericalRegion&amp; r) cons
t;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual SphericalRegionP getSubtraction(const EmptySphericalRegion&amp; 
r) const;</td><td> </td><td class="right">       virtual SphericalRegionP getSubtraction(const EmptySphericalRegion&amp; 
r) const;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0008" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">//! Draw the region as triangles (i.e. filling the region).</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //!</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //! @param renderer Renderer to use for drawing.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //! @param params   Drawing parameters (projector, clipping cap, if </span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">any, etc.).</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //!</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //! @see DrawParams</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       virtual void drawFill(class StelRenderer* renderer, const DrawParams</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">&amp; params);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //! Draw the outline of the region.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //!</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //! @param renderer Renderer to use for drawing.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //! @param params   Drawing parameters (projector, clipping cap, if </span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">any, etc.).</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //!                 Note that maxSqDistortion has no effect here.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //!</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //! @see DrawParams</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       virtual void drawOutline(class StelRenderer* renderer, const DrawPar</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ams&amp; params);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">protected:</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //! Cached plain vertex buffer for drawing.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       StelVertexBuffer&lt;PlainVertex&gt;* fillPlainVertexBuffer;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //! Should Renderer draw calls specify a projector?</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //!</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //! This is true unless we've projected the vertices ourselves (whic</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">h is the</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //! case when we're subdividing the region into smaller triangles.)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       bool useProjector;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //! Update the vertex buffer used by drawFill().</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //!</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //! Called when drawing parameters have changed, or when we cannot c</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ache</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //! vertices (e.g. when subdividing and this projecting outside Rend</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">erer).</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //!</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //! @param renderer            Renderer to create vertex buffer.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //! @param params              Parameters used for drawing</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //!                            (which also affect vertex generation)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //! @param handleDiscontinuity Do we need to ensure that no triangle</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">s cross a</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //!                            projection discontinuity?</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       virtual void updateFillVertexBuffer(class StelRenderer* renderer, co</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">nst DrawParams&amp; params, bool handleDiscontinuity);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //! Drawing part of drawFill() - assumes the buffer/s is/are generat</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ed.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //!</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //! @param renderer  Renderer used for drawing.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //! @param projector Projector to project the vertices</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //!                  (NULL if subdivision is enabled, as in that cas</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">e</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //!                  the projection is done during buffer generation</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       virtual void drawFillVertexBuffer(class StelRenderer* renderer, clas</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">s StelProjector* projector);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //! Do we need to update vertex buffer/s used by drawFill()?</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //!</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //! Might be true if e.g. the region has changed. Note that this is </span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">only</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //! one possible reason to update the buffers, drawFill() contains t</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">he full</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //! logic to determine this (e.g. we always update when subdividing </span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">is enabled).</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       virtual bool needToUpdateFillVertexBuffers() const</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               // Can't determine whether we can cache anything -</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               // we'd need to know if polygon returned by getOctahedronPol</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ygon has changed,</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               // but since getOctahedronPolygon returns by value, not refe</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">rence,</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               // it returns a new octahedronPolygon every time.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               //</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               // If it was by reference, _and_ guaranteed to always point </span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">to the same polygon,</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               // we might store a flag in the polygon determining if its v</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ertex array has</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               // changed, and use that for caching.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               return true;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //! Called after updating vertex buffer/s used by drawFill().</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       virtual void fillVertexBuffersUpdated() {}</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">private:</td><td> </td><td class="right">private:</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0009" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">//! Parameters used for the previous drawFill() call.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       DrawParams previousFillDrawParams;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       bool containsDefault(const SphericalRegion* r) const;</td><td> </td><td class="right">       bool containsDefault(const SphericalRegion* r) const;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       bool intersectsDefault(const SphericalRegion* r) const;</td><td> </td><td class="right">       bool intersectsDefault(const SphericalRegion* r) const;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       SphericalRegionP getIntersectionDefault(const SphericalRegion* r) co
nst;</td><td> </td><td class="right">       SphericalRegionP getIntersectionDefault(const SphericalRegion* r) co
nst;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       SphericalRegionP getUnionDefault(const SphericalRegion* r) const;</td><td> </td><td class="right">       SphericalRegionP getUnionDefault(const SphericalRegion* r) const;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       SphericalRegionP getSubtractionDefault(const SphericalRegion* r) con
st;</td><td> </td><td class="right">       SphericalRegionP getSubtractionDefault(const SphericalRegion* r) con
st;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">};</td><td> </td><td class="right">};</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! @class SphericalCap</td><td> </td><td class="right">//! @class SphericalCap</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! A SphericalCap is defined by a direction and an aperture.</td><td> </td><td class="right">//! A SphericalCap is defined by a direction and an aperture.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! It forms a cone from the center of the Coordinate frame with a radius d
.</td><td> </td><td class="right">//! It forms a cone from the center of the Coordinate frame with a radius d
.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l5" /><small>skipping to change at</small><em> line 299</em></th><th> </th><th><a name="part-r5" /><small>skipping to change at</small><em> line 535</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Return true if the region is empty.</td><td> </td><td class="right">       //! Return true if the region is empty.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual bool isEmpty() const {return d&gt;=1.;}</td><td> </td><td class="right">       virtual bool isEmpty() const {return d&gt;=1.;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Return a point located inside the SphericalCap.</td><td> </td><td class="right">       //! Return a point located inside the SphericalCap.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual Vec3d getPointInside() const {return n;}</td><td> </td><td class="right">       virtual Vec3d getPointInside() const {return n;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Return itself.</td><td> </td><td class="right">       //! Return itself.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual SphericalCap getBoundingCap() const {return *this;}</td><td> </td><td class="right">       virtual SphericalCap getBoundingCap() const {return *this;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Contain and intersect</td><td> </td><td class="right">       // Contain and intersect</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0010" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">virtual</span> bool contains(const Vec3d &amp;v) const <span class="delete">{Q_ASSERT(d==0</span> || <span class="delete">std::f</span></td><td> </td><td class="rblock">       bool contains(const Vec3d &amp;v) const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">abs(v.lengthSquared()-1.)&lt;0.0000002);return (v*n&gt;=d);}</span></td><td> </td><td class="rblock">       <span class="insert">{</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       virtual bool contains(const Vec3f &amp;v) const {Q_ASSERT(d==0 || std::f</span></td><td> </td><td class="rblock"><span class="insert">               Q_ASSERT(d==0</span> || <span class="insert">std::fabs(v.lengthSquared()-1.)&lt;0.00000021)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">abs(v.lengthSquared()-1.f)&lt;0.000002f);return (v[0]*n[0]+v[1]*n[1]+v[2]*n[2]</span></td><td> </td><td class="rblock"><span class="insert">;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">&gt;=d);}</span></td><td> </td><td class="rblock"><span class="insert">               return (v*n&gt;=d);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual bool contains(const SphericalConvexPolygon&amp; r) const;</td><td> </td><td class="right">       virtual bool contains(const SphericalConvexPolygon&amp; r) const;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual bool contains(const SphericalCap&amp; h) const</td><td> </td><td class="right">       virtual bool contains(const SphericalCap&amp; h) const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               const double a = n*h.n-d*h.d;</td><td> </td><td class="right">               const double a = n*h.n-d*h.d;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return d&lt;=h.d &amp;&amp; ( a&gt;=1. || (a&gt;=0. &amp;&amp; a*a &gt;= (1.-d*d)*(1.-h.
d*h.d)));</td><td> </td><td class="right">               return d&lt;=h.d &amp;&amp; ( a&gt;=1. || (a&gt;=0. &amp;&amp; a*a &gt;= (1.-d*d)*(1.-h.
d*h.d)));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual bool contains(const AllSkySphericalRegion&amp;) const {return d&lt;
=-1;}</td><td> </td><td class="right">       virtual bool contains(const AllSkySphericalRegion&amp;) const {return d&lt;
=-1;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual bool intersects(const SphericalPolygon&amp; r) const;</td><td> </td><td class="right">       virtual bool intersects(const SphericalPolygon&amp; r) const;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual bool intersects(const SphericalConvexPolygon&amp; r) const;</td><td> </td><td class="right">       virtual bool intersects(const SphericalConvexPolygon&amp; r) const;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Returns whether a SphericalCap intersects with this one.</td><td> </td><td class="right">       //! Returns whether a SphericalCap intersects with this one.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l6" /><small>skipping to change at</small><em> line 356</em></th><th> </th><th><a name="part-r6" /><small>skipping to change at</small><em> line 595</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Comparison operator.</td><td> </td><td class="right">       //! Comparison operator.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       bool operator==(const SphericalCap&amp; other) const {return (n==other.n
 &amp;&amp; d==other.d);}</td><td> </td><td class="right">       bool operator==(const SphericalCap&amp; other) const {return (n==other.n
 &amp;&amp; d==other.d);}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Return the list of closed contours defining the polygon boundari
es.</td><td> </td><td class="right">       //! Return the list of closed contours defining the polygon boundari
es.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       QVector&lt;Vec3d&gt; getClosedOutlineContour() const;</td><td> </td><td class="right">       QVector&lt;Vec3d&gt; getClosedOutlineContour() const;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Return whether the cap intersect with a convex contour defined b
y nbVertice.</td><td> </td><td class="right">       //! Return whether the cap intersect with a convex contour defined b
y nbVertice.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       bool intersectsConvexContour(const Vec3d* vertice, int nbVertice) co
nst;</td><td> </td><td class="right">       bool intersectsConvexContour(const Vec3d* vertice, int nbVertice) co
nst;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0011" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       //! <span class="delete">Return whether</span> the cap <span class="delete">contains</span> the passed <span class="delete">triangle.</span></td><td> </td><td class="rblock">       //! <span class="insert">Does</span> the cap <span class="insert">contain</span> the passed <span class="insert">triangle?</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       bool containsTriangle(const <span class="delete">Vec3d* vertice)</span> const;</td><td> </td><td class="rblock">       bool containsTriangle(const <span class="insert">Triplet&lt;Vec3d&gt; triangle)</span> const;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0012" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       //! <span class="delete">Return whether</span> the cap intersect with the passed <span class="delete">triangle.</span></td><td> </td><td class="rblock">       //! <span class="insert">Does</span> the cap intersect with the passed <span class="insert">triangle?</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       bool intersectsTriangle(const <span class="delete">Vec3d* vertice)</span> const;</td><td> </td><td class="rblock">       bool intersectsTriangle(const <span class="insert">Triplet&lt;Vec3d&gt;&amp; triangle)</span> const;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Deserialize the region. This method must allow as fast as possib
le deserialization.</td><td> </td><td class="right">       //! Deserialize the region. This method must allow as fast as possib
le deserialization.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       static SphericalRegionP deserialize(QDataStream&amp; in);</td><td> </td><td class="right">       static SphericalRegionP deserialize(QDataStream&amp; in);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Return the relative overlap between the areas of the 2 caps, i.e
:</td><td> </td><td class="right">       //! Return the relative overlap between the areas of the 2 caps, i.e
:</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! min(intersectionArea/c1.area, intersectionArea/c2.area)</td><td> </td><td class="right">       //! min(intersectionArea/c1.area, intersectionArea/c2.area)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       static double relativeAreaOverlap(const SphericalCap&amp; c1, const Sphe
ricalCap&amp; c2);</td><td> </td><td class="right">       static double relativeAreaOverlap(const SphericalCap&amp; c1, const Sphe
ricalCap&amp; c2);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Return the relative overlap between the diameter of the 2 caps, 
i.e:</td><td> </td><td class="right">       //! Return the relative overlap between the diameter of the 2 caps, 
i.e:</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! min(intersectionDistance/c1.diameter, intersectionDistance/c2.di
ameter)</td><td> </td><td class="right">       //! min(intersectionDistance/c1.diameter, intersectionDistance/c2.di
ameter)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l7" /><small>skipping to change at</small><em> line 457</em></th><th> </th><th><a name="part-r7" /><small>skipping to change at</small><em> line 696</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">};</td><td> </td><td class="right">};</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! @class AllSkySphericalRegion</td><td> </td><td class="right">//! @class AllSkySphericalRegion</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! Special SphericalRegion for the whole sphere.</td><td> </td><td class="right">//! Special SphericalRegion for the whole sphere.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">class AllSkySphericalRegion : public SphericalRegion</td><td> </td><td class="right">class AllSkySphericalRegion : public SphericalRegion</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">public:</td><td> </td><td class="right">public:</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual ~AllSkySphericalRegion() {;}</td><td> </td><td class="right">       virtual ~AllSkySphericalRegion() {;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual SphericalRegionType getType() const {return SphericalRegion:
:AllSky;}</td><td> </td><td class="right">       virtual SphericalRegionType getType() const {return SphericalRegion:
:AllSky;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0013" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       virtual OctahedronPolygon getOctahedronPolygon() const <span class="delete">{return Octah</span></td><td> </td><td class="rblock">       virtual OctahedronPolygon getOctahedronPolygon() const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">edronPolygon::getAllSkyOctahedronPolygon();}</span></td><td> </td><td class="rblock">       <span class="insert">{</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               return OctahedronPolygon::getAllSkyOctahedronPolygon();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual double getArea() const {return 4.*M_PI;}</td><td> </td><td class="right">       virtual double getArea() const {return 4.*M_PI;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual bool isEmpty() const {return false;}</td><td> </td><td class="right">       virtual bool isEmpty() const {return false;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual Vec3d getPointInside() const {return Vec3d(1,0,0);}</td><td> </td><td class="right">       virtual Vec3d getPointInside() const {return Vec3d(1,0,0);}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual SphericalCap getBoundingCap() const {return SphericalCap(Vec
3d(1,0,0), -2);}</td><td> </td><td class="right">       virtual SphericalCap getBoundingCap() const {return SphericalCap(Vec
3d(1,0,0), -2);}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Serialize the region into a QVariant map matching the JSON forma
t.</td><td> </td><td class="right">       //! Serialize the region into a QVariant map matching the JSON forma
t.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! The format is ["ALLSKY"]</td><td> </td><td class="right">       //! The format is ["ALLSKY"]</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual QVariantList toQVariant() const;</td><td> </td><td class="right">       virtual QVariantList toQVariant() const;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual void serialize(QDataStream&amp;) const {;}</td><td> </td><td class="right">       virtual void serialize(QDataStream&amp;) const {;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Contain and intersect</td><td> </td><td class="right">       // Contain and intersect</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l8" /><small>skipping to change at</small><em> line 499</em></th><th> </th><th><a name="part-r8" /><small>skipping to change at</small><em> line 741</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       using SphericalRegion::intersects;</td><td> </td><td class="right">       using SphericalRegion::intersects;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       using SphericalRegion::contains;</td><td> </td><td class="right">       using SphericalRegion::contains;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       using SphericalRegion::getIntersection;</td><td> </td><td class="right">       using SphericalRegion::getIntersection;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       using SphericalRegion::getUnion;</td><td> </td><td class="right">       using SphericalRegion::getUnion;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       using SphericalRegion::getSubtraction;</td><td> </td><td class="right">       using SphericalRegion::getSubtraction;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       EmptySphericalRegion() {;}</td><td> </td><td class="right">       EmptySphericalRegion() {;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual ~EmptySphericalRegion() {;}</td><td> </td><td class="right">       virtual ~EmptySphericalRegion() {;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual SphericalRegionType getType() const {return SphericalRegion:
:Empty;}</td><td> </td><td class="right">       virtual SphericalRegionType getType() const {return SphericalRegion:
:Empty;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0014" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       virtual OctahedronPolygon getOctahedronPolygon() const <span class="delete">{return Octah</span></td><td> </td><td class="rblock">       virtual OctahedronPolygon getOctahedronPolygon() const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">edronPolygon::getEmptyOctahedronPolygon();}</span></td><td> </td><td class="rblock">       <span class="insert">{</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               return OctahedronPolygon::getEmptyOctahedronPolygon();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual double getArea() const {return 0.;}</td><td> </td><td class="right">       virtual double getArea() const {return 0.;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual bool isEmpty() const {return true;}</td><td> </td><td class="right">       virtual bool isEmpty() const {return true;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual Vec3d getPointInside() const {return Vec3d(1,0,0);}</td><td> </td><td class="right">       virtual Vec3d getPointInside() const {return Vec3d(1,0,0);}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual SphericalCap getBoundingCap() const {return SphericalCap(Vec
3d(1,0,0), 2);}</td><td> </td><td class="right">       virtual SphericalCap getBoundingCap() const {return SphericalCap(Vec
3d(1,0,0), 2);}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Serialize the region into a QVariant map matching the JSON forma
t.</td><td> </td><td class="right">       //! Serialize the region into a QVariant map matching the JSON forma
t.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! The format is ["EMPTY"]</td><td> </td><td class="right">       //! The format is ["EMPTY"]</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual QVariantList toQVariant() const;</td><td> </td><td class="right">       virtual QVariantList toQVariant() const;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual void serialize(QDataStream&amp;) const {;}</td><td> </td><td class="right">       virtual void serialize(QDataStream&amp;) const {;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Contain and intersect</td><td> </td><td class="right">       // Contain and intersect</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l9" /><small>skipping to change at</small><em> line 547</em></th><th> </th><th><a name="part-r9" /><small>skipping to change at</small><em> line 792</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       SphericalPolygon() {;}</td><td> </td><td class="right">       SphericalPolygon() {;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Constructor from a list of contours.</td><td> </td><td class="right">       //! Constructor from a list of contours.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       SphericalPolygon(const QVector&lt;QVector&lt;Vec3d&gt; &gt;&amp; contours) : octahed
ronPolygon(contours) {;}</td><td> </td><td class="right">       SphericalPolygon(const QVector&lt;QVector&lt;Vec3d&gt; &gt;&amp; contours) : octahed
ronPolygon(contours) {;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Constructor from one contour.</td><td> </td><td class="right">       //! Constructor from one contour.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       SphericalPolygon(const QVector&lt;Vec3d&gt;&amp; contour) : octahedronPolygon(
contour) {;}</td><td> </td><td class="right">       SphericalPolygon(const QVector&lt;Vec3d&gt;&amp; contour) : octahedronPolygon(
contour) {;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       SphericalPolygon(const OctahedronPolygon&amp; octContour) : octahedronPo
lygon(octContour) {;}</td><td> </td><td class="right">       SphericalPolygon(const OctahedronPolygon&amp; octContour) : octahedronPo
lygon(octContour) {;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       SphericalPolygon(const QList&lt;OctahedronPolygon&gt;&amp; octContours) : octa
hedronPolygon(octContours) {;}</td><td> </td><td class="right">       SphericalPolygon(const QList&lt;OctahedronPolygon&gt;&amp; octContours) : octa
hedronPolygon(octContours) {;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual SphericalRegionType getType() const {return SphericalRegion:
:Polygon;}</td><td> </td><td class="right">       virtual SphericalRegionType getType() const {return SphericalRegion:
:Polygon;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0015" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       virtual OctahedronPolygon getOctahedronPolygon() const <span class="delete">{return octah</span></td><td> </td><td class="rblock">       virtual OctahedronPolygon getOctahedronPolygon() const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">edronPolygon;}</span></td><td> </td><td class="rblock">       <span class="insert">{</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               return octahedronPolygon;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Serialize the region into a QVariant map matching the JSON forma
t.</td><td> </td><td class="right">       //! Serialize the region into a QVariant map matching the JSON forma
t.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! The format is:</td><td> </td><td class="right">       //! The format is:</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! @code[[[ra,dec], [ra,dec], [ra,dec], [ra,dec]], [[ra,dec], [ra,d
ec], [ra,dec]],[...]]@endcode</td><td> </td><td class="right">       //! @code[[[ra,dec], [ra,dec], [ra,dec], [ra,dec]], [[ra,dec], [ra,d
ec], [ra,dec]],[...]]@endcode</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! it is a list of closed contours, with each points defined by ra 
dec in degree in the ICRS frame.</td><td> </td><td class="right">       //! it is a list of closed contours, with each points defined by ra 
dec in degree in the ICRS frame.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual QVariantList toQVariant() const;</td><td> </td><td class="right">       virtual QVariantList toQVariant() const;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual void serialize(QDataStream&amp; out) const;</td><td> </td><td class="right">       virtual void serialize(QDataStream&amp; out) const;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual SphericalCap getBoundingCap() const;</td><td> </td><td class="right">       virtual SphericalCap getBoundingCap() const;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l10" /><small>skipping to change at</small><em> line 585</em></th><th> </th><th><a name="part-r10" /><small>skipping to change at</small><em> line 833</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual SphericalRegionP getUnion(const EmptySphericalRegion&amp;) const
 {return SphericalRegionP(new SphericalPolygon(octahedronPolygon));}</td><td> </td><td class="right">       virtual SphericalRegionP getUnion(const EmptySphericalRegion&amp;) const
 {return SphericalRegionP(new SphericalPolygon(octahedronPolygon));}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual SphericalRegionP getSubtraction(const SphericalPoint&amp;) const
 {return SphericalRegionP(new SphericalPolygon(octahedronPolygon));}</td><td> </td><td class="right">       virtual SphericalRegionP getSubtraction(const SphericalPoint&amp;) const
 {return SphericalRegionP(new SphericalPolygon(octahedronPolygon));}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual SphericalRegionP getSubtraction(const EmptySphericalRegion&amp;)
 const {return SphericalRegionP(new SphericalPolygon(octahedronPolygon));}</td><td> </td><td class="right">       virtual SphericalRegionP getSubtraction(const EmptySphericalRegion&amp;)
 const {return SphericalRegionP(new SphericalPolygon(octahedronPolygon));}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       ////////////////////////////////////////////////////////////////////</td><td> </td><td class="right">       ////////////////////////////////////////////////////////////////////</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Methods specific to SphericalPolygon</td><td> </td><td class="right">       // Methods specific to SphericalPolygon</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Set the contours defining the SphericalPolygon.</td><td> </td><td class="right">       //! Set the contours defining the SphericalPolygon.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! @param contours the list of contours defining the polygon area. 
The contours are combined using</td><td> </td><td class="right">       //! @param contours the list of contours defining the polygon area. 
The contours are combined using</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! the positive winding rule, meaning that the polygon is the union
 of the positive contours minus the negative ones.</td><td> </td><td class="right">       //! the positive winding rule, meaning that the polygon is the union
 of the positive contours minus the negative ones.</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0016" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       void setContours(const QVector&lt;QVector&lt;Vec3d&gt; &gt;&amp; contours) <span class="delete">{octahedr</span></td><td> </td><td class="rblock">       void setContours(const QVector&lt;QVector&lt;Vec3d&gt; &gt;&amp; contours)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">onPolygon</span> = <span class="delete">OctahedronPolygon(contours);}</span></td><td> </td><td class="rblock">       <span class="insert">{</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               octahedronPolygon</span> = <span class="insert">OctahedronPolygon(contours);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Set a single contour defining the SphericalPolygon.</td><td> </td><td class="right">       //! Set a single contour defining the SphericalPolygon.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! @param contour a contour defining the polygon area.</td><td> </td><td class="right">       //! @param contour a contour defining the polygon area.</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0017" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       void setContour(const QVector&lt;Vec3d&gt;&amp; contour) <span class="delete">{octahedronPolygon</span> = </td><td> </td><td class="rblock">       void setContour(const QVector&lt;Vec3d&gt;&amp; contour)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">OctahedronPolygon(contour);}</span></td><td> </td><td class="rblock">       <span class="insert">{</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               octahedronPolygon</span> = <span class="insert">OctahedronPolygon(contour);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Return the list of closed contours defining the polygon boundari
es.</td><td> </td><td class="right">       //! Return the list of closed contours defining the polygon boundari
es.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       QVector&lt;QVector&lt;Vec3d&gt; &gt; getClosedOutlineContours() const {Q_ASSERT(
0); return QVector&lt;QVector&lt;Vec3d&gt; &gt;();}</td><td> </td><td class="right">       QVector&lt;QVector&lt;Vec3d&gt; &gt; getClosedOutlineContours() const {Q_ASSERT(
0); return QVector&lt;QVector&lt;Vec3d&gt; &gt;();}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Deserialize the region. This method must allow as fast as possib
le deserialization.</td><td> </td><td class="right">       //! Deserialize the region. This method must allow as fast as possib
le deserialization.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       static SphericalRegionP deserialize(QDataStream&amp; in);</td><td> </td><td class="right">       static SphericalRegionP deserialize(QDataStream&amp; in);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Create a new SphericalRegionP which is the union of all the pass
ed ones.</td><td> </td><td class="right">       //! Create a new SphericalRegionP which is the union of all the pass
ed ones.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       static SphericalRegionP multiUnion(const QList&lt;SphericalRegionP&gt;&amp; re
gions, bool optimizeByPreGrouping=false);</td><td> </td><td class="right">       static SphericalRegionP multiUnion(const QList&lt;SphericalRegionP&gt;&amp; re
gions, bool optimizeByPreGrouping=false);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l11" /><small>skipping to change at</small><em> line 620</em></th><th> </th><th><a name="part-r11" /><small>skipping to change at</small><em> line 874</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">public:</td><td> </td><td class="right">public:</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Avoid name hiding when overloading the virtual methods.</td><td> </td><td class="right">       // Avoid name hiding when overloading the virtual methods.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       using SphericalRegion::intersects;</td><td> </td><td class="right">       using SphericalRegion::intersects;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       using SphericalRegion::contains;</td><td> </td><td class="right">       using SphericalRegion::contains;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Default constructor.</td><td> </td><td class="right">       //! Default constructor.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       SphericalConvexPolygon() {;}</td><td> </td><td class="right">       SphericalConvexPolygon() {;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Constructor from a list of contours.</td><td> </td><td class="right">       //! Constructor from a list of contours.</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0018" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       SphericalConvexPolygon(const QVector&lt;QVector&lt;Vec3d&gt; &gt;&amp; contours) <span class="delete">{Q_</span></td><td> </td><td class="rblock">       SphericalConvexPolygon(const QVector&lt;QVector&lt;Vec3d&gt; &gt;&amp; contours)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">ASSERT(contours.size()==1); setContour(contours.at(0));}</span></td><td> </td><td class="rblock">               <span class="insert">: fillVertexBufferNeedsUpdate(true)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               Q_ASSERT(contours.size()==1);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               setContour(contours.at(0));</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Constructor from one contour.</td><td> </td><td class="right">       //! Constructor from one contour.</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0019" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       SphericalConvexPolygon(const QVector&lt;Vec3d&gt;&amp; contour) <span class="delete">{setContour(co</span></td><td> </td><td class="rblock">       SphericalConvexPolygon(const QVector&lt;Vec3d&gt;&amp; contour)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">ntour);}</span></td><td> </td><td class="rblock">               <span class="insert">: fillVertexBufferNeedsUpdate(true)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               setContour(contour);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Special constructor for triangle.</td><td> </td><td class="right">       //! Special constructor for triangle.</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0020" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       SphericalConvexPolygon(const Vec3d &amp;e0,const Vec3d &amp;e1,const Vec3d &amp;</td><td> </td><td class="rblock">       SphericalConvexPolygon(const Vec3d &amp;e0,const Vec3d &amp;e1,const Vec3d &amp;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">e2) <span class="delete">{contour</span> &lt;&lt; e0 &lt;&lt; e1 &lt;&lt; e2; <span class="delete">updateBoundingCap();}</span></td><td> </td><td class="rblock">e2)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">               <span class="insert">: fillVertexBufferNeedsUpdate(true)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               contour</span> &lt;&lt; e0 &lt;&lt; e1 &lt;&lt; e2; <span class="insert">updateBoundingCap();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Special constructor for quads.</td><td> </td><td class="right">       //! Special constructor for quads.</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0021" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       SphericalConvexPolygon(const Vec3d &amp;e0,const Vec3d &amp;e1,const Vec3d &amp;</td><td> </td><td class="rblock">       SphericalConvexPolygon(const Vec3d &amp;e0,const Vec3d &amp;e1,const Vec3d &amp;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">e2, const Vec3d &amp;e3)  <span class="delete">{contour</span> &lt;&lt; e0 &lt;&lt; e1 &lt;&lt; e2 &lt;&lt; e3; <span class="delete">updateBoundingCap()</span></td><td> </td><td class="rblock">e2, const Vec3d &amp;e3)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">;}</span></td><td> </td><td class="rblock">               <span class="insert">: fillVertexBufferNeedsUpdate(true)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               contour</span> &lt;&lt; e0 &lt;&lt; e1 &lt;&lt; e2 &lt;&lt; e3; <span class="insert">updateBoundingCap();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual SphericalRegionType getType() const {return SphericalRegion:
:ConvexPolygon;}</td><td> </td><td class="right">       virtual SphericalRegionType getType() const {return SphericalRegion:
:ConvexPolygon;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0022" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       virtual OctahedronPolygon getOctahedronPolygon() const <span class="delete">{return Octah</span></td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">edronPolygon(contour);}</span></td><td> </td><td class="rblock">       virtual OctahedronPolygon getOctahedronPolygon() const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       virtual <span class="delete">StelVertexArray getFillVertexArray()</span> const <span class="delete">{return StelVerte</span></td><td> </td><td class="rblock">       <span class="insert">{</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">xArray(contour, StelVertexArray::TriangleFan);}</span></td><td> </td><td class="rblock"><span class="insert">               return OctahedronPolygon(contour);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       virtual <span class="delete">StelVertexArray getOutlineVertexArray()</span> const <span class="delete">{return StelVe</span></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">rtexArray(contour, StelVertexArray::LineLoop);}</span></td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       virtual const <span class="insert">QVector&lt;Vec3d&gt;&amp; getFillVertexPositions() const</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               return contour;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       virtual PrimitiveType getFillPrimitiveType() const</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               return PrimitiveType_TriangleFan;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       virtual const QVector&lt;Vec3d&gt;&amp; getOutlineVertexPositions() const</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               return contour;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       virtual <span class="insert">PrimitiveType getOutlinePrimitiveType()</span> const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">{</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               return PrimitiveType_LineLoop;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual double getArea() const;</td><td> </td><td class="right">       virtual double getArea() const;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual bool isEmpty() const {return contour.isEmpty();}</td><td> </td><td class="right">       virtual bool isEmpty() const {return contour.isEmpty();}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual Vec3d getPointInside() const;</td><td> </td><td class="right">       virtual Vec3d getPointInside() const;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual SphericalCap getBoundingCap() const {return cachedBoundingCa
p;}</td><td> </td><td class="right">       virtual SphericalCap getBoundingCap() const {return cachedBoundingCa
p;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       QVector&lt;SphericalCap&gt; getBoundingSphericalCaps() const;</td><td> </td><td class="right">       QVector&lt;SphericalCap&gt; getBoundingSphericalCaps() const;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Serialize the region into a QVariant map matching the JSON forma
t.</td><td> </td><td class="right">       //! Serialize the region into a QVariant map matching the JSON forma
t.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! The format is</td><td> </td><td class="right">       //! The format is</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! @code["CONVEX_POLYGON", [[ra,dec], [ra,dec], [ra,dec], [ra,dec]]
]@endcode</td><td> </td><td class="right">       //! @code["CONVEX_POLYGON", [[ra,dec], [ra,dec], [ra,dec], [ra,dec]]
]@endcode</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! where the coords are a closed convex contour, with each points d
efined by ra dec in degree in the ICRS frame.</td><td> </td><td class="right">       //! where the coords are a closed convex contour, with each points d
efined by ra dec in degree in the ICRS frame.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual QVariantList toQVariant() const;</td><td> </td><td class="right">       virtual QVariantList toQVariant() const;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l12" /><small>skipping to change at</small><em> line 679</em></th><th> </th><th><a name="part-r12" /><small>skipping to change at</small><em> line 976</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//     virtual SphericalRegionP getSubtraction(const SphericalConvexPolygon
&amp; r) const;</td><td> </td><td class="right">//     virtual SphericalRegionP getSubtraction(const SphericalConvexPolygon
&amp; r) const;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//     virtual SphericalRegionP getSubtraction(const SphericalCap&amp; r) const
;</td><td> </td><td class="right">//     virtual SphericalRegionP getSubtraction(const SphericalCap&amp; r) const
;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//     virtual SphericalRegionP getSubtraction(const SphericalPoint&amp; r) con
st;</td><td> </td><td class="right">//     virtual SphericalRegionP getSubtraction(const SphericalPoint&amp; r) con
st;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//     virtual SphericalRegionP getSubtraction(const EmptySphericalRegion&amp; 
r) const;</td><td> </td><td class="right">//     virtual SphericalRegionP getSubtraction(const EmptySphericalRegion&amp; 
r) const;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       ////////////////////////////////////////////////////////////////////</td><td> </td><td class="right">       ////////////////////////////////////////////////////////////////////</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Methods specific to SphericalConvexPolygon</td><td> </td><td class="right">       // Methods specific to SphericalConvexPolygon</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       ////////////////////////////////////////////////////////////////////</td><td> </td><td class="right">       ////////////////////////////////////////////////////////////////////</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Set a single contour defining the SphericalPolygon.</td><td> </td><td class="right">       //! Set a single contour defining the SphericalPolygon.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! @param acontour a contour defining the polygon area.</td><td> </td><td class="right">       //! @param acontour a contour defining the polygon area.</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0023" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       void setContour(const QVector&lt;Vec3d&gt;&amp; acontour) <span class="delete">{contour=acontour; u</span></td><td> </td><td class="rblock">       void setContour(const QVector&lt;Vec3d&gt;&amp; acontour)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">pdateBoundingCap();}</span></td><td> </td><td class="rblock">       <span class="insert">{</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               contour = acontour;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               fillVertexBufferNeedsUpdate = true;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               updateBoundingCap();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Get the single contour defining the SphericalConvexPolygon.</td><td> </td><td class="right">       //! Get the single contour defining the SphericalConvexPolygon.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const QVector&lt;Vec3d&gt;&amp; getConvexContour() const {return contour;}</td><td> </td><td class="right">       const QVector&lt;Vec3d&gt;&amp; getConvexContour() const {return contour;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Check if the polygon is valid, i.e. it has no side &gt;180.</td><td> </td><td class="right">       //! Check if the polygon is valid, i.e. it has no side &gt;180.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       bool checkValid() const;</td><td> </td><td class="right">       bool checkValid() const;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Check if the passed contour is convex and valid, i.e. it has no 
side &gt;180.</td><td> </td><td class="right">       //! Check if the passed contour is convex and valid, i.e. it has no 
side &gt;180.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       static bool checkValidContour(const QVector&lt;Vec3d&gt;&amp; contour);</td><td> </td><td class="right">       static bool checkValidContour(const QVector&lt;Vec3d&gt;&amp; contour);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Deserialize the region. This method must allow as fast as possib
le deserialization.</td><td> </td><td class="right">       //! Deserialize the region. This method must allow as fast as possib
le deserialization.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       static SphericalRegionP deserialize(QDataStream&amp; in);</td><td> </td><td class="right">       static SphericalRegionP deserialize(QDataStream&amp; in);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">protected:</td><td> </td><td class="right">protected:</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! A list of vertices of the convex contour.</td><td> </td><td class="right">       //! A list of vertices of the convex contour.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       QVector&lt;Vec3d&gt; contour;</td><td> </td><td class="right">       QVector&lt;Vec3d&gt; contour;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Cache the bounding cap.</td><td> </td><td class="right">       //! Cache the bounding cap.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       SphericalCap cachedBoundingCap;</td><td> </td><td class="right">       SphericalCap cachedBoundingCap;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0024" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">//! Does the drawFill() vertex buffer need an update?</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       bool fillVertexBufferNeedsUpdate;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Update the bounding cap from the vertex list.</td><td> </td><td class="right">       //! Update the bounding cap from the vertex list.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       void updateBoundingCap();</td><td> </td><td class="right">       void updateBoundingCap();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0025" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">virtual void updateFillVertexBuffer(class StelRenderer* renderer, co</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">nst DrawParams&amp; params, bool handleDiscontinuity);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       virtual void drawFillVertexBuffer(class StelRenderer* renderer, clas</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">s StelProjector* projector);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       virtual bool needToUpdateFillVertexBuffers() const</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               return fillVertexBufferNeedsUpdate;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       virtual void fillVertexBuffersUpdated()</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               fillVertexBufferNeedsUpdate = false;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Computes whether the passed points are all outside of at least o
ne SphericalCap defining the polygon boundary.</td><td> </td><td class="right">       //! Computes whether the passed points are all outside of at least o
ne SphericalCap defining the polygon boundary.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! @param thisContour the vertices defining the contour.</td><td> </td><td class="right">       //! @param thisContour the vertices defining the contour.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! @param nbThisContour nb of vertice of the contour.</td><td> </td><td class="right">       //! @param nbThisContour nb of vertice of the contour.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! @param points the points to test.</td><td> </td><td class="right">       //! @param points the points to test.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! @param nbPoints the number of points to test.</td><td> </td><td class="right">       //! @param nbPoints the number of points to test.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       static bool areAllPointsOutsideOneSide(const Vec3d* thisContour, int
 nbThisContour, const Vec3d* points, int nbPoints);</td><td> </td><td class="right">       static bool areAllPointsOutsideOneSide(const Vec3d* thisContour, int
 nbThisContour, const Vec3d* points, int nbPoints);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Computes whether the passed points are all outside of at least o
ne SphericalCap defining the polygon boundary.</td><td> </td><td class="right">       //! Computes whether the passed points are all outside of at least o
ne SphericalCap defining the polygon boundary.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       bool areAllPointsOutsideOneSide(const QVector&lt;Vec3d&gt;&amp; points) const</td><td> </td><td class="right">       bool areAllPointsOutsideOneSide(const QVector&lt;Vec3d&gt;&amp; points) const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l13" /><small>skipping to change at</small><em> line 779</em></th><th> </th><th><a name="part-r13" /><small>skipping to change at</small><em> line 1098</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//protected:</td><td> </td><td class="right">//protected:</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//     QVector&lt;SphericalConvexPolygon&gt; contours;</td><td> </td><td class="right">//     QVector&lt;SphericalConvexPolygon&gt; contours;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//</td><td> </td><td class="right">//</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//     //! Cache the bounding cap.</td><td> </td><td class="right">//     //! Cache the bounding cap.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//     SphericalCap cachedBoundingCap;</td><td> </td><td class="right">//     SphericalCap cachedBoundingCap;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//</td><td> </td><td class="right">//</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//     //! Update the bounding cap from the vertex list.</td><td> </td><td class="right">//     //! Update the bounding cap from the vertex list.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//     void updateBoundingCap();</td><td> </td><td class="right">//     void updateBoundingCap();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//};</td><td> </td><td class="right">//};</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0026" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//! @class SphericalTexturedPolygon</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//! An extension of SphericalPolygon with addition of texture coordinates.</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">class SphericalTexturedPolygon : public SphericalPolygon</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">{</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">public:</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       //! @struct TextureVertex</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       //! A container for 3D vertex + associated texture coordinates</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       struct TextureVertex</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       {</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               Vec3d vertex;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               Vec2f texCoord;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       };</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       SphericalTexturedPolygon() {;}</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       //! Constructor from a list of contours.</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       SphericalTexturedPolygon(const QVector&lt;QVector&lt;TextureVertex&gt; &gt;&amp; con</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">tours) {Q_UNUSED(contours); Q_ASSERT(0);}</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       //! Constructor from one contour.</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       SphericalTexturedPolygon(const QVector&lt;TextureVertex&gt;&amp; contour) {Q_U</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">NUSED(contour); Q_ASSERT(0);}</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       //! Return an openGL compatible array of texture coords to be used u</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">sing vertex arrays.</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       virtual StelVertexArray getFillVertexArray() const {Q_ASSERT(0); ret</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">urn StelVertexArray();}</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       //! Serialize the region into a QVariant map matching the JSON forma</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">t.</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       //! The format is:</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       //! @code["TEXTURED_POLYGON", [[[ra,dec], [ra,dec], [ra,dec], [ra,de</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">c]], [[ra,dec], [ra,dec], [ra,dec]],[...]],</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       //! [[[u,v],[u,v],[u,v],[u,v]], [[u,v],[u,v],[u,v]], [...]]]@endcode</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       //! where the two lists are a list of closed contours, with each poi</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">nts defined by ra dec in degree in the ICRS frame</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       //! followed by a list of texture coordinates in the u,v texture spa</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">ce (between 0 and 1).</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       //! There must be one texture coordinate for each vertex.</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       virtual QVariantList toQVariant() const;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       virtual void serialize(QDataStream&amp; out) const {Q_UNUSED(out); Q_ASS</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">ERT(0);}</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       ////////////////////////////////////////////////////////////////////</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       // Methods specific to SphericalTexturedPolygon</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       //! Set the contours defining the SphericalPolygon.</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       //! @param contours the list of contours defining the polygon area u</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">sing the WindingPositive winding rule.</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       void setContours(const QVector&lt;QVector&lt;TextureVertex&gt; &gt;&amp; contours) {</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">Q_UNUSED(contours); Q_ASSERT(0);}</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       //! Set a single contour defining the SphericalPolygon.</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       //! @param contour a contour defining the polygon area.</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       void setContour(const QVector&lt;TextureVertex&gt;&amp; contour) {Q_UNUSED(con</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">tour); Q_ASSERT(0);}</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">private:</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       //! A list of uv textures coordinates corresponding to the triangle </span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">vertices.</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       //! There should be 1 uv position per vertex.</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       QVector&lt;Vec2f&gt; textureCoords;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">};</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">Q_DECLARE_TYPEINFO(SphericalTexturedPolygon::TextureVertex, Q_PRIMITIVE_TYP</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">E);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                                                           </td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! @class SphericalTexturedConvexPolygon</td><td> </td><td class="right">//! @class SphericalTexturedConvexPolygon</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! Extension of SphericalConvexPolygon for textured polygon.</td><td> </td><td class="right">//! Extension of SphericalConvexPolygon for textured polygon.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">class SphericalTexturedConvexPolygon : public SphericalConvexPolygon</td><td> </td><td class="right">class SphericalTexturedConvexPolygon : public SphericalConvexPolygon</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">public:</td><td> </td><td class="right">public:</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Default constructor.</td><td> </td><td class="right">       //! Default constructor.</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0027" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       SphericalTexturedConvexPolygon() <span class="delete">{;}</span></td><td> </td><td class="rblock">       SphericalTexturedConvexPolygon() <span class="insert">: fillTexturedVertexBuffer(NULL)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               fillVertexBufferNeedsUpdate = true;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Constructor from one contour.</td><td> </td><td class="right">       //! Constructor from one contour.</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0028" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       SphericalTexturedConvexPolygon(const QVector&lt;Vec3d&gt;&amp; contour, const </td><td> </td><td class="rblock">       SphericalTexturedConvexPolygon(const QVector&lt;Vec3d&gt;&amp; contour, const </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">QVector&lt;Vec2f&gt;&amp; texCoord) <span class="delete">{setContour(contour, texCoord);}</span></td><td> </td><td class="rblock">QVector&lt;Vec2f&gt;&amp; texCoord)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">               <span class="insert">: fillTexturedVertexBuffer(NULL)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               setContour(contour, texCoord);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               fillVertexBufferNeedsUpdate = true;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Special constructor for quads.</td><td> </td><td class="right">       //! Special constructor for quads.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Use the 4 textures corners for the 4 vertices.</td><td> </td><td class="right">       //! Use the 4 textures corners for the 4 vertices.</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0029" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       SphericalTexturedConvexPolygon(const Vec3d &amp;e0,const Vec3d &amp;e1,const</td><td> </td><td class="rblock">       SphericalTexturedConvexPolygon(const Vec3d &amp;e0,const Vec3d &amp;e1,const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"> Vec3d &amp;e2, const Vec3d &amp;e3) : SphericalConvexPolygon(e0,e1,e2,e3)</td><td> </td><td class="rblock"> Vec3d &amp;e2, const Vec3d &amp;e3)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">               : SphericalConvexPolygon(e0,e1,e2,e3)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">               <span class="insert">, fillTexturedVertexBuffer(NULL)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               textureCoords &lt;&lt; Vec2f(0.f, 0.f) &lt;&lt; Vec2f(1.f, 0.f) &lt;&lt; Vec2f
(1.f, 1.f) &lt;&lt; Vec2f(0.f, 1.f);</td><td> </td><td class="right">               textureCoords &lt;&lt; Vec2f(0.f, 0.f) &lt;&lt; Vec2f(1.f, 0.f) &lt;&lt; Vec2f
(1.f, 1.f) &lt;&lt; Vec2f(0.f, 1.f);</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0030" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               fillVertexBufferNeedsUpdate = true;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0031" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">//! Return an openGL compatible array to be displayed using vertex a</span></td><td> </td><td class="rblock">       virtual <span class="insert">~SphericalTexturedConvexPolygon()</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">rrays.</span></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       //! This method is not optimized for SphericalConvexPolygon instance</span></td><td> </td><td class="rblock"><span class="insert">               if(NULL != fillTexturedVertexBuffer)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">s.</span></td><td> </td><td class="rblock"><span class="insert">               {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       virtual <span class="delete">StelVertexArray getFillVertexArray() const {return StelVerte</span></td><td> </td><td class="rblock"><span class="insert">                       delete fillTexturedVertexBuffer;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">xArray(contour, StelVertexArray::TriangleFan, textureCoords);}</span></td><td> </td><td class="rblock"><span class="insert">               }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Set a single contour defining the SphericalPolygon.</td><td> </td><td class="right">       //! Set a single contour defining the SphericalPolygon.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! @param acontour a contour defining the polygon area.</td><td> </td><td class="right">       //! @param acontour a contour defining the polygon area.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! @param texCoord a list of texture coordinates matching the verti
ces of the contour.</td><td> </td><td class="right">       //! @param texCoord a list of texture coordinates matching the verti
ces of the contour.</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0032" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       virtual void setContour(const QVector&lt;Vec3d&gt;&amp; acontour, const QVecto</td><td> </td><td class="rblock">       virtual void setContour(const QVector&lt;Vec3d&gt;&amp; acontour, const QVecto</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">r&lt;Vec2f&gt;&amp; texCoord) <span class="delete">{SphericalConvexPolygon::setContour(acontour); textureC</span></td><td> </td><td class="rblock">r&lt;Vec2f&gt;&amp; texCoord)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">oords=texCoord;}</span></td><td> </td><td class="rblock">       <span class="insert">{</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               SphericalConvexPolygon::setContour(acontour);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               textureCoords=texCoord;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               fillVertexBufferNeedsUpdate = true;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Serialize the region into a QVariant map matching the JSON forma
t.</td><td> </td><td class="right">       //! Serialize the region into a QVariant map matching the JSON forma
t.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! The format is:</td><td> </td><td class="right">       //! The format is:</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! @code["TEXTURED_CONVEX_POLYGON", [[ra,dec], [ra,dec], [ra,dec], 
[ra,dec]], [[u,v],[u,v],[u,v],[u,v]]]@endcode</td><td> </td><td class="right">       //! @code["TEXTURED_CONVEX_POLYGON", [[ra,dec], [ra,dec], [ra,dec], 
[ra,dec]], [[u,v],[u,v],[u,v],[u,v]]]@endcode</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! where the two lists are a closed convex contours, with each poin
ts defined by ra dec in degree in the ICRS frame</td><td> </td><td class="right">       //! where the two lists are a closed convex contours, with each poin
ts defined by ra dec in degree in the ICRS frame</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! followed by a list of texture coordinates in the u,v texture spa
ce (between 0 and 1).</td><td> </td><td class="right">       //! followed by a list of texture coordinates in the u,v texture spa
ce (between 0 and 1).</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! There must be one texture coordinate for each vertex.</td><td> </td><td class="right">       //! There must be one texture coordinate for each vertex.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual QVariantList toQVariant() const;</td><td> </td><td class="right">       virtual QVariantList toQVariant() const;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual void serialize(QDataStream&amp; out) const {out &lt;&lt; contour &lt;&lt; te
xtureCoords;}</td><td> </td><td class="right">       virtual void serialize(QDataStream&amp; out) const {out &lt;&lt; contour &lt;&lt; te
xtureCoords;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">protected:</td><td> </td><td class="right">protected:</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0033" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       //! A list of uv texture<span class="delete">s coordinates corresponding to the triangle 
v</span>ertices.</td><td> </td><td class="rblock">       //! A list of uv texture<span class="insert"> coordinates corresponding to the triangle v
</span>ertices.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! There should be 1 uv position per vertex.</td><td> </td><td class="right">       //! There should be 1 uv position per vertex.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       QVector&lt;Vec2f&gt; textureCoords;</td><td> </td><td class="right">       QVector&lt;Vec2f&gt; textureCoords;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0034" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">//! Vertex buffer used in our override of drawFill() (using vertices</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> with texcoords).</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       StelVertexBuffer&lt;TexturedVertex&gt;* fillTexturedVertexBuffer;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       virtual void updateFillVertexBuffer(class StelRenderer* renderer, co</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">nst DrawParams&amp; params, bool handleDiscontinuity);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       virtual void drawFillVertexBuffer(class StelRenderer* renderer, clas</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">s StelProjector* projector);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">};</td><td> </td><td class="right">};</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! Compute the intersection of 2 great circles segments.</td><td> </td><td class="right">//! Compute the intersection of 2 great circles segments.</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0035" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//! @param p1 Start of the first great circle segment.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//! @param p2 End of the first great circle segment.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//! @param p3 Start of the second great circle segment.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//! @param p4 End of the second great circle segment.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! @param ok is set to false if no intersection was found.</td><td> </td><td class="right">//! @param ok is set to false if no intersection was found.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! @return the intersection point on the sphere (normalized) if ok is true
, or undefined of ok is false.</td><td> </td><td class="right">//! @return the intersection point on the sphere (normalized) if ok is true
, or undefined of ok is false.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">Vec3d greatCircleIntersection(const Vec3d&amp; p1, const Vec3d&amp; p2, const Vec3d
&amp; p3, const Vec3d&amp; p4, bool&amp; ok);</td><td> </td><td class="right">Vec3d greatCircleIntersection(const Vec3d&amp; p1, const Vec3d&amp; p2, const Vec3d
&amp; p3, const Vec3d&amp; p4, bool&amp; ok);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! Compute the intersection of a great circles segment with another great 
circle.</td><td> </td><td class="right">//! Compute the intersection of a great circles segment with another great 
circle.</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0036" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//! @param p1 Start of the great circle segment.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//! @param p2 End of the great circle segment.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//! @param nHalfSpace Normal of the plane separating half space to intersec</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">t with.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! @param ok is set to false if no intersection was found.</td><td> </td><td class="right">//! @param ok is set to false if no intersection was found.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! @return the intersection point on the sphere (normalized) if ok is true
, or undefined of ok is false.</td><td> </td><td class="right">//! @return the intersection point on the sphere (normalized) if ok is true
, or undefined of ok is false.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">Vec3d greatCircleIntersection(const Vec3d&amp; p1, const Vec3d&amp; p2, const Vec3d
&amp; nHalfSpace, bool&amp; ok);</td><td> </td><td class="right">Vec3d greatCircleIntersection(const Vec3d&amp; p1, const Vec3d&amp; p2, const Vec3d
&amp; nHalfSpace, bool&amp; ok);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#endif // _STELSPHEREGEOMETRY_HPP_</td><td> </td><td class="right">#endif // _STELSPHEREGEOMETRY_HPP_</td><td class="lineno" valign="top"></td></tr>

     <tr><td></td><td class="left"></td><td> </td><td class="right"></td><td></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 36 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><td></td><th><i>127 lines changed or deleted</i></th><th><i> </i></th><th><i>459 lines changed or added</i></th><td></td></tr>
     <tr><td colspan="5" align="center" class="small"><br/>This html diff was produced by rfcdiff 1.41. The latest version is available from <a href="http://www.tools.ietf.org/tools/rfcdiff/" >http://tools.ietf.org/tools/rfcdiff/</a> </td></tr>
   </table>
   </body>
   </html>
