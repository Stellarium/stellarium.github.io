<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"> 
<!-- Generated by rfcdiff 1.41: rfcdiff  --> 
<!-- <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional" > -->
<!-- System: Linux fomalhaut.local 3.13.0-38-generic #65-Ubuntu SMP Thu Oct 9 11:36:50 UTC 2014 x86_64 x86_64 x86_64 GNU/Linux --> 
<!-- Using awk: /usr/bin/gawk: GNU Awk 4.0.1 --> 
<!-- Using diff: /usr/bin/diff: diff (GNU diffutils) 3.3 --> 
<!-- Using wdiff: /usr/bin/wdiff: wdiff (GNU wdiff) 1.2.1 --> 
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"> 
<head> 
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /> 
  <meta http-equiv="Content-Style-Type" content="text/css" /> 
  <title>Diff: GridLinesMgr.cpp - GridLinesMgr.cpp</title> 
  <style type="text/css"> 
    body    { font-size:16px; margin: 0.4ex; margin-right: auto; } 
    tr      { } 
    td      { white-space: pre; font-family: Consolas, "DejaVu Sans Mono", "Droid Sans Mono", Monaco, Monospace; vertical-align: top; font-size: 0.86em;} 
    th      { font-size: 0.86em; } 
    .small  { font-size: 0.6em; font-style: italic; font-family: Verdana, Helvetica, sans-serif; } 
    .left   { background-color: #EEE; } 
    .right  { background-color: #FFF; } 
    .diff   { background-color: #CCF; } 
    .lblock { background-color: #BFB; } 
    .rblock { background-color: #FF8; } 
    .insert { background-color: #8FF; } 
    .delete { background-color: #ACF; } 
    .void   { background-color: #FFB; } 
    .cont   { background-color: #EEE; } 
    .linebr { background-color: #AAA; } 
    .lineno { color: red; background-color: #FFF; font-size: 0.7em; text-align: right; padding: 0 2px; } 
    .elipsis{ background-color: #AAA; } 
    .left .cont { background-color: #DDD; } 
    .right .cont { background-color: #EEE; } 
    .lblock .cont { background-color: #9D9; } 
    .rblock .cont { background-color: #DD6; } 
    .insert .cont { background-color: #0DD; } 
    .delete .cont { background-color: #8AD; } 
    .stats, .stats td, .stats th { background-color: #EEE; padding: 2px 0; } 
  </style> 
</head> 
<body > 
  <table border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th></th><th>&nbsp;GridLinesMgr.cpp&nbsp;</th><th> </th><th>&nbsp;GridLinesMgr.cpp&nbsp;</th><th></th></tr> 
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l1" /><small>skipping to change at</small><em> line 24</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 24</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"> *</td><td> </td><td class="right"> *</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"> * You should have received a copy of the GNU General Public License</td><td> </td><td class="right"> * You should have received a copy of the GNU General Public License</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"> * along with this program; if not, write to the Free Software</td><td> </td><td class="right"> * along with this program; if not, write to the Free Software</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"> * Foundation, Inc., 51 Franklin Street, Suite 500, Boston, MA  02110-1335,
 USA.</td><td> </td><td class="right"> * Foundation, Inc., 51 Franklin Street, Suite 500, Boston, MA  02110-1335,
 USA.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"> */</td><td> </td><td class="right"> */</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#include &lt;set&gt;</td><td> </td><td class="right">#include &lt;set&gt;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#include &lt;QSettings&gt;</td><td> </td><td class="right">#include &lt;QSettings&gt;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#include &lt;QDebug&gt;</td><td> </td><td class="right">#include &lt;QDebug&gt;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#include &lt;QFontMetrics&gt;</td><td> </td><td class="right">#include &lt;QFontMetrics&gt;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">#include &lt;QtOpenGL&gt;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#include "GridLinesMgr.hpp"</td><td> </td><td class="right">#include "GridLinesMgr.hpp"</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#include "StelApp.hpp"</td><td> </td><td class="right">#include "StelApp.hpp"</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0002" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#include "renderer/StelCircleArcRenderer.hpp"</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#include "renderer/StelRenderer.hpp"</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#include "StelTranslator.hpp"</td><td> </td><td class="right">#include "StelTranslator.hpp"</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#include "StelProjector.hpp"</td><td> </td><td class="right">#include "StelProjector.hpp"</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#include "StelFader.hpp"</td><td> </td><td class="right">#include "StelFader.hpp"</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#include "Planet.hpp"</td><td> </td><td class="right">#include "Planet.hpp"</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#include "StelLocaleMgr.hpp"</td><td> </td><td class="right">#include "StelLocaleMgr.hpp"</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#include "StelModuleMgr.hpp"</td><td> </td><td class="right">#include "StelModuleMgr.hpp"</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#include "StelCore.hpp"</td><td> </td><td class="right">#include "StelCore.hpp"</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0003" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">#include "StelPainter.hpp"</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#include "StelSkyDrawer.hpp"</td><td> </td><td class="right">#include "StelSkyDrawer.hpp"</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! @class SkyGrid</td><td> </td><td class="right">//! @class SkyGrid</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! Class which manages a grid to display in the sky.</td><td> </td><td class="right">//! Class which manages a grid to display in the sky.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! TODO needs support for DMS/DMS labelling, not only HMS/DMS</td><td> </td><td class="right">//! TODO needs support for DMS/DMS labelling, not only HMS/DMS</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">class SkyGrid</td><td> </td><td class="right">class SkyGrid</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">public:</td><td> </td><td class="right">public:</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Create and precompute positions of a SkyGrid</td><td> </td><td class="right">       // Create and precompute positions of a SkyGrid</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       SkyGrid(StelCore::FrameType frame);</td><td> </td><td class="right">       SkyGrid(StelCore::FrameType frame);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual ~SkyGrid();</td><td> </td><td class="right">       virtual ~SkyGrid();</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0004" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       void draw(const StelCore* <span class="delete">prj)</span> const;</td><td> </td><td class="rblock">       <span class="insert">//! Draw the grid.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //!</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //! @param core     The StelCore object.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //! @param renderer Renderer to draw with.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       void draw(const StelCore* <span class="insert">core, StelRenderer* renderer)</span> const;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       void setFontSize(double newFontSize);</td><td> </td><td class="right">       void setFontSize(double newFontSize);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       void setColor(const Vec3f&amp; c) {color = c;}</td><td> </td><td class="right">       void setColor(const Vec3f&amp; c) {color = c;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const Vec3f&amp; getColor() {return color;}</td><td> </td><td class="right">       const Vec3f&amp; getColor() {return color;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       void update(double deltaTime) {fader.update((int)(deltaTime*1000));}</td><td> </td><td class="right">       void update(double deltaTime) {fader.update((int)(deltaTime*1000));}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       void setFadeDuration(float duration) {fader.setDuration((int)(durati
on*1000.f));}</td><td> </td><td class="right">       void setFadeDuration(float duration) {fader.setDuration((int)(durati
on*1000.f));}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       void setDisplayed(const bool displayed){fader = displayed;}</td><td> </td><td class="right">       void setDisplayed(const bool displayed){fader = displayed;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       bool isDisplayed(void) const {return fader;}</td><td> </td><td class="right">       bool isDisplayed(void) const {return fader;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">private:</td><td> </td><td class="right">private:</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Vec3f color;</td><td> </td><td class="right">       Vec3f color;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       StelCore::FrameType frameType;</td><td> </td><td class="right">       StelCore::FrameType frameType;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l2" /><small>skipping to change at</small><em> line 79</em></th><th> </th><th><a name="part-r2" /><small>skipping to change at</small><em> line 84</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               EQUATOR,</td><td> </td><td class="right">               EQUATOR,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               ECLIPTIC,</td><td> </td><td class="right">               ECLIPTIC,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               MERIDIAN,</td><td> </td><td class="right">               MERIDIAN,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               HORIZON,</td><td> </td><td class="right">               HORIZON,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               GALACTICPLANE</td><td> </td><td class="right">               GALACTICPLANE</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       };</td><td> </td><td class="right">       };</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Create and precompute positions of a SkyGrid</td><td> </td><td class="right">       // Create and precompute positions of a SkyGrid</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       SkyLine(SKY_LINE_TYPE _line_type = EQUATOR);</td><td> </td><td class="right">       SkyLine(SKY_LINE_TYPE _line_type = EQUATOR);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       virtual ~SkyLine();</td><td> </td><td class="right">       virtual ~SkyLine();</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0005" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       void draw(StelCore* <span class="delete">core)</span> const;</td><td> </td><td class="rblock">       <span class="insert">//! Draw the line.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //!</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //! @param core     The StelCore object.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //! @param renderer Renderer to draw with.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       void draw(StelCore* <span class="insert">core, StelRenderer* renderer)</span> const;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       void setColor(const Vec3f&amp; c) {color = c;}</td><td> </td><td class="right">       void setColor(const Vec3f&amp; c) {color = c;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const Vec3f&amp; getColor() {return color;}</td><td> </td><td class="right">       const Vec3f&amp; getColor() {return color;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       void update(double deltaTime) {fader.update((int)(deltaTime*1000));}</td><td> </td><td class="right">       void update(double deltaTime) {fader.update((int)(deltaTime*1000));}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       void setFadeDuration(float duration) {fader.setDuration((int)(durati
on*1000.f));}</td><td> </td><td class="right">       void setFadeDuration(float duration) {fader.setDuration((int)(durati
on*1000.f));}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       void setDisplayed(const bool displayed){fader = displayed;}</td><td> </td><td class="right">       void setDisplayed(const bool displayed){fader = displayed;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       bool isDisplayed(void) const {return fader;}</td><td> </td><td class="right">       bool isDisplayed(void) const {return fader;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       void setFontSize(double newSize);</td><td> </td><td class="right">       void setFontSize(double newSize);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //! Re-translates the label.</td><td> </td><td class="right">       //! Re-translates the label.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       void updateLabel();</td><td> </td><td class="right">       void updateLabel();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">private:</td><td> </td><td class="right">private:</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l3" /><small>skipping to change at</small><em> line 147</em></th><th> </th><th><a name="part-r3" /><small>skipping to change at</small><em> line 156</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       double minResolution = 80.;</td><td> </td><td class="right">       double minResolution = 80.;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       double minSizeArcsec = minResolution/pixelPerRad*180./M_PI*3600;</td><td> </td><td class="right">       double minSizeArcsec = minResolution/pixelPerRad*180./M_PI*3600;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       for (unsigned int i=0;i&lt;11;++i)</td><td> </td><td class="right">       for (unsigned int i=0;i&lt;11;++i)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               if (STEP_SIZES_HMS[i]&gt;minSizeArcsec)</td><td> </td><td class="right">               if (STEP_SIZES_HMS[i]&gt;minSizeArcsec)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       return STEP_SIZES_HMS[i]/3600.;</td><td> </td><td class="right">                       return STEP_SIZES_HMS[i]/3600.;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       return 15.;</td><td> </td><td class="right">       return 15.;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0006" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//! Data passed to viewportEdgeIntersectCallback.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">struct ViewportEdgeIntersectCallbackData</td><td> </td><td class="right">struct ViewportEdgeIntersectCallbackData</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0007" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">ViewportEdgeIntersectCallbackData(StelPainter* p)</span> : <span class="delete">sPainter(p) {;}</span></td><td> </td><td class="rblock">       <span class="insert">//! Construct ViewportEdgeIntersectCallbackData with specified font </span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       StelPainter* sPainter;</span></td><td> </td><td class="rblock"><span class="insert">metrics.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       ViewportEdgeIntersectCallbackData(const QFontMetrics&amp; metrics)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">               : <span class="insert">fontMetrics(metrics){}</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //! Renderer to draw the label with.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       StelRenderer* renderer;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //! Projector to project 3D coordinates to viewport.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       StelProjectorP projector;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //! Color of label text.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Vec4f textColor;</td><td> </td><td class="right">       Vec4f textColor;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0008" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">QString text;           // Label to display at</span> the <span class="delete">intersection</span> of <span class="delete">t</span></td><td> </td><td class="rblock">       <span class="insert">//! Color of</span> the <span class="insert">sky line (or grid) being drawn.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">he lines and screen side</span></td><td> </td><td class="rblock"><span class="insert">       Vec4f skyLineColor;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       double <span class="delete">raAngle;         //</span> Used for meridians</td><td> </td><td class="rblock"><span class="insert">       //! Metrics</span> of <span class="insert">the label font (so we know how to offset the label).</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       const QFontMetrics fontMetrics;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //! Label text.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       QString text;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       double <span class="insert">raAngle;//</span> Used for meridians</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       StelCore::FrameType frameType;</td><td> </td><td class="right">       StelCore::FrameType frameType;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">};</td><td> </td><td class="right">};</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0009" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//</span> Callback which draws the label of the grid</td><td> </td><td class="rblock"><span class="insert">//!</span> Callback which draws the label of the grid <span class="insert">at the edge of the viewport.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//!</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//! @param screenPos 2D position of the intersection on the screen.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//! @param direction Normalized direction of the arc toward the inside of t</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">he viewport.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//! @param userData  ViewportEdgeIntersectCallbackData.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void viewportEdgeIntersectCallback(const Vec3d&amp; screenPos, const Vec3d&amp; dir
ection, void* userData)</td><td> </td><td class="right">void viewportEdgeIntersectCallback(const Vec3d&amp; screenPos, const Vec3d&amp; dir
ection, void* userData)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0010" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       ViewportEdgeIntersectCallbackData* d = <span class="delete">static_cast&lt;ViewportEdgeInter</span></td><td> </td><td class="rblock">       ViewportEdgeIntersectCallbackData* d =</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">sectCallbackData*&gt;(userData);</span></td><td> </td><td class="rblock">               <span class="insert">static_cast&lt;ViewportEdgeIntersectCallbackData*&gt;(userData);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       Vec3d direc(direction);</span></td><td> </td><td class="rblock"><span class="insert">       d-&gt;renderer-&gt;setGlobalColor(d-&gt;textColor);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       direc.normalize();</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       const Vec4f tmpColor = d-&gt;sPainter-&gt;getColor();</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       d-&gt;sPainter-&gt;setColor(d-&gt;textColor[0], d-&gt;textColor[1], d-&gt;textColor</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">[2], d-&gt;textColor[3]);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       QString text;</td><td> </td><td class="right">       QString text;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (d-&gt;text.isEmpty())</td><td> </td><td class="right">       if (d-&gt;text.isEmpty())</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0011" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               // We are in the case of meridians, we need to determine <span class="delete">whi</span></td><td> </td><td class="rblock">               // We are in the case of meridians,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">ch</span> of the 2 labels (3h or <span class="delete">15h</span> to <span class="delete">use)</span></td><td> </td><td class="rblock">               <span class="insert">//</span> we need to determine <span class="insert">which</span> of the 2 labels (3h or <span class="insert">15h)</span> to</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">use</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               Vec3d tmpV;</td><td> </td><td class="right">               Vec3d tmpV;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0012" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               <span class="delete">d-&gt;sPainter-&gt;getProjector()-&gt;unProject(screenPos,</span> tmpV);</td><td> </td><td class="rblock">               <span class="insert">d-&gt;projector-&gt;unProject(screenPos,</span> tmpV);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               double lon, <span class="delete">lat;</span></td><td> </td><td class="rblock">               double lon, <span class="insert">lat, raAngle;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               StelUtils::rectToSphe(&amp;lon, &amp;lat, tmpV);</td><td> </td><td class="right">               StelUtils::rectToSphe(&amp;lon, &amp;lat, tmpV);</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0013" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               <span class="delete">switch (d-&gt;frameType)</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               {</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       case StelCore::FrameAltAz:</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       {</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                               double raAngle = M_PI-d-&gt;raAngle;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                               lon = M_PI-lon;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                               if (raAngle&lt;0)</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                                       raAngle=+2.*M_PI;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                               if (lon&lt;0)</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                                       lon=+2.*M_PI;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                               if (std::fabs(2.*M_PI-lon)&lt;0.01)</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                               {</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                                       // We are at meridian 0</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                                       lon = 0.;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                               }</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                               if (std::fabs(lon-raAngle) &lt; 0.01)</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                                       text = StelUtils::radToDmsStrAdapt(r</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">aAngle);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                               else</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                               {</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                                       const double delta = raAngle&lt;M_PI ? </span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">M_PI : -M_PI;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                                       if (raAngle==2*M_PI &amp;&amp; delta==-M_PI)</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                                       {</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                                               text = StelUtils::radToDmsSt</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">rAdapt(0);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                                       }</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                                       else</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                                       {</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                                               text = StelUtils::radToDmsSt</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">rAdapt(raAngle+delta);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                                       }</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                               }</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                               break;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       }</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       case StelCore::FrameGalactic:</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       {</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                               double raAngle = M_PI-d-&gt;raAngle;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                               lon = M_PI-lon;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                               if (raAngle&lt;0)</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                                       raAngle=+2.*M_PI;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                               if (lon&lt;0)</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                                       lon=+2.*M_PI;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0014" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                               <span class="delete">if (std::fabs(2.*M_PI-lon)&lt;0.01)</span></td><td> </td><td class="rblock">               <span class="insert">const bool altAzOrGalactic</span> = <span class="insert">d-&gt;frameType == StelCore::Frame</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                               {</span></td><td> </td><td class="rblock"><span class="insert">AltAz ||</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                                       // We are at meridian 0</span></td><td> </td><td class="rblock"><span class="insert">                                            d-&gt;frameType == StelCore::Frame</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                                       lon</span> = <span class="delete">0.;</span></td><td> </td><td class="rblock"><span class="insert">Galactic;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                               }</span></td><td> </td><td class="rblock"><span class="insert">               raAngle</span> = <span class="insert">d-&gt;raAngle;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                               if (std::fabs(lon-raAngle) &lt; 0.01)</span></td><td> </td><td class="rblock"><span class="insert">               if(altAzOrGalactic)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                                       text</span> = <span class="delete">StelUtils::radToDmsStrAdapt(-</span></td><td> </td><td class="rblock">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">raAngle+M_PI);</span></td><td> </td><td class="rblock">                       <span class="insert">raAngle</span> = M_PI <span class="insert">- raAngle;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                               else</span></td><td> </td><td class="rblock">                       lon     = <span class="insert">M_PI - lon;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                               {</td><td> </td><td class="rblock">                       if <span class="insert">(raAngle</span> &lt; <span class="insert">0) {raAngle += 2.0 * M_PI;}</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                       <span class="delete">const double delta</span> = <span class="delete">raAngle&lt;M_PI ?</span> </td><td> </td><td class="rblock"><span class="insert">                       if (lon &lt; 0)     {lon     += 2.0 * M_PI;}</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">M_PI <span class="delete">: -M_PI;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                                       text = StelUtils::radToDmsStrAdapt(-</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">raAngle-delta+M_PI);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                               }</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                               break;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       }</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       default:</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       {</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                               if (std::fabs(2.*M_PI-lon)&lt;0.01)</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                               {</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                                       // We are at meridian 0</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                       lon = <span class="delete">0.;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                               }</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                               if <span class="delete">(std::fabs(lon-d-&gt;raAngle)</span> &lt; <span class="delete">0.01)</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                                       text = StelUtils::radToHmsStrAdapt(d</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">-&gt;raAngle);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                               else</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                               {</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                                       const double delta = d-&gt;raAngle&lt;M_PI</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"> ? M_PI : -M_PI;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                                       text = StelUtils::radToHmsStrAdapt(d</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">-&gt;raAngle+delta);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                               }</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       }</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0015" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">               <span class="insert">if (std::fabs(2.0 * M_PI - lon) &lt; 0.01)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       // We are at meridian 0</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       lon = 0.0;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               const double delta = raAngle &lt; M_PI ? M_PI : -M_PI;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               double textAngle;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               if (std::fabs(lon - raAngle) &lt; 0.01)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       textAngle =</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               (d-&gt;frameType == StelCore::FrameGalactic) ? </span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">-raAngle + M_PI : raAngle;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               else if(d-&gt;frameType == StelCore::FrameAltAz)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       textAngle =</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               (std::fabs(raAngle - 2.0 * M_PI) &lt; 0.01) ? 0</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">.0 : raAngle + delta;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               else if(d-&gt;frameType == StelCore::FrameGalactic)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       textAngle = -raAngle - delta + M_PI;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               else</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       textAngle = raAngle + delta;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               text = altAzOrGalactic ? StelUtils::radToDmsStrAdapt(textAng</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">le)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                      : StelUtils::radToHmsStrAdapt(textAng</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">le);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       else</td><td> </td><td class="right">       else</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0016" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               text = d-&gt;text;</td><td> </td><td class="right">               text = d-&gt;text;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0017" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0018" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">double</span> angleDeg = <span class="delete">std::atan2(-direc[1], -direc[0])*180./M_PI;</span></td><td> </td><td class="rblock">       <span class="insert">float</span> angleDeg = <span class="insert">std::atan2(-direction[1], -direction[0]) * 180.0 / </span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       float <span class="delete">xshift=6.f;</span></td><td> </td><td class="rblock"><span class="insert">M_PI;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       if <span class="delete">(angleDeg&gt;90.</span> || <span class="delete">angleDeg&lt;-90.)</span></td><td> </td><td class="rblock">       float <span class="insert">xshift = 6.0f;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       {</td><td> </td><td class="rblock">       if <span class="insert">(angleDeg &gt; 90.0f</span> || <span class="insert">angleDeg &lt; -90.0f)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               <span class="delete">angleDeg+=180.;</span></td><td> </td><td class="rblock">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               xshift=-d-&gt;sPainter-&gt;getFontMetrics().width(text)-6.f;</span></td><td> </td><td class="rblock">               <span class="insert">angleDeg += 180.0f;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               xshift = -(d-&gt;fontMetrics.width(text)) - 6.0f;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0019" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">d-&gt;sPainter-&gt;drawText(screenPos[0],</span> screenPos[1], <span class="delete">text, angleDeg, xs</span></td><td> </td><td class="rblock">       <span class="insert">d-&gt;renderer-&gt;drawText(TextParams(screenPos[0],</span> screenPos[1], <span class="insert">text)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">hift, 3);</span></td><td> </td><td class="rblock"><span class="insert">                         .angleDegrees(angleDeg).shift(xshift, 3));</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       d-&gt;sPainter-&gt;setColor(tmpColor[0], tmpColor[1], tmpColor[2], tmpColo</span></td><td> </td><td class="rblock"><span class="insert">       d-&gt;renderer-&gt;setGlobalColor(d-&gt;skyLineColor);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">r[3]);</span></td><td> </td><td class="rblock"><span class="insert">       d-&gt;renderer-&gt;setBlendMode(BlendMode_Alpha);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       glDisable(GL_TEXTURE_2D);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! Draw the sky grid in the current frame</td><td> </td><td class="right">//! Draw the sky grid in the current frame</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0020" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">void SkyGrid::draw(const StelCore* core) const</td><td> </td><td class="rblock">void SkyGrid::draw(const StelCore* core<span class="insert">, StelRenderer* renderer</span>) const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0021" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       const StelProjectorP pr<span class="delete">j = core-&gt;getProjection(frameType, frameType!
=StelCore::FrameAltAz ? StelCore::RefractionAuto : StelCore::RefractionOff)
</span>;</td><td> </td><td class="rblock">       const StelProjectorP pr<span class="insert">ojector = core-&gt;getProjection(frameType, fram
eType!=StelCore::FrameAltAz ? StelCore::RefractionAuto : StelCore::Refracti
onOff)</span>;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (!fader.getInterstate())</td><td> </td><td class="right">       if (!fader.getInterstate())</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return;</td><td> </td><td class="right">               return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Look for all meridians and parallels intersecting with the disk b
ounding the viewport</td><td> </td><td class="right">       // Look for all meridians and parallels intersecting with the disk b
ounding the viewport</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Check whether the pole are in the viewport</td><td> </td><td class="right">       // Check whether the pole are in the viewport</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       bool northPoleInViewport = false;</td><td> </td><td class="right">       bool northPoleInViewport = false;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       bool southPoleInViewport = false;</td><td> </td><td class="right">       bool southPoleInViewport = false;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Vec3f win;</td><td> </td><td class="right">       Vec3f win;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0022" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       if (pr<span class="delete">j-&gt;project(Vec3f(0,0,1), win) &amp;&amp; prj-&gt;checkInViewp</span>ort(win))</td><td> </td><td class="rblock">       if (pr<span class="insert">ojector-&gt;project(Vec3f(0,0,1), win) &amp;&amp; projector-&gt;checkInViewp
</span>ort(win))</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               northPoleInViewport = true;</td><td> </td><td class="right">               northPoleInViewport = true;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0023" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       if (pr<span class="delete">j-&gt;project(Vec3f(0,0,-1), win) &amp;&amp; prj-&gt;checkInView</span>port(win))</td><td> </td><td class="rblock">       if (pr<span class="insert">ojector-&gt;project(Vec3f(0,0,-1), win) &amp;&amp; projector-&gt;checkInView
</span>port(win))</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               southPoleInViewport = true;</td><td> </td><td class="right">               southPoleInViewport = true;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Get the longitude and latitude resolution at the center of the vi
ewport</td><td> </td><td class="right">       // Get the longitude and latitude resolution at the center of the vi
ewport</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Vec3d centerV;</td><td> </td><td class="right">       Vec3d centerV;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0024" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       pr<span class="delete">j-&gt;unProject(prj-&gt;getViewportPosX()+prj-&gt;getViewportWidth()/2, prj
-&gt;getViewportPosY()+prj-&gt;getViewportHeight()/</span>2+1, centerV);</td><td> </td><td class="rblock">       pr<span class="insert">ojector-&gt;unProject(projector-&gt;getViewportPosX()+projector-&gt;getView
portWidth()/2, projector-&gt;getViewportPosY()+projector-&gt;getViewportHeight()/
</span>2+1, centerV);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       double lon2, lat2;</td><td> </td><td class="right">       double lon2, lat2;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       StelUtils::rectToSphe(&amp;lon2, &amp;lat2, centerV);</td><td> </td><td class="right">       StelUtils::rectToSphe(&amp;lon2, &amp;lat2, centerV);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0025" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       const double gridStepParallelRad = M_PI/180.*getClosestResolutionDMS
(pr<span class="delete">j</span>-&gt;getPixelPerRadAtCenter());</td><td> </td><td class="rblock">       const double gridStepParallelRad = M_PI/180.*getClosestResolutionDMS
(pr<span class="insert">ojector</span>-&gt;getPixelPerRadAtCenter());</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       double gridStepMeridianRad;</td><td> </td><td class="right">       double gridStepMeridianRad;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (northPoleInViewport || southPoleInViewport)</td><td> </td><td class="right">       if (northPoleInViewport || southPoleInViewport)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               gridStepMeridianRad = (frameType==StelCore::FrameAltAz || fr
ameType==StelCore::FrameGalactic) ? M_PI/180.* 10. : M_PI/180.* 15.;</td><td> </td><td class="right">               gridStepMeridianRad = (frameType==StelCore::FrameAltAz || fr
ameType==StelCore::FrameGalactic) ? M_PI/180.* 10. : M_PI/180.* 15.;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       else</td><td> </td><td class="right">       else</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0026" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               const double closetResLon = (frameType==StelCore::FrameAltAz
 || frameType==StelCore::FrameGalactic) ? getClosestResolutionDMS(pr<span class="delete">j-&gt;getP
ixelPerRadAtCenter()*std::cos(lat2)) : getClosestResolutionHMS(prj-&gt;getPixe
</span>lPerRadAtCenter()*std::cos(lat2));</td><td> </td><td class="rblock">               const double closetResLon = (frameType==StelCore::FrameAltAz
 || frameType==StelCore::FrameGalactic) ? getClosestResolutionDMS(pr<span class="insert">ojector
-&gt;getPixelPerRadAtCenter()*std::cos(lat2)) : getClosestResolutionHMS(projec
tor-&gt;getPixe</span>lPerRadAtCenter()*std::cos(lat2));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               gridStepMeridianRad = M_PI/180.* ((northPoleInViewport || so
uthPoleInViewport) ? 15. : closetResLon);</td><td> </td><td class="right">               gridStepMeridianRad = M_PI/180.* ((northPoleInViewport || so
uthPoleInViewport) ? 15. : closetResLon);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Get the bounding halfspace</td><td> </td><td class="right">       // Get the bounding halfspace</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0027" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       const SphericalCap&amp; viewPortSphericalCap = pr<span class="delete">j-&gt;getBoundingCap</span>();</td><td> </td><td class="rblock">       const SphericalCap&amp; viewPortSphericalCap = pr<span class="insert">ojector-&gt;getBoundingCap
</span>();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Compute the first grid starting point. This point is close to the
 center of the screen</td><td> </td><td class="right">       // Compute the first grid starting point. This point is close to the
 center of the screen</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // and lays at the intersection of a meridien and a parallel</td><td> </td><td class="right">       // and lays at the intersection of a meridien and a parallel</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       lon2 = gridStepMeridianRad*((int)(lon2/gridStepMeridianRad+0.5));</td><td> </td><td class="right">       lon2 = gridStepMeridianRad*((int)(lon2/gridStepMeridianRad+0.5));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       lat2 = gridStepParallelRad*((int)(lat2/gridStepParallelRad+0.5));</td><td> </td><td class="right">       lat2 = gridStepParallelRad*((int)(lat2/gridStepParallelRad+0.5));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Vec3d firstPoint;</td><td> </td><td class="right">       Vec3d firstPoint;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       StelUtils::spheToRect(lon2, lat2, firstPoint);</td><td> </td><td class="right">       StelUtils::spheToRect(lon2, lat2, firstPoint);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       firstPoint.normalize();</td><td> </td><td class="right">       firstPoint.normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Q_ASSERT(viewPortSphericalCap.contains(firstPoint));</td><td> </td><td class="right">       // Q_ASSERT(viewPortSphericalCap.contains(firstPoint));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0028" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       // <span class="delete">Initialize a painter and set openGL state</span></td><td> </td><td class="rblock">       // <span class="insert">Prepare for drawing</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       StelPainter sPainter(prj);</span></td><td> </td><td class="rblock"><span class="insert">       renderer-&gt;setBlendMode(BlendMode_Alpha);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       glEnable(GL_BLEND);</span></td><td> </td><td class="rblock">       Vec4f textColor(color[0], color[1], color[2], <span class="insert">0.0f);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); // Normal transpa</span></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">rency mode</span></td><td> </td><td class="rblock"><span class="insert">       Vec4f skyGridColor;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       Vec4f textColor(color[0], color[1], color[2], <span class="delete">0);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (StelApp::getInstance().getVisionModeNight())</td><td> </td><td class="right">       if (StelApp::getInstance().getVisionModeNight())</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               // instead of a filter which just zeros G&amp;B, set the red</td><td> </td><td class="right">               // instead of a filter which just zeros G&amp;B, set the red</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               // value to the mean brightness of RGB.</td><td> </td><td class="right">               // value to the mean brightness of RGB.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               float red = (color[0] + color[1] + color[2]) / 3.0;</td><td> </td><td class="right">               float red = (color[0] + color[1] + color[2]) / 3.0;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               textColor[0] = red;</td><td> </td><td class="right">               textColor[0] = red;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               textColor[1] = 0.; textColor[2] = 0.;</td><td> </td><td class="right">               textColor[1] = 0.; textColor[2] = 0.;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0029" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               s<span class="delete">Painter.setColor(red, 0, 0, fader.getInterstate())</span>;</td><td> </td><td class="rblock">               s<span class="insert">kyGridColor = Vec4f(red, 0.0f, 0.0f, fader.getInterstate())
</span>;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       else</td><td> </td><td class="right">       else</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0030" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               s<span class="delete">Painter.setColor(color[0],color[1],color[2], fader.getInter
</span>state());</td><td> </td><td class="rblock">               s<span class="insert">kyGridColor = Vec4f(color[0], color[1], color[2], fader.get
Inter</span>state());</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0031" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       renderer-&gt;setGlobalColor(skyGridColor);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0032" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">textColor*=2;</span></td><td> </td><td class="rblock">       <span class="insert">textColor *= 2;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       textColor[3]=fader.getInterstate();</span></td><td> </td><td class="rblock"><span class="insert">       textColor[3] = fader.getInterstate();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0033" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">sPainter.setFont(font);</span></td><td> </td><td class="rblock">       <span class="insert">renderer-&gt;setFont(font);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       ViewportEdgeIntersectCallbackData <span class="delete">userData(&amp;sPainter);</span></td><td> </td><td class="rblock">       ViewportEdgeIntersectCallbackData <span class="insert">userData =</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       userData.textColor = textColor;</td><td> </td><td class="rblock"><span class="insert">               ViewportEdgeIntersectCallbackData(QFontMetrics(font));</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       userData.frameType = frameType;</td><td> </td><td class="rblock"><span class="insert">       userData.renderer     = renderer;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       userData.projector    = projector;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       userData.textColor    = textColor;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       userData.frameType    = frameType;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">userData.skyLineColor = skyGridColor;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       /////////////////////////////////////////////////</td><td> </td><td class="right">       /////////////////////////////////////////////////</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Draw all the meridians (great circles)</td><td> </td><td class="right">       // Draw all the meridians (great circles)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       SphericalCap meridianSphericalCap(Vec3d(1,0,0), 0);</td><td> </td><td class="right">       SphericalCap meridianSphericalCap(Vec3d(1,0,0), 0);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Mat4d rotLon = Mat4d::zrotation(gridStepMeridianRad);</td><td> </td><td class="right">       Mat4d rotLon = Mat4d::zrotation(gridStepMeridianRad);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Vec3d fpt = firstPoint;</td><td> </td><td class="right">       Vec3d fpt = firstPoint;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Vec3d p1, p2;</td><td> </td><td class="right">       Vec3d p1, p2;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       int maxNbIter = (int)(M_PI/gridStepMeridianRad);</td><td> </td><td class="right">       int maxNbIter = (int)(M_PI/gridStepMeridianRad);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       int i;</td><td> </td><td class="right">       int i;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0034" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       StelCircleArcRenderer circleRenderer(renderer, projector);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       for (i=0; i&lt;maxNbIter; ++i)</td><td> </td><td class="right">       for (i=0; i&lt;maxNbIter; ++i)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               StelUtils::rectToSphe(&amp;lon2, &amp;lat2, fpt);</td><td> </td><td class="right">               StelUtils::rectToSphe(&amp;lon2, &amp;lat2, fpt);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               userData.raAngle = lon2;</td><td> </td><td class="right">               userData.raAngle = lon2;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               meridianSphericalCap.n = fpt^Vec3d(0,0,1);</td><td> </td><td class="right">               meridianSphericalCap.n = fpt^Vec3d(0,0,1);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               meridianSphericalCap.n.normalize();</td><td> </td><td class="right">               meridianSphericalCap.n.normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               if (!SphericalCap::intersectionPoints(viewPortSphericalCap, 
meridianSphericalCap, p1, p2))</td><td> </td><td class="right">               if (!SphericalCap::intersectionPoints(viewPortSphericalCap, 
meridianSphericalCap, p1, p2))</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       if (viewPortSphericalCap.d&lt;meridianSphericalCap.d &amp;&amp;
 viewPortSphericalCap.contains(meridianSphericalCap.n))</td><td> </td><td class="right">                       if (viewPortSphericalCap.d&lt;meridianSphericalCap.d &amp;&amp;
 viewPortSphericalCap.contains(meridianSphericalCap.n))</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       {</td><td> </td><td class="right">                       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               // The meridian is fully included in the vie
wport, draw it in 3 sub-arcs to avoid length &gt; 180.</td><td> </td><td class="right">                               // The meridian is fully included in the vie
wport, draw it in 3 sub-arcs to avoid length &gt; 180.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               const Mat4d&amp; rotLon120 = Mat4d::rotation(mer
idianSphericalCap.n, 120.*M_PI/180.);</td><td> </td><td class="right">                               const Mat4d&amp; rotLon120 = Mat4d::rotation(mer
idianSphericalCap.n, 120.*M_PI/180.);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               Vec3d rotFpt=fpt;</td><td> </td><td class="right">                               Vec3d rotFpt=fpt;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               rotFpt.transfo4d(rotLon120);</td><td> </td><td class="right">                               rotFpt.transfo4d(rotLon120);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               Vec3d rotFpt2=rotFpt;</td><td> </td><td class="right">                               Vec3d rotFpt2=rotFpt;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               rotFpt2.transfo4d(rotLon120);</td><td> </td><td class="right">                               rotFpt2.transfo4d(rotLon120);</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0035" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                               <span class="delete">sPainter.drawGreatCircleArc(fpt,</span> rotFpt, <span class="delete">NUL</span></td><td> </td><td class="rblock">                               <span class="insert">circleRenderer.drawGreatCircleArc</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">L, viewportEdgeIntersectCallback,</span> &amp;userData);</td><td> </td><td class="rblock"><span class="insert">                                       (fpt,</span> rotFpt, <span class="insert">NULL, viewportEdgeInte</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                               <span class="delete">sPainter.drawGreatCircleArc(rotFpt,</span> rotFpt2,</td><td> </td><td class="rblock"><span class="insert">rsectCallback,</span> &amp;userData);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"> NULL, <span class="delete">viewportEdgeIntersectCallback,</span> &amp;userData);</td><td> </td><td class="rblock">                               <span class="insert">circleRenderer.drawGreatCircleArc</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                               <span class="delete">sPainter.drawGreatCircleArc(rotFpt2,</span> fpt, <span class="delete">NU</span></td><td> </td><td class="rblock"><span class="insert">                                       (rotFpt,</span> rotFpt2, NULL, <span class="insert">viewportEdge</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">LL, viewportEdgeIntersectCallback,</span> &amp;userData);</td><td> </td><td class="rblock"><span class="insert">IntersectCallback,</span> &amp;userData);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                               <span class="insert">circleRenderer.drawGreatCircleArc</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                       (rotFpt2,</span> fpt, <span class="insert">NULL, viewportEdgeInt</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ersectCallback,</span> &amp;userData);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               fpt.transfo4d(rotLon);</td><td> </td><td class="right">                               fpt.transfo4d(rotLon);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               continue;</td><td> </td><td class="right">                               continue;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       }</td><td> </td><td class="right">                       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       else</td><td> </td><td class="right">                       else</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               break;</td><td> </td><td class="right">                               break;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               Vec3d middlePoint = p1+p2;</td><td> </td><td class="right">               Vec3d middlePoint = p1+p2;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               middlePoint.normalize();</td><td> </td><td class="right">               middlePoint.normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               if (!viewPortSphericalCap.contains(middlePoint))</td><td> </td><td class="right">               if (!viewPortSphericalCap.contains(middlePoint))</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       middlePoint*=-1.;</td><td> </td><td class="right">                       middlePoint*=-1.;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               // Draw the arc in 2 sub-arcs to avoid lengths &gt; 180 deg</td><td> </td><td class="right">               // Draw the arc in 2 sub-arcs to avoid lengths &gt; 180 deg</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0036" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               <span class="delete">sPainter.drawGreatCircleArc(p1,</span> middlePoint, NULL, <span class="delete">viewportE</span></td><td> </td><td class="rblock">               <span class="insert">circleRenderer.drawGreatCircleArc</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">dgeIntersectCallback,</span> &amp;userData);</td><td> </td><td class="rblock"><span class="insert">                       (p1,</span> middlePoint, NULL, <span class="insert">viewportEdgeIntersectCallbac</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               <span class="delete">sPainter.drawGreatCircleArc(p2,</span> middlePoint, NULL, <span class="delete">viewportE</span></td><td> </td><td class="rblock"><span class="insert">k,</span> &amp;userData);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">dgeIntersectCallback,</span> &amp;userData);</td><td> </td><td class="rblock">               <span class="insert">circleRenderer.drawGreatCircleArc</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       (p2,</span> middlePoint, NULL, <span class="insert">viewportEdgeIntersectCallbac</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">k,</span> &amp;userData);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               fpt.transfo4d(rotLon);</td><td> </td><td class="right">               fpt.transfo4d(rotLon);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (i!=maxNbIter)</td><td> </td><td class="right">       if (i!=maxNbIter)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               rotLon = Mat4d::zrotation(-gridStepMeridianRad);</td><td> </td><td class="right">               rotLon = Mat4d::zrotation(-gridStepMeridianRad);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               fpt = firstPoint;</td><td> </td><td class="right">               fpt = firstPoint;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               fpt.transfo4d(rotLon);</td><td> </td><td class="right">               fpt.transfo4d(rotLon);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               for (int j=0; j&lt;maxNbIter-i; ++j)</td><td> </td><td class="right">               for (int j=0; j&lt;maxNbIter-i; ++j)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l4" /><small>skipping to change at</small><em> line 402</em></th><th> </th><th><a name="part-r4" /><small>skipping to change at</small><em> line 408</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       meridianSphericalCap.n = fpt^Vec3d(0,0,1);</td><td> </td><td class="right">                       meridianSphericalCap.n = fpt^Vec3d(0,0,1);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       meridianSphericalCap.n.normalize();</td><td> </td><td class="right">                       meridianSphericalCap.n.normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       if (!SphericalCap::intersectionPoints(viewPortSpheri
calCap, meridianSphericalCap, p1, p2))</td><td> </td><td class="right">                       if (!SphericalCap::intersectionPoints(viewPortSpheri
calCap, meridianSphericalCap, p1, p2))</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               break;</td><td> </td><td class="right">                               break;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       Vec3d middlePoint = p1+p2;</td><td> </td><td class="right">                       Vec3d middlePoint = p1+p2;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       middlePoint.normalize();</td><td> </td><td class="right">                       middlePoint.normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       if (!viewPortSphericalCap.contains(middlePoint))</td><td> </td><td class="right">                       if (!viewPortSphericalCap.contains(middlePoint))</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               middlePoint*=-1;</td><td> </td><td class="right">                               middlePoint*=-1;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0037" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       <span class="delete">sPainter.drawGreatCircleArc(p1,</span> middlePoint, NULL, <span class="delete">v</span></td><td> </td><td class="rblock">                       <span class="insert">circleRenderer.drawGreatCircleArc</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">iewportEdgeIntersectCallback,</span> &amp;userData);</td><td> </td><td class="rblock"><span class="insert">                               (p1,</span> middlePoint, NULL, <span class="insert">viewportEdgeIntersec</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       <span class="delete">sPainter.drawGreatCircleArc(p2,</span> middlePoint, NULL, <span class="delete">v</span></td><td> </td><td class="rblock"><span class="insert">tCallback,</span> &amp;userData);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">iewportEdgeIntersectCallback,</span> &amp;userData);</td><td> </td><td class="rblock">                       <span class="insert">circleRenderer.drawGreatCircleArc</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               (p2,</span> middlePoint, NULL, <span class="insert">viewportEdgeIntersec</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">tCallback,</span> &amp;userData);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       fpt.transfo4d(rotLon);</td><td> </td><td class="right">                       fpt.transfo4d(rotLon);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       /////////////////////////////////////////////////</td><td> </td><td class="right">       /////////////////////////////////////////////////</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Draw all the parallels (small circles)</td><td> </td><td class="right">       // Draw all the parallels (small circles)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       SphericalCap parallelSphericalCap(Vec3d(0,0,1), 0);</td><td> </td><td class="right">       SphericalCap parallelSphericalCap(Vec3d(0,0,1), 0);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       rotLon = Mat4d::rotation(firstPoint^Vec3d(0,0,1), gridStepParallelRa
d);</td><td> </td><td class="right">       rotLon = Mat4d::rotation(firstPoint^Vec3d(0,0,1), gridStepParallelRa
d);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       fpt = firstPoint;</td><td> </td><td class="right">       fpt = firstPoint;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l5" /><small>skipping to change at</small><em> line 425</em></th><th> </th><th><a name="part-r5" /><small>skipping to change at</small><em> line 433</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       for (i=0; i&lt;maxNbIter; ++i)</td><td> </td><td class="right">       for (i=0; i&lt;maxNbIter; ++i)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               StelUtils::rectToSphe(&amp;lon2, &amp;lat2, fpt);</td><td> </td><td class="right">               StelUtils::rectToSphe(&amp;lon2, &amp;lat2, fpt);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               userData.text = StelUtils::radToDmsStrAdapt(lat2);</td><td> </td><td class="right">               userData.text = StelUtils::radToDmsStrAdapt(lat2);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               parallelSphericalCap.d = fpt[2];</td><td> </td><td class="right">               parallelSphericalCap.d = fpt[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               if (parallelSphericalCap.d&gt;0.9999999)</td><td> </td><td class="right">               if (parallelSphericalCap.d&gt;0.9999999)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       break;</td><td> </td><td class="right">                       break;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               const Vec3d rotCenter(0,0,parallelSphericalCap.d);</td><td> </td><td class="right">               const Vec3d rotCenter(0,0,parallelSphericalCap.d);</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0038" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">               <span class="insert">circleRenderer.setRotCenter(rotCenter);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               if (!SphericalCap::intersectionPoints(viewPortSphericalCap, 
parallelSphericalCap, p1, p2))</td><td> </td><td class="right">               if (!SphericalCap::intersectionPoints(viewPortSphericalCap, 
parallelSphericalCap, p1, p2))</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       if ((viewPortSphericalCap.d&lt;parallelSphericalCap.d &amp;
&amp; viewPortSphericalCap.contains(parallelSphericalCap.n))</td><td> </td><td class="right">                       if ((viewPortSphericalCap.d&lt;parallelSphericalCap.d &amp;
&amp; viewPortSphericalCap.contains(parallelSphericalCap.n))</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               || (viewPortSphericalCap.d&lt;-parallelSpherica
lCap.d &amp;&amp; viewPortSphericalCap.contains(-parallelSphericalCap.n)))</td><td> </td><td class="right">                               || (viewPortSphericalCap.d&lt;-parallelSpherica
lCap.d &amp;&amp; viewPortSphericalCap.contains(-parallelSphericalCap.n)))</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       {</td><td> </td><td class="right">                       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               // The parallel is fully included in the vie
wport, draw it in 3 sub-arcs to avoid lengths &gt;= 180 deg</td><td> </td><td class="right">                               // The parallel is fully included in the vie
wport, draw it in 3 sub-arcs to avoid lengths &gt;= 180 deg</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               static const Mat4d rotLon120 = Mat4d::zrotat
ion(120.*M_PI/180.);</td><td> </td><td class="right">                               static const Mat4d rotLon120 = Mat4d::zrotat
ion(120.*M_PI/180.);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               Vec3d rotFpt=fpt;</td><td> </td><td class="right">                               Vec3d rotFpt=fpt;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               rotFpt.transfo4d(rotLon120);</td><td> </td><td class="right">                               rotFpt.transfo4d(rotLon120);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               Vec3d rotFpt2=rotFpt;</td><td> </td><td class="right">                               Vec3d rotFpt2=rotFpt;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               rotFpt2.transfo4d(rotLon120);</td><td> </td><td class="right">                               rotFpt2.transfo4d(rotLon120);</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0039" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                               <span class="delete">sPainter.drawSmallCircleArc(fpt,</span> rotFpt, <span class="delete">rot</span></td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">Center, viewportEdgeIntersectCallback,</span> &amp;userData);</td><td> </td><td class="rblock">                               <span class="insert">circleRenderer.drawSmallCircleArc</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                               <span class="delete">sPainter.drawSmallCircleArc(rotFpt,</span> rotFpt2,</td><td> </td><td class="rblock"><span class="insert">                                       (fpt,</span> rotFpt, <span class="insert">viewportEdgeIntersectC</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"> <span class="delete">rotCenter, viewportEdgeIntersectCallback,</span> &amp;userData);</td><td> </td><td class="rblock"><span class="insert">allback,</span> &amp;userData);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                               <span class="delete">sPainter.drawSmallCircleArc(rotFpt2,</span> fpt, <span class="delete">ro</span></td><td> </td><td class="rblock">                               <span class="insert">circleRenderer.drawSmallCircleArc</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">tCenter, viewportEdgeIntersectCallback,</span> &amp;userData);</td><td> </td><td class="rblock"><span class="insert">                                       (rotFpt,</span> rotFpt2, <span class="insert">viewportEdgeInters</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ectCallback,</span> &amp;userData);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                               <span class="insert">circleRenderer.drawSmallCircleArc</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                       (rotFpt2,</span> fpt, <span class="insert">viewportEdgeIntersect</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">Callback,</span> &amp;userData);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               fpt.transfo4d(rotLon);</td><td> </td><td class="right">                               fpt.transfo4d(rotLon);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               continue;</td><td> </td><td class="right">                               continue;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       }</td><td> </td><td class="right">                       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       else</td><td> </td><td class="right">                       else</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               break;</td><td> </td><td class="right">                               break;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               // Draw the arc in 2 sub-arcs to avoid lengths &gt; 180 deg</td><td> </td><td class="right">               // Draw the arc in 2 sub-arcs to avoid lengths &gt; 180 deg</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               Vec3d middlePoint = p1-rotCenter+p2-rotCenter;</td><td> </td><td class="right">               Vec3d middlePoint = p1-rotCenter+p2-rotCenter;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               middlePoint.normalize();</td><td> </td><td class="right">               middlePoint.normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               middlePoint*=(p1-rotCenter).length();</td><td> </td><td class="right">               middlePoint*=(p1-rotCenter).length();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               middlePoint+=rotCenter;</td><td> </td><td class="right">               middlePoint+=rotCenter;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               if (!viewPortSphericalCap.contains(middlePoint))</td><td> </td><td class="right">               if (!viewPortSphericalCap.contains(middlePoint))</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       middlePoint-=rotCenter;</td><td> </td><td class="right">                       middlePoint-=rotCenter;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       middlePoint*=-1.;</td><td> </td><td class="right">                       middlePoint*=-1.;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       middlePoint+=rotCenter;</td><td> </td><td class="right">                       middlePoint+=rotCenter;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0040" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               <span class="delete">sPainter.drawSmallCircleArc(p1,</span> middlePoint, <span class="delete">rotCenter, view</span></td><td> </td><td class="rblock">               <span class="insert">circleRenderer.drawSmallCircleArc</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">portEdgeIntersectCallback, &amp;userData);</span></td><td> </td><td class="rblock"><span class="insert">                       (p1,</span> middlePoint, <span class="insert">viewportEdgeIntersectCallback, &amp;us</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               sPainter.drawSmallCircleArc(p2,</span> middlePoint, <span class="delete">rotCenter, view</span></td><td> </td><td class="rblock"><span class="insert">erData);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">portEdgeIntersectCallback, &amp;userData);</span></td><td> </td><td class="rblock"><span class="insert">               circleRenderer.drawSmallCircleArc</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       (p2,</span> middlePoint, <span class="insert">viewportEdgeIntersectCallback, &amp;us</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">erData);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               fpt.transfo4d(rotLon);</td><td> </td><td class="right">               fpt.transfo4d(rotLon);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (i!=maxNbIter)</td><td> </td><td class="right">       if (i!=maxNbIter)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               rotLon = Mat4d::rotation(firstPoint^Vec3d(0,0,1), -gridStepP
arallelRad);</td><td> </td><td class="right">               rotLon = Mat4d::rotation(firstPoint^Vec3d(0,0,1), -gridStepP
arallelRad);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               fpt = firstPoint;</td><td> </td><td class="right">               fpt = firstPoint;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               fpt.transfo4d(rotLon);</td><td> </td><td class="right">               fpt.transfo4d(rotLon);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               for (int j=0; j&lt;maxNbIter-i; ++j)</td><td> </td><td class="right">               for (int j=0; j&lt;maxNbIter-i; ++j)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       StelUtils::rectToSphe(&amp;lon2, &amp;lat2, fpt);</td><td> </td><td class="right">                       StelUtils::rectToSphe(&amp;lon2, &amp;lat2, fpt);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       userData.text = StelUtils::radToDmsStrAdapt(lat2);</td><td> </td><td class="right">                       userData.text = StelUtils::radToDmsStrAdapt(lat2);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       parallelSphericalCap.d = fpt[2];</td><td> </td><td class="right">                       parallelSphericalCap.d = fpt[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       const Vec3d rotCenter(0,0,parallelSphericalCap.d);</td><td> </td><td class="right">                       const Vec3d rotCenter(0,0,parallelSphericalCap.d);</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0041" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       circleRenderer.setRotCenter(rotCenter);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       if (!SphericalCap::intersectionPoints(viewPortSpheri
calCap, parallelSphericalCap, p1, p2))</td><td> </td><td class="right">                       if (!SphericalCap::intersectionPoints(viewPortSpheri
calCap, parallelSphericalCap, p1, p2))</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       {</td><td> </td><td class="right">                       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               if ((viewPortSphericalCap.d&lt;parallelSpherica
lCap.d &amp;&amp; viewPortSphericalCap.contains(parallelSphericalCap.n))</td><td> </td><td class="right">                               if ((viewPortSphericalCap.d&lt;parallelSpherica
lCap.d &amp;&amp; viewPortSphericalCap.contains(parallelSphericalCap.n))</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                                        || (viewPortSphericalCap.d&lt;-paralle
lSphericalCap.d &amp;&amp; viewPortSphericalCap.contains(-parallelSphericalCap.n)))</td><td> </td><td class="right">                                        || (viewPortSphericalCap.d&lt;-paralle
lSphericalCap.d &amp;&amp; viewPortSphericalCap.contains(-parallelSphericalCap.n)))</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               {</td><td> </td><td class="right">                               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                                       // The parallel is fully included in
 the viewport, draw it in 3 sub-arcs to avoid lengths &gt;= 180 deg</td><td> </td><td class="right">                                       // The parallel is fully included in
 the viewport, draw it in 3 sub-arcs to avoid lengths &gt;= 180 deg</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                                       static const Mat4d rotLon120 = Mat4d
::zrotation(120.*M_PI/180.);</td><td> </td><td class="right">                                       static const Mat4d rotLon120 = Mat4d
::zrotation(120.*M_PI/180.);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                                       Vec3d rotFpt=fpt;</td><td> </td><td class="right">                                       Vec3d rotFpt=fpt;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                                       rotFpt.transfo4d(rotLon120);</td><td> </td><td class="right">                                       rotFpt.transfo4d(rotLon120);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                                       Vec3d rotFpt2=rotFpt;</td><td> </td><td class="right">                                       Vec3d rotFpt2=rotFpt;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                                       rotFpt2.transfo4d(rotLon120);</td><td> </td><td class="right">                                       rotFpt2.transfo4d(rotLon120);</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0042" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                       <span class="delete">sPainter.drawSmallCircleArc(fpt, rot</span></td><td> </td><td class="rblock">                                       <span class="insert">circleRenderer.drawSmallCircleArc</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">Fpt, rotCenter, viewportEdgeIntersectCallback,</span> &amp;userData);</td><td> </td><td class="rblock"><span class="insert">                                               (fpt, rotFpt, viewportEdgeIn</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                       <span class="delete">sPainter.drawSmallCircleArc(rotFpt,</span> </td><td> </td><td class="rblock"><span class="insert">tersectCallback,</span> &amp;userData);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">rotFpt2, <span class="delete">rotCenter, viewportEdgeIntersectCallback,</span> &amp;userData);</td><td> </td><td class="rblock">                                       <span class="insert">circleRenderer.drawSmallCircleArc</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                       <span class="delete">sPainter.drawSmallCircleArc(rotFpt2,</span></td><td> </td><td class="rblock"><span class="insert">                                               (rotFpt,</span> rotFpt2, <span class="insert">viewportEd</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"> fpt, <span class="delete">rotCenter, viewportEdgeIntersectCallback,</span> &amp;userData);</td><td> </td><td class="rblock"><span class="insert">geIntersectCallback,</span> &amp;userData);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                                       <span class="insert">circleRenderer.drawSmallCircleArc</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                               (rotFpt2,</span> fpt, <span class="insert">viewportEdgeI</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ntersectCallback,</span> &amp;userData);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                                       fpt.transfo4d(rotLon);</td><td> </td><td class="right">                                       fpt.transfo4d(rotLon);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                                       continue;</td><td> </td><td class="right">                                       continue;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               }</td><td> </td><td class="right">                               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               else</td><td> </td><td class="right">                               else</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                                       break;</td><td> </td><td class="right">                                       break;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       }</td><td> </td><td class="right">                       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       // Draw the arc in 2 sub-arcs to avoid lengths &gt; 180
 deg</td><td> </td><td class="right">                       // Draw the arc in 2 sub-arcs to avoid lengths &gt; 180
 deg</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       Vec3d middlePoint = p1-rotCenter+p2-rotCenter;</td><td> </td><td class="right">                       Vec3d middlePoint = p1-rotCenter+p2-rotCenter;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       middlePoint.normalize();</td><td> </td><td class="right">                       middlePoint.normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       middlePoint*=(p1-rotCenter).length();</td><td> </td><td class="right">                       middlePoint*=(p1-rotCenter).length();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       middlePoint+=rotCenter;</td><td> </td><td class="right">                       middlePoint+=rotCenter;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       if (!viewPortSphericalCap.contains(middlePoint))</td><td> </td><td class="right">                       if (!viewPortSphericalCap.contains(middlePoint))</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       {</td><td> </td><td class="right">                       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               middlePoint-=rotCenter;</td><td> </td><td class="right">                               middlePoint-=rotCenter;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               middlePoint*=-1.;</td><td> </td><td class="right">                               middlePoint*=-1.;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               middlePoint+=rotCenter;</td><td> </td><td class="right">                               middlePoint+=rotCenter;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       }</td><td> </td><td class="right">                       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0043" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       <span class="delete">sPainter.drawSmallCircleArc(p1,</span> middlePoint, <span class="delete">rotCent</span></td><td> </td><td class="rblock">                       <span class="insert">circleRenderer.drawSmallCircleArc</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">er, viewportEdgeIntersectCallback,</span> &amp;userData);</td><td> </td><td class="rblock"><span class="insert">                               (p1,</span> middlePoint, <span class="insert">viewportEdgeIntersectCallb</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       <span class="delete">sPainter.drawSmallCircleArc(p2,</span> middlePoint, <span class="delete">rotCent</span></td><td> </td><td class="rblock"><span class="insert">ack,</span> &amp;userData);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">er, viewportEdgeIntersectCallback,</span> &amp;userData);</td><td> </td><td class="rblock">                       <span class="insert">circleRenderer.drawSmallCircleArc</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               (p2,</span> middlePoint, <span class="insert">viewportEdgeIntersectCallb</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ack,</span> &amp;userData);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       fpt.transfo4d(rotLon);</td><td> </td><td class="right">                       fpt.transfo4d(rotLon);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">SkyLine::SkyLine(SKY_LINE_TYPE _line_type) : color(0.f, 0.f, 1.f)</td><td> </td><td class="right">SkyLine::SkyLine(SKY_LINE_TYPE _line_type) : color(0.f, 0.f, 1.f)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       font.setPixelSize(14);</td><td> </td><td class="right">       font.setPixelSize(14);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       line_type = _line_type;</td><td> </td><td class="right">       line_type = _line_type;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l6" /><small>skipping to change at</small><em> line 561</em></th><th> </th><th><a name="part-r6" /><small>skipping to change at</small><em> line 583</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       frameType = StelCore::FrameAltAz;</td><td> </td><td class="right">                       frameType = StelCore::FrameAltAz;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       label = q_("Horizon");</td><td> </td><td class="right">                       label = q_("Horizon");</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       break;</td><td> </td><td class="right">                       break;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               case GALACTICPLANE:</td><td> </td><td class="right">               case GALACTICPLANE:</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       frameType = StelCore::FrameGalactic;</td><td> </td><td class="right">                       frameType = StelCore::FrameGalactic;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       label = q_("Galactic Plane");</td><td> </td><td class="right">                       label = q_("Galactic Plane");</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       break;</td><td> </td><td class="right">                       break;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0044" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">void SkyLine::draw(StelCore *core) const</td><td> </td><td class="rblock">void SkyLine::draw(StelCore *core<span class="insert">, StelRenderer* renderer</span>) const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (!fader.getInterstate())</td><td> </td><td class="right">       if (!fader.getInterstate())</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return;</td><td> </td><td class="right">               return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0045" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       StelProjectorP pr<span class="delete">j = core-&gt;getProjection(frameType, frameType!=StelC
ore::FrameAltAz ? StelCore::RefractionAuto : StelCore::RefractionOff)</span>;</td><td> </td><td class="rblock">       StelProjectorP pr<span class="insert">ojector = core-&gt;getProjection(frameType, frameType!
=StelCore::FrameAltAz ? StelCore::RefractionAuto : StelCore::RefractionOff)
</span>;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Get the bounding halfspace</td><td> </td><td class="right">       // Get the bounding halfspace</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0046" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       const SphericalCap&amp; viewPortSphericalCap = <span class="delete">prj-&gt;getBoundingCap();</span></td><td> </td><td class="rblock">       const SphericalCap&amp; viewPortSphericalCap = <span class="insert">projector-&gt;getBoundingCap</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       Vec4f textColor, skyLineColor;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       if (StelApp::getInstance().getVisionModeNight())</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               // instead of a filter which just zeros G&amp;B, set the red</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               // value to the mean brightness of RGB.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               float red = (color[0] + color[1] + color[2]) / 3.0;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               textColor = Vec4f(red, 0.0f, 0.0f, 0.0f);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               skyLineColor = Vec4f(red, 0.0f, 0.0f, fader.getInterstate())</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       else</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               skyLineColor = Vec4f(color[0], color[1], color[2], fader.get</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">Interstate());</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               textColor = Vec4f(color[0], color[1], color[2], 0.0f);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       renderer-&gt;setGlobalColor(skyLineColor);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       renderer-&gt;setBlendMode(BlendMode_Alpha);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       textColor *= 2;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       textColor[3] = fader.getInterstate();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       renderer-&gt;setFont(font);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       ViewportEdgeIntersectCallbackData userData =</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               ViewportEdgeIntersectCallbackData(QFontMetrics(font));</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       userData.renderer     = renderer;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       userData.projector    = projector;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       userData.textColor    = textColor;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       userData.skyLineColor = skyLineColor;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       userData.text         = label;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0047" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">// Initialize a painter and set openGL state</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       StelPainter sPainter(prj);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       sPainter.setColor(color[0], color[1], color[2], fader.getInterstate(</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">));</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       glEnable(GL_BLEND);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); // Normal transpa</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">rency mode</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       Vec4f textColor(color[0], color[1], color[2], 0);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       textColor*=2;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       textColor[3]=fader.getInterstate();</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       ViewportEdgeIntersectCallbackData userData(&amp;sPainter);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       sPainter.setFont(font);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       userData.textColor = textColor;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       userData.text = label;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       /////////////////////////////////////////////////</td><td> </td><td class="right">       /////////////////////////////////////////////////</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Draw the line</td><td> </td><td class="right">       // Draw the line</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       SphericalCap meridianSphericalCap(Vec3d(0,0,1), 0);</td><td> </td><td class="right">       SphericalCap meridianSphericalCap(Vec3d(0,0,1), 0);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Vec3d fpt(1,0,0);</td><td> </td><td class="right">       Vec3d fpt(1,0,0);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (line_type==MERIDIAN)</td><td> </td><td class="right">       if (line_type==MERIDIAN)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               meridianSphericalCap.n.set(0,1,0);</td><td> </td><td class="right">               meridianSphericalCap.n.set(0,1,0);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0048" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       StelCircleArcRenderer circleRenderer(renderer, projector);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Vec3d p1, p2;</td><td> </td><td class="right">       Vec3d p1, p2;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (!SphericalCap::intersectionPoints(viewPortSphericalCap, meridian
SphericalCap, p1, p2))</td><td> </td><td class="right">       if (!SphericalCap::intersectionPoints(viewPortSphericalCap, meridian
SphericalCap, p1, p2))</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               if ((viewPortSphericalCap.d&lt;meridianSphericalCap.d &amp;&amp; viewPo
rtSphericalCap.contains(meridianSphericalCap.n))</td><td> </td><td class="right">               if ((viewPortSphericalCap.d&lt;meridianSphericalCap.d &amp;&amp; viewPo
rtSphericalCap.contains(meridianSphericalCap.n))</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       || (viewPortSphericalCap.d&lt;-meridianSphericalCap.d &amp;
&amp; viewPortSphericalCap.contains(-meridianSphericalCap.n)))</td><td> </td><td class="right">                       || (viewPortSphericalCap.d&lt;-meridianSphericalCap.d &amp;
&amp; viewPortSphericalCap.contains(-meridianSphericalCap.n)))</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       // The meridian is fully included in the viewport, d
raw it in 3 sub-arcs to avoid length &gt; 180.</td><td> </td><td class="right">                       // The meridian is fully included in the viewport, d
raw it in 3 sub-arcs to avoid length &gt; 180.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       const Mat4d&amp; rotLon120 = Mat4d::rotation(meridianSph
ericalCap.n, 120.*M_PI/180.);</td><td> </td><td class="right">                       const Mat4d&amp; rotLon120 = Mat4d::rotation(meridianSph
ericalCap.n, 120.*M_PI/180.);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       Vec3d rotFpt=fpt;</td><td> </td><td class="right">                       Vec3d rotFpt=fpt;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       rotFpt.transfo4d(rotLon120);</td><td> </td><td class="right">                       rotFpt.transfo4d(rotLon120);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       Vec3d rotFpt2=rotFpt;</td><td> </td><td class="right">                       Vec3d rotFpt2=rotFpt;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       rotFpt2.transfo4d(rotLon120);</td><td> </td><td class="right">                       rotFpt2.transfo4d(rotLon120);</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0049" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       <span class="delete">sPainter.drawGreatCircleArc(fpt,</span> rotFpt, NULL, <span class="delete">viewp</span></td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">ortEdgeIntersectCallback,</span> &amp;userData);</td><td> </td><td class="rblock">                       <span class="insert">circleRenderer.drawGreatCircleArc</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       <span class="delete">sPainter.drawGreatCircleArc(rotFpt,</span> rotFpt2, NULL, <span class="delete">v</span></td><td> </td><td class="rblock"><span class="insert">                               (fpt,</span> rotFpt, NULL, <span class="insert">viewportEdgeIntersectCal</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">iewportEdgeIntersectCallback,</span> &amp;userData);</td><td> </td><td class="rblock"><span class="insert">lback,</span> &amp;userData);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       <span class="delete">sPainter.drawGreatCircleArc(rotFpt2,</span> fpt, NULL, <span class="delete">view</span></td><td> </td><td class="rblock">                       <span class="insert">circleRenderer.drawGreatCircleArc</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">portEdgeIntersectCallback,</span> &amp;userData);</td><td> </td><td class="rblock"><span class="insert">                               (rotFpt,</span> rotFpt2, NULL, <span class="insert">viewportEdgeIntersec</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       <span class="delete">return;</span></td><td> </td><td class="rblock"><span class="insert">tCallback,</span> &amp;userData);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                       <span class="insert">circleRenderer.drawGreatCircleArc</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               (rotFpt2,</span> fpt, NULL, <span class="insert">viewportEdgeIntersectCa</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">llback,</span> &amp;userData);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0050" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               <span class="delete">else</span></td><td> </td><td class="rblock">               return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       return;</td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Vec3d middlePoint = p1+p2;</td><td> </td><td class="right">       Vec3d middlePoint = p1+p2;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       middlePoint.normalize();</td><td> </td><td class="right">       middlePoint.normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (!viewPortSphericalCap.contains(middlePoint))</td><td> </td><td class="right">       if (!viewPortSphericalCap.contains(middlePoint))</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               middlePoint*=-1.;</td><td> </td><td class="right">               middlePoint*=-1.;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Draw the arc in 2 sub-arcs to avoid lengths &gt; 180 deg</td><td> </td><td class="right">       // Draw the arc in 2 sub-arcs to avoid lengths &gt; 180 deg</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0051" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">sPainter.drawGreatCircleArc(p1,</span> middlePoint, NULL, <span class="delete">viewportEdgeInter</span></td><td> </td><td class="rblock">       <span class="insert">circleRenderer.drawGreatCircleArc</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">sectCallback, &amp;userData);</span></td><td> </td><td class="rblock"><span class="insert">               (p1,</span> middlePoint, NULL, <span class="insert">viewportEdgeIntersectCallback, &amp;user</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       sPainter.drawGreatCircleArc(p2,</span> middlePoint, NULL, <span class="delete">viewportEdgeInter</span></td><td> </td><td class="rblock"><span class="insert">Data);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">sectCallback, &amp;userData);</span></td><td> </td><td class="rblock"><span class="insert">       circleRenderer.drawGreatCircleArc</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               (p2,</span> middlePoint, NULL, <span class="insert">viewportEdgeIntersectCallback, &amp;user</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">Data);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//     // Johannes: use a big radius as a dirty workaround for the bug that
 the</td><td> </td><td class="right">//     // Johannes: use a big radius as a dirty workaround for the bug that
 the</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//     // ecliptic line is not drawn around the observer, but around the su
n:</td><td> </td><td class="right">//     // ecliptic line is not drawn around the observer, but around the su
n:</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//     const Vec3d vv(1000000,0,0);</td><td> </td><td class="right">//     const Vec3d vv(1000000,0,0);</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0052" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                                                                           </span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">GridLinesMgr::GridLinesMgr()</td><td> </td><td class="right">GridLinesMgr::GridLinesMgr()</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       setObjectName("GridLinesMgr");</td><td> </td><td class="right">       setObjectName("GridLinesMgr");</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0053" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       equGrid = new SkyGrid(StelCore::FrameEquinoxEqu);</td><td> </td><td class="rblock">       equGrid           = new SkyGrid(StelCore::FrameEquinoxEqu);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       equJ2000Grid = new SkyGrid(StelCore::FrameJ2000);</td><td> </td><td class="rblock">       equJ2000Grid      = new SkyGrid(StelCore::FrameJ2000);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       eclJ2000Grid = new <span class="delete">SkyGrid(StelCore::FrameObservercentricEcliptic);</span></td><td> </td><td class="rblock">       eclJ2000Grid      = new <span class="insert">SkyGrid(StelCore::FrameObservercentricEclipt</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       galacticGrid = new SkyGrid(StelCore::FrameGalactic);</td><td> </td><td class="rblock"><span class="insert">ic);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       aziGrid = new SkyGrid(StelCore::FrameAltAz);</td><td> </td><td class="rblock">       galacticGrid      = new SkyGrid(StelCore::FrameGalactic);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       equatorLine = new SkyLine(SkyLine::EQUATOR);</td><td> </td><td class="rblock">       aziGrid           = new SkyGrid(StelCore::FrameAltAz);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       eclipticLine = new SkyLine(SkyLine::ECLIPTIC);</td><td> </td><td class="rblock">       equatorLine       = new SkyLine(SkyLine::EQUATOR);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       meridianLine = new SkyLine(SkyLine::MERIDIAN);</td><td> </td><td class="rblock">       eclipticLine      = new SkyLine(SkyLine::ECLIPTIC);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       horizonLine = new SkyLine(SkyLine::HORIZON);</td><td> </td><td class="rblock">       meridianLine      = new SkyLine(SkyLine::MERIDIAN);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       horizonLine       = new SkyLine(SkyLine::HORIZON);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       galacticPlaneLine = new SkyLine(SkyLine::GALACTICPLANE);</td><td> </td><td class="right">       galacticPlaneLine = new SkyLine(SkyLine::GALACTICPLANE);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">GridLinesMgr::~GridLinesMgr()</td><td> </td><td class="right">GridLinesMgr::~GridLinesMgr()</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       delete equGrid;</td><td> </td><td class="right">       delete equGrid;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       delete equJ2000Grid;</td><td> </td><td class="right">       delete equJ2000Grid;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       delete eclJ2000Grid;</td><td> </td><td class="right">       delete eclJ2000Grid;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       delete galacticGrid;</td><td> </td><td class="right">       delete galacticGrid;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       delete aziGrid;</td><td> </td><td class="right">       delete aziGrid;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l7" /><small>skipping to change at</small><em> line 705</em></th><th> </th><th><a name="part-r7" /><small>skipping to change at</small><em> line 747</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       eclJ2000Grid-&gt;update(deltaTime);</td><td> </td><td class="right">       eclJ2000Grid-&gt;update(deltaTime);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       galacticGrid-&gt;update(deltaTime);</td><td> </td><td class="right">       galacticGrid-&gt;update(deltaTime);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       aziGrid-&gt;update(deltaTime);</td><td> </td><td class="right">       aziGrid-&gt;update(deltaTime);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       equatorLine-&gt;update(deltaTime);</td><td> </td><td class="right">       equatorLine-&gt;update(deltaTime);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       eclipticLine-&gt;update(deltaTime);</td><td> </td><td class="right">       eclipticLine-&gt;update(deltaTime);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       meridianLine-&gt;update(deltaTime);</td><td> </td><td class="right">       meridianLine-&gt;update(deltaTime);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       horizonLine-&gt;update(deltaTime);</td><td> </td><td class="right">       horizonLine-&gt;update(deltaTime);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       galacticPlaneLine-&gt;update(deltaTime);</td><td> </td><td class="right">       galacticPlaneLine-&gt;update(deltaTime);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0054" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">void GridLinesMgr::draw(StelCore* core)</td><td> </td><td class="rblock">void GridLinesMgr::draw(StelCore* core<span class="insert">, class StelRenderer* renderer</span>)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0055" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">equGrid-&gt;draw(core);</span></td><td> </td><td class="rblock">       <span class="insert">equGrid-&gt;draw(core, renderer);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       galacticGrid-&gt;draw(core);</span></td><td> </td><td class="rblock"><span class="insert">       galacticGrid-&gt;draw(core, renderer);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       equJ2000Grid-&gt;draw(core);</span></td><td> </td><td class="rblock"><span class="insert">       equJ2000Grid-&gt;draw(core, renderer);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       eclJ2000Grid-&gt;draw(core);</span></td><td> </td><td class="rblock"><span class="insert">       eclJ2000Grid-&gt;draw(core, renderer);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       aziGrid-&gt;draw(core);</span></td><td> </td><td class="rblock"><span class="insert">       aziGrid-&gt;draw(core, renderer);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       equatorLine-&gt;draw(core);</span></td><td> </td><td class="rblock"><span class="insert">       equatorLine-&gt;draw(core, renderer);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       eclipticLine-&gt;draw(core);</span></td><td> </td><td class="rblock"><span class="insert">       eclipticLine-&gt;draw(core, renderer);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       meridianLine-&gt;draw(core);</span></td><td> </td><td class="rblock"><span class="insert">       meridianLine-&gt;draw(core, renderer);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       horizonLine-&gt;draw(core);</span></td><td> </td><td class="rblock"><span class="insert">       horizonLine-&gt;draw(core, renderer);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       galacticPlaneLine-&gt;draw(core);</span></td><td> </td><td class="rblock"><span class="insert">       galacticPlaneLine-&gt;draw(core, renderer);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void GridLinesMgr::setStelStyle(const QString&amp; section)</td><td> </td><td class="right">void GridLinesMgr::setStelStyle(const QString&amp; section)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       QSettings* conf = StelApp::getInstance().getSettings();</td><td> </td><td class="right">       QSettings* conf = StelApp::getInstance().getSettings();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Load colors from config file</td><td> </td><td class="right">       // Load colors from config file</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       QString defaultColor = conf-&gt;value(section+"/default_color").toStrin
g();</td><td> </td><td class="right">       QString defaultColor = conf-&gt;value(section+"/default_color").toStrin
g();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       setColorEquatorGrid(StelUtils::strToVec3f(conf-&gt;value(section+"/equa
torial_color", defaultColor).toString()));</td><td> </td><td class="right">       setColorEquatorGrid(StelUtils::strToVec3f(conf-&gt;value(section+"/equa
torial_color", defaultColor).toString()));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       setColorEquatorJ2000Grid(StelUtils::strToVec3f(conf-&gt;value(section+"
/equatorial_J2000_color", defaultColor).toString()));</td><td> </td><td class="right">       setColorEquatorJ2000Grid(StelUtils::strToVec3f(conf-&gt;value(section+"
/equatorial_J2000_color", defaultColor).toString()));</td><td class="lineno" valign="top"></td></tr>

     <tr><td></td><td class="left"></td><td> </td><td class="right"></td><td></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 55 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><td></td><th><i>221 lines changed or deleted</i></th><th><i> </i></th><th><i>258 lines changed or added</i></th><td></td></tr>
     <tr><td colspan="5" align="center" class="small"><br/>This html diff was produced by rfcdiff 1.41. The latest version is available from <a href="http://www.tools.ietf.org/tools/rfcdiff/" >http://tools.ietf.org/tools/rfcdiff/</a> </td></tr>
   </table>
   </body>
   </html>
