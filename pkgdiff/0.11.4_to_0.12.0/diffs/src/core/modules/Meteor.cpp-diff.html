<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"> 
<!-- Generated by rfcdiff 1.41: rfcdiff  --> 
<!-- <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional" > -->
<!-- System: Linux fomalhaut.local 3.13.0-38-generic #65-Ubuntu SMP Thu Oct 9 11:36:50 UTC 2014 x86_64 x86_64 x86_64 GNU/Linux --> 
<!-- Using awk: /usr/bin/gawk: GNU Awk 4.0.1 --> 
<!-- Using diff: /usr/bin/diff: diff (GNU diffutils) 3.3 --> 
<!-- Using wdiff: /usr/bin/wdiff: wdiff (GNU wdiff) 1.2.1 --> 
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"> 
<head> 
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /> 
  <meta http-equiv="Content-Style-Type" content="text/css" /> 
  <title>Diff: Meteor.cpp - Meteor.cpp</title> 
  <style type="text/css"> 
    body    { font-size:16px; margin: 0.4ex; margin-right: auto; } 
    tr      { } 
    td      { white-space: pre; font-family: Consolas, "DejaVu Sans Mono", "Droid Sans Mono", Monaco, Monospace; vertical-align: top; font-size: 0.86em;} 
    th      { font-size: 0.86em; } 
    .small  { font-size: 0.6em; font-style: italic; font-family: Verdana, Helvetica, sans-serif; } 
    .left   { background-color: #EEE; } 
    .right  { background-color: #FFF; } 
    .diff   { background-color: #CCF; } 
    .lblock { background-color: #BFB; } 
    .rblock { background-color: #FF8; } 
    .insert { background-color: #8FF; } 
    .delete { background-color: #ACF; } 
    .void   { background-color: #FFB; } 
    .cont   { background-color: #EEE; } 
    .linebr { background-color: #AAA; } 
    .lineno { color: red; background-color: #FFF; font-size: 0.7em; text-align: right; padding: 0 2px; } 
    .elipsis{ background-color: #AAA; } 
    .left .cont { background-color: #DDD; } 
    .right .cont { background-color: #EEE; } 
    .lblock .cont { background-color: #9D9; } 
    .rblock .cont { background-color: #DD6; } 
    .insert .cont { background-color: #0DD; } 
    .delete .cont { background-color: #8AD; } 
    .stats, .stats td, .stats th { background-color: #EEE; padding: 2px 0; } 
  </style> 
</head> 
<body > 
  <table border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th></th><th>&nbsp;Meteor.cpp&nbsp;</th><th> </th><th>&nbsp;Meteor.cpp&nbsp;</th><th></th></tr> 
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l1" /><small>skipping to change at</small><em> line 31</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 31</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// Could use a simple ablation physics model in the future</td><td> </td><td class="right">// Could use a simple ablation physics model in the future</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">/*</td><td> </td><td class="right">/*</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">NOTE: Here the radiant is always along the ecliptic at the apex of the Eart
h's way.</td><td> </td><td class="right">NOTE: Here the radiant is always along the ecliptic at the apex of the Eart
h's way.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">In reality, individual meteor streams have varying velocity vectors and the
refore radiants</td><td> </td><td class="right">In reality, individual meteor streams have varying velocity vectors and the
refore radiants</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">which are generally not at the apex of the Earth's way, such as the Perseid
s shower.</td><td> </td><td class="right">which are generally not at the apex of the Earth's way, such as the Perseid
s shower.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">*/</td><td> </td><td class="right">*/</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// Improved realism and efficiency 2004-12</td><td> </td><td class="right">// Improved realism and efficiency 2004-12</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">#include &lt;QtOpenGL&gt;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#include &lt;cstdlib&gt;</td><td> </td><td class="right">#include &lt;cstdlib&gt;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#include "Meteor.hpp"</td><td> </td><td class="right">#include "Meteor.hpp"</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#include "StelCore.hpp"</td><td> </td><td class="right">#include "StelCore.hpp"</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0002" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#include "renderer/StelRenderer.hpp"</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#include "StelToneReproducer.hpp"</td><td> </td><td class="right">#include "StelToneReproducer.hpp"</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#include "StelMovementMgr.hpp"</td><td> </td><td class="right">#include "StelMovementMgr.hpp"</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0003" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">#include "StelPainter.hpp"</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">Meteor::Meteor(const StelCore* core, double v)</td><td> </td><td class="right">Meteor::Meteor(const StelCore* core, double v)</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0004" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       : vertexBuffer(NULL)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const StelToneReproducer* eye = core-&gt;getToneReproducer();</td><td> </td><td class="right">       const StelToneReproducer* eye = core-&gt;getToneReproducer();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0005" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  //  velocity = 11+(double)rand()/((double)RAND_MAX+1)*v;  // abs <span class="delete">range 11</span></td><td> </td><td class="rblock">       //  velocity = 11+(double)rand()/((double)RAND_MAX+1)*v;  // abs <span class="insert">ran</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">-72</span> km/s</td><td> </td><td class="rblock"><span class="insert">ge 11-72</span> km/s</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  velocity=v;</td><td> </td><td class="rblock">       velocity=v;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0006" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  maxMag = 1;</td><td> </td><td class="rblock">  <span class="insert">     </span>maxMag = 1;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0007" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  // determine meteor model view matrix (want z in dir of travel of <span class="delete">earth,</span> </td><td> </td><td class="rblock">       // determine meteor model view matrix (want z in dir of travel of <span class="insert">ea</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">z=0 at center of earth)</td><td> </td><td class="rblock"><span class="insert">rth,</span> z=0 at center of earth)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  // meteor life is so short, no need to recalculate</td><td> </td><td class="rblock">       // meteor life is so short, no need to recalculate</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  double equ_rotation; // rotation needed to align with path of earth</td><td> </td><td class="rblock">       double equ_rotation; // rotation needed to align with path of earth</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  Vec3d sun_dir = core-&gt;heliocentricEclipticToEquinoxEqu( Vec3d(0,0,0) );</td><td> </td><td class="rblock">       Vec3d sun_dir = core-&gt;heliocentricEclipticToEquinoxEqu( Vec3d(0,0,0)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                                                           </td><td> </td><td class="rblock"> );</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  Mat4d tmat = Mat4d::xrotation(-23.45f*M_PI/180.f);  // ecliptical <span class="delete">tilt</span></td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  sun_dir.transfo4d(tmat);  // convert to ecliptical coordinates</td><td> </td><td class="rblock">       Mat4d tmat = Mat4d::xrotation(-23.45f*M_PI/180.f);  // ecliptical <span class="insert">ti</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  sun_dir.normalize();</td><td> </td><td class="rblock"><span class="insert">lt</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  equ_rotation = acos( sun_dir.dot( Vec3d(1,0,0) ) );</td><td> </td><td class="rblock">       sun_dir.transfo4d(tmat);  // convert to ecliptical coordinates</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  if( sun_dir[1] &lt; 0 ) equ_rotation = 2*M_PI - equ_rotation;</td><td> </td><td class="rblock">       sun_dir.normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                                                           </td><td> </td><td class="rblock">       equ_rotation = acos( sun_dir.dot( Vec3d(1,0,0) ) );</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  equ_rotation -= M_PI_2;</td><td> </td><td class="rblock">       if( sun_dir[1] &lt; 0 ) equ_rotation = 2*M_PI - equ_rotation;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                                                           </td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  mmat = Mat4d::xrotation(23.45f*M_PI/180.f) * <span class="delete">Mat4d::zrotation(equ_rotatio</span></td><td> </td><td class="rblock">       equ_rotation -= M_PI_2;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">n)</span> * Mat4d::yrotation(M_PI_2);</td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                                                           </td><td> </td><td class="rblock">       mmat = Mat4d::xrotation(23.45f*M_PI/180.f) * <span class="insert">Mat4d::zrotation(equ_ro</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  // select random trajectory using polar coordinates in XY plane, <span class="delete">centered</span></td><td> </td><td class="rblock"><span class="insert">tation)</span> * Mat4d::yrotation(M_PI_2);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"> on observer</td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  xydistance = (double)rand()/((double)RAND_MAX+1)*(VISIBLE_RADIUS);</td><td> </td><td class="rblock">       // select random trajectory using polar coordinates in XY plane, <span class="insert">cen</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  double angle = (double)rand()/((double)RAND_MAX+1)*2*M_PI;</td><td> </td><td class="rblock"><span class="insert">tered</span> on observer</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                                                           </td><td> </td><td class="rblock">       xydistance = (double)rand()/((double)RAND_MAX+1)*(VISIBLE_RADIUS);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  // find observer position in meteor coordinate system</td><td> </td><td class="rblock">       double angle = (double)rand()/((double)RAND_MAX+1)*2*M_PI;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  obs = core-&gt;altAzToEquinoxEqu(Vec3d(0,0,EARTH_RADIUS));</td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  obs.transfo4d(mmat.transpose());</td><td> </td><td class="rblock">       // find observer position in meteor coordinate system</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                                                           </td><td> </td><td class="rblock">       obs = core-&gt;altAzToEquinoxEqu(Vec3d(0,0,EARTH_RADIUS));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  // set meteor start x,y</td><td> </td><td class="rblock">       obs.transfo4d(mmat.transpose());</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  posInternal[0] = posTrain[0] = position[0] = xydistance*cos(angle) <span class="delete">+obs[0</span></td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">];</span></td><td> </td><td class="rblock">       // set meteor start x,y</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  posInternal[1] = posTrain[1] = position[1] = xydistance*sin(angle) <span class="delete">+obs[1</span></td><td> </td><td class="rblock">       posInternal[0] = posTrain[0] = position[0] = xydistance*cos(angle) <span class="insert">+</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">];</span></td><td> </td><td class="rblock"><span class="insert">obs[0];</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                                                           </td><td> </td><td class="rblock">       posInternal[1] = posTrain[1] = position[1] = xydistance*sin(angle) <span class="insert">+</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  // determine life of meteor (start and end z value based on <span class="delete">atmosphere bu</span></td><td> </td><td class="rblock"><span class="insert">obs[1];</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">rn</span> altitudes)</td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                                                           </td><td> </td><td class="rblock">       // determine life of meteor (start and end z value based on <span class="insert">atmosphe</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  // D is distance from center of earth</td><td> </td><td class="rblock"><span class="insert">re burn</span> altitudes)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  double D = sqrt( position[0]*position[0] + position[1]*position[1] <span class="delete">);</span></td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                                                           </td><td> </td><td class="rblock">       // D is distance from center of earth</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  if( D &gt; EARTH_RADIUS+HIGH_ALTITUDE ) {</td><td> </td><td class="rblock">       double D = sqrt( position[0]*position[0] + position[1]*position[1] <span class="insert">)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    // won't be visible</td><td> </td><td class="rblock"><span class="insert">;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    alive = 0;</td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    return;</td><td> </td><td class="rblock">       if( D &gt; EARTH_RADIUS+HIGH_ALTITUDE )</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  }</td><td> </td><td class="rblock">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                                                           </td><td> </td><td class="rblock">               // won't be visible</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  startH = sqrt( pow(EARTH_RADIUS+HIGH_ALTITUDE,2) - D*D);</td><td> </td><td class="rblock">               alive = 0;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                                                           </td><td> </td><td class="rblock">               return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  // determine end of burn point, and nearest point to observer for <span class="delete">distanc</span></td><td> </td><td class="rblock">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">e</span> mag calculation</td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  // mag should be max at nearest point still burning</td><td> </td><td class="rblock">       startH = sqrt( pow(EARTH_RADIUS+HIGH_ALTITUDE,2) - D*D);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  if( D &gt; EARTH_RADIUS+LOW_ALTITUDE ) {</td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    endH = -startH;  // earth grazing</td><td> </td><td class="rblock">       // determine end of burn point, and nearest point to observer for <span class="insert">di</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    minDist = xydistance;</td><td> </td><td class="rblock"><span class="insert">stance</span> mag calculation</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  } else {</td><td> </td><td class="rblock">       // mag should be max at nearest point still burning</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    endH = sqrt( pow(EARTH_RADIUS+LOW_ALTITUDE,2) - D*D);</td><td> </td><td class="rblock">       if( D &gt; EARTH_RADIUS+LOW_ALTITUDE )</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    minDist = sqrt( xydistance*xydistance + pow( endH - obs[2], 2) );</td><td> </td><td class="rblock">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  }</td><td> </td><td class="rblock">               endH = -startH;  // earth grazing</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                                                           </td><td> </td><td class="rblock">               minDist = xydistance;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  if(minDist &gt; VISIBLE_RADIUS ) {</td><td> </td><td class="rblock">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    // on average, not visible (although if were zoomed ...)</td><td> </td><td class="rblock">       else</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    alive = 0;</td><td> </td><td class="rblock">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    return;</td><td> </td><td class="rblock">               endH = sqrt( pow(EARTH_RADIUS+LOW_ALTITUDE,2) - D*D);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  }</td><td> </td><td class="rblock">               minDist = sqrt( xydistance*xydistance + pow( endH - obs[2], </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                                                           </td><td> </td><td class="rblock">2) );</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  /* experiment</td><td> </td><td class="rblock">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  // limit lifetime to 0.5-3.0 sec</td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  double tmp_h = startH - velocity * (0.5 + <span class="delete">(double)rand()/((double)RAND_MA</span></td><td> </td><td class="rblock">       if(minDist &gt; VISIBLE_RADIUS )</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">X+1)</span> * 2.5);</td><td> </td><td class="rblock">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  if( tmp_h &gt; endH ) {</td><td> </td><td class="rblock">               // on average, not visible (although if were zoomed ...)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    endH = tmp_h;</td><td> </td><td class="rblock">               alive = 0;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  }</td><td> </td><td class="rblock">               return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  */</td><td> </td><td class="rblock">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                                                           </td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  posTrain[2] = position[2] = startH;</td><td> </td><td class="rblock">       /* experiment</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                                                           </td><td> </td><td class="rblock">       // limit lifetime to 0.5-3.0 sec</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  //  qDebug("New meteor: %f %f s:%f e:%f v:%f\n", position[0], <span class="delete">position[1]</span></td><td> </td><td class="rblock">       double tmp_h = startH - velocity * (0.5 + <span class="insert">(double)rand()/((double)RA</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">,</span> startH, endH, velocity);</td><td> </td><td class="rblock"><span class="insert">ND_MAX+1)</span> * 2.5);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                                                           </td><td> </td><td class="rblock">       if( tmp_h &gt; endH ) {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  alive = 1;</td><td> </td><td class="rblock">         endH = tmp_h;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  <span class="delete">train=0;</span></td><td> </td><td class="rblock">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                                                           </td><td> </td><td class="rblock">       */</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  // Determine drawing color given magnitude and eye</td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  // (won't be visible during daylight)</td><td> </td><td class="rblock">       posTrain[2] = position[2] = startH;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                                                           </td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  // *** color varies somewhat based on velocity, plus atmosphere <span class="delete">reddening</span></td><td> </td><td class="rblock">       //  qDebug("New meteor: %f %f s:%f e:%f v:%f\n", position[0], <span class="insert">positi</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                                                           </td><td> </td><td class="rblock"><span class="insert">on[1],</span> startH, endH, velocity);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  // determine intensity</td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  float Mag1 = (double)rand()/((double)RAND_MAX+1)*6.75f - 3;</td><td> </td><td class="rblock">       alive = 1;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  float Mag2 = (double)rand()/((double)RAND_MAX+1)*6.75f - 3;</td><td> </td><td class="rblock">       <span class="insert">train = 1;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  float Mag = (Mag1 + Mag2)/2.0f;</td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                                                           </td><td> </td><td class="rblock">       // Determine drawing color given magnitude and eye</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  mag = (5. + Mag) / 256.0;</td><td> </td><td class="rblock">       // (won't be visible during daylight)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  if (mag&gt;250) mag = mag - 256;</td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                                                           </td><td> </td><td class="rblock">       // *** color varies somewhat based on velocity, plus atmosphere <span class="insert">redd</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  float term1 = std::exp(-0.92103f*(mag + 12.12331f)) * 108064.73f;</td><td> </td><td class="rblock"><span class="insert">ening</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                                                           </td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  float cmag=1.f;</td><td> </td><td class="rblock">       // determine intensity</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  float rmag;</td><td> </td><td class="rblock">       float Mag1 = (double)rand()/((double)RAND_MAX+1)*6.75f - 3;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                                                           </td><td> </td><td class="rblock">       float Mag2 = (double)rand()/((double)RAND_MAX+1)*6.75f - 3;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  // Compute the equivalent star luminance for a 5 arc min circle and <span class="delete">conve</span></td><td> </td><td class="rblock">       float Mag = (Mag1 + Mag2)/2.0f;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">rt</span> it</td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  // in function of the eye adaptation</td><td> </td><td class="rblock">       mag = (5. + Mag) / 256.0;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  rmag = eye-&gt;adaptLuminanceScaled(term1);</td><td> </td><td class="rblock">       if (mag&gt;250) mag = mag - 256;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  rmag = <span class="delete">rmag/powf(core-&gt;getMovementMgr()-&gt;getCurrentFov(),0.85f)*500.f;</span></td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                                                           </td><td> </td><td class="rblock">       float term1 = std::exp(-0.92103f*(mag + 12.12331f)) * 108064.73f;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  // if size of star is too small (blink) we put its size to 1.2 --&gt; <span class="delete">no mor</span></td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">e</span> blink</td><td> </td><td class="rblock">       float cmag=1.f;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  // And we compensate the difference of brighteness with cmag</td><td> </td><td class="rblock">       float rmag;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  if (rmag&lt;1.2f) {</td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    cmag=rmag*rmag/1.44f;</td><td> </td><td class="rblock">       // Compute the equivalent star luminance for a 5 arc min circle and </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  }</td><td> </td><td class="rblock"><span class="insert">convert</span> it</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                                                           </td><td> </td><td class="rblock">       // in function of the eye adaptation</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  mag = cmag;  // assumes white</td><td> </td><td class="rblock">       rmag = eye-&gt;adaptLuminanceScaled(term1);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                                                           </td><td> </td><td class="rblock">       rmag = <span class="insert">rmag/powf(core-&gt;getMovementMgr()-&gt;getCurrentFov(),0.85f)*500.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  // most visible meteors are under about 180km distant</td><td> </td><td class="rblock"><span class="insert">f;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  // scale max mag down if outside this range</td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  float scale = 1;</td><td> </td><td class="rblock">       // if size of star is too small (blink) we put its size to 1.2 --&gt; <span class="insert">n</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  if(minDist!=0) scale = 180*180/(minDist*minDist);</td><td> </td><td class="rblock"><span class="insert">o more</span> blink</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  if( scale &lt; 1 ) mag *= scale;</td><td> </td><td class="rblock">       // And we compensate the difference of brighteness with cmag</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       if (rmag&lt;1.2f)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">               cmag=rmag*rmag/1.44f;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       mag = cmag;  // assumes white</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       // most visible meteors are under about 180km distant</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       // scale max mag down if outside this range</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       float scale = 1;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       if(minDist!=0) scale = 180*180/(minDist*minDist);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       if( scale &lt; 1 ) mag *= scale;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">Meteor::~Meteor()</td><td> </td><td class="right">Meteor::~Meteor()</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0008" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">if(NULL != vertexBuffer)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               delete vertexBuffer;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// returns true if alive</td><td> </td><td class="right">// returns true if alive</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">bool Meteor::update(double deltaTime)</td><td> </td><td class="right">bool Meteor::update(double deltaTime)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0009" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  if(!alive) return(0);</td><td> </td><td class="rblock">       if(!alive) return(0);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                                                           </td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  <span class="delete">if( position[2] &lt; endH ) {</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">    // burning has stopped so magnitude fades out</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">    // assume linear fade out</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0010" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    <span class="delete">mag -= maxMag * deltaTime/500.0f;</span></td><td> </td><td class="rblock">       <span class="insert">if(position[2]</span> &lt; <span class="insert">endH)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">    if( mag</span> &lt; <span class="delete">0 ) alive=0;</span>  // <span class="delete">no longer visible</span></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">               // <span class="insert">burning has stopped so magnitude fades out</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               // assume linear fade out</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0011" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  }</td><td> </td><td class="rblock">               <span class="insert">mag -= maxMag * deltaTime/500.0f;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               if(mag &lt; 0) alive=0;  // no longer visible</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0012" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  // *** would need time direction multiplier to allow reverse time <span class="delete">replay</span></td><td> </td><td class="rblock">       // *** would need time direction multiplier to allow reverse time <span class="insert">re</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  position[2] = position[2] - velocity*deltaTime/1000.0f;</td><td> </td><td class="rblock"><span class="insert">play</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       position[2] = position[2] - velocity*deltaTime/1000.0f;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0013" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  // train doesn't extend beyond start of burn</td><td> </td><td class="rblock">       // train doesn't extend beyond start of burn</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  <span class="delete">if( position[2]</span> + velocity*0.5f &gt; <span class="delete">startH )</span> {</td><td> </td><td class="rblock">       <span class="insert">if(position[2]</span> + velocity*0.5f &gt; <span class="insert">startH)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    posTrain[2] = startH ;</td><td> </td><td class="rblock">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  } else {</td><td> </td><td class="rblock">               posTrain[2] = startH ;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    posTrain[2] -= velocity*deltaTime/1000.0f;</td><td> </td><td class="rblock">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  }</td><td> </td><td class="rblock">       else</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">               posTrain[2] -= velocity*deltaTime/1000.0f;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0014" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  <span class="delete">//qDebug("meteor position: %f delta_t %d\n", position[2], deltaTime)</span>;</td><td> </td><td class="rblock">  <span class="insert">     //qDebug("meteor position: %f delta_t %d\n", position[2], deltaTime)
</span>;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0015" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  // determine visual magnitude based on distance to observer</td><td> </td><td class="rblock">       // determine visual magnitude based on distance to observer</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  double dist = <span class="delete">sqrt( xydistance*xydistance</span> + pow( position[2]-obs[2], <span class="delete">2) )</span></td><td> </td><td class="rblock">       double dist = <span class="insert">sqrt(xydistance*xydistance</span> + pow( position[2]-obs[2], </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">;</span></td><td> </td><td class="rblock"><span class="insert">2));</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0016" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  <span class="delete">if( dist == 0 ) dist = .01;  // just to be cautious (meteor hits observer
</span>!)</td><td> </td><td class="rblock">  <span class="insert">     if(dist == 0) dist = .01;  // just to be cautious (meteor hits obser
ver</span>!)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0017" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  distMultiplier = minDist*minDist / (dist*dist);</td><td> </td><td class="rblock">  <span class="insert">     </span>distMultiplier = minDist*minDist / (dist*dist);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0018" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  return(alive);</td><td> </td><td class="rblock">  <span class="insert">     </span>return(alive);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0019" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">// returns true if visible</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// Assumes that we are in local frame</td><td> </td><td class="right">// Assumes that we are in local frame</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0020" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">void Meteor::draw(const StelCore* core, StelP<span class="delete">ainter&amp; sPaint</span>er)</td><td> </td><td class="rblock">void Meteor::draw(const StelCore* core, StelP<span class="insert">rojectorP projector, StelRende
rer* render</span>er)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0021" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       if (!alive)</td><td> </td><td class="rblock">       if (!alive) <span class="insert">{return;}</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               <span class="delete">return;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       const StelProjectorP proj = sPainter.getProjector();</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Vec3d spos = position;</td><td> </td><td class="right">       Vec3d spos = position;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Vec3d epos = posTrain;</td><td> </td><td class="right">       Vec3d epos = posTrain;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // convert to equ</td><td> </td><td class="right">       // convert to equ</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       spos.transfo4d(mmat);</td><td> </td><td class="right">       spos.transfo4d(mmat);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       epos.transfo4d(mmat);</td><td> </td><td class="right">       epos.transfo4d(mmat);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // convert to local and correct for earth radius [since equ and loca
l coordinates in stellarium use same 0 point!]</td><td> </td><td class="right">       // convert to local and correct for earth radius [since equ and loca
l coordinates in stellarium use same 0 point!]</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0022" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       spos = <span class="delete">core-&gt;equinoxEquToAltAz( spos );</span></td><td> </td><td class="rblock">       spos = <span class="insert">core-&gt;equinoxEquToAltAz(spos);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       epos = <span class="delete">core-&gt;equinoxEquToAltAz( epos );</span></td><td> </td><td class="rblock">       epos = <span class="insert">core-&gt;equinoxEquToAltAz(epos);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       spos[2] -= EARTH_RADIUS;</td><td> </td><td class="right">       spos[2] -= EARTH_RADIUS;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       epos[2] -= EARTH_RADIUS;</td><td> </td><td class="right">       epos[2] -= EARTH_RADIUS;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // 1216 is to scale down under 1 for desktop version</td><td> </td><td class="right">       // 1216 is to scale down under 1 for desktop version</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0023" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">spos/=1216;</span></td><td> </td><td class="rblock">       <span class="insert">spos /= 1216;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       epos/=1216;</span></td><td> </td><td class="rblock"><span class="insert">       epos /= 1216;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //  qDebug("[%f %f %f] (%d, %d) (%d, %d)\n", position[0], position[1
], position[2], (int)start[0], (int)start[1], (int)end[0], (int)end[1]);</td><td> </td><td class="right">       //  qDebug("[%f %f %f] (%d, %d) (%d, %d)\n", position[0], position[1
], position[2], (int)start[0], (int)start[1], (int)end[0], (int)end[1]);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0024" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">if(NULL == vertexBuffer)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               // This well need to be rewritten if the train data member g</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ets changed after construction.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               vertexBuffer =</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       renderer-&gt;createVertexBuffer&lt;Vertex&gt;(train ? Primiti</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">veType_LineStrip : PrimitiveType_Points);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (train)</td><td> </td><td class="right">       if (train)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               // connect this point with last drawn point</td><td> </td><td class="right">               // connect this point with last drawn point</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0025" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               <span class="delete">double tmag = mag*</span>distMultiplier;</td><td> </td><td class="rblock">               <span class="insert">const double tmag = mag * </span>distMultiplier;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               // compute an intermediate point so can curve slightly along
 projection distortions</td><td> </td><td class="right">               // compute an intermediate point so can curve slightly along
 projection distortions</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               Vec3d posi = posInternal;</td><td> </td><td class="right">               Vec3d posi = posInternal;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0026" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               posi[2] <span class="delete">= position[2] + (posTrain[2] - position[2])/</span>2;</td><td> </td><td class="rblock">               posi[2] <span class="insert">   = position[2] + (posTrain[2] - position[2]) / </span>2;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               posi.transfo4d(mmat);</td><td> </td><td class="right">               posi.transfo4d(mmat);</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0027" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               posi = core-&gt;equinoxEquToAltAz( posi );</td><td> </td><td class="rblock">               posi       = core-&gt;equinoxEquToAltAz( posi );</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               posi[2] -= EARTH_RADIUS;</td><td> </td><td class="rblock">               posi[2]   -= EARTH_RADIUS;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               <span class="delete">posi/=1216;</span></td><td> </td><td class="rblock">               <span class="insert">posi      /= 1216;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               // draw dark to light</span></td><td> </td><td class="rblock"><span class="insert">               vertexBuffer-&gt;unlock();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               Vec4f colorArray[3];</span></td><td> </td><td class="rblock"><span class="insert">               vertexBuffer-&gt;clear();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               colorArray[0].set(0,0,0,0);</span></td><td> </td><td class="rblock"><span class="insert">               vertexBuffer-&gt;addVertex(Vertex(epos, Vec4f(0.0f, 0.0f, 0.0f,</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               colorArray[1].set(1,1,1,tmag*0.5);</span></td><td> </td><td class="rblock"><span class="insert"> 0.0f)));</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               colorArray[2].set(1,1,1,tmag);</span></td><td> </td><td class="rblock"><span class="insert">               vertexBuffer-&gt;addVertex(Vertex(posi, Vec4f(1.0f, 1.0f, 1.0f,</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               Vec3d vertexArray[3];</span></td><td> </td><td class="rblock"><span class="insert"> tmag * 0.5)));</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               vertexArray[0]=epos;</span></td><td> </td><td class="rblock"><span class="insert">               vertexBuffer-&gt;addVertex(Vertex(spos, Vec4f(1.0f, 1.0f, 1.0f,</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               vertexArray[1]=posi;</span></td><td> </td><td class="rblock"><span class="insert"> tmag)));</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               vertexArray[2]=spos;</span></td><td> </td><td class="rblock"><span class="insert">               vertexBuffer-&gt;lock();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               sPainter.setColorPointer(4, GL_FLOAT, colorArray);</span></td><td> </td><td class="rblock"><span class="insert">               renderer-&gt;drawVertexBuffer(vertexBuffer, NULL, projector);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               sPainter.setVertexPointer(3, GL_DOUBLE, vertexArray);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               // TODO the crash doesn't appear when the last true is set t</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">o false</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               sPainter.enableClientStates(true, false, true);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               sPainter.drawFromArray(StelPainter::LineStrip, 3, 0, true);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               sPainter.enableClientStates(false);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       else</td><td> </td><td class="right">       else</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0028" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               <span class="delete">sPainter.setPointSize(1.f);</span></td><td> </td><td class="rblock">               <span class="insert">vertexBuffer-&gt;unlock();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               Vec3d start;</span></td><td> </td><td class="rblock"><span class="insert">               vertexBuffer-&gt;clear();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               proj-&gt;project(spos, start);</span></td><td> </td><td class="rblock"><span class="insert">               // A line with two identical points ends up being a point.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               sPainter.drawPoint2d(start[0],start[1]);</span></td><td> </td><td class="rblock"><span class="insert">               vertexBuffer-&gt;addVertex(Vertex(spos, Vec4f(1.0f, 1.0f, 1.0f,</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> 1.0f)));</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               vertexBuffer-&gt;lock();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               renderer-&gt;drawVertexBuffer(vertexBuffer, NULL, projector);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0029" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                                                           </td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">train = 1;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">bool Meteor::isAlive(void)</td><td> </td><td class="right">bool Meteor::isAlive(void)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0030" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  return(alive);</td><td> </td><td class="rblock">  <span class="insert">     </span>return(alive);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>

     <tr><td></td><td class="left"></td><td> </td><td class="right"></td><td></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 30 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><td></td><th><i>186 lines changed or deleted</i></th><th><i> </i></th><th><i>206 lines changed or added</i></th><td></td></tr>
     <tr><td colspan="5" align="center" class="small"><br/>This html diff was produced by rfcdiff 1.41. The latest version is available from <a href="http://www.tools.ietf.org/tools/rfcdiff/" >http://tools.ietf.org/tools/rfcdiff/</a> </td></tr>
   </table>
   </body>
   </html>
