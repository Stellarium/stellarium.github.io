<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"> 
<!-- Generated by rfcdiff 1.41: rfcdiff  --> 
<!-- <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional" > -->
<!-- System: Linux fomalhaut.local 3.13.0-38-generic #65-Ubuntu SMP Thu Oct 9 11:36:50 UTC 2014 x86_64 x86_64 x86_64 GNU/Linux --> 
<!-- Using awk: /usr/bin/gawk: GNU Awk 4.0.1 --> 
<!-- Using diff: /usr/bin/diff: diff (GNU diffutils) 3.3 --> 
<!-- Using wdiff: /usr/bin/wdiff: wdiff (GNU wdiff) 1.2.1 --> 
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"> 
<head> 
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /> 
  <meta http-equiv="Content-Style-Type" content="text/css" /> 
  <title>Diff: Landscape.cpp - Landscape.cpp</title> 
  <style type="text/css"> 
    body    { font-size:16px; margin: 0.4ex; margin-right: auto; } 
    tr      { } 
    td      { white-space: pre; font-family: Consolas, "DejaVu Sans Mono", "Droid Sans Mono", Monaco, Monospace; vertical-align: top; font-size: 0.86em;} 
    th      { font-size: 0.86em; } 
    .small  { font-size: 0.6em; font-style: italic; font-family: Verdana, Helvetica, sans-serif; } 
    .left   { background-color: #EEE; } 
    .right  { background-color: #FFF; } 
    .diff   { background-color: #CCF; } 
    .lblock { background-color: #BFB; } 
    .rblock { background-color: #FF8; } 
    .insert { background-color: #8FF; } 
    .delete { background-color: #ACF; } 
    .void   { background-color: #FFB; } 
    .cont   { background-color: #EEE; } 
    .linebr { background-color: #AAA; } 
    .lineno { color: red; background-color: #FFF; font-size: 0.7em; text-align: right; padding: 0 2px; } 
    .elipsis{ background-color: #AAA; } 
    .left .cont { background-color: #DDD; } 
    .right .cont { background-color: #EEE; } 
    .lblock .cont { background-color: #9D9; } 
    .rblock .cont { background-color: #DD6; } 
    .insert .cont { background-color: #0DD; } 
    .delete .cont { background-color: #8AD; } 
    .stats, .stats td, .stats th { background-color: #EEE; padding: 2px 0; } 
  </style> 
</head> 
<body > 
  <table border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th></th><th>&nbsp;Landscape.cpp&nbsp;</th><th> </th><th>&nbsp;Landscape.cpp&nbsp;</th><th></th></tr> 
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l1" /><small>skipping to change at</small><em> line 23</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 23</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</td><td> </td><td class="right"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"> * GNU General Public License for more details.</td><td> </td><td class="right"> * GNU General Public License for more details.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"> *</td><td> </td><td class="right"> *</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"> * You should have received a copy of the GNU General Public License</td><td> </td><td class="right"> * You should have received a copy of the GNU General Public License</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"> * along with this program; if not, write to the Free Software</td><td> </td><td class="right"> * along with this program; if not, write to the Free Software</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"> * Foundation, Inc., 51 Franklin Street, Suite 500, Boston, MA  02110-1335,
 USA.</td><td> </td><td class="right"> * Foundation, Inc., 51 Franklin Street, Suite 500, Boston, MA  02110-1335,
 USA.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"> */</td><td> </td><td class="right"> */</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#include "Landscape.hpp"</td><td> </td><td class="right">#include "Landscape.hpp"</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#include "StelApp.hpp"</td><td> </td><td class="right">#include "StelApp.hpp"</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">#include <span class="delete">"StelTextureMgr.hpp"</span></td><td> </td><td class="rblock">#include <span class="insert">"renderer/StelGeometryBuilder.hpp"</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#include "renderer/StelRenderer.hpp"</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#include "renderer/StelTextureNew.hpp"</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#include "StelFileMgr.hpp"</td><td> </td><td class="right">#include "StelFileMgr.hpp"</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#include "StelIniParser.hpp"</td><td> </td><td class="right">#include "StelIniParser.hpp"</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#include "StelLocation.hpp"</td><td> </td><td class="right">#include "StelLocation.hpp"</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#include "StelCore.hpp"</td><td> </td><td class="right">#include "StelCore.hpp"</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0002" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">#include "StelPainter.hpp"</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#include &lt;QDebug&gt;</td><td> </td><td class="right">#include &lt;QDebug&gt;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#include &lt;QSettings&gt;</td><td> </td><td class="right">#include &lt;QSettings&gt;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#include &lt;QVarLengthArray&gt;</td><td> </td><td class="right">#include &lt;QVarLengthArray&gt;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">Landscape::Landscape(float _radius) : radius(_radius), skyBrightness(1.), n
ightBrightness(0.8), angleRotateZOffset(0.)</td><td> </td><td class="right">Landscape::Landscape(float _radius) : radius(_radius), skyBrightness(1.), n
ightBrightness(0.8), angleRotateZOffset(0.)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       validLandscape = 0;</td><td> </td><td class="right">       validLandscape = 0;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l2" /><small>skipping to change at</small><em> line 143</em></th><th> </th><th><a name="part-r2" /><small>skipping to change at</small><em> line 144</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       }</td><td> </td><td class="right">                       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       catch (std::runtime_error&amp; e)</td><td> </td><td class="right">                       catch (std::runtime_error&amp; e)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       {;}</td><td> </td><td class="right">                       {;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#endif</td><td> </td><td class="right">#endif</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               path = StelFileMgr::findFile("textures/" + basename);</td><td> </td><td class="right">               path = StelFileMgr::findFile("textures/" + basename);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return path;</td><td> </td><td class="right">               return path;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0003" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">LandscapeOldStyle::LandscapeOldStyle(float _radius) : <span class="delete">Landscape(_radius), s</span></td><td> </td><td class="rblock">LandscapeOldStyle::LandscapeOldStyle(float _radius)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">ideTexs(NULL), sides(NULL), tanMode(false),</span> calibrated(false)</td><td> </td><td class="rblock">       : <span class="insert">Landscape(_radius)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       , sideTexs(NULL)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       , texturesInitialized(false)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       , sides(NULL)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       , fogTex(NULL)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       , groundTex(NULL)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       , tanMode(false)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       ,</span> calibrated(false)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">, fogCylinderBuffer(NULL)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       // Way off to ensure the height is detected as "changed" on the firs</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">t drawFog() call.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       , previousFogHeight(-1000.0f)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       , groundFanDisk(NULL)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       , groundFanDiskIndices(NULL)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{}</td><td> </td><td class="right">{}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">LandscapeOldStyle::~LandscapeOldStyle()</td><td> </td><td class="right">LandscapeOldStyle::~LandscapeOldStyle()</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0004" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       if (sideTexs)</td><td> </td><td class="rblock">       if (<span class="insert">NULL != </span>sideTexs)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0005" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">               <span class="insert">if(texturesInitialized)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       for(int i = 0; i &lt; nbSideTexs; ++i)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               delete sideTexs[i].texture;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               delete [] sideTexs;</td><td> </td><td class="right">               delete [] sideTexs;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               sideTexs = NULL;</td><td> </td><td class="right">               sideTexs = NULL;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0006" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       if <span class="delete">(sides)</span> delete [] sides;</td><td> </td><td class="rblock">       <span class="insert">if(NULL != fogTex)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               delete fogTex;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               fogTex = NULL;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       if(NULL != groundTex)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               delete groundTex;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               groundTex = NULL;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       if <span class="insert">(NULL != fogCylinderBuffer)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               delete fogCylinderBuffer;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               fogCylinderBuffer = NULL;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       if (NULL != groundFanDisk)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               Q_ASSERT_X(NULL != groundFanDiskIndices, Q_FUNC_INFO,</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                          "Vertex buffer is generated but index buffer is n</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ot");</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               delete groundFanDisk;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               groundFanDisk = NULL;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               delete groundFanDiskIndices;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               groundFanDiskIndices = NULL;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       if (NULL != sides)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">               delete [] sides;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">               <span class="insert">sides = NULL;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       for(int side = 0; side &lt; precomputedSides.length(); ++side)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               delete precomputedSides[side].vertices;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               delete precomputedSides[side].indices;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       precomputedSides.clear();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void LandscapeOldStyle::load(const QSettings&amp; landscapeIni, const QString&amp; 
landscapeId)</td><td> </td><td class="right">void LandscapeOldStyle::load(const QSettings&amp; landscapeIni, const QString&amp; 
landscapeId)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // TODO: put values into hash and call create method to consolidate 
code</td><td> </td><td class="right">       // TODO: put values into hash and call create method to consolidate 
code</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       loadCommon(landscapeIni, landscapeId);</td><td> </td><td class="right">       loadCommon(landscapeIni, landscapeId);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (landscapeIni.contains("landscape/tesselate_rows"))</td><td> </td><td class="right">       if (landscapeIni.contains("landscape/tesselate_rows"))</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               rows = landscapeIni.value("landscape/tesselate_rows").toInt(
);</td><td> </td><td class="right">               rows = landscapeIni.value("landscape/tesselate_rows").toInt(
);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       else rows=8;</td><td> </td><td class="right">       else rows=8;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l3" /><small>skipping to change at</small><em> line 180</em></th><th> </th><th><a name="part-r3" /><small>skipping to change at</small><em> line 240</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if(type != "old_style")</td><td> </td><td class="right">       if(type != "old_style")</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               qWarning() &lt;&lt; "Landscape type mismatch for landscape " &lt;&lt; la
ndscapeId</td><td> </td><td class="right">               qWarning() &lt;&lt; "Landscape type mismatch for landscape " &lt;&lt; la
ndscapeId</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                                  &lt;&lt; ", expected old_style, found " &lt;&lt; type
 &lt;&lt; ".  No landscape in use.";</td><td> </td><td class="right">                                  &lt;&lt; ", expected old_style, found " &lt;&lt; type
 &lt;&lt; ".  No landscape in use.";</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               validLandscape = 0;</td><td> </td><td class="right">               validLandscape = 0;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return;</td><td> </td><td class="right">               return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Load sides textures</td><td> </td><td class="right">       // Load sides textures</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       nbSideTexs = landscapeIni.value("landscape/nbsidetex", 0).toInt();</td><td> </td><td class="right">       nbSideTexs = landscapeIni.value("landscape/nbsidetex", 0).toInt();</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0007" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       sideTexs = new S<span class="delete">telTextureSP</span>[nbSideTexs];</td><td> </td><td class="rblock">       sideTexs = new S<span class="insert">ideTexture</span>[nbSideTexs];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       for (int i=0; i&lt;nbSideTexs; ++i)</td><td> </td><td class="right">       for (int i=0; i&lt;nbSideTexs; ++i)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               QString textureKey = QString("landscape/tex%1").arg(i);</td><td> </td><td class="right">               QString textureKey = QString("landscape/tex%1").arg(i);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               QString textureName = landscapeIni.value(textureKey).toStrin
g();</td><td> </td><td class="right">               QString textureName = landscapeIni.value(textureKey).toStrin
g();</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0008" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               <span class="delete">const QString texturePath</span> = getTexturePath(textureName, <span class="delete">land</span></td><td> </td><td class="rblock">               <span class="insert">sideTexs[i].path</span> = getTexturePath(textureName, <span class="insert">landscapeId);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">scapeId);</span></td><td> </td><td class="rblock"><span class="insert">               // Will be lazily initialized</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               sideTexs[i]</span> = <span class="delete">StelApp::getInstance().getTextureManager().cre</span></td><td> </td><td class="rblock"><span class="insert">               sideTexs[i].texture</span> = <span class="insert">NULL;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">ateTexture(texturePath);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0009" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       QMap&lt;int, int&gt; texToSide;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Init sides parameters</td><td> </td><td class="right">       // Init sides parameters</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       nbSide = landscapeIni.value("landscape/nbside", 0).toInt();</td><td> </td><td class="right">       nbSide = landscapeIni.value("landscape/nbside", 0).toInt();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       sides = new landscapeTexCoord[nbSide];</td><td> </td><td class="right">       sides = new landscapeTexCoord[nbSide];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       int texnum;</td><td> </td><td class="right">       int texnum;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0010" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                                                           </span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       for (int i=0;i&lt;nbSide;++i)</td><td> </td><td class="right">       for (int i=0;i&lt;nbSide;++i)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               QString key = QString("landscape/side%1").arg(i);</td><td> </td><td class="right">               QString key = QString("landscape/side%1").arg(i);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               QString description = landscapeIni.value(key).toString();</td><td> </td><td class="right">               QString description = landscapeIni.value(key).toString();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               //sscanf(s.toLocal8Bit(),"tex%d:%f:%f:%f:%f",&amp;texnum,&amp;a,&amp;b,&amp;
c,&amp;d);</td><td> </td><td class="right">               //sscanf(s.toLocal8Bit(),"tex%d:%f:%f:%f:%f",&amp;texnum,&amp;a,&amp;b,&amp;
c,&amp;d);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               QStringList parameters = description.split(':');</td><td> </td><td class="right">               QStringList parameters = description.split(':');</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               //TODO: How should be handled an invalid texture description
?</td><td> </td><td class="right">               //TODO: How should be handled an invalid texture description
?</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               QString textureName = parameters.value(0);</td><td> </td><td class="right">               QString textureName = parameters.value(0);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               texnum = textureName.right(textureName.length() - 3).toInt()
;</td><td> </td><td class="right">               texnum = textureName.right(textureName.length() - 3).toInt()
;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0011" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               sides[i].tex = sideTexs[texnum];</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               sides[i].texCoords[0] = parameters.at(1).toFloat();</td><td> </td><td class="right">               sides[i].texCoords[0] = parameters.at(1).toFloat();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               sides[i].texCoords[1] = parameters.at(2).toFloat();</td><td> </td><td class="right">               sides[i].texCoords[1] = parameters.at(2).toFloat();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               sides[i].texCoords[2] = parameters.at(3).toFloat();</td><td> </td><td class="right">               sides[i].texCoords[2] = parameters.at(3).toFloat();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               sides[i].texCoords[3] = parameters.at(4).toFloat();</td><td> </td><td class="right">               sides[i].texCoords[3] = parameters.at(4).toFloat();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               //qDebug() &lt;&lt; i &lt;&lt; texnum &lt;&lt; sides[i].texCoords[0] &lt;&lt; sides[
i].texCoords[1] &lt;&lt; sides[i].texCoords[2] &lt;&lt; sides[i].texCoords[3];</td><td> </td><td class="right">               //qDebug() &lt;&lt; i &lt;&lt; texnum &lt;&lt; sides[i].texCoords[0] &lt;&lt; sides[
i].texCoords[1] &lt;&lt; sides[i].texCoords[2] &lt;&lt; sides[i].texCoords[3];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               // Prior to precomputing the sides, we used to match E to si
de0</td><td> </td><td class="right">               // Prior to precomputing the sides, we used to match E to si
de0</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               // in r4598 the precomputing was put in place and caused a p
roblem for</td><td> </td><td class="right">               // in r4598 the precomputing was put in place and caused a p
roblem for</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               // old_style landscapes which had a z rotation on the side t
extures</td><td> </td><td class="right">               // old_style landscapes which had a z rotation on the side t
extures</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               // and where side0 did not map to tex0</td><td> </td><td class="right">               // and where side0 did not map to tex0</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               // texToSide is a nasty hack to replace the old behaviour</td><td> </td><td class="right">               // texToSide is a nasty hack to replace the old behaviour</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               texToSide[i] = texnum;</td><td> </td><td class="right">               texToSide[i] = texnum;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       nbDecorRepeat = landscapeIni.value("landscape/nb_decor_repeat", 1).t
oInt();</td><td> </td><td class="right">       nbDecorRepeat = landscapeIni.value("landscape/nb_decor_repeat", 1).t
oInt();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       QString groundTexName = landscapeIni.value("landscape/groundtex").to
String();</td><td> </td><td class="right">       QString groundTexName = landscapeIni.value("landscape/groundtex").to
String();</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0012" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">QString</span> groundTexPath = getTexturePath(groundTexName, landscapeId);</td><td> </td><td class="rblock">       groundTexPath = getTexturePath(groundTexName, landscapeId);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">groundTex = StelApp::getInstance().getTextureManager().createTexture</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">(groundTexPath, StelTexture::StelTextureParams(true));</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       QString description = landscapeIni.value("landscape/ground").toStrin
g();</td><td> </td><td class="right">       QString description = landscapeIni.value("landscape/ground").toStrin
g();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //sscanf(description.toLocal8Bit(),"groundtex:%f:%f:%f:%f",&amp;a,&amp;b,&amp;c,
&amp;d);</td><td> </td><td class="right">       //sscanf(description.toLocal8Bit(),"groundtex:%f:%f:%f:%f",&amp;a,&amp;b,&amp;c,
&amp;d);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       QStringList parameters = description.split(':');</td><td> </td><td class="right">       QStringList parameters = description.split(':');</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0013" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       groundTexCoord.tex = groundTex;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       groundTexCoord.texCoords[0] = parameters.at(1).toFloat();</td><td> </td><td class="right">       groundTexCoord.texCoords[0] = parameters.at(1).toFloat();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       groundTexCoord.texCoords[1] = parameters.at(2).toFloat();</td><td> </td><td class="right">       groundTexCoord.texCoords[1] = parameters.at(2).toFloat();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       groundTexCoord.texCoords[2] = parameters.at(3).toFloat();</td><td> </td><td class="right">       groundTexCoord.texCoords[2] = parameters.at(3).toFloat();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       groundTexCoord.texCoords[3] = parameters.at(4).toFloat();</td><td> </td><td class="right">       groundTexCoord.texCoords[3] = parameters.at(4).toFloat();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       QString fogTexName = landscapeIni.value("landscape/fogtex").toString
();</td><td> </td><td class="right">       QString fogTexName = landscapeIni.value("landscape/fogtex").toString
();</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0014" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">QString</span> fogTexPath = getTexturePath(fogTexName, landscapeId);</td><td> </td><td class="rblock">       fogTexPath = getTexturePath(fogTexName, landscapeId);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">fogTex = StelApp::getInstance().getTextureManager().createTexture(fo</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">gTexPath, StelTexture::StelTextureParams(true, GL_LINEAR, GL_REPEAT));</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       description = landscapeIni.value("landscape/fog").toString();</td><td> </td><td class="right">       description = landscapeIni.value("landscape/fog").toString();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //sscanf(description.toLocal8Bit(),"fogtex:%f:%f:%f:%f",&amp;a,&amp;b,&amp;c,&amp;d)
;</td><td> </td><td class="right">       //sscanf(description.toLocal8Bit(),"fogtex:%f:%f:%f:%f",&amp;a,&amp;b,&amp;c,&amp;d)
;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       parameters = description.split(':');</td><td> </td><td class="right">       parameters = description.split(':');</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0015" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       fogTexCoord.tex = fogTex;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       fogTexCoord.texCoords[0] = parameters.at(1).toFloat();</td><td> </td><td class="right">       fogTexCoord.texCoords[0] = parameters.at(1).toFloat();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       fogTexCoord.texCoords[1] = parameters.at(2).toFloat();</td><td> </td><td class="right">       fogTexCoord.texCoords[1] = parameters.at(2).toFloat();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       fogTexCoord.texCoords[2] = parameters.at(3).toFloat();</td><td> </td><td class="right">       fogTexCoord.texCoords[2] = parameters.at(3).toFloat();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       fogTexCoord.texCoords[3] = parameters.at(4).toFloat();</td><td> </td><td class="right">       fogTexCoord.texCoords[3] = parameters.at(4).toFloat();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       fogAltAngle        = landscapeIni.value("landscape/fog_alt_angle", 0
.).toFloat();</td><td> </td><td class="right">       fogAltAngle        = landscapeIni.value("landscape/fog_alt_angle", 0
.).toFloat();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       fogAngleShift      = landscapeIni.value("landscape/fog_angle_shift",
 0.).toFloat();</td><td> </td><td class="right">       fogAngleShift      = landscapeIni.value("landscape/fog_angle_shift",
 0.).toFloat();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       decorAltAngle      = landscapeIni.value("landscape/decor_alt_angle",
 0.).toFloat();</td><td> </td><td class="right">       decorAltAngle      = landscapeIni.value("landscape/decor_alt_angle",
 0.).toFloat();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       decorAngleShift    = landscapeIni.value("landscape/decor_angle_shift
", 0.).toFloat();</td><td> </td><td class="right">       decorAngleShift    = landscapeIni.value("landscape/decor_angle_shift
", 0.).toFloat();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       angleRotateZ       = landscapeIni.value("landscape/decor_angle_rotat
ez", 0.).toFloat();</td><td> </td><td class="right">       angleRotateZ       = landscapeIni.value("landscape/decor_angle_rotat
ez", 0.).toFloat();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       groundAngleShift   = landscapeIni.value("landscape/ground_angle_shif
t", 0.).toFloat();</td><td> </td><td class="right">       groundAngleShift   = landscapeIni.value("landscape/ground_angle_shif
t", 0.).toFloat();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       groundAngleRotateZ = landscapeIni.value("landscape/ground_angle_rota
tez", 0.).toFloat();</td><td> </td><td class="right">       groundAngleRotateZ = landscapeIni.value("landscape/ground_angle_rota
tez", 0.).toFloat();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       drawGroundFirst    = landscapeIni.value("landscape/draw_ground_first
", 0).toInt();</td><td> </td><td class="right">       drawGroundFirst    = landscapeIni.value("landscape/draw_ground_first
", 0).toInt();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       tanMode            = landscapeIni.value("landscape/tan_mode", false)
.toBool();</td><td> </td><td class="right">       tanMode            = landscapeIni.value("landscape/tan_mode", false)
.toBool();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       calibrated         = landscapeIni.value("landscape/calibrated", fals
e).toBool();</td><td> </td><td class="right">       calibrated         = landscapeIni.value("landscape/calibrated", fals
e).toBool();</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0016" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">}</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0017" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">// Precompute the vertex arrays for ground display</span></td><td> </td><td class="rblock"><span class="insert">void LandscapeOldStyle::draw(StelCore* core, StelRenderer* renderer)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       // Make slices_per_side=(3&lt;&lt;K) so that the innermost polygon of the </span></td><td> </td><td class="rblock"><span class="insert">{</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">fandisk becomes a triangle:</span></td><td> </td><td class="rblock">       if <span class="insert">(!validLandscape) {return;}</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       int slices_per_side = 3*64/(nbDecorRepeat*nbSide);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       if <span class="delete">(slices_per_side&lt;=0)</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               slices_per_side = 1;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0018" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       // <span class="delete">draw a fan disk instead of a ordinary disk to that</span> the <span class="delete">inner slic</span></td><td> </td><td class="rblock">       <span class="insert">lazyInitTextures(renderer);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">es</span></td><td> </td><td class="rblock"><span class="insert">       renderer-&gt;setBlendMode(BlendMode_Alpha);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       // are not so slender. When they are too slender, culling errors occ</span></td><td> </td><td class="rblock"><span class="insert">       StelProjectorP projector =</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">ur</span></td><td> </td><td class="rblock"><span class="insert">               core-&gt;getProjection(StelCore::FrameAltAz, StelCore::Refracti</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       // in cylinder projection mode.</span></td><td> </td><td class="rblock"><span class="insert">onOff);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       int slices_inside = nbSide*slices_per_side*nbDecorRepeat;</span></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       int level = 0;</span></td><td> </td><td class="rblock"><span class="insert">       renderer-&gt;setCulledFaces(CullFace_Back);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       while ((slices_inside&amp;1)==0 &amp;&amp; slices_inside</span> &gt; <span class="delete">4)</span></td><td> </td><td class="rblock"><span class="insert">       if (drawGroundFirst) {drawGround(core, renderer);}</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       drawDecor(core, renderer);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       if (!drawGroundFirst) {drawGround(core, renderer);}</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       drawFog(core, renderer);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       renderer-&gt;setCulledFaces(CullFace_None);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">}</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">// <span class="insert">Draw</span> the <span class="insert">horizon fog</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">void LandscapeOldStyle::drawFog(StelCore* core, StelRenderer* renderer)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">{</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       if (!fogFader.getInterstate()) {return;}</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       const float vpos = radius * ((tanMode || calibrated)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                 ? std::tan(fogAngleShift * M_PI / 180.0)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                 : std::sin(fogAngleShift * M_PI / 180.0));</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       StelProjector::ModelViewTranformP transform =</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               core-&gt;getAltAzModelViewTransform(StelCore::RefractionOff);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       transform-&gt;combine(Mat4d::translation(Vec3d(0.,0.,vpos)));</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       StelProjectorP projector = core-&gt;getProjection(transform);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       renderer-&gt;setBlendMode(BlendMode_Add);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       const float nightModeFilter =</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               StelApp::getInstance().getVisionModeNight() ? 0.f : 1.f;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       const float intensity = fogFader.getInterstate() * (0.1f + 0.1f * sk</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">yBrightness);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       const float filteredIntensity = intensity * nightModeFilter;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       renderer-&gt;setGlobalColor(intensity, filteredIntensity, filteredInten</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">sity);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       fogTex-&gt;bind();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       const float height = (tanMode || calibrated)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                          ? radius * std::tan(fogAltAngle * M_PI / 180.f)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                          : radius * std::sin(fogAltAngle * M_PI / 180.f);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       if(std::fabs(height - previousFogHeight)</span> &gt; <span class="insert">0.01)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0019" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               <span class="delete">++level;</span></td><td> </td><td class="rblock">               <span class="insert">// Height has changed, need to regenerate the buffer.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               slices_inside&gt;&gt;=1;</span></td><td> </td><td class="rblock"><span class="insert">               delete fogCylinderBuffer;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               fogCylinderBuffer = NULL;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               previousFogHeight = height;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       if(NULL == fogCylinderBuffer)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               fogCylinderBuffer = renderer-&gt;createVertexBuffer&lt;VertexP3T2&gt;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">(PrimitiveType_TriangleStrip);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               StelGeometryBuilder().buildCylinder(fogCylinderBuffer, radiu</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">s, height, 64, true);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       renderer-&gt;drawVertexBuffer(fogCylinderBuffer, NULL, projector);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       renderer-&gt;setBlendMode(BlendMode_Alpha);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">}</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">void LandscapeOldStyle::lazyInitTextures(StelRenderer* renderer)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">{</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       if(texturesInitialized){return;}</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       for (int i = 0; i &lt; nbSideTexs; ++i)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               sideTexs[i].texture = renderer-&gt;createTexture(sideTexs[i].pa</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">th);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0020" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">StelPainter::computeFanDisk(radius, slices_inside, level, groundVert</span></td><td> </td><td class="rblock">       <span class="insert">for (int i=0;i&lt;nbSide;++i)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">exArr, groundTexCoordArr);</span></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               sides[i].tex = sideTexs[i].texture;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       fogTex = renderer-&gt;createTexture(fogTexPath,</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                             TextureParams().generateMipmap</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">s().wrap(TextureWrap_Repeat));</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       fogTexCoord.tex = fogTex;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       groundTex = renderer-&gt;createTexture(groundTexPath, TextureParams().g</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">enerateMipmaps());</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       groundTexCoord.tex = groundTex;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       texturesInitialized = true;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">}</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">void LandscapeOldStyle::generatePrecomputedSides(StelRenderer* renderer)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">{</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       // Make slicesPerSide=(3&lt;&lt;K) so that the innermost polygon of the fa</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ndisk becomes a triangle:</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       const int slicesPerSide = std::max(1, 3 * 64 / (nbDecorRepeat * nbSi</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">de));</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Precompute the vertex arrays for side display</td><td> </td><td class="right">       // Precompute the vertex arrays for side display</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       static const int stacks = (calibrated ? 16 : 8); // GZ: 8-&gt;16, I nee
d better precision.</td><td> </td><td class="right">       static const int stacks = (calibrated ? 16 : 8); // GZ: 8-&gt;16, I nee
d better precision.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const double z0 = calibrated ?</td><td> </td><td class="right">       const double z0 = calibrated ?</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // GZ: For calibrated, we use z=decorAngleShift...(decorAltAngle-dec
orAngleShift), but we must compute the tan in the loop.</td><td> </td><td class="right">       // GZ: For calibrated, we use z=decorAngleShift...(decorAltAngle-dec
orAngleShift), but we must compute the tan in the loop.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       decorAngleShift : (tanMode ? radius * std::tan(decorAngleShift*M_PI/
180.f) : radius * std::sin(decorAngleShift*M_PI/180.f));</td><td> </td><td class="right">       decorAngleShift : (tanMode ? radius * std::tan(decorAngleShift*M_PI/
180.f) : radius * std::sin(decorAngleShift*M_PI/180.f));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // GZ: The old formula is completely meaningless for photos with ope
ning angle &gt;90,</td><td> </td><td class="right">       // GZ: The old formula is completely meaningless for photos with ope
ning angle &gt;90,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // and most likely also not what was intended for other images.</td><td> </td><td class="right">       // and most likely also not what was intended for other images.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Note that GZ fills this value with a different meaning!</td><td> </td><td class="right">       // Note that GZ fills this value with a different meaning!</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const double d_z = calibrated ? decorAltAngle/stacks : (tanMode ? ra
dius*std::tan(decorAltAngle*M_PI/180.f)/stacks : radius*std::sin(decorAltAn
gle*M_PI/180.0)/stacks);</td><td> </td><td class="right">       const double d_z = calibrated ? decorAltAngle/stacks : (tanMode ? ra
dius*std::tan(decorAltAngle*M_PI/180.f)/stacks : radius*std::sin(decorAltAn
gle*M_PI/180.0)/stacks);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0021" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       const float alpha = 2.f<span class="delete">*M_PI/(nbDecorRepeat*nbSide*slices_per_s</span>ide);</td><td> </td><td class="rblock">       const float alpha = 2.f<span class="insert"> * M_PI / (nbDecorRepeat * nbSide * slicesPer
S</span>ide);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const float ca = std::cos(alpha);</td><td> </td><td class="right">       const float ca = std::cos(alpha);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const float sa = std::sin(alpha);</td><td> </td><td class="right">       const float sa = std::sin(alpha);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       float y0 = radius*std::cos(angleRotateZ*M_PI/180.f);</td><td> </td><td class="right">       float y0 = radius*std::cos(angleRotateZ*M_PI/180.f);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       float x0 = radius*std::sin(angleRotateZ*M_PI/180.f);</td><td> </td><td class="right">       float x0 = radius*std::sin(angleRotateZ*M_PI/180.f);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       LOSSide precompSide;</td><td> </td><td class="right">       LOSSide precompSide;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0022" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">precompSide.arr.primitiveType=StelVertexArray::Triangles;</span></td><td> </td><td class="rblock">       for (int <span class="insert">n = 0; n &lt; nbDecorRepeat; n++)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       for (int <span class="delete">n=0;n&lt;nbDecorRepeat;n++)</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0023" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               for (int i<span class="delete">=0;i&lt;nbSide;</span>i++)</td><td> </td><td class="rblock">               for (int i<span class="insert"> = 0; i &lt; nbSide; </span>i++)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0024" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       <span class="delete">int ti;</span></td><td> </td><td class="rblock">                       if <span class="insert">(!texToSide.contains(i))</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       if <span class="delete">(texToSide.contains(i))</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                               ti = texToSide[i];</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       else</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       {</td><td> </td><td class="right">                       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               qDebug() &lt;&lt; QString("LandscapeOldStyle::load
 ERROR: found no corresponding tex value for side%1").arg(i);</td><td> </td><td class="right">                               qDebug() &lt;&lt; QString("LandscapeOldStyle::load
 ERROR: found no corresponding tex value for side%1").arg(i);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               break;</td><td> </td><td class="right">                               break;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       }</td><td> </td><td class="right">                       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0025" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       <span class="delete">precompSide.arr.vertex.resize(0);</span></td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       precompSide.arr.texCoords.resize(0);</span></td><td> </td><td class="rblock">                       <span class="insert">const int ti = texToSide[i];</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       precompSide.arr.indices.resize(0);</span></td><td> </td><td class="rblock"><span class="insert">                       precompSide.vertices =</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       precompSide.tex=sideTexs[ti];</span></td><td> </td><td class="rblock"><span class="insert">                               renderer-&gt;createVertexBuffer&lt;VertexP3T2&gt;(Pri</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">mitiveType_Triangles);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       precompSide.indices = renderer-&gt;createIndexBuffer(In</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">dexType_U16);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       precompSide.tex = sideTexs[ti].texture;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       float tx0 = sides[ti].texCoords[0];</td><td> </td><td class="right">                       float tx0 = sides[ti].texCoords[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0026" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       const float d_tx0 = <span class="delete">(sides[ti].texCoords[2]-sides[ti</span></td><td> </td><td class="rblock">                       const float d_tx0 = <span class="insert">(sides[ti].texCoords[2] - sides[</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">].texCoords[0])</span> / <span class="delete">slices_per_side;</span></td><td> </td><td class="rblock"><span class="insert">ti].texCoords[0])</span> / <span class="insert">slicesPerSide;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       const float d_ty = <span class="delete">(sides[ti].texCoords[3]-sides[ti]</span></td><td> </td><td class="rblock">                       const float d_ty  = <span class="insert">(sides[ti].texCoords[3] - sides[</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">.texCoords[1])</span> / stacks;</td><td> </td><td class="rblock"><span class="insert">ti].texCoords[1])</span> / stacks;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       for (int <span class="delete">j=0;j&lt;slices_per_side;j++)</span></td><td> </td><td class="rblock">                       for (int <span class="insert">j = 0; j &lt; slicesPerSide; j++)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       {</td><td> </td><td class="right">                       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0027" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                               const float y1 = <span class="delete">y0*ca</span> - <span class="delete">x0*sa;</span></td><td> </td><td class="rblock">                               const float y1  = <span class="insert">y0 * ca</span> - <span class="insert">x0 * sa;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                               const float x1 = <span class="delete">y0*sa</span> + <span class="delete">x0*ca;</span></td><td> </td><td class="rblock">                               const float x1  = <span class="insert">y0 * sa</span> + <span class="insert">x0 * ca;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               const float tx1 = tx0 + d_tx0;</td><td> </td><td class="right">                               const float tx1 = tx0 + d_tx0;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0028" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                               float z = z0;</td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                               float z   = z0;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               float ty0 = sides[ti].texCoords[1];</td><td> </td><td class="right">                               float ty0 = sides[ti].texCoords[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0029" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                               for (int <span class="delete">k=0;k&lt;=stacks*2;k+=2)</span></td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                               for (int <span class="insert">k = 0; k &lt;= stacks * 2; k += 2)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               {</td><td> </td><td class="right">                               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0030" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                       <span class="delete">precompSide.arr.texCoords &lt;&lt; Vec2f(t</span></td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">x0, ty0) &lt;&lt; Vec2f(tx1, ty0);</span></td><td> </td><td class="rblock">                                       <span class="insert">const</span> float <span class="insert">calibratedZ =</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                                       if (calibrated)</span></td><td> </td><td class="rblock"><span class="insert">                                               calibrated ? radius</span> * <span class="insert">std::t</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                                       {</span></td><td> </td><td class="rblock"><span class="insert">an(z * M_PI / 180.0f) : z;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                               float <span class="delete">tanZ=radius</span> * <span class="delete">std::tan</span></td><td> </td><td class="rblock"><span class="insert">                                       precompSide.vertices-&gt;addVertex</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">(z*M_PI/180.f);</span></td><td> </td><td class="rblock"><span class="insert">                                               (VertexP3T2(Vec3f(x0,</span> y0, <span class="insert">ca</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                                               precompSide.arr.vertex &lt;&lt; Ve</span></td><td> </td><td class="rblock"><span class="insert">libratedZ), Vec2f(tx0, ty0)));</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">c3d(x0, y0, tanZ) &lt;&lt; Vec3d(x1, y1, tanZ);</span></td><td> </td><td class="rblock"><span class="insert">                                       precompSide.vertices-&gt;addVertex</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                                       } else</span></td><td> </td><td class="rblock"><span class="insert">                                               (VertexP3T2(Vec3f(x1,</span> y1, <span class="insert">ca</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                                       {</span></td><td> </td><td class="rblock"><span class="insert">libratedZ), Vec2f(tx1, ty0)));</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                                               precompSide.arr.vertex &lt;&lt; Ve</span></td><td> </td><td class="rblock">                                       z   += d_z;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">c3d(x0,</span> y0, <span class="delete">z) &lt;&lt; Vec3d(x1,</span> y1, <span class="delete">z);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                                       }</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                       z += d_z;</td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                                       ty0 += d_ty;</td><td> </td><td class="right">                                       ty0 += d_ty;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               }</td><td> </td><td class="right">                               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0031" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                               <span class="delete">unsigned int</span> offset = j*(stacks+1)*2;</td><td> </td><td class="rblock">                               <span class="insert">const uint</span> offset = j*(stacks+1)*2;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                               for (int k = <span class="delete">2;k&lt;stacks*2+2;k+=2)</span></td><td> </td><td class="rblock">                               for (int k = <span class="insert">2; k &lt; stacks * 2 + 2; k += 2)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               {</td><td> </td><td class="right">                               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0032" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                       <span class="delete">precompSide.arr.indices &lt;&lt; offset+k-</span></td><td> </td><td class="rblock">                                       <span class="insert">precompSide.indices-&gt;addIndex(offset</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">2 &lt;&lt; offset+k-1 &lt;&lt; offset+k;</span></td><td> </td><td class="rblock"><span class="insert"> + k - 2);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                                       precompSide.arr.indices &lt;&lt; offset+k </span></td><td> </td><td class="rblock"><span class="insert">                                       precompSide.indices-&gt;addIndex(offset</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">&lt;&lt; offset+k-1 &lt;&lt; offset+k+1;</span></td><td> </td><td class="rblock"><span class="insert"> + k - 1);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                       precompSide.indices-&gt;addIndex(offset</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> + k);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                       precompSide.indices-&gt;addIndex(offset</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> + k);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                       precompSide.indices-&gt;addIndex(offset</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> + k - 1);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                       precompSide.indices-&gt;addIndex(offset</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> + k + 1);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               }</td><td> </td><td class="right">                               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0033" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                               y0 = y1;</td><td> </td><td class="rblock">                               y0  = y1;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                               x0 = x1;</td><td> </td><td class="rblock">                               x0  = x1;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               tx0 = tx1;</td><td> </td><td class="right">                               tx0 = tx1;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       }</td><td> </td><td class="right">                       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0034" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                       <span class="insert">precompSide.vertices-&gt;lock();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       precompSide.indices-&gt;lock();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       precomputedSides.append(precompSide);</td><td> </td><td class="right">                       precomputedSides.append(precompSide);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0035" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">void LandscapeOldStyle::draw(StelCore* core)</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">{</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       StelPainter painter(core-&gt;getProjection(StelCore::FrameAltAz, StelCo</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">re::RefractionOff));</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       glEnable(GL_BLEND);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       painter.enableTexture2d(true);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       glEnable(GL_CULL_FACE);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       if (!validLandscape)</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               return;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       if (drawGroundFirst)</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               drawGround(core, painter);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       drawDecor(core, painter);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       if (!drawGroundFirst)</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               drawGround(core, painter);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       drawFog(core, painter);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">}</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">// Draw the horizon fog</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">void LandscapeOldStyle::drawFog(StelCore* core, StelPainter&amp; sPainter) cons</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">t</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">{</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       if (!fogFader.getInterstate())</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               return;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       const float vpos = (tanMode||calibrated) ? radius*std::tan(fogAngleS</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">hift*M_PI/180.) : radius*std::sin(fogAngleShift*M_PI/180.);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       StelProjector::ModelViewTranformP transfo = core-&gt;getAltAzModelViewT</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">ransform(StelCore::RefractionOff);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       transfo-&gt;combine(Mat4d::translation(Vec3d(0.,0.,vpos)));</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       sPainter.setProjector(core-&gt;getProjection(transfo));</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       glBlendFunc(GL_ONE, GL_ONE);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       const float nightModeFilter = StelApp::getInstance().getVisionModeNi</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">ght() ? 0.f : 1.f;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       sPainter.setColor(fogFader.getInterstate()*(0.1f+0.1f*skyBrightness)</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">,</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                         fogFader.getInterstate()*(0.1f+0.1f*skyBrightness)</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">*nightModeFilter,</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                         fogFader.getInterstate()*(0.1f+0.1f*skyBrightness)</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">*nightModeFilter);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       fogTex-&gt;bind();</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       const float height = (tanMode||calibrated) ? radius*std::tan(fogAltA</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">ngle*M_PI/180.) : radius*std::sin(fogAltAngle*M_PI/180.);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       sPainter.sCylinder(radius, height, 64, 1);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">}</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                                                           </td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// Draw the mountains with a few pieces of texture</td><td> </td><td class="right">// Draw the mountains with a few pieces of texture</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0036" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">void LandscapeOldStyle::drawDecor(StelCore* core, Stel<span class="delete">Painter&amp; sPainter) co
nst</span></td><td> </td><td class="rblock">void LandscapeOldStyle::drawDecor(StelCore* core, Stel<span class="insert">Renderer* renderer)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0037" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       if (!landFader.getInterstate()) {return;}</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Patched by Georg Zotti: I located an undocumented switch tan_mode
, maybe tan_mode=true means cylindrical panorama projection.</td><td> </td><td class="right">       // Patched by Georg Zotti: I located an undocumented switch tan_mode
, maybe tan_mode=true means cylindrical panorama projection.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // anyway, the old code makes unfortunately no sense.</td><td> </td><td class="right">       // anyway, the old code makes unfortunately no sense.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // I added a switch "calibrated" for the ini file. If true, it works
 as this landscape apparently was originally intended.</td><td> </td><td class="right">       // I added a switch "calibrated" for the ini file. If true, it works
 as this landscape apparently was originally intended.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // So I corrected the texture coordinates so that decorAltAngle is t
he total angle, decorAngleShift the lower angle,</td><td> </td><td class="right">       // So I corrected the texture coordinates so that decorAltAngle is t
he total angle, decorAngleShift the lower angle,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // and the texture in between is correctly stretched.</td><td> </td><td class="right">       // and the texture in between is correctly stretched.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // TODO: (1) Replace fog cylinder by similar texture, which could be
 painted as image layer in Photoshop/Gimp.</td><td> </td><td class="right">       // TODO: (1) Replace fog cylinder by similar texture, which could be
 painted as image layer in Photoshop/Gimp.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //       (2) Implement calibrated &amp;&amp; tan_mode</td><td> </td><td class="right">       //       (2) Implement calibrated &amp;&amp; tan_mode</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0038" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       StelProjector::ModelViewTranformP <span class="delete">transfo</span> = <span class="delete">core-&gt;getAltAzModelViewT</span></td><td> </td><td class="rblock">       StelProjector::ModelViewTranformP <span class="insert">transform</span> =</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">ransform(StelCore::RefractionOff);</span></td><td> </td><td class="rblock">               <span class="insert">core-&gt;getAltAzModelViewTransform(StelCore::RefractionOff);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       transfo-&gt;combine(Mat4d::zrotation(-angleRotateZOffset*M_PI/180.f));</span></td><td> </td><td class="rblock"><span class="insert">       transform-&gt;combine(Mat4d::zrotation(-angleRotateZOffset*M_PI/180.f))</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       StelProjectorP projector = core-&gt;getProjection(transform);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0039" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">sPainter.setProjector(core-&gt;getProjection(transfo));</span></td><td> </td><td class="rblock">       <span class="insert">const Vec4f color = StelApp::getInstance().getVisionModeNight()</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                         ? Vec4f(skyBrightness*nightBrightness, 0.0, 0.0, l</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">andFader.getInterstate())</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                         : Vec4f(skyBrightness, skyBrightness, skyBrightnes</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">s, landFader.getInterstate());</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       renderer-&gt;setGlobalColor(color);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0040" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">if (!landFader.getInterstate())</span></td><td> </td><td class="rblock">       <span class="insert">// Lazily generate decoration sides.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               return;</span></td><td> </td><td class="rblock"><span class="insert">       if(precomputedSides.empty())</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       if (StelApp::getInstance().getVisionModeNight())</span></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               sPainter.setColor(skyBrightness*nightBrightness, 0.0, 0.0, l</span></td><td> </td><td class="rblock"><span class="insert">               generatePrecomputedSides(renderer);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">andFader.getInterstate());</span></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       else</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               sPainter.setColor(skyBrightness, skyBrightness, skyBrightnes</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">s, landFader.getInterstate());</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0041" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       // Draw decoration sides.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       foreach (const LOSSide&amp; side, precomputedSides)</td><td> </td><td class="right">       foreach (const LOSSide&amp; side, precomputedSides)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               side.tex-&gt;bind();</td><td> </td><td class="right">               side.tex-&gt;bind();</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0042" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               <span class="delete">sPainter.drawSphericalTriangles(side.arr, true, NULL, false)
</span>;</td><td> </td><td class="rblock">               <span class="insert">renderer-&gt;drawVertexBuffer(side.vertices, side.indices, proj
ector)</span>;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0043" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">void LandscapeOldStyle::generateGroundFanDisk(StelRenderer* renderer)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">{</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       // Precompute the vertex buffer for ground display</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       // Make slicesPerSide = (3&lt;&lt;K) so that the</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       // innermost polygon of the fandisk becomes a triangle:</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       int slicesPerSide = std::max(1, 3 * 64 / (nbDecorRepeat * nbSide));</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       // draw a fan disk instead of a ordinary disk so that the inner slic</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">es</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       // are not so slender. When they are too slender, culling errors occ</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ur</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       // in cylinder projection mode.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       int slicesInside = nbSide * slicesPerSide * nbDecorRepeat;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       int level = 0;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       while ((slicesInside &amp; 1) == 0 &amp;&amp; slicesInside &gt; 4)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               ++level;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               slicesInside &gt;&gt;= 1;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       groundFanDisk = renderer-&gt;createVertexBuffer&lt;VertexP3T2&gt;(PrimitiveTy</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">pe_Triangles);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       groundFanDiskIndices = renderer-&gt;createIndexBuffer(IndexType_U16);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       StelGeometryBuilder()</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               .buildFanDisk(groundFanDisk, groundFanDiskIndices, radius, s</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">licesInside, level);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">}</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// Draw the ground</td><td> </td><td class="right">// Draw the ground</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0044" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">void LandscapeOldStyle::drawGround(StelCore* core, Stel<span class="delete">Painter&amp; sPainter) c
onst</span></td><td> </td><td class="rblock">void LandscapeOldStyle::drawGround(StelCore* core, Stel<span class="insert">Renderer* renderer)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0045" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       if (!landFader.getInterstate())</td><td> </td><td class="rblock">       if (!landFader.getInterstate()) <span class="insert">{return;}</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               <span class="delete">return;</span></td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       const float vshift = (tanMode || calibrated) ?</td><td> </td><td class="rblock">       const float vshift = (tanMode || calibrated)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">         <span class="delete">radius*std::tan(groundAngleShift*M_PI/180.)</span> :</td><td> </td><td class="rblock">                          ? <span class="insert">radius * std::tan(groundAngleShift * M_PI / 180</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">         <span class="delete">radius*std::sin(groundAngleShift*M_PI/180.);</span></td><td> </td><td class="rblock"><span class="insert">.0f)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       StelProjector::ModelViewTranformP <span class="delete">transfo</span> = <span class="delete">core-&gt;getAltAzModelViewT</span></td><td> </td><td class="rblock">                          : <span class="insert">radius * std::sin(groundAngleShift * M_PI / 180</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">ransform(StelCore::RefractionOff);</span></td><td> </td><td class="rblock"><span class="insert">.0f);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       transfo-&gt;combine(Mat4d::zrotation((groundAngleRotateZ-angleRotateZOf</span></td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">fset)*M_PI/180.f) * Mat4d::translation(Vec3d(0,0,vshift)));</span></td><td> </td><td class="rblock">       StelProjector::ModelViewTranformP <span class="insert">transform =</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"><span class="insert">               core-&gt;getAltAzModelViewTransform(StelCore::RefractionOff);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       sPainter.setProjector(core-&gt;getProjection(transfo));</span></td><td> </td><td class="rblock"><span class="insert">       transform-&gt;combine</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       if (StelApp::getInstance().getVisionModeNight())</span></td><td> </td><td class="rblock"><span class="insert">               (Mat4d::zrotation((groundAngleRotateZ - angleRotateZOffset) </span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               sPainter.setColor(skyBrightness*nightBrightness,</span> 0.0, 0.0, l</td><td> </td><td class="rblock"><span class="insert">* M_PI / 180.0f) *</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">andFader.getInterstate());</span></td><td> </td><td class="rblock"><span class="insert">                Mat4d::translation(Vec3d(0.0, 0.0, vshift)));</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       else</span></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               sPainter.setColor(skyBrightness,</span> skyBrightness, skyBrightnes</td><td> </td><td class="rblock"><span class="insert">       StelProjectorP projector = core-&gt;getProjection(transform);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">s, landFader.getInterstate());</td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       const Vec4f color</span> = <span class="insert">StelApp::getInstance().getVisionModeNight()</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                         ? Vec4f(skyBrightness*nightBrightness,</span> 0.0, 0.0, l</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">andFader.getInterstate())</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                         : Vec4f(skyBrightness,</span> skyBrightness, skyBrightnes</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">s, landFader.getInterstate());</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">renderer-&gt;setGlobalColor(color);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       groundTex-&gt;bind();</td><td> </td><td class="right">       groundTex-&gt;bind();</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0046" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">sPainter.setArrays((Vec3d*)groundVertexArr.constData(), (Vec2f*)grou</span></td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">ndTexCoordArr.constData());</span></td><td> </td><td class="rblock">       <span class="insert">// Lazily generate the ground fan disk.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       sPainter.drawFromArray(StelPainter::Triangles, groundVertexArr.size(</span></td><td> </td><td class="rblock"><span class="insert">       if(NULL == groundFanDisk)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">)/3);</span></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               Q_ASSERT_X(NULL == groundFanDiskIndices, Q_FUNC_INFO,</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                          "Vertex buffer is NULL but index buffer is alread</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">y generated");</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               generateGroundFanDisk(renderer);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       // Draw the ground.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       renderer-&gt;drawVertexBuffer(groundFanDisk, groundFanDiskIndices, proj</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ector);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0047" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">LandscapeFisheye::LandscapeFisheye(float _radius) : Landscape(_radius)</td><td> </td><td class="rblock">LandscapeFisheye::LandscapeFisheye(float _radius)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       : Landscape(_radius)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">, mapTex(NULL)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       , fisheyeSphere(NULL)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{}</td><td> </td><td class="right">{}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">LandscapeFisheye::~LandscapeFisheye()</td><td> </td><td class="right">LandscapeFisheye::~LandscapeFisheye()</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0048" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">if(NULL != fisheyeSphere)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               delete fisheyeSphere;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       if(NULL != mapTex)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               delete mapTex;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void LandscapeFisheye::load(const QSettings&amp; landscapeIni, const QString&amp; l
andscapeId)</td><td> </td><td class="right">void LandscapeFisheye::load(const QSettings&amp; landscapeIni, const QString&amp; l
andscapeId)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       loadCommon(landscapeIni, landscapeId);</td><td> </td><td class="right">       loadCommon(landscapeIni, landscapeId);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       QString type = landscapeIni.value("landscape/type").toString();</td><td> </td><td class="right">       QString type = landscapeIni.value("landscape/type").toString();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if(type != "fisheye")</td><td> </td><td class="right">       if(type != "fisheye")</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               qWarning() &lt;&lt; "Landscape type mismatch for landscape "&lt;&lt; lan
dscapeId &lt;&lt; ", expected fisheye, found " &lt;&lt; type &lt;&lt; ".  No landscape in use
.\n";</td><td> </td><td class="right">               qWarning() &lt;&lt; "Landscape type mismatch for landscape "&lt;&lt; lan
dscapeId &lt;&lt; ", expected fisheye, found " &lt;&lt; type &lt;&lt; ".  No landscape in use
.\n";</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l4" /><small>skipping to change at</small><em> line 467</em></th><th> </th><th><a name="part-r4" /><small>skipping to change at</small><em> line 613</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               landscapeIni.value("landscape/texturefov", 360).toFloat(),</td><td> </td><td class="right">               landscapeIni.value("landscape/texturefov", 360).toFloat(),</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               landscapeIni.value("landscape/angle_rotatez", 0.).toFloat())
;</td><td> </td><td class="right">               landscapeIni.value("landscape/angle_rotatez", 0.).toFloat())
;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// create a fisheye landscape from basic parameters (no ini file needed)</td><td> </td><td class="right">// create a fisheye landscape from basic parameters (no ini file needed)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void LandscapeFisheye::create(const QString _name, const QString&amp; _maptex, 
float atexturefov, float aangleRotateZ)</td><td> </td><td class="right">void LandscapeFisheye::create(const QString _name, const QString&amp; _maptex, 
float atexturefov, float aangleRotateZ)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // qDebug() &lt;&lt; _name &lt;&lt; " " &lt;&lt; _fullpath &lt;&lt; " " &lt;&lt; _maptex &lt;&lt; " " &lt;&lt;
 _texturefov;</td><td> </td><td class="right">       // qDebug() &lt;&lt; _name &lt;&lt; " " &lt;&lt; _fullpath &lt;&lt; " " &lt;&lt; _maptex &lt;&lt; " " &lt;&lt;
 _texturefov;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       validLandscape = 1;  // assume ok...</td><td> </td><td class="right">       validLandscape = 1;  // assume ok...</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       name = _name;</td><td> </td><td class="right">       name = _name;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0049" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       mapTex<span class="delete"> = StelApp::getInstance().getTextureManager().createTexture(_m
aptex, StelTexture::StelTextureParams(true))</span>;</td><td> </td><td class="rblock">       mapTex<span class="insert">Path = _maptex</span>;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       texFov = atexturefov*M_PI/180.f;</td><td> </td><td class="right">       texFov = atexturefov*M_PI/180.f;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       angleRotateZ = aangleRotateZ*M_PI/180.f;</td><td> </td><td class="right">       angleRotateZ = aangleRotateZ*M_PI/180.f;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0050" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">const SphereParams params = SphereParams(radius).resolution(cols, ro</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ws).orientInside();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       fisheyeSphere = StelGeometryBuilder().buildSphereFisheye(params, tex</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">Fov);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0051" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">void LandscapeFisheye::draw(StelCore* core)</td><td> </td><td class="rblock">void LandscapeFisheye::draw(StelCore* core<span class="insert">, StelRenderer* renderer</span>)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if(!validLandscape) return;</td><td> </td><td class="right">       if(!validLandscape) return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if(!landFader.getInterstate()) return;</td><td> </td><td class="right">       if(!landFader.getInterstate()) return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0052" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">StelProjector::ModelViewTranformP transfo</span> = <span class="delete">core-&gt;getAltAzModelViewT</span></td><td> </td><td class="rblock">       <span class="insert">if(NULL == mapTex)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">ransform(StelCore::RefractionOff);</span></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       transfo-&gt;combine(Mat4d::zrotation(-(angleRotateZ+(angleRotateZOffset</span></td><td> </td><td class="rblock"><span class="insert">               mapTex</span> = <span class="insert">renderer-&gt;createTexture(mapTexPath, TextureParams()</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">*M_PI/180.))));</span></td><td> </td><td class="rblock"><span class="insert">.generateMipmaps());</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       const StelProjectorP prj = core-&gt;getProjection(transfo);</span></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       StelPainter sPainter(prj);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       // Normal transparency mode</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       if (StelApp::getInstance().getVisionModeNight())</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               sPainter.setColor(skyBrightness*nightBrightness, 0.0, 0.0, l</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">andFader.getInterstate());</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       else</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               sPainter.setColor(skyBrightness, skyBrightness, skyBrightnes</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">s, landFader.getInterstate());</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0053" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">glEnable(GL_CULL_FACE);</span></td><td> </td><td class="rblock">       <span class="insert">StelProjector::ModelViewTranformP transform = core-&gt;getAltAzModelVie</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       sPainter.enableTexture2d(true);</span></td><td> </td><td class="rblock"><span class="insert">wTransform(StelCore::RefractionOff);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       glEnable(GL_BLEND);</span></td><td> </td><td class="rblock"><span class="insert">       transform-&gt;combine(Mat4d::zrotation(-(angleRotateZ+(angleRotateZOffs</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">et*M_PI/180.))));</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       const StelProjectorP projector = core-&gt;getProjection(transform);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       const Vec4f color = StelApp::getInstance().getVisionModeNight()</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                         ? Vec4f(skyBrightness*nightBrightness, 0.0, 0.0, l</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">andFader.getInterstate())</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                         : Vec4f(skyBrightness, skyBrightness, skyBrightnes</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">s, landFader.getInterstate());</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       renderer-&gt;setGlobalColor(color);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       renderer-&gt;setCulledFaces(CullFace_Back);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       renderer-&gt;setBlendMode(BlendMode_Alpha);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       mapTex-&gt;bind();</td><td> </td><td class="right">       mapTex-&gt;bind();</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0054" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">// Patch GZ: (40,20)-&gt;(cols,rows)</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       sPainter.sSphereMap(radius,cols,rows,texFov,1);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0055" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">glDisable(GL_CULL_FACE);</span></td><td> </td><td class="rblock">       <span class="insert">fisheyeSphere-&gt;draw(renderer, projector);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       renderer-&gt;setCulledFaces(CullFace_None);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// spherical panoramas</td><td> </td><td class="right">// spherical panoramas</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0056" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">LandscapeSpherical::LandscapeSpherical(float _radius) : Landscape(_radius)</td><td> </td><td class="rblock">LandscapeSpherical::LandscapeSpherical(float _radius)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">{}</span></td><td> </td><td class="rblock">       : Landscape(_radius)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">, mapTex(NULL)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">{</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">}</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">LandscapeSpherical::~LandscapeSpherical()</td><td> </td><td class="right">LandscapeSpherical::~LandscapeSpherical()</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0057" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">if(NULL != landscapeSphere)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               delete landscapeSphere;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               landscapeSphere = NULL;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       if(NULL != mapTex)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               delete mapTex;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void LandscapeSpherical::load(const QSettings&amp; landscapeIni, const QString&amp;
 landscapeId)</td><td> </td><td class="right">void LandscapeSpherical::load(const QSettings&amp; landscapeIni, const QString&amp;
 landscapeId)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       loadCommon(landscapeIni, landscapeId);</td><td> </td><td class="right">       loadCommon(landscapeIni, landscapeId);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       QString type = landscapeIni.value("landscape/type").toString();</td><td> </td><td class="right">       QString type = landscapeIni.value("landscape/type").toString();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (type != "spherical")</td><td> </td><td class="right">       if (type != "spherical")</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               qWarning() &lt;&lt; "Landscape type mismatch for landscape "&lt;&lt; lan
dscapeId</td><td> </td><td class="right">               qWarning() &lt;&lt; "Landscape type mismatch for landscape "&lt;&lt; lan
dscapeId</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l5" /><small>skipping to change at</small><em> line 532</em></th><th> </th><th><a name="part-r5" /><small>skipping to change at</small><em> line 692</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       create(name, getTexturePath(landscapeIni.value("landscape/maptex").t
oString(), landscapeId),</td><td> </td><td class="right">       create(name, getTexturePath(landscapeIni.value("landscape/maptex").t
oString(), landscapeId),</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               landscapeIni.value("landscape/angle_rotatez", 0.f).toFloat()
);</td><td> </td><td class="right">               landscapeIni.value("landscape/angle_rotatez", 0.f).toFloat()
);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// create a spherical landscape from basic parameters (no ini file needed)</td><td> </td><td class="right">// create a spherical landscape from basic parameters (no ini file needed)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void LandscapeSpherical::create(const QString _name, const QString&amp; _maptex
, float _angleRotateZ)</td><td> </td><td class="right">void LandscapeSpherical::create(const QString _name, const QString&amp; _maptex
, float _angleRotateZ)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // qDebug() &lt;&lt; _name &lt;&lt; " " &lt;&lt; _fullpath &lt;&lt; " " &lt;&lt; _maptex &lt;&lt; " " &lt;&lt;
 _texturefov;</td><td> </td><td class="right">       // qDebug() &lt;&lt; _name &lt;&lt; " " &lt;&lt; _fullpath &lt;&lt; " " &lt;&lt; _maptex &lt;&lt; " " &lt;&lt;
 _texturefov;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       validLandscape = 1;  // assume ok...</td><td> </td><td class="right">       validLandscape = 1;  // assume ok...</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       name = _name;</td><td> </td><td class="right">       name = _name;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0058" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       mapTex = StelApp::getInstance().getTextureManager().createTexture(_m
aptex, StelTexture::StelTextureParams(true));</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       angleRotateZ = _angleRotateZ*M_PI/180.f;</td><td> </td><td class="right">       angleRotateZ = _angleRotateZ*M_PI/180.f;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0059" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">mapTexPath = _maptex;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       const SphereParams params</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               = SphereParams(radius).resolution(64, 48).orientInside().fli</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">pTexture();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       landscapeSphere = StelGeometryBuilder().buildSphereUnlit(params);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0060" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">void LandscapeSpherical::draw(StelCore* core)</td><td> </td><td class="rblock">void LandscapeSpherical::draw(StelCore* core<span class="insert">, StelRenderer* renderer</span>)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if(!validLandscape) return;</td><td> </td><td class="right">       if(!validLandscape) return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if(!landFader.getInterstate()) return;</td><td> </td><td class="right">       if(!landFader.getInterstate()) return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0061" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">if(NULL == mapTex)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               mapTex = renderer-&gt;createTexture(mapTexPath, TextureParams()</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">.generateMipmaps());</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0062" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       StelProjector::ModelViewTranformP <span class="delete">transfo</span> = <span class="delete">core-&gt;getAltAzModelViewT</span></td><td> </td><td class="rblock">       StelProjector::ModelViewTranformP <span class="insert">transform</span> = <span class="insert">core-&gt;getAltAzModelVie</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">ransform(StelCore::RefractionOff);</span></td><td> </td><td class="rblock"><span class="insert">wTransform(StelCore::RefractionOff);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       transfo-&gt;combine(Mat4d::zrotation(-(angleRotateZ+(angleRotateZOffset</span></td><td> </td><td class="rblock"><span class="insert">       transform-&gt;combine(Mat4d::zrotation(-(angleRotateZ+(angleRotateZOffs</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">*M_PI/180.))));</span></td><td> </td><td class="rblock"><span class="insert">et*M_PI/180.))));</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       const StelProjectorP <span class="delete">prj</span> = <span class="delete">core-&gt;getProjection(transfo);</span></td><td> </td><td class="rblock">       const StelProjectorP <span class="insert">projector</span> = <span class="insert">core-&gt;getProjection(transform);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       StelPainter sPainter(prj);</span></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"><span class="insert">       renderer-&gt;setBlendMode(BlendMode_Alpha);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       // Normal transparency mode</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       if (StelApp::getInstance().getVisionModeNight())</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               sPainter.setColor(skyBrightness*nightBrightness, 0.0, 0.0, l</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">andFader.getInterstate());</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       else</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               sPainter.setColor(skyBrightness, skyBrightness, skyBrightnes</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">s, landFader.getInterstate());</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0063" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">glEnable(GL_CULL_FACE);</span></td><td> </td><td class="rblock">       <span class="insert">const Vec4f color = StelApp::getInstance().getVisionModeNight()</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       sPainter.enableTexture2d(true);</span></td><td> </td><td class="rblock"><span class="insert">                         ? Vec4f(skyBrightness*nightBrightness, 0.0, 0.0, l</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       glEnable(GL_BLEND);</span></td><td> </td><td class="rblock"><span class="insert">andFader.getInterstate())</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                         : Vec4f(skyBrightness, skyBrightness, skyBrightnes</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">s, landFader.getInterstate());</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       renderer-&gt;setGlobalColor(color);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       renderer-&gt;setCulledFaces(CullFace_Back);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       mapTex-&gt;bind();</td><td> </td><td class="right">       mapTex-&gt;bind();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0064" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       landscapeSphere-&gt;draw(renderer, projector);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // TODO: verify that this works correctly for custom projections</td><td> </td><td class="right">       // TODO: verify that this works correctly for custom projections</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // seam is at East</td><td> </td><td class="right">       // seam is at East</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0065" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       //sPainter.sSphere(radius, 1.0, 40, 20, 1, true);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // GZ: Want better angle resolution, optional!</td><td> </td><td class="right">       // GZ: Want better angle resolution, optional!</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0066" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">sPainter.sSphere(radius, 1.0, cols, rows, 1, true);</span></td><td> </td><td class="rblock">       <span class="insert">renderer-&gt;setCulledFaces(CullFace_None);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       glDisable(GL_CULL_FACE);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>

     <tr><td></td><td class="left"></td><td> </td><td class="right"></td><td></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 66 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><td></td><th><i>216 lines changed or deleted</i></th><th><i> </i></th><th><i>387 lines changed or added</i></th><td></td></tr>
     <tr><td colspan="5" align="center" class="small"><br/>This html diff was produced by rfcdiff 1.41. The latest version is available from <a href="http://www.tools.ietf.org/tools/rfcdiff/" >http://tools.ietf.org/tools/rfcdiff/</a> </td></tr>
   </table>
   </body>
   </html>
