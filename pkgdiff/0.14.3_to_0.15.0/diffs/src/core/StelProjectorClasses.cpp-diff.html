<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"> 
<!-- Generated by rfcdiff 1.41: rfcdiff  --> 
<!-- <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional" > -->
<!-- System: Linux fomalhaut.home 3.13.0-92-generic #139-Ubuntu SMP Tue Jun 28 20:42:26 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux --> 
<!-- Using awk: /usr/bin/gawk: GNU Awk 4.0.1 --> 
<!-- Using diff: /usr/bin/diff: diff (GNU diffutils) 3.3 --> 
<!-- Using wdiff: /usr/bin/wdiff: wdiff (GNU wdiff) 1.2.1 --> 
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"> 
<head> 
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /> 
  <meta http-equiv="Content-Style-Type" content="text/css" /> 
  <title>Diff: StelProjectorClasses.cpp - StelProjectorClasses.cpp</title> 
  <style type="text/css"> 
    body    { font-size:16px; margin: 0.4ex; margin-right: auto; } 
    tr      { } 
    td      { white-space: pre; font-family: Consolas, "DejaVu Sans Mono", "Droid Sans Mono", Monaco, Monospace; vertical-align: top; font-size: 0.86em;} 
    th      { font-size: 0.86em; } 
    .small  { font-size: 0.6em; font-style: italic; font-family: Verdana, Helvetica, sans-serif; } 
    .left   { background-color: #EEE; } 
    .right  { background-color: #FFF; } 
    .diff   { background-color: #CCF; } 
    .lblock { background-color: #BFB; } 
    .rblock { background-color: #FF8; } 
    .insert { background-color: #8FF; } 
    .delete { background-color: #ACF; } 
    .void   { background-color: #FFB; } 
    .cont   { background-color: #EEE; } 
    .linebr { background-color: #AAA; } 
    .lineno { color: red; background-color: #FFF; font-size: 0.7em; text-align: right; padding: 0 2px; } 
    .elipsis{ background-color: #AAA; } 
    .left .cont { background-color: #DDD; } 
    .right .cont { background-color: #EEE; } 
    .lblock .cont { background-color: #9D9; } 
    .rblock .cont { background-color: #DD6; } 
    .insert .cont { background-color: #0DD; } 
    .delete .cont { background-color: #8AD; } 
    .stats, .stats td, .stats th { background-color: #EEE; padding: 2px 0; } 
  </style> 
</head> 
<body > 
  <table border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th></th><th>&nbsp;StelProjectorClasses.cpp&nbsp;</th><th> </th><th>&nbsp;StelProjectorClasses.cpp&nbsp;</th><th></th></tr> 
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l1" /><small>skipping to change at</small><em> line 32</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 32</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#include &lt;limits&gt;</td><td> </td><td class="right">#include &lt;limits&gt;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">QString StelProjectorPerspective::getNameI18() const</td><td> </td><td class="right">QString StelProjectorPerspective::getNameI18() const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       return q_("Perspective");</td><td> </td><td class="right">       return q_("Perspective");</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">QString StelProjectorPerspective::getDescriptionI18() const</td><td> </td><td class="right">QString StelProjectorPerspective::getDescriptionI18() const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       return q_("Perspective projection <span class="delete">keeps the horizon a straight line.
 The mathematical name for this projection method is &lt;i&gt;gnomonic projection
&lt;/i&gt;.")</span>;</td><td> </td><td class="rblock">       return q_("Perspective projection <span class="insert">maps the horizon and other great c
ircles like equator, ecliptic, hour lines, etc. into straight lines. The ma
thematical name for this projection method is &lt;i&gt;gnomonic projection&lt;/i&gt;.")
</span>;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">bool StelProjectorPerspective::forward(Vec3f &amp;v) const</td><td> </td><td class="right">bool StelProjectorPerspective::forward(Vec3f &amp;v) const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const float r = std::sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);</td><td> </td><td class="right">       const float r = std::sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (v[2] &lt; 0) {</td><td> </td><td class="right">       if (v[2] &lt; 0) {</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0002" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               v[0] <span class="delete">/= (-</span>v[2]);</td><td> </td><td class="rblock">               v[0] <span class="insert">*= (-widthStretch/</span>v[2]);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               v[1] /= (-v[2]);</td><td> </td><td class="right">               v[1] /= (-v[2]);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               v[2] = r;</td><td> </td><td class="right">               v[2] = r;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return true;</td><td> </td><td class="right">               return true;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (v[2] &gt; 0) {</td><td> </td><td class="right">       if (v[2] &gt; 0) {</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0003" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               v[0] <span class="delete">/= </span>v[2];</td><td> </td><td class="rblock">               v[0] <span class="insert">*= widthStretch/</span>v[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               v[1] /= v[2];</td><td> </td><td class="right">               v[1] /= v[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               v[2] = -std::numeric_limits&lt;float&gt;::max();</td><td> </td><td class="right">               v[2] = -std::numeric_limits&lt;float&gt;::max();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return false;</td><td> </td><td class="right">               return false;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       v[0] = std::numeric_limits&lt;float&gt;::max();</td><td> </td><td class="right">       v[0] = std::numeric_limits&lt;float&gt;::max();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       v[1] = std::numeric_limits&lt;float&gt;::max();</td><td> </td><td class="right">       v[1] = std::numeric_limits&lt;float&gt;::max();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       v[2] = -std::numeric_limits&lt;float&gt;::max();</td><td> </td><td class="right">       v[2] = -std::numeric_limits&lt;float&gt;::max();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       return false;</td><td> </td><td class="right">       return false;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">bool StelProjectorPerspective::backward(Vec3d &amp;v) const</td><td> </td><td class="right">bool StelProjectorPerspective::backward(Vec3d &amp;v) const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0004" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       v[0] /= widthStretch;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       v[2] = std::sqrt(1.0/(1.0+v[0]*v[0]+v[1]*v[1]));</td><td> </td><td class="right">       v[2] = std::sqrt(1.0/(1.0+v[0]*v[0]+v[1]*v[1]));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       v[0] *= v[2];</td><td> </td><td class="right">       v[0] *= v[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       v[1] *= v[2];</td><td> </td><td class="right">       v[1] *= v[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       v[2] = -v[2];</td><td> </td><td class="right">       v[2] = -v[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       return true;</td><td> </td><td class="right">       return true;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">float StelProjectorPerspective::fovToViewScalingFactor(float fov) const</td><td> </td><td class="right">float StelProjectorPerspective::fovToViewScalingFactor(float fov) const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       return std::tan(fov);</td><td> </td><td class="right">       return std::tan(fov);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l2" /><small>skipping to change at</small><em> line 90</em></th><th> </th><th><a name="part-r2" /><small>skipping to change at</small><em> line 91</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       return vsf / (1.f+vsf*vsf);</td><td> </td><td class="right">       return vsf / (1.f+vsf*vsf);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">QString StelProjectorEqualArea::getNameI18() const</td><td> </td><td class="right">QString StelProjectorEqualArea::getNameI18() const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       return q_("Equal Area");</td><td> </td><td class="right">       return q_("Equal Area");</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">QString StelProjectorEqualArea::getDescriptionI18() const</td><td> </td><td class="right">QString StelProjectorEqualArea::getDescriptionI18() const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0005" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       return q_("The full name of this projection method is<span class="delete">, &lt;i&gt;Lambert az
imuthal equal-area projection&lt;/i&gt;. It preserves the area but not the angle.
"</span>);</td><td> </td><td class="rblock">       return q_("The full name of this projection method is<span class="insert"> &lt;i&gt;Lambert azi
muthal equal-area projection&lt;/i&gt;. It preserves the area but not the angle."
</span>);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">bool StelProjectorEqualArea::forward(Vec3f &amp;v) const</td><td> </td><td class="right">bool StelProjectorEqualArea::forward(Vec3f &amp;v) const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const float r = std::sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);</td><td> </td><td class="right">       const float r = std::sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const float f = std::sqrt(2.f/(r*(r-v[2])));</td><td> </td><td class="right">       const float f = std::sqrt(2.f/(r*(r-v[2])));</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0006" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       v[0] *= f;</td><td> </td><td class="rblock">       v[0] *= f<span class="insert">*widthStretch</span>;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       v[1] *= f;</td><td> </td><td class="right">       v[1] *= f;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       v[2] = r;</td><td> </td><td class="right">       v[2] = r;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       return true;</td><td> </td><td class="right">       return true;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">bool StelProjectorEqualArea::backward(Vec3d &amp;v) const</td><td> </td><td class="right">bool StelProjectorEqualArea::backward(Vec3d &amp;v) const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0007" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       v[0] /= widthStretch;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // FIXME: for high FoV, return false but don't cause crash with Mous
e Pointer Coordinates.</td><td> </td><td class="right">       // FIXME: for high FoV, return false but don't cause crash with Mous
e Pointer Coordinates.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const double dq = v[0]*v[0] + v[1]*v[1];</td><td> </td><td class="right">       const double dq = v[0]*v[0] + v[1]*v[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       double l = 1.0 - 0.25*dq;</td><td> </td><td class="right">       double l = 1.0 - 0.25*dq;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (l &lt; 0)</td><td> </td><td class="right">       if (l &lt; 0)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               v[0] = 0.0;</td><td> </td><td class="right">               v[0] = 0.0;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               v[1] = 0.0;</td><td> </td><td class="right">               v[1] = 0.0;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               v[2] = 1.0;</td><td> </td><td class="right">               v[2] = 1.0;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               //return false; // GZ tentative fix for projecting invalid o
utlying screen point. CAUSES CRASH SOMETIMES!?</td><td> </td><td class="right">               //return false; // GZ tentative fix for projecting invalid o
utlying screen point. CAUSES CRASH SOMETIMES!?</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l3" /><small>skipping to change at</small><em> line 147</em></th><th> </th><th><a name="part-r3" /><small>skipping to change at</small><em> line 149</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       return fov;</td><td> </td><td class="right">       return fov;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">QString StelProjectorStereographic::getNameI18() const</td><td> </td><td class="right">QString StelProjectorStereographic::getNameI18() const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       return q_("Stereographic");</td><td> </td><td class="right">       return q_("Stereographic");</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">QString StelProjectorStereographic::getDescriptionI18() const</td><td> </td><td class="right">QString StelProjectorStereographic::getDescriptionI18() const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0008" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       return q_("Stereographic projection is known since <span class="delete">the antiquity and
 was originally known as the planisphere projection. It preserves the angle
s at</span> which curves cross each other but it does not preserve area.");</td><td> </td><td class="rblock">       return q_("Stereographic projection is known since <span class="insert">antiquity and was
 originally known as the planisphere projection. It preserves the angles at
</span> which curves cross each other but it does not preserve area.");</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">bool StelProjectorStereographic::forward(Vec3f &amp;v) const</td><td> </td><td class="right">bool StelProjectorStereographic::forward(Vec3f &amp;v) const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const float r = std::sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);</td><td> </td><td class="right">       const float r = std::sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const float h = 0.5f*(r-v[2]);</td><td> </td><td class="right">       const float h = 0.5f*(r-v[2]);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (h &lt;= 0.f) {</td><td> </td><td class="right">       if (h &lt;= 0.f) {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               v[0] = std::numeric_limits&lt;float&gt;::max();</td><td> </td><td class="right">               v[0] = std::numeric_limits&lt;float&gt;::max();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               v[1] = std::numeric_limits&lt;float&gt;::max();</td><td> </td><td class="right">               v[1] = std::numeric_limits&lt;float&gt;::max();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               v[2] = -std::numeric_limits&lt;float&gt;::min();</td><td> </td><td class="right">               v[2] = -std::numeric_limits&lt;float&gt;::min();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return false;</td><td> </td><td class="right">               return false;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const float f = 1.f / h;</td><td> </td><td class="right">       const float f = 1.f / h;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0009" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       v[0] *= f;</td><td> </td><td class="rblock">       v[0] *= f<span class="insert">*widthStretch</span>;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       v[1] *= f;</td><td> </td><td class="right">       v[1] *= f;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       v[2] = r;</td><td> </td><td class="right">       v[2] = r;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       return true;</td><td> </td><td class="right">       return true;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">bool StelProjectorStereographic::backward(Vec3d &amp;v) const</td><td> </td><td class="right">bool StelProjectorStereographic::backward(Vec3d &amp;v) const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0010" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  const double lqq = 0.25*(v[0]*v[0] + v[1]*v[1]);</td><td> </td><td class="rblock">       <span class="insert">v[0] /= widthStretch;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  v[2] = lqq - 1.0;</td><td> </td><td class="rblock">       const double lqq = 0.25*(v[0]*v[0] + v[1]*v[1]);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  v *= (1.0 / (lqq + 1.0));</td><td> </td><td class="rblock">       v[2] = lqq - 1.0;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  return true;</td><td> </td><td class="rblock">       v *= (1.0 / (lqq + 1.0));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       return true;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">float StelProjectorStereographic::fovToViewScalingFactor(float fov) const</td><td> </td><td class="right">float StelProjectorStereographic::fovToViewScalingFactor(float fov) const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       return 2.f * std::tan(0.5f * fov);</td><td> </td><td class="right">       return 2.f * std::tan(0.5f * fov);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">float StelProjectorStereographic::viewScalingFactorToFov(float vsf) const</td><td> </td><td class="right">float StelProjectorStereographic::viewScalingFactorToFov(float vsf) const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       return 2.f * std::atan(0.5f * vsf);</td><td> </td><td class="right">       return 2.f * std::atan(0.5f * vsf);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l4" /><small>skipping to change at</small><em> line 207</em></th><th> </th><th><a name="part-r4" /><small>skipping to change at</small><em> line 210</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       return q_("In fish-eye projection, or &lt;i&gt;azimuthal equidistant proje
ction&lt;/i&gt;, straight lines become curves when they appear a large angular di
stance from the centre of the field of view (like the distortions seen with
 very wide angle camera lenses).");</td><td> </td><td class="right">       return q_("In fish-eye projection, or &lt;i&gt;azimuthal equidistant proje
ction&lt;/i&gt;, straight lines become curves when they appear a large angular di
stance from the centre of the field of view (like the distortions seen with
 very wide angle camera lenses).");</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">bool StelProjectorFisheye::forward(Vec3f &amp;v) const</td><td> </td><td class="right">bool StelProjectorFisheye::forward(Vec3f &amp;v) const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const float rq1 = v[0]*v[0] + v[1]*v[1];</td><td> </td><td class="right">       const float rq1 = v[0]*v[0] + v[1]*v[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (rq1 &gt; 0.f) {</td><td> </td><td class="right">       if (rq1 &gt; 0.f) {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               const float h = std::sqrt(rq1);</td><td> </td><td class="right">               const float h = std::sqrt(rq1);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               const float f = std::atan2(h,-v[2]) / h;</td><td> </td><td class="right">               const float f = std::atan2(h,-v[2]) / h;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0011" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               v[0] *= f;</td><td> </td><td class="rblock">               v[0] *= f<span class="insert">*widthStretch</span>;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               v[1] *= f;</td><td> </td><td class="right">               v[1] *= f;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               v[2] = std::sqrt(rq1 + v[2]*v[2]);</td><td> </td><td class="right">               v[2] = std::sqrt(rq1 + v[2]*v[2]);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return true;</td><td> </td><td class="right">               return true;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (v[2] &lt; 0.f) {</td><td> </td><td class="right">       if (v[2] &lt; 0.f) {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               v[0] = 0.f;</td><td> </td><td class="right">               v[0] = 0.f;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               v[1] = 0.f;</td><td> </td><td class="right">               v[1] = 0.f;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               v[2] = 1.f;</td><td> </td><td class="right">               v[2] = 1.f;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return true;</td><td> </td><td class="right">               return true;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       v[0] = std::numeric_limits&lt;float&gt;::max();</td><td> </td><td class="right">       v[0] = std::numeric_limits&lt;float&gt;::max();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       v[1] = std::numeric_limits&lt;float&gt;::max();</td><td> </td><td class="right">       v[1] = std::numeric_limits&lt;float&gt;::max();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       v[2] = std::numeric_limits&lt;float&gt;::min();</td><td> </td><td class="right">       v[2] = std::numeric_limits&lt;float&gt;::min();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       return false;</td><td> </td><td class="right">       return false;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">bool StelProjectorFisheye::backward(Vec3d &amp;v) const</td><td> </td><td class="right">bool StelProjectorFisheye::backward(Vec3d &amp;v) const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0012" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       v[0] /= widthStretch;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const double a = std::sqrt(v[0]*v[0]+v[1]*v[1]);</td><td> </td><td class="right">       const double a = std::sqrt(v[0]*v[0]+v[1]*v[1]);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const double f = (a &gt; 0.0) ? (std::sin(a) / a) : 1.0;</td><td> </td><td class="right">       const double f = (a &gt; 0.0) ? (std::sin(a) / a) : 1.0;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       v[0] *= f;</td><td> </td><td class="right">       v[0] *= f;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       v[1] *= f;</td><td> </td><td class="right">       v[1] *= f;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       v[2] = -std::cos(a);</td><td> </td><td class="right">       v[2] = -std::cos(a);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       return (a &lt; M_PI);</td><td> </td><td class="right">       return (a &lt; M_PI);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">float StelProjectorFisheye::fovToViewScalingFactor(float fov) const</td><td> </td><td class="right">float StelProjectorFisheye::fovToViewScalingFactor(float fov) const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l5" /><small>skipping to change at</small><em> line 266</em></th><th> </th><th><a name="part-r5" /><small>skipping to change at</small><em> line 270</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       return q_("The Hammer projection is an equal-area map projection, de
scribed by Ernst Hammer in 1892 and directly inspired by the Aitoff project
ion.");</td><td> </td><td class="right">       return q_("The Hammer projection is an equal-area map projection, de
scribed by Ernst Hammer in 1892 and directly inspired by the Aitoff project
ion.");</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">bool StelProjectorHammer::forward(Vec3f &amp;v) const</td><td> </td><td class="right">bool StelProjectorHammer::forward(Vec3f &amp;v) const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Hammer Aitoff</td><td> </td><td class="right">       // Hammer Aitoff</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const float r = std::sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);</td><td> </td><td class="right">       const float r = std::sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const float alpha = std::atan2(v[0],-v[2]);</td><td> </td><td class="right">       const float alpha = std::atan2(v[0],-v[2]);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const float cosDelta = std::sqrt(1.f-v[1]*v[1]/(r*r));</td><td> </td><td class="right">       const float cosDelta = std::sqrt(1.f-v[1]*v[1]/(r*r));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       float z = std::sqrt(1.+cosDelta*std::cos(alpha/2.f));</td><td> </td><td class="right">       float z = std::sqrt(1.+cosDelta*std::cos(alpha/2.f));</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0013" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       v[0] = 2.f*M_SQRT2*cosDelta*std::sin(alpha/2.f)/z;</td><td> </td><td class="rblock">       v[0] = 2.f*M_SQRT2*cosDelta*std::sin(alpha/2.f)/z<span class="insert"> * widthStretch</span>;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       v[1] = M_SQRT2*v[1]/r/z;</td><td> </td><td class="right">       v[1] = M_SQRT2*v[1]/r/z;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       v[2] = r;</td><td> </td><td class="right">       v[2] = r;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       return true;</td><td> </td><td class="right">       return true;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">bool StelProjectorHammer::backward(Vec3d &amp;v) const</td><td> </td><td class="right">bool StelProjectorHammer::backward(Vec3d &amp;v) const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0014" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       v[0] /= widthStretch;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const double zsq = 1.-0.25*0.25*v[0]*v[0]-0.5*0.5*v[1]*v[1];</td><td> </td><td class="right">       const double zsq = 1.-0.25*0.25*v[0]*v[0]-0.5*0.5*v[1]*v[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const double z = zsq&lt;0. ? 0. : std::sqrt(zsq);</td><td> </td><td class="right">       const double z = zsq&lt;0. ? 0. : std::sqrt(zsq);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const bool ret = 0.25*v[0]*v[0]+v[1]*v[1]&lt;2.0; // This is stolen fro
m glunatic</td><td> </td><td class="right">       const bool ret = 0.25*v[0]*v[0]+v[1]*v[1]&lt;2.0; // This is stolen fro
m glunatic</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const double alpha = 2.*std::atan2(z*v[0],(2.*(2.*zsq-1.)));</td><td> </td><td class="right">       const double alpha = 2.*std::atan2(z*v[0],(2.*(2.*zsq-1.)));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const double delta = std::asin(v[1]*z);</td><td> </td><td class="right">       const double delta = std::asin(v[1]*z);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const double cd = std::cos(delta);</td><td> </td><td class="right">       const double cd = std::cos(delta);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       v[2] = - cd * std::cos(alpha);</td><td> </td><td class="right">       v[2] = - cd * std::cos(alpha);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       v[0] = cd * std::sin(alpha);</td><td> </td><td class="right">       v[0] = cd * std::sin(alpha);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       v[1] = v[1]*z;</td><td> </td><td class="right">       v[1] = v[1]*z;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       return ret;</td><td> </td><td class="right">       return ret;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l6" /><small>skipping to change at</small><em> line 317</em></th><th> </th><th><a name="part-r6" /><small>skipping to change at</small><em> line 322</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       return q_("The full name of this projection mode is &lt;i&gt;cylindrical e
quidistant projection&lt;/i&gt;. With this projection all parallels are equally s
paced.");</td><td> </td><td class="right">       return q_("The full name of this projection mode is &lt;i&gt;cylindrical e
quidistant projection&lt;/i&gt;. With this projection all parallels are equally s
paced.");</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">bool StelProjectorCylinder::forward(Vec3f &amp;v) const</td><td> </td><td class="right">bool StelProjectorCylinder::forward(Vec3f &amp;v) const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const float r = std::sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);</td><td> </td><td class="right">       const float r = std::sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const bool rval = (-r &lt; v[1] &amp;&amp; v[1] &lt; r);</td><td> </td><td class="right">       const bool rval = (-r &lt; v[1] &amp;&amp; v[1] &lt; r);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const float alpha = std::atan2(v[0],-v[2]);</td><td> </td><td class="right">       const float alpha = std::atan2(v[0],-v[2]);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const float delta = std::asin(v[1]/r);</td><td> </td><td class="right">       const float delta = std::asin(v[1]/r);</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0015" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       v[0] = alpha;</td><td> </td><td class="rblock">       v[0] = alpha<span class="insert">*widthStretch</span>;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       v[1] = delta;</td><td> </td><td class="right">       v[1] = delta;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       v[2] = r;</td><td> </td><td class="right">       v[2] = r;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       return rval;</td><td> </td><td class="right">       return rval;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">bool StelProjectorCylinder::backward(Vec3d &amp;v) const</td><td> </td><td class="right">bool StelProjectorCylinder::backward(Vec3d &amp;v) const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0016" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       v[0] /= widthStretch;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const bool rval = v[1]&lt;M_PI_2 &amp;&amp; v[1]&gt;-M_PI_2 &amp;&amp; v[0]&gt;-M_PI &amp;&amp; v[0]&lt;
M_PI;</td><td> </td><td class="right">       const bool rval = v[1]&lt;M_PI_2 &amp;&amp; v[1]&gt;-M_PI_2 &amp;&amp; v[0]&gt;-M_PI &amp;&amp; v[0]&lt;
M_PI;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const double cd = std::cos(v[1]);</td><td> </td><td class="right">       const double cd = std::cos(v[1]);</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0017" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       v[2] = - cd * <span class="delete">std::cos(v[0]);</span></td><td> </td><td class="rblock">       <span class="insert">const double alpha=v[0];</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       v[0] = cd * <span class="delete">std::sin(v[0]);</span></td><td> </td><td class="rblock">       v[2] = - cd * <span class="insert">std::cos(alpha);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       v[0] = cd * <span class="insert">std::sin(alpha);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       v[1] = std::sin(v[1]);</td><td> </td><td class="right">       v[1] = std::sin(v[1]);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       return rval;</td><td> </td><td class="right">       return rval;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">float StelProjectorCylinder::fovToViewScalingFactor(float fov) const</td><td> </td><td class="right">float StelProjectorCylinder::fovToViewScalingFactor(float fov) const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       return fov;</td><td> </td><td class="right">       return fov;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">float StelProjectorCylinder::viewScalingFactorToFov(float vsf) const</td><td> </td><td class="right">float StelProjectorCylinder::viewScalingFactorToFov(float vsf) const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l7" /><small>skipping to change at</small><em> line 363</em></th><th> </th><th><a name="part-r7" /><small>skipping to change at</small><em> line 370</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">QString StelProjectorMercator::getDescriptionI18() const</td><td> </td><td class="right">QString StelProjectorMercator::getDescriptionI18() const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       return q_("The Mercator projection is one of the most used world map
 projections. It preserves direction and shapes but distorts size, in an in
creasing degree away from the equator.");</td><td> </td><td class="right">       return q_("The Mercator projection is one of the most used world map
 projections. It preserves direction and shapes but distorts size, in an in
creasing degree away from the equator.");</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">bool StelProjectorMercator::forward(Vec3f &amp;v) const</td><td> </td><td class="right">bool StelProjectorMercator::forward(Vec3f &amp;v) const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const float r = std::sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);</td><td> </td><td class="right">       const float r = std::sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const bool rval = (-r &lt; v[1] &amp;&amp; v[1] &lt; r);</td><td> </td><td class="right">       const bool rval = (-r &lt; v[1] &amp;&amp; v[1] &lt; r);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const float sin_delta = v[1]/r;</td><td> </td><td class="right">       const float sin_delta = v[1]/r;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0018" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       v[0] = std::atan2(v[0],-v[2]);</td><td> </td><td class="rblock">       v[0] = std::atan2(v[0],-v[2])<span class="insert"> *widthStretch</span>;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       v[1] = 0.5f*std::log((1.f+sin_delta)/(1.f-sin_delta));</td><td> </td><td class="right">       v[1] = 0.5f*std::log((1.f+sin_delta)/(1.f-sin_delta));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       v[2] = r;</td><td> </td><td class="right">       v[2] = r;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       return rval;</td><td> </td><td class="right">       return rval;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">bool StelProjectorMercator::backward(Vec3d &amp;v) const</td><td> </td><td class="right">bool StelProjectorMercator::backward(Vec3d &amp;v) const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0019" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       const bool rval = <span class="delete">v[1]&lt;M_PI_2 &amp;&amp; v[1]&gt;-M_PI_2 &amp;&amp;</span> v[0]&gt;-M_PI &amp;&amp; <span class="delete">v[0]&lt;</span></td><td> </td><td class="rblock">       <span class="insert">v[0] /= widthStretch;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">M_PI;</span></td><td> </td><td class="rblock">       const bool rval = v[0]&gt;-M_PI &amp;&amp; <span class="insert">v[0]&lt;M_PI;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const double E = std::exp(v[1]);</td><td> </td><td class="right">       const double E = std::exp(v[1]);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const double h = E*E;</td><td> </td><td class="right">       const double h = E*E;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const double h1 = 1.0/(1.0+h);</td><td> </td><td class="right">       const double h1 = 1.0/(1.0+h);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const double sin_delta = (h-1.0)*h1;</td><td> </td><td class="right">       const double sin_delta = (h-1.0)*h1;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const double cos_delta = 2.0*E*h1;</td><td> </td><td class="right">       const double cos_delta = 2.0*E*h1;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       v[2] = - cos_delta * std::cos(v[0]);</td><td> </td><td class="right">       v[2] = - cos_delta * std::cos(v[0]);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       v[0] = cos_delta * std::sin(v[0]);</td><td> </td><td class="right">       v[0] = cos_delta * std::sin(v[0]);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       v[1] = sin_delta;</td><td> </td><td class="right">       v[1] = sin_delta;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       return rval;</td><td> </td><td class="right">       return rval;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l8" /><small>skipping to change at</small><em> line 412</em></th><th> </th><th><a name="part-r8" /><small>skipping to change at</small><em> line 420</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">QString StelProjectorOrthographic::getDescriptionI18() const</td><td> </td><td class="right">QString StelProjectorOrthographic::getDescriptionI18() const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       return q_("Orthographic projection is related to perspective project
ion, but the point of perspective is set to an infinite distance.");</td><td> </td><td class="right">       return q_("Orthographic projection is related to perspective project
ion, but the point of perspective is set to an infinite distance.");</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">bool StelProjectorOrthographic::forward(Vec3f &amp;v) const</td><td> </td><td class="right">bool StelProjectorOrthographic::forward(Vec3f &amp;v) const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const float r = std::sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);</td><td> </td><td class="right">       const float r = std::sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const float h = 1.f/r;</td><td> </td><td class="right">       const float h = 1.f/r;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0020" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       v[0] *= h;</td><td> </td><td class="rblock">       v[0] *= h<span class="insert"> *widthStretch</span>;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       v[1] *= h;</td><td> </td><td class="right">       v[1] *= h;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const bool rval = (v[2] &lt;= 0.f);</td><td> </td><td class="right">       const bool rval = (v[2] &lt;= 0.f);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       v[2] = r;</td><td> </td><td class="right">       v[2] = r;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       return rval;</td><td> </td><td class="right">       return rval;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">bool StelProjectorOrthographic::backward(Vec3d &amp;v) const</td><td> </td><td class="right">bool StelProjectorOrthographic::backward(Vec3d &amp;v) const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0021" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       v[0] /= widthStretch;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const double dq = v[0]*v[0] + v[1]*v[1];</td><td> </td><td class="right">       const double dq = v[0]*v[0] + v[1]*v[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       double h = 1.0 - dq;</td><td> </td><td class="right">       double h = 1.0 - dq;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (h &lt; 0) {</td><td> </td><td class="right">       if (h &lt; 0) {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               h = 1.0/std::sqrt(dq);</td><td> </td><td class="right">               h = 1.0/std::sqrt(dq);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               v[0] *= h;</td><td> </td><td class="right">               v[0] *= h;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               v[1] *= h;</td><td> </td><td class="right">               v[1] *= h;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               v[2] = 0.0;</td><td> </td><td class="right">               v[2] = 0.0;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return false;</td><td> </td><td class="right">               return false;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       v[2] = -std::sqrt(h);</td><td> </td><td class="right">       v[2] = -std::sqrt(h);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l9" /><small>skipping to change at</small><em> line 465</em></th><th> </th><th><a name="part-r9" /><small>skipping to change at</small><em> line 474</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       return q_("The sinusoidal projection is a &lt;i&gt;pseudocylindrical equal
-area map projection&lt;/i&gt;, sometimes called the Sanson–Flamsteed or the Merc
ator equal-area projection.");</td><td> </td><td class="right">       return q_("The sinusoidal projection is a &lt;i&gt;pseudocylindrical equal
-area map projection&lt;/i&gt;, sometimes called the Sanson–Flamsteed or the Merc
ator equal-area projection.");</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">bool StelProjectorSinusoidal::forward(Vec3f &amp;v) const</td><td> </td><td class="right">bool StelProjectorSinusoidal::forward(Vec3f &amp;v) const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const float r = std::sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);</td><td> </td><td class="right">       const float r = std::sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const bool rval = (-r &lt; v[1] &amp;&amp; v[1] &lt; r);</td><td> </td><td class="right">       const bool rval = (-r &lt; v[1] &amp;&amp; v[1] &lt; r);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const float alpha = std::atan2(v[0],-v[2]);</td><td> </td><td class="right">       const float alpha = std::atan2(v[0],-v[2]);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const float delta = std::asin(v[1]/r);</td><td> </td><td class="right">       const float delta = std::asin(v[1]/r);</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0022" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       v[0] = alpha*std::cos(delta);</td><td> </td><td class="rblock">       v[0] = alpha*std::cos(delta)<span class="insert"> *widthStretch</span>;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       v[1] = delta;</td><td> </td><td class="right">       v[1] = delta;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       v[2] = r;</td><td> </td><td class="right">       v[2] = r;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       return rval;</td><td> </td><td class="right">       return rval;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">bool StelProjectorSinusoidal::backward(Vec3d &amp;v) const</td><td> </td><td class="right">bool StelProjectorSinusoidal::backward(Vec3d &amp;v) const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0023" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       v[0] /= widthStretch;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const bool rval = v[1]&lt;M_PI_2 &amp;&amp; v[1]&gt;-M_PI_2 &amp;&amp; v[0]&gt;-M_PI &amp;&amp; v[0]&lt;
M_PI;</td><td> </td><td class="right">       const bool rval = v[1]&lt;M_PI_2 &amp;&amp; v[1]&gt;-M_PI_2 &amp;&amp; v[0]&gt;-M_PI &amp;&amp; v[0]&lt;
M_PI;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const double cd = std::cos(v[1]);</td><td> </td><td class="right">       const double cd = std::cos(v[1]);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const double pcd = v[0]/cd;</td><td> </td><td class="right">       const double pcd = v[0]/cd;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (v[0]&lt;-M_PI*cd || v[0]&gt;M_PI*cd)</td><td> </td><td class="right">       if (v[0]&lt;-M_PI*cd || v[0]&gt;M_PI*cd)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               v[0] = -cd;</td><td> </td><td class="right">               v[0] = -cd;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               v[1] = 1.0;</td><td> </td><td class="right">               v[1] = 1.0;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               // FIXME: It is unclear what happens to v[2] here.</td><td> </td><td class="right">               // FIXME: It is unclear what happens to v[2] here.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               v.normalize(); // make sure the length test in Atmosphere.cp
p work.</td><td> </td><td class="right">               v.normalize(); // make sure the length test in Atmosphere.cp
p work.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return false;</td><td> </td><td class="right">               return false;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       v[2] = -cd * std::cos(pcd);</td><td> </td><td class="right">       v[2] = -cd * std::cos(pcd);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       v[0] = cd * std::sin(pcd);</td><td> </td><td class="right">       v[0] = cd * std::sin(pcd);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       v[1] = std::sin(v[1]);</td><td> </td><td class="right">       v[1] = std::sin(v[1]);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       return rval;</td><td> </td><td class="right">       return rval;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0024" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">QString StelProjectorMiller::getNameI18() const</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">{</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       return q_("Miller cylindrical");</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">}</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">QString StelProjectorMiller::getDescriptionI18() const</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">{</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       return q_("The Miller cylindrical projection is a modified Mercator </span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">projection, proposed by Osborn Maitland Miller (1897–1979) in 1942. The pol</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">es are no longer mapped to infinity.");</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">}</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">bool StelProjectorMiller::forward(Vec3f &amp;v) const</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">{</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       const float r = std::sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       const bool rval = (-r &lt; v[1] &amp;&amp; v[1] &lt; r);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       const float sin_delta = v[1]/r;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       const float delta=asin(sin_delta);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       v[0] = std::atan2(v[0],-v[2]) * widthStretch;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       v[1] = 1.25f*asinh(tan(0.8f*delta));</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       v[2] = r;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       return rval;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">}</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">bool StelProjectorMiller::backward(Vec3d &amp;v) const</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">{</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       v[0] /= widthStretch;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       const double yMax=1.25f*asinh(tan(M_PI*2.0/5.0));</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       const bool rval = v[1]&lt;yMax &amp;&amp; v[1]&gt;-yMax &amp;&amp; v[0]&gt;-M_PI &amp;&amp; v[0]&lt;M_PI</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       const double lat = 1.25*atan(sinh(0.8*v[1]));</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       const double lng = v[0];</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       const double cos_lat=cos(lat);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       v[0] = cos_lat*sin(lng);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       v[1] = sin(lat);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       v[2]= -cos_lat*cos(lng);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       return rval;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">}</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">QString StelProjector2d::getNameI18() const</td><td> </td><td class="right">QString StelProjector2d::getNameI18() const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       return "2d";</td><td> </td><td class="right">       return "2d";</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">QString StelProjector2d::getDescriptionI18() const</td><td> </td><td class="right">QString StelProjector2d::getDescriptionI18() const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       return "Simple 2d projection for internal use.";</td><td> </td><td class="right">       return "Simple 2d projection for internal use.";</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>

     <tr><td></td><td class="left"></td><td> </td><td class="right"></td><td></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 24 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><td></td><th><i>21 lines changed or deleted</i></th><th><i> </i></th><th><i>69 lines changed or added</i></th><td></td></tr>
     <tr><td colspan="5" align="center" class="small"><br/>This html diff was produced by rfcdiff 1.41. The latest version is available from <a href="http://www.tools.ietf.org/tools/rfcdiff/" >http://tools.ietf.org/tools/rfcdiff/</a> </td></tr>
   </table>
   </body>
   </html>
