<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"> 
<!-- Generated by rfcdiff 1.41: rfcdiff  --> 
<!-- <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional" > -->
<!-- System: Linux fomalhaut.local 3.13.0-38-generic #65-Ubuntu SMP Thu Oct 9 11:36:50 UTC 2014 x86_64 x86_64 x86_64 GNU/Linux --> 
<!-- Using awk: /usr/bin/gawk: GNU Awk 4.0.1 --> 
<!-- Using diff: /usr/bin/diff: diff (GNU diffutils) 3.3 --> 
<!-- Using wdiff: /usr/bin/wdiff: wdiff (GNU wdiff) 1.2.1 --> 
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"> 
<head> 
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /> 
  <meta http-equiv="Content-Style-Type" content="text/css" /> 
  <title>Diff: Comet.cpp - Comet.cpp</title> 
  <style type="text/css"> 
    body    { font-size:16px; margin: 0.4ex; margin-right: auto; } 
    tr      { } 
    td      { white-space: pre; font-family: Consolas, "DejaVu Sans Mono", "Droid Sans Mono", Monaco, Monospace; vertical-align: top; font-size: 0.86em;} 
    th      { font-size: 0.86em; } 
    .small  { font-size: 0.6em; font-style: italic; font-family: Verdana, Helvetica, sans-serif; } 
    .left   { background-color: #EEE; } 
    .right  { background-color: #FFF; } 
    .diff   { background-color: #CCF; } 
    .lblock { background-color: #BFB; } 
    .rblock { background-color: #FF8; } 
    .insert { background-color: #8FF; } 
    .delete { background-color: #ACF; } 
    .void   { background-color: #FFB; } 
    .cont   { background-color: #EEE; } 
    .linebr { background-color: #AAA; } 
    .lineno { color: red; background-color: #FFF; font-size: 0.7em; text-align: right; padding: 0 2px; } 
    .elipsis{ background-color: #AAA; } 
    .left .cont { background-color: #DDD; } 
    .right .cont { background-color: #EEE; } 
    .lblock .cont { background-color: #9D9; } 
    .rblock .cont { background-color: #DD6; } 
    .insert .cont { background-color: #0DD; } 
    .delete .cont { background-color: #8AD; } 
    .stats, .stats td, .stats th { background-color: #EEE; padding: 2px 0; } 
  </style> 
</head> 
<body > 
  <table border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th></th><th>&nbsp;Comet.cpp&nbsp;</th><th> </th><th>&nbsp;Comet.cpp&nbsp;</th><th></th></tr> 
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l1" /><small>skipping to change at</small><em> line 55</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 55</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                double radius,</td><td> </td><td class="right">                double radius,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                double oblateness,</td><td> </td><td class="right">                double oblateness,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                Vec3f color,</td><td> </td><td class="right">                Vec3f color,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                float albedo,</td><td> </td><td class="right">                float albedo,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                const QString&amp; atexMapName,</td><td> </td><td class="right">                const QString&amp; atexMapName,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                posFuncType coordFunc,</td><td> </td><td class="right">                posFuncType coordFunc,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                void* auserDataPtr,</td><td> </td><td class="right">                void* auserDataPtr,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                OsculatingFunctType *osculatingFunc,</td><td> </td><td class="right">                OsculatingFunctType *osculatingFunc,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                bool acloseOrbit,</td><td> </td><td class="right">                bool acloseOrbit,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                bool hidden,</td><td> </td><td class="right">                bool hidden,</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                const QString&amp; pType,</td><td> </td><td class="rblock">                const QString&amp; pType<span class="insert">Str</span>,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                float dustTailWidthFact, float dustTailLengthFact, float du
stTailBrightnessFact)</td><td> </td><td class="right">                float dustTailWidthFact, float dustTailLengthFact, float du
stTailBrightnessFact)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       : Planet (englishName,</td><td> </td><td class="right">       : Planet (englishName,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                 flagLighting,</td><td> </td><td class="right">                 flagLighting,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                 radius,</td><td> </td><td class="right">                 radius,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                 oblateness,</td><td> </td><td class="right">                 oblateness,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                 color,</td><td> </td><td class="right">                 color,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                 albedo,</td><td> </td><td class="right">                 albedo,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                 atexMapName,</td><td> </td><td class="right">                 atexMapName,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                 "",</td><td> </td><td class="right">                 "",</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                 coordFunc,</td><td> </td><td class="right">                 coordFunc,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                 auserDataPtr,</td><td> </td><td class="right">                 auserDataPtr,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                 osculatingFunc,</td><td> </td><td class="right">                 osculatingFunc,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                 acloseOrbit,</td><td> </td><td class="right">                 acloseOrbit,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                 hidden,</td><td> </td><td class="right">                 hidden,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                 false, //No atmosphere</td><td> </td><td class="right">                 false, //No atmosphere</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                 true, //halo</td><td> </td><td class="right">                 true, //halo</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0002" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                 <span class="delete">pType),</span></td><td> </td><td class="rblock">                 <span class="insert">pTypeStr),</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">         tailActive(false),</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">         dustTailWidthFactor(dustTailWidthFact),</td><td> </td><td class="right">         dustTailWidthFactor(dustTailWidthFact),</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">         dustTailLengthFactor(dustTailLengthFact),</td><td> </td><td class="right">         dustTailLengthFactor(dustTailLengthFact),</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">         dustTailBrightnessFactor(dustTailBrightnessFact)</td><td> </td><td class="right">         dustTailBrightnessFactor(dustTailBrightnessFact)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       texMapName = atexMapName;</td><td> </td><td class="right">       texMapName = atexMapName;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       lastOrbitJD =0;</td><td> </td><td class="right">       lastOrbitJD =0;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       deltaJD = StelCore::JD_SECOND;</td><td> </td><td class="right">       deltaJD = StelCore::JD_SECOND;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0003" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">deltaJDtail=15.0*StelCore::JD_MINUTE; // update tail geometry every </span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">15 minutes only</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       lastJDtail=0.0;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       orbitCached = 0;</td><td> </td><td class="right">       orbitCached = 0;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       closeOrbit = acloseOrbit;</td><td> </td><td class="right">       closeOrbit = acloseOrbit;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       eclipticPos=Vec3d(0.,0.,0.);</td><td> </td><td class="right">       eclipticPos=Vec3d(0.,0.,0.);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       rotLocalToParent = Mat4d::identity();</td><td> </td><td class="right">       rotLocalToParent = Mat4d::identity();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       texMap = StelApp::getInstance().getTextureManager().createTextureThr
ead(StelFileMgr::getInstallationDir()+"/textures/"+texMapName, StelTexture:
:StelTextureParams(true, GL_LINEAR, GL_REPEAT));</td><td> </td><td class="right">       texMap = StelApp::getInstance().getTextureManager().createTextureThr
ead(StelFileMgr::getInstallationDir()+"/textures/"+texMapName, StelTexture:
:StelTextureParams(true, GL_LINEAR, GL_REPEAT));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       gastailVertexArr.clear();</td><td> </td><td class="right">       gastailVertexArr.clear();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       dusttailVertexArr.clear();</td><td> </td><td class="right">       dusttailVertexArr.clear();</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0004" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">gastailTexCoordArr.clear();</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       //dusttailTexCoordArr.clear();</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       gastailIndices.clear();</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       //dusttailIndices.clear();</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       comaVertexArr.clear();</td><td> </td><td class="right">       comaVertexArr.clear();</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0005" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">comaTexCoordArr.clear();</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       comaTexture = StelApp::getInstance().getTextureManager().createTextu</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">reThread(StelFileMgr::getInstallationDir()+"/textures/cometComa.png", StelT</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">exture::StelTextureParams(true, GL_LINEAR, GL_CLAMP_TO_EDGE));</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       //GZ: tail textures. We use a paraboloid tail body, textured like a </span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">fisheye sphere, i.e. center=head. The texture should be something like a mo</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">ttled star to give some structure.</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       gasTailTexture = StelApp::getInstance().getTextureManager().createTe</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">xtureThread(StelFileMgr::getInstallationDir()+"/textures/cometTail.png", St</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">elTexture::StelTextureParams(true, GL_LINEAR, GL_CLAMP_TO_EDGE));</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       // GZ: I think we need only one texture for the tails.</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       //dusttailTexture = StelApp::getInstance().getTextureManager().creat</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">eTextureThread(StelFileMgr::getInstallationDir()+"/textures/cometTail.png",</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"> StelTexture::StelTextureParams(true, GL_LINEAR, GL_CLAMP_TO_EDGE));</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //Comet specific members</td><td> </td><td class="right">       //Comet specific members</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       absoluteMagnitude = 0;</td><td> </td><td class="right">       absoluteMagnitude = 0;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       slopeParameter = -1;//== uninitialized: used in getVMagnitude()</td><td> </td><td class="right">       slopeParameter = -1;//== uninitialized: used in getVMagnitude()</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //TODO: Name processing?</td><td> </td><td class="right">       //TODO: Name processing?</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       nameI18 = englishName;</td><td> </td><td class="right">       nameI18 = englishName;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       flagLabels = true;</td><td> </td><td class="right">       flagLabels = true;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l2" /><small>skipping to change at</small><em> line 154</em></th><th> </th><th><a name="part-r2" /><small>skipping to change at</small><em> line 146</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               oss &lt;&lt; q_(englishName);  // UI translation can differ from s
ky translation</td><td> </td><td class="right">               oss &lt;&lt; q_(englishName);  // UI translation can differ from s
ky translation</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               oss.setRealNumberNotation(QTextStream::FixedNotation);</td><td> </td><td class="right">               oss.setRealNumberNotation(QTextStream::FixedNotation);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               oss.setRealNumberPrecision(1);</td><td> </td><td class="right">               oss.setRealNumberPrecision(1);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               if (sphereScale != 1.f)</td><td> </td><td class="right">               if (sphereScale != 1.f)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       oss &lt;&lt; QString::fromUtf8(" (\xC3\x97") &lt;&lt; sphereScal
e &lt;&lt; ")";</td><td> </td><td class="right">                       oss &lt;&lt; QString::fromUtf8(" (\xC3\x97") &lt;&lt; sphereScal
e &lt;&lt; ")";</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               oss &lt;&lt; "&lt;/h2&gt;";</td><td> </td><td class="right">               oss &lt;&lt; "&lt;/h2&gt;";</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (flags&amp;ObjectType)</td><td> </td><td class="right">       if (flags&amp;ObjectType)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0006" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               <span class="delete">if (pType.length()&gt;0)</span></td><td> </td><td class="rblock">               oss &lt;&lt; q_("Type: <span class="insert">&lt;b&gt;%1&lt;/b&gt;").arg(q_(getPlanetTypeString()))</span> </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       oss &lt;&lt; q_("Type: <span class="delete">&lt;b&gt;%1&lt;/b&gt;").arg(q_(pType))</span> &lt;&lt; "&lt;br </td><td> </td><td class="rblock">&lt;&lt; "&lt;br /&gt;";</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">/&gt;";</td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (flags&amp;Magnitude)</td><td> </td><td class="right">       if (flags&amp;Magnitude)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">           if (core-&gt;getSkyDrawer()-&gt;getFlagHasAtmosphere())</td><td> </td><td class="right">           if (core-&gt;getSkyDrawer()-&gt;getFlagHasAtmosphere())</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               oss &lt;&lt; q_("Magnitude: &lt;b&gt;%1&lt;/b&gt; (extincted to: &lt;b&gt;%2&lt;/b&gt;)").
arg(QString::number(getVMagnitude(core), 'f', 2),</td><td> </td><td class="right">               oss &lt;&lt; q_("Magnitude: &lt;b&gt;%1&lt;/b&gt; (extincted to: &lt;b&gt;%2&lt;/b&gt;)").
arg(QString::number(getVMagnitude(core), 'f', 2),</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                                                                           
QString::number(getVMagnitudeWithExtinction(core), 'f', 2)) &lt;&lt; "&lt;br&gt;";</td><td> </td><td class="right">                                                                           
QString::number(getVMagnitudeWithExtinction(core), 'f', 2)) &lt;&lt; "&lt;br&gt;";</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">           else</td><td> </td><td class="right">           else</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               oss &lt;&lt; q_("Magnitude: &lt;b&gt;%1&lt;/b&gt;").arg(getVMagnitude(core), 0
, 'f', 2) &lt;&lt; "&lt;br&gt;";</td><td> </td><td class="right">               oss &lt;&lt; q_("Magnitude: &lt;b&gt;%1&lt;/b&gt;").arg(getVMagnitude(core), 0
, 'f', 2) &lt;&lt; "&lt;br&gt;";</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l3" /><small>skipping to change at</small><em> line 215</em></th><th> </th><th><a name="part-r3" /><small>skipping to change at</small><em> line 206</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                                  .arg(distanceKm, 0, 'f', 3);</td><td> </td><td class="right">                                  .arg(distanceKm, 0, 'f', 3);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               else</td><td> </td><td class="right">               else</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       // xgettext:no-c-format</td><td> </td><td class="right">                       // xgettext:no-c-format</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       oss &lt;&lt; QString(q_("Distance: %1AU (%2 Mio km)"))</td><td> </td><td class="right">                       oss &lt;&lt; QString(q_("Distance: %1AU (%2 Mio km)"))</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                                  .arg(distanceAu, 0, 'f', 3)</td><td> </td><td class="right">                                  .arg(distanceAu, 0, 'f', 3)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                                  .arg(distanceKm / 1.0e6, 0, 'f', 3);</td><td> </td><td class="right">                                  .arg(distanceKm / 1.0e6, 0, 'f', 3);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               oss &lt;&lt; "&lt;br&gt;";</td><td> </td><td class="right">               oss &lt;&lt; "&lt;br&gt;";</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0007" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               // GZ: Add speed. I don't know where to place that bit of <span class="delete">in</span></td><td> </td><td class="rblock">       <span class="insert">}</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">formation.</span></td><td> </td><td class="rblock"><span class="insert">       if (flags&amp;Extra)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">               // GZ: Add speed. I don't know where <span class="insert">else</span> to place that bit </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">of <span class="insert">information.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               // xgettext:no-c-format</td><td> </td><td class="right">               // xgettext:no-c-format</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               oss &lt;&lt; QString(q_("Speed: %1 km/s"))</td><td> </td><td class="right">               oss &lt;&lt; QString(q_("Speed: %1 km/s"))</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                          .arg(((CometOrbit*)userDataPtr)-&gt;getVelocity().le
ngth()*AU/86400.0, 0, 'f', 3);</td><td> </td><td class="right">                          .arg(((CometOrbit*)userDataPtr)-&gt;getVelocity().le
ngth()*AU/86400.0, 0, 'f', 3);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               oss &lt;&lt; "&lt;br&gt;";</td><td> </td><td class="right">               oss &lt;&lt; "&lt;br&gt;";</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0008" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       /*</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (flags&amp;Size)</td><td> </td><td class="right">       if (flags&amp;Size)</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0009" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               oss &lt;&lt; <span class="delete">q_("Apparent diameter: %1").arg(StelUtils::radToDmsSt</span></td><td> </td><td class="rblock">       <span class="insert">{</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">r(2.*getAngularSize(core)*M_PI/180., true));</span></td><td> </td><td class="rblock"><span class="insert">               // GZ: Add estimates for coma diameter and tail length.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       */</span></td><td> </td><td class="rblock"><span class="insert">               // xgettext:no-c-format</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">               oss &lt;&lt; <span class="insert">QString(q_("Coma diameter (estimate): %1 km"))</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                          .arg(floor(tailFactors[0]*AU/1000.0f)*1000.0f, 0,</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> 'f', 0);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               oss &lt;&lt; "&lt;br&gt;";</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               // xgettext:no-c-format</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               oss &lt;&lt; QString(q_("Gas tail length (estimate): %1 Mio km"))</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                          .arg(tailFactors[1]*AU*1e-6, 0, 'G', 3);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               oss &lt;&lt; "&lt;br&gt;";</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // If semi-major axis not zero then calculate and display orbital pe
riod for comet in days</td><td> </td><td class="right">       // If semi-major axis not zero then calculate and display orbital pe
riod for comet in days</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       double siderealPeriod = getSiderealPeriod();</td><td> </td><td class="right">       double siderealPeriod = getSiderealPeriod();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if ((flags&amp;Extra) &amp;&amp; (siderealPeriod&gt;0))</td><td> </td><td class="right">       if ((flags&amp;Extra) &amp;&amp; (siderealPeriod&gt;0))</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               // TRANSLATORS: Sidereal (orbital) period for solar system b
odies in days and in Julian years (symbol: a)</td><td> </td><td class="right">               // TRANSLATORS: Sidereal (orbital) period for solar system b
odies in days and in Julian years (symbol: a)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               oss &lt;&lt; q_("Sidereal period: %1 days (%2 a)").arg(QString::nu
mber(siderealPeriod, 'f', 2)).arg(QString::number(siderealPeriod/365.25, 'f
', 3)) &lt;&lt; "&lt;br&gt;";</td><td> </td><td class="right">               oss &lt;&lt; q_("Sidereal period: %1 days (%2 a)").arg(QString::nu
mber(siderealPeriod, 'f', 2)).arg(QString::number(siderealPeriod/365.25, 'f
', 3)) &lt;&lt; "&lt;br&gt;";</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       postProcessInfoString(str, flags);</td><td> </td><td class="right">       postProcessInfoString(str, flags);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l4" /><small>skipping to change at</small><em> line 282</em></th><th> </th><th><a name="part-r4" /><small>skipping to change at</small><em> line 284</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //Sources: http://www.clearskyinstitute.com/xephem/help/xephem.html#
mozTocId564354</td><td> </td><td class="right">       //Sources: http://www.clearskyinstitute.com/xephem/help/xephem.html#
mozTocId564354</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //(XEphem manual, section 7.1.2.3 "Magnitude models"), also</td><td> </td><td class="right">       //(XEphem manual, section 7.1.2.3 "Magnitude models"), also</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //http://www.ayton.id.au/gary/Science/Astronomy/Ast_comets.htm#Comet
%20facts:</td><td> </td><td class="right">       //http://www.ayton.id.au/gary/Science/Astronomy/Ast_comets.htm#Comet
%20facts:</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // GZ: Note that Meeus, Astr.Alg.1998 p.231, has m=absoluteMagnitude
+5log10(observerCometDistance) + kappa*log10(cometSunDistance)</td><td> </td><td class="right">       // GZ: Note that Meeus, Astr.Alg.1998 p.231, has m=absoluteMagnitude
+5log10(observerCometDistance) + kappa*log10(cometSunDistance)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // with kappa typically 5..15. MPC provides Slope parameter. So we s
hould expect to have slopeParameter (a word only used for minor planets!) f
or our comets 2..6</td><td> </td><td class="right">       // with kappa typically 5..15. MPC provides Slope parameter. So we s
hould expect to have slopeParameter (a word only used for minor planets!) f
or our comets 2..6</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       double apparentMagnitude = absoluteMagnitude + 5 * std::log10(observ
erCometDistance) + 2.5 * slopeParameter * std::log10(cometSunDistance);</td><td> </td><td class="right">       double apparentMagnitude = absoluteMagnitude + 5 * std::log10(observ
erCometDistance) + 2.5 * slopeParameter * std::log10(cometSunDistance);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       return apparentMagnitude;</td><td> </td><td class="right">       return apparentMagnitude;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0010" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">// Compute the position in the parent Planet coordinate system</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">// Actually call the provided function to compute the ecliptical position, </span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">and buildup the tails!</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">void Comet::computePosition(const double date)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">{</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       Planet::computePosition(date);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //GZ: I think we can make deltaJD adaptive, depending on distance to</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> sun! For some reason though, this leads to a crash!</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //deltaJD=StelCore::JD_SECOND * qMax(1.0, qMin(eclipticPos.length(),</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> 20.0));</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       if (fabs(lastJDtail-date)&gt;deltaJDtail)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               lastJDtail=date;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               // GZ: Moved from draw() :-)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               // The CometOrbit is in fact available in userDataPtr!</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               CometOrbit* orbit=(CometOrbit*)userDataPtr;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               Q_ASSERT(orbit);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               if (!orbit-&gt;objectDateValid(date)) return; // out of useful </span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">date range. This should allow having hundreds of comet elements.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               if (orbit-&gt;getUpdateTails()){</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       // Compute lengths and orientations from orbit objec</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">t, but only if required.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       // This part moved from draw() to keep draw() free f</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">rom too much computation.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       tailFactors=getComaDiameterAndTailLengthAU();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       // Note that we use a diameter larger than what the </span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">formula returns. A scale factor of 1.2 is ad-hoc/empirical (GZ), but may lo</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ok better.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       computeComa(1.0f*tailFactors[0]);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       tailActive = (tailFactors[1] &gt; tailFactors[0]); // I</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">nhibit tails drawing if too short. Would be nice to include geometric proje</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ction angle, but this is too costly.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       if (tailActive)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               float gasTailEndRadius=qMax(tailFactors[0], </span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">0.025f*tailFactors[1]) ; // This avoids too slim gas tails for bright comet</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">s like Hale-Bopp.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               float gasparameter=gasTailEndRadius*gasTailE</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ndRadius/(2.0f*tailFactors[1]); // parabola formula: z=r²/2p, so p=r²/2z</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               // The dust tail is thicker and usually shor</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ter. The factors can be configured in the elements.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               float dustparameter=gasTailEndRadius*gasTail</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">EndRadius*dustTailWidthFactor*dustTailWidthFactor/(2.0f*dustTailLengthFacto</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">r*tailFactors[1]);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               // Find valid parameters to create paraboloi</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">d vertex arrays: dustTail, gasTail.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               computeParabola(gasparameter, gasTailEndRadi</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">us, -0.5f*gasparameter, gastailVertexArr,  tailTexCoordArr, tailIndices);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               // This was for a rotated straight parabola:</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               //computeParabola(dustparameter, 2.0f*tailFa</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ctors[0], -0.5f*dustparameter, dusttailVertexArr, dusttailTexCoordArr, dust</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">tailIndices);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               // Now we make a skewed parabola. Skew facto</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">r (xOffset, last arg) is rather ad-hoc/empirical. TBD later: Find physicall</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">y correct solution.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               computeParabola(dustparameter, dustTailWidth</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">Factor*gasTailEndRadius, -0.5f*dustparameter, dusttailVertexArr, tailTexCoo</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">rdArr, tailIndices, 25.0f*orbit-&gt;getVelocity().length());</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               // 2014-08 for 0.13.1 Moved from drawTail() </span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">to save lots of computation per frame (There *are* folks downloading all 73</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">0 MPC current comet elements...)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               // Find rotation matrix from 0/0/1 to eclipt</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">icPosition: crossproduct for axis (normal vector), dotproduct for angle.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               Vec3d eclposNrm=eclipticPos; eclposNrm.norma</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">lize();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               gasTailRot=Mat4d::rotation(Vec3d(0.0, 0.0, 1</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">.0)^(eclposNrm), std::acos(Vec3d(0.0, 0.0, 1.0).dot(eclposNrm)) );</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               Vec3d velocity=orbit-&gt;getVelocity(); // [AU/</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">d]</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               // This was a try to rotate a straight parab</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ola somewhat away from the antisolar direction.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               //Mat4d dustTailRot=Mat4d::rotation(eclposNr</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">m^(-velocity), 0.15f*std::acos(eclposNrm.dot(-velocity))); // GZ: This scal</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">e factor of 0.15 is empirical from photos of Halley and Hale-Bopp.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               // The curved tail is curved towards positiv</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">e X. We first rotate around the Z axis into a direction opposite of the mot</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ion vector, then again the antisolar rotation applies.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               // In addition, we let the dust tail already</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> start with a light tilt.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               dustTailRot=gasTailRot * Mat4d::zrotation(at</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">an2(velocity[1], velocity[0]) + M_PI) * Mat4d::yrotation(5.0f*velocity.leng</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">th());</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               // TODO: If we want to be even faster, rotat</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">e vertex arrays here and not in drawTail()!</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               Vec3d* gasVertices=(Vec3d*) (gastailVertexAr</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">r.data());</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               Vec3d* dustVertices=(Vec3d*) (dusttailVertex</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">Arr.data());</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               for (int i=0; i&lt;COMET_TAIL_SLICES*COMET_TAIL</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">_STACKS+1; ++i)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                       gasVertices[i].transfo4d(gasTailRot)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                       dustVertices[i].transfo4d(dustTailRo</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">t);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       orbit-&gt;setUpdateTails(false); // don't update until </span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">position has been recalculated elsewhere</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               // Note: we can make deltaJDtail adaptive, depending on dist</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ance to sun!</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               //deltaJDtail=5.0*StelCore::JD_MINUTE * qMax(0.01, qMin(ecli</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">pticPos.length(), 20.0));</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">}</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// Draw the Comet and all the related infos : name, circle etc... GZ: Taken
 from Planet.cpp 2013-11-05 and extended</td><td> </td><td class="right">// Draw the Comet and all the related infos : name, circle etc... GZ: Taken
 from Planet.cpp 2013-11-05 and extended</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void Comet::draw(StelCore* core, float maxMagLabels, const QFont&amp; planetNam
eFont)</td><td> </td><td class="right">void Comet::draw(StelCore* core, float maxMagLabels, const QFont&amp; planetNam
eFont)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (hidden)</td><td> </td><td class="right">       if (hidden)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return;</td><td> </td><td class="right">               return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (getEnglishName() == core-&gt;getCurrentLocation().planetName)</td><td> </td><td class="right">       if (getEnglishName() == core-&gt;getCurrentLocation().planetName)</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0011" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       { // GZ<span class="delete"> moved this up. Maybe even don't do that? E.g., draw tail whi
le riding the </span>comet? Decide later.</td><td> </td><td class="rblock">       { // GZ<span class="insert">: Maybe even don't do that? E.g., draw tail while riding the 
</span>comet? Decide later.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return;</td><td> </td><td class="right">               return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0012" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">// GZ: If comet is too faint to be seen, don't bother rendering. (oo</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ps, should have been here in 2014-01... ;-)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       if ((getVMagnitude(core)-2.0f) &gt; core-&gt;getSkyDrawer()-&gt;getLimitMagni</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">tude())</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               return;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // The CometOrbit is in fact available in userDataPtr!</td><td> </td><td class="right">       // The CometOrbit is in fact available in userDataPtr!</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       CometOrbit* orbit=(CometOrbit*)userDataPtr;</td><td> </td><td class="right">       CometOrbit* orbit=(CometOrbit*)userDataPtr;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Q_ASSERT(orbit);</td><td> </td><td class="right">       Q_ASSERT(orbit);</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0013" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       if (!orbit-&gt;objectDateValid(core-&gt;getJDay())) return; // out of <span class="delete">usef</span></td><td> </td><td class="rblock">       if (!orbit-&gt;objectDateValid(core-&gt;getJDay())) return; // <span class="insert">don't draw </span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">ul</span> date range. This allows having hundreds of comet <span class="delete">elements.</span></td><td> </td><td class="rblock"><span class="insert">at all</span> out of <span class="insert">useful</span> date range. This allows having hundreds of comet <span class="insert">eleme</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"><span class="insert">nts.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       if (orbit-&gt;getUpdateTails()){</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               // Compute lengths and orientations from orbit object, but o</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">nly if required.</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               // TODO: This part should possibly be moved to another threa</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">d to keep draw() free from too much computation.</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               Vec2f tailFactors=getComaDiameterAndTailLengthAU();</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               float gasTailEndRadius=qMax(tailFactors[0], 0.025f*tailFacto</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">rs[1]) ; // This avoids too slim gas tails for bright comets like Hale-Bopp</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">.</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               float gasparameter=gasTailEndRadius*gasTailEndRadius/(2.0f*t</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">ailFactors[1]); // parabola formula: z=r²/2p, so p=r²/2z</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               // The dust tail is thicker and usually shorter. The factors</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"> can be configured in the elements.</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               float dustparameter=gasTailEndRadius*gasTailEndRadius*dustTa</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">ilWidthFactor*dustTailWidthFactor/(2.0f*dustTailLengthFactor*tailFactors[1]</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               // Find valid parameters to create paraboloid vertex arrays:</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"> dustTail, gasTail.</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               computeParabola(gasparameter, gasTailEndRadius, -0.5f*gaspar</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">ameter, gastailVertexArr,  gastailTexCoordArr, gastailIndices);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               // This was for a rotated straight parabola:</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               //computeParabola(dustparameter, 2.0f*tailFactors[0], -0.5f*</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">dustparameter, dusttailVertexArr, dusttailTexCoordArr, dusttailIndices);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               // Now we make a skewed parabola. Skew factor 15 (last arg) </span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">ad-hoc/empirical. TBD later: Find physically correct solution.</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               computeParabola(dustparameter, dustTailWidthFactor*gasTailEn</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">dRadius, -0.5f*dustparameter, dusttailVertexArr, gastailTexCoordArr, gastai</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">lIndices, 25.0f*orbit-&gt;getVelocity().length());</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               // Note that we use a diameter larger than what the formula </span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">returns. A scale factor of 1.2 is ad-hoc/empirical (GZ), but may look bette</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">r.</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               computeComa(1.0f*tailFactors[0]);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               orbit-&gt;setUpdateTails(false); // don't update until position</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"> has been recalculated elsewhere</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       }</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Mat4d mat = Mat4d::translation(eclipticPos) * rotLocalToParent;</td><td> </td><td class="right">       Mat4d mat = Mat4d::translation(eclipticPos) * rotLocalToParent;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0014" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">/*  // We can remove that - a Comet has no parent except for the sun...</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       PlanetP p = parent;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       while (p &amp;&amp; p-&gt;parent)</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       {</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               mat = Mat4d::translation(p-&gt;eclipticPos) * mat * p-&gt;rotLocal</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">ToParent;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               p = p-&gt;parent;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       }</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">*/</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // This removed totally the Planet shaking bug!!!</td><td> </td><td class="right">       // This removed totally the Planet shaking bug!!!</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       StelProjector::ModelViewTranformP transfo = core-&gt;getHeliocentricEcl
ipticModelViewTransform();</td><td> </td><td class="right">       StelProjector::ModelViewTranformP transfo = core-&gt;getHeliocentricEcl
ipticModelViewTransform();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       transfo-&gt;combine(mat);</td><td> </td><td class="right">       transfo-&gt;combine(mat);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Compute the 2D position and check if in the screen</td><td> </td><td class="right">       // Compute the 2D position and check if in the screen</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const StelProjectorP prj = core-&gt;getProjection(transfo);</td><td> </td><td class="right">       const StelProjectorP prj = core-&gt;getProjection(transfo);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       float screenSz = getAngularSize(core)*M_PI/180.*prj-&gt;getPixelPerRadA
tCenter();</td><td> </td><td class="right">       float screenSz = getAngularSize(core)*M_PI/180.*prj-&gt;getPixelPerRadA
tCenter();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       float viewport_left = prj-&gt;getViewportPosX();</td><td> </td><td class="right">       float viewport_left = prj-&gt;getViewportPosX();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       float viewport_bottom = prj-&gt;getViewportPosY();</td><td> </td><td class="right">       float viewport_bottom = prj-&gt;getViewportPosY();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (prj-&gt;project(Vec3d(0), screenPos)</td><td> </td><td class="right">       if (prj-&gt;project(Vec3d(0), screenPos)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l5" /><small>skipping to change at</small><em> line 361</em></th><th> </th><th><a name="part-r5" /><small>skipping to change at</small><em> line 409</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       labelsFader=true;</td><td> </td><td class="right">                       labelsFader=true;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               else</td><td> </td><td class="right">               else</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       labelsFader=false;</td><td> </td><td class="right">                       labelsFader=false;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               drawHints(core, planetNameFont);</td><td> </td><td class="right">               drawHints(core, planetNameFont);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               draw3dModel(core,transfo,screenSz);</td><td> </td><td class="right">               draw3dModel(core,transfo,screenSz);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0015" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       // tails should also be drawn if core is off-screen...</td><td> </td><td class="rblock">       // tails should also be drawn if <span class="insert">comet</span> core is off-screen...</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       drawTail(core,transfo,true);  // gas tail</td><td> </td><td class="rblock">       <span class="insert">if (tailActive)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       drawTail(core,transfo,false); // dust tail</td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                                                           </td><td> </td><td class="rblock">               drawTail(core,transfo,true);  // gas tail</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">               drawTail(core,transfo,false); // dust tail</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">}</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //Coma: this is just a fan disk tilted towards the observer;-)</td><td> </td><td class="right">       //Coma: this is just a fan disk tilted towards the observer;-)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       drawComa(core, transfo);</td><td> </td><td class="right">       drawComa(core, transfo);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       return;</td><td> </td><td class="right">       return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void Comet::drawTail(StelCore* core, StelProjector::ModelViewTranformP tran
sfo, bool gas)</td><td> </td><td class="right">void Comet::drawTail(StelCore* core, StelProjector::ModelViewTranformP tran
sfo, bool gas)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0016" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">// Find rotation matrix from 0/0/1 to eclipticPosition: crossproduct</span></td><td> </td><td class="rblock">       StelPainter* sPainter = new <span class="insert">StelPainter(core-&gt;getProjection(transfo)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"> for axis (normal vector), dotproduct for angle.</span></td><td> </td><td class="rblock"><span class="insert">);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       Vec3d eclposNrm=eclipticPos; eclposNrm.normalize();</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       Mat4d tailrot=Mat4d::rotation(Vec3d(0.0, 0.0, 1.0)^(eclposNrm), std:</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">:acos(Vec3d(0.0, 0.0, 1.0).dot(eclposNrm)) );</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       StelProjector::ModelViewTranformP transfo2 = transfo-&gt;clone();</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       transfo2-&gt;combine(tailrot);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       if (!gas) {</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               CometOrbit* orbit=(CometOrbit*)userDataPtr;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               Vec3d velocity=orbit-&gt;getVelocity(); // [AU/d]</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               // This was a try to rotate a straight parabola somewhat awa</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">y from the antisolar direction.</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               //Mat4d dustTailRot=Mat4d::rotation(eclposNrm^(-velocity), 0</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">.15f*std::acos(eclposNrm.dot(-velocity))); // GZ: This scale factor of 0.15</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"> is empirical from photos of Halley and Hale-Bopp.</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               // The curved tail is curved towards positive X. We first ro</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">tate around the Z axis into a direction opposite of the motion vector, then</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"> again the antisolar rotation applies.</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               Mat4d dustTailRot=Mat4d::zrotation(atan2(velocity[1], veloci</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">ty[0]) + M_PI);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               transfo2-&gt;combine(dustTailRot);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               // In addition, we let the dust tail already start with a li</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">ght tilt.</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               Mat4d dustTailYrot=Mat4d::yrotation(5.0f*velocity.length());</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"> // again, this is pretty ad-hoc, feel free to improve!</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               transfo2-&gt;combine(dustTailYrot);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       }</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       StelPainter* sPainter = new <span class="delete">StelPainter(core-&gt;getProjection(transfo2</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">));</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       glEnable(GL_BLEND);</td><td> </td><td class="right">       glEnable(GL_BLEND);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       glBlendFunc(GL_ONE, GL_ONE);</td><td> </td><td class="right">       glBlendFunc(GL_ONE, GL_ONE);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       glDisable(GL_CULL_FACE);</td><td> </td><td class="right">       glDisable(GL_CULL_FACE);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // GZ: If we use getVMagnitudeWithExtinction(), a head extincted in 
the horizon mist can completely hide an otherwise frighteningly long tail.</td><td> </td><td class="right">       // GZ: If we use getVMagnitudeWithExtinction(), a head extincted in 
the horizon mist can completely hide an otherwise frighteningly long tail.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // we must use unextincted mag, but mix/dim with atmosphere/sky brig
htness.</td><td> </td><td class="right">       // we must use unextincted mag, but mix/dim with atmosphere/sky brig
htness.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // In addition, light falloff is a bit reduced for better visibility
. Power basis should be 0.4, we use 0.6.</td><td> </td><td class="right">       // In addition, light falloff is a bit reduced for better visibility
. Power basis should be 0.4, we use 0.6.</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0017" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       //float magfactor=std::pow(0.4f , getVMagnitudeWithExtinction(core))
;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       float magFactor=std::pow(0.6f , getVMagnitude(core));</td><td> </td><td class="right">       float magFactor=std::pow(0.6f , getVMagnitude(core));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (core-&gt;getSkyDrawer()-&gt;getFlagHasAtmosphere())</td><td> </td><td class="right">       if (core-&gt;getSkyDrawer()-&gt;getFlagHasAtmosphere())</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               // Mix with sky brightness and light pollution: This is very
 ad-hoc, if someone finds a better solution, please go ahead!</td><td> </td><td class="right">               // Mix with sky brightness and light pollution: This is very
 ad-hoc, if someone finds a better solution, please go ahead!</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               // Light pollution:</td><td> </td><td class="right">               // Light pollution:</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               float bortleIndexFactor=0.1f * (11 - core-&gt;getSkyDrawer()-&gt;g
etBortleScaleIndex());</td><td> </td><td class="right">               float bortleIndexFactor=0.1f * (11 - core-&gt;getSkyDrawer()-&gt;g
etBortleScaleIndex());</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               magFactor*= bortleIndexFactor*bortleIndexFactor; // GZ-Guess
timate for light pollution influence</td><td> </td><td class="right">               magFactor*= bortleIndexFactor*bortleIndexFactor; // GZ-Guess
timate for light pollution influence</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               // sky brightness: This is about 10 for twilight where brigh
t comet tails should already be visible. Dark night is close to 0.</td><td> </td><td class="right">               // sky brightness: This is about 10 for twilight where brigh
t comet tails should already be visible. Dark night is close to 0.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               float avgAtmLum=GETSTELMODULE(LandscapeMgr)-&gt;getAtmosphereAv
erageLuminance();</td><td> </td><td class="right">               float avgAtmLum=GETSTELMODULE(LandscapeMgr)-&gt;getAtmosphereAv
erageLuminance();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               float atmLumFactor=(15.0f-avgAtmLum)/15.0f;  if (atmLumFacto
r&lt;0.05f) atmLumFactor=0.05f;    //atmLumFactor=std::sqrt(atmLumFactor);</td><td> </td><td class="right">               float atmLumFactor=(15.0f-avgAtmLum)/15.0f;  if (atmLumFacto
r&lt;0.05f) atmLumFactor=0.05f;    //atmLumFactor=std::sqrt(atmLumFactor);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               magFactor*=atmLumFactor*atmLumFactor;</td><td> </td><td class="right">               magFactor*=atmLumFactor*atmLumFactor;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       magFactor*=(gas? 0.9 : dustTailBrightnessFactor); // TBD: empirical 
adjustment for texture brightness.</td><td> </td><td class="right">       magFactor*=(gas? 0.9 : dustTailBrightnessFactor); // TBD: empirical 
adjustment for texture brightness.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       magFactor=qMin(magFactor, 1.05f); // Limit excessively bright displa
y.</td><td> </td><td class="right">       magFactor=qMin(magFactor, 1.05f); // Limit excessively bright displa
y.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0018" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">gasT</span>ailTexture-&gt;bind();</td><td> </td><td class="rblock">       <span class="insert">t</span>ailTexture-&gt;bind();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (gas) {</td><td> </td><td class="right">       if (gas) {</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0019" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               //gasTailTexture-&gt;bind();</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               sPainter-&gt;setColor(0.15f*magFactor,0.15f*magFactor,0.6f*magF
actor);</td><td> </td><td class="right">               sPainter-&gt;setColor(0.15f*magFactor,0.15f*magFactor,0.6f*magF
actor);</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0020" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               sPainter-&gt;setArrays((Vec3d*)gastailVertexArr.constData(), (V</td><td> </td><td class="rblock">               sPainter-&gt;setArrays((Vec3d*)gastailVertexArr.constData(), (V</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">ec2f*)gastailTexCoordArr.constData());</span></td><td> </td><td class="rblock"><span class="insert">ec2f*)tailTexCoordArr.constData());</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               sPainter-&gt;drawFromArray(StelPainter::Triangles, <span class="delete">gastailIndic</span></td><td> </td><td class="rblock">               sPainter-&gt;drawFromArray(StelPainter::Triangles, <span class="insert">tailIndices.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">es.size(),</span> 0, true, <span class="delete">gastailIndices.constData());</span></td><td> </td><td class="rblock"><span class="insert">size(),</span> 0, true, <span class="insert">tailIndices.constData());</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       } else {</td><td> </td><td class="right">       } else {</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0021" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               //dustTailTexture-&gt;bind();</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               sPainter-&gt;setColor(magFactor, magFactor,0.6f*magFactor);</td><td> </td><td class="right">               sPainter-&gt;setColor(magFactor, magFactor,0.6f*magFactor);</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0022" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               <span class="delete">//sPainter-&gt;setArrays((Vec3d*)dusttailVertexArr.constData(),</span></td><td> </td><td class="rblock">               sPainter-&gt;setArrays((Vec3d*)dusttailVertexArr.constData(), (</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"> (Vec2f*)dusttailTexCoordArr.constData());</span></td><td> </td><td class="rblock"><span class="insert">Vec2f*)tailTexCoordArr.constData());</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               //sPainter-&gt;drawFromArray(StelPainter::Triangles, dusttailIn</span></td><td> </td><td class="rblock">               sPainter-&gt;drawFromArray(StelPainter::Triangles, <span class="insert">tailIndices.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">dices.size(), 0, true, dusttailIndices.constData());</span></td><td> </td><td class="rblock"><span class="insert">size(),</span> 0, true, <span class="insert">tailIndices.constData());</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               sPainter-&gt;setArrays((Vec3d*)dusttailVertexArr.constData(), (</td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">Vec2f*)gastailTexCoordArr.constData());</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               sPainter-&gt;drawFromArray(StelPainter::Triangles, <span class="delete">gastailIndic</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">es.size(),</span> 0, true, <span class="delete">gastailIndices.constData());</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       glDisable(GL_BLEND);</td><td> </td><td class="right">       glDisable(GL_BLEND);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (sPainter)</td><td> </td><td class="right">       if (sPainter)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               delete sPainter;</td><td> </td><td class="right">               delete sPainter;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       sPainter=NULL;</td><td> </td><td class="right">       sPainter=NULL;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void Comet::drawComa(StelCore* core, StelProjector::ModelViewTranformP tran
sfo)</td><td> </td><td class="right">void Comet::drawComa(StelCore* core, StelProjector::ModelViewTranformP tran
sfo)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l6" /><small>skipping to change at</small><em> line 471</em></th><th> </th><th><a name="part-r6" /><small>skipping to change at</small><em> line 498</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       sPainter-&gt;drawFromArray(StelPainter::Triangles, comaVertexArr.size()
/3);</td><td> </td><td class="right">       sPainter-&gt;drawFromArray(StelPainter::Triangles, comaVertexArr.size()
/3);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       glDisable(GL_BLEND);</td><td> </td><td class="right">       glDisable(GL_BLEND);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (sPainter)</td><td> </td><td class="right">       if (sPainter)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               delete sPainter;</td><td> </td><td class="right">               delete sPainter;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       sPainter=NULL;</td><td> </td><td class="right">       sPainter=NULL;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// Formula found at http://www.projectpluto.com/update7b.htm#comet_tail_for
mula</td><td> </td><td class="right">// Formula found at http://www.projectpluto.com/update7b.htm#comet_tail_for
mula</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0023" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">Vec2f Comet::getComaDiameterAndTailLengthAU()<span class="delete"> const</span></td><td> </td><td class="rblock">Vec2f Comet::getComaDiameterAndTailLengthAU()</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       float r = getHeliocentricEclipticPos().length();</td><td> </td><td class="right">       float r = getHeliocentricEclipticPos().length();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       float mhelio = absoluteMagnitude + slopeParameter * log10(r);</td><td> </td><td class="right">       float mhelio = absoluteMagnitude + slopeParameter * log10(r);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       float Do = pow(10.0f, ((-0.0033f*mhelio - 0.07f) * mhelio + 3.25f));</td><td> </td><td class="right">       float Do = pow(10.0f, ((-0.0033f*mhelio - 0.07f) * mhelio + 3.25f));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       float common = 1.0f - pow(10.0f, (-2.0f*r));</td><td> </td><td class="right">       float common = 1.0f - pow(10.0f, (-2.0f*r));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       float D = Do * common * (1.0f - pow(10.0f, -r)) * (1000.0f*AU_KM);</td><td> </td><td class="right">       float D = Do * common * (1.0f - pow(10.0f, -r)) * (1000.0f*AU_KM);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       float Lo = pow(10.0f, ((-0.0075f*mhelio - 0.19f) * mhelio + 2.1f));</td><td> </td><td class="right">       float Lo = pow(10.0f, ((-0.0075f*mhelio - 0.19f) * mhelio + 2.1f));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       float L = Lo*(1.0f-pow(10.0f, -4.0f*r)) * common * (1e6*AU_KM);</td><td> </td><td class="right">       float L = Lo*(1.0f-pow(10.0f, -4.0f*r)) * common * (1e6*AU_KM);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       return Vec2f(D, L);</td><td> </td><td class="right">       return Vec2f(D, L);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l7" /><small>skipping to change at</small><em> line 494</em></th><th> </th><th><a name="part-r7" /><small>skipping to change at</small><em> line 521</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       StelPainter::computeFanDisk(0.5f*diameter, 3, 3, comaVertexArr, coma
TexCoordArr);</td><td> </td><td class="right">       StelPainter::computeFanDisk(0.5f*diameter, 3, 3, comaVertexArr, coma
TexCoordArr);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! create parabola shell to represent a tail. Designed for slices=16, stac
ks=16, but should work with other sizes as well.</td><td> </td><td class="right">//! create parabola shell to represent a tail. Designed for slices=16, stac
ks=16, but should work with other sizes as well.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! (Maybe slices must be an even number.)</td><td> </td><td class="right">//! (Maybe slices must be an even number.)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// Parabola equation: z=x²/2p.</td><td> </td><td class="right">// Parabola equation: z=x²/2p.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// xOffset for the dust tail, this may introduce a bend. Units are x per sq
rt(z).</td><td> </td><td class="right">// xOffset for the dust tail, this may introduce a bend. Units are x per sq
rt(z).</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void Comet::computeParabola(const float parameter, const float radius, cons
t float zshift,</td><td> </td><td class="right">void Comet::computeParabola(const float parameter, const float radius, cons
t float zshift,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                           QVector&lt;double&gt;&amp; vertexArr, QVector&lt;float&gt;&amp; texC
oordArr, QVector&lt;unsigned short&gt; &amp;indices, const float xOffset) {</td><td> </td><td class="right">                           QVector&lt;double&gt;&amp; vertexArr, QVector&lt;float&gt;&amp; texC
oordArr, QVector&lt;unsigned short&gt; &amp;indices, const float xOffset) {</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0024" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">vertexArr.clear();</span></td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       //texCoordArr.clear();</span></td><td> </td><td class="rblock">       <span class="insert">// GZ: keep the array and replace contents. However, using replace()</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       //indices.clear();</span></td><td> </td><td class="rblock"><span class="insert"> is only slightly faster.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       bool createIndices= indices.empty();</span></td><td> </td><td class="rblock"><span class="insert">       if (vertexArr.length() &lt; (3*(COMET_TAIL_SLICES*COMET_TAIL_STACKS+1))</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       bool createTexcoords= texCoordArr.empty();</span></td><td> </td><td class="rblock"><span class="insert">)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               vertexArr.resize(3*(COMET_TAIL_SLICES*COMET_TAIL_STACKS+1));</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       if (createTailIndices) indices.clear();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       if (createTailTextureCoords) texCoordArr.clear();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       int i;</td><td> </td><td class="right">       int i;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // The parabola has triangular faces with vertices on two circles th
at are rotated against each other.</td><td> </td><td class="right">       // The parabola has triangular faces with vertices on two circles th
at are rotated against each other.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       float xa[2*COMET_TAIL_SLICES];</td><td> </td><td class="right">       float xa[2*COMET_TAIL_SLICES];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       float ya[2*COMET_TAIL_SLICES];</td><td> </td><td class="right">       float ya[2*COMET_TAIL_SLICES];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       float x, y, z;</td><td> </td><td class="right">       float x, y, z;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // fill xa, ya with sin/cosines. TBD: make more efficient with index
 mirroring etc.</td><td> </td><td class="right">       // fill xa, ya with sin/cosines. TBD: make more efficient with index
 mirroring etc.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       float da=M_PI/COMET_TAIL_SLICES; // full circle/2slices</td><td> </td><td class="right">       float da=M_PI/COMET_TAIL_SLICES; // full circle/2slices</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       for (i=0; i&lt;2*COMET_TAIL_SLICES; ++i){</td><td> </td><td class="right">       for (i=0; i&lt;2*COMET_TAIL_SLICES; ++i){</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               xa[i]=-sin(i*da);</td><td> </td><td class="right">               xa[i]=-sin(i*da);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               ya[i]=cos(i*da);</td><td> </td><td class="right">               ya[i]=cos(i*da);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0025" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">// center point, vertex0</span></td><td> </td><td class="rblock">       <span class="insert">vertexArr.replace(0, 0.0); vertexArr.replace(1, 0.0); vertexArr.repl</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       vertexArr &lt;&lt; 0.0f &lt;&lt; 0.0f &lt;&lt; zshift;</span></td><td> </td><td class="rblock"><span class="insert">ace(2, zshift);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       if <span class="delete">(createTexcoords)</span> texCoordArr &lt;&lt; 0.5f &lt;&lt; 0.5f;</td><td> </td><td class="rblock"><span class="insert">       int vertexArrIndex=3;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       if <span class="insert">(createTailTextureCoords)</span> texCoordArr &lt;&lt; 0.5f &lt;&lt; 0.5f;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // define the indices lying on circles, starting at 1: odd rings hav
e 1/slices+1/2slices, even-numbered rings straight 1/slices</td><td> </td><td class="right">       // define the indices lying on circles, starting at 1: odd rings hav
e 1/slices+1/2slices, even-numbered rings straight 1/slices</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // inner ring#1</td><td> </td><td class="right">       // inner ring#1</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       int ring;</td><td> </td><td class="right">       int ring;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       for (ring=1; ring&lt;=COMET_TAIL_STACKS; ++ring){</td><td> </td><td class="right">       for (ring=1; ring&lt;=COMET_TAIL_STACKS; ++ring){</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               z=ring*radius/COMET_TAIL_STACKS; z=z*z/(2*parameter) + zshif
t;</td><td> </td><td class="right">               z=ring*radius/COMET_TAIL_STACKS; z=z*z/(2*parameter) + zshif
t;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               float xShift= xOffset*z*z;</td><td> </td><td class="right">               float xShift= xOffset*z*z;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               for (i=ring &amp; 1; i&lt;2*COMET_TAIL_SLICES; i+=2) { // i.e., rin
g1 has shifted vertices, ring2 has even ones.</td><td> </td><td class="right">               for (i=ring &amp; 1; i&lt;2*COMET_TAIL_SLICES; i+=2) { // i.e., rin
g1 has shifted vertices, ring2 has even ones.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       x=xa[i]*radius*ring/COMET_TAIL_STACKS;</td><td> </td><td class="right">                       x=xa[i]*radius*ring/COMET_TAIL_STACKS;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       y=ya[i]*radius*ring/COMET_TAIL_STACKS;</td><td> </td><td class="right">                       y=ya[i]*radius*ring/COMET_TAIL_STACKS;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0026" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       <span class="delete">vertexArr &lt;&lt; x+xShift &lt;&lt; y &lt;&lt; z;</span></td><td> </td><td class="rblock">                       <span class="insert">vertexArr.replace(vertexArrIndex++, x+xShift);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       if <span class="delete">(createTexcoords)</span> texCoordArr &lt;&lt; 0.5+ <span class="delete">0.5*x/radiu</span></td><td> </td><td class="rblock"><span class="insert">                       vertexArr.replace(vertexArrIndex++, y);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">s</span> &lt;&lt; 0.5+0.5*y/radius;</td><td> </td><td class="rblock"><span class="insert">                       vertexArr.replace(vertexArrIndex++, z);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                       if <span class="insert">(createTailTextureCoords)</span> texCoordArr &lt;&lt; 0.5+ <span class="insert">0.5</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">*x/radius</span> &lt;&lt; 0.5+0.5*y/radius;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0027" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       // now link the faces with indices. <span class="delete">That's fun... ;-)</span></td><td> </td><td class="rblock">       // now link the faces with indices.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       if <span class="delete">(createIndices)</span></td><td> </td><td class="rblock">       if <span class="insert">(createTailIndices)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               for (i=1; i&lt;COMET_TAIL_SLICES; ++i) indices &lt;&lt; 0 &lt;&lt; i &lt;&lt; i+1
;</td><td> </td><td class="right">               for (i=1; i&lt;COMET_TAIL_SLICES; ++i) indices &lt;&lt; 0 &lt;&lt; i &lt;&lt; i+1
;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               indices &lt;&lt; 0 &lt;&lt; COMET_TAIL_SLICES &lt;&lt; 1; // close inner fan.</td><td> </td><td class="right">               indices &lt;&lt; 0 &lt;&lt; COMET_TAIL_SLICES &lt;&lt; 1; // close inner fan.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               // The other slices are a repeating pattern of 2 possibiliti
es. Index @ring always is on the inner ring (slices-agon)</td><td> </td><td class="right">               // The other slices are a repeating pattern of 2 possibiliti
es. Index @ring always is on the inner ring (slices-agon)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               for (ring=1; ring&lt;COMET_TAIL_STACKS; ring+=2) { // odd rings</td><td> </td><td class="right">               for (ring=1; ring&lt;COMET_TAIL_STACKS; ring+=2) { // odd rings</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       const int first=(ring-1)*COMET_TAIL_SLICES+1;</td><td> </td><td class="right">                       const int first=(ring-1)*COMET_TAIL_SLICES+1;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       for (i=0; i&lt;COMET_TAIL_SLICES-1; ++i){</td><td> </td><td class="right">                       for (i=0; i&lt;COMET_TAIL_SLICES-1; ++i){</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               indices &lt;&lt; first+i &lt;&lt; first+COMET_TAIL_SLICE
S+i &lt;&lt; first+COMET_TAIL_SLICES+1+i;</td><td> </td><td class="right">                               indices &lt;&lt; first+i &lt;&lt; first+COMET_TAIL_SLICE
S+i &lt;&lt; first+COMET_TAIL_SLICES+1+i;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               indices &lt;&lt; first+i &lt;&lt; first+COMET_TAIL_SLICE
S+1+i &lt;&lt; first+1+i;</td><td> </td><td class="right">                               indices &lt;&lt; first+i &lt;&lt; first+COMET_TAIL_SLICE
S+1+i &lt;&lt; first+1+i;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       }</td><td> </td><td class="right">                       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l8" /><small>skipping to change at</small><em> line 556</em></th><th> </th><th><a name="part-r8" /><small>skipping to change at</small><em> line 586</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       const int first=(ring-1)*COMET_TAIL_SLICES+1;</td><td> </td><td class="right">                       const int first=(ring-1)*COMET_TAIL_SLICES+1;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       for (i=0; i&lt;COMET_TAIL_SLICES-1; ++i){</td><td> </td><td class="right">                       for (i=0; i&lt;COMET_TAIL_SLICES-1; ++i){</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               indices &lt;&lt; first+i &lt;&lt; first+COMET_TAIL_SLICE
S+i &lt;&lt; first+1+i;</td><td> </td><td class="right">                               indices &lt;&lt; first+i &lt;&lt; first+COMET_TAIL_SLICE
S+i &lt;&lt; first+1+i;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               indices &lt;&lt; first+1+i &lt;&lt; first+COMET_TAIL_SLI
CES+i &lt;&lt; first+COMET_TAIL_SLICES+1+i;</td><td> </td><td class="right">                               indices &lt;&lt; first+1+i &lt;&lt; first+COMET_TAIL_SLI
CES+i &lt;&lt; first+COMET_TAIL_SLICES+1+i;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       }</td><td> </td><td class="right">                       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       // closing slice: mesh with other indices...</td><td> </td><td class="right">                       // closing slice: mesh with other indices...</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       indices &lt;&lt; ring*COMET_TAIL_SLICES &lt;&lt; (ring+1)*COMET_
TAIL_SLICES &lt;&lt; first;</td><td> </td><td class="right">                       indices &lt;&lt; ring*COMET_TAIL_SLICES &lt;&lt; (ring+1)*COMET_
TAIL_SLICES &lt;&lt; first;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       indices &lt;&lt; first &lt;&lt; (ring+1)*COMET_TAIL_SLICES &lt;&lt; ri
ng*COMET_TAIL_SLICES+1;</td><td> </td><td class="right">                       indices &lt;&lt; first &lt;&lt; (ring+1)*COMET_TAIL_SLICES &lt;&lt; ri
ng*COMET_TAIL_SLICES+1;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0028" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//     qDebug() &lt;&lt; "Parabola: Vertex index dump\n";</span></td><td> </td><td class="rblock">       <span class="insert">createTailIndices=false;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//     for (int i=0; i&lt;indices.length(); i+=3)</span></td><td> </td><td class="rblock"><span class="insert">       createTailTextureCoords=false;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//             qDebug() &lt;&lt; indices[i] &lt;&lt; "-" &lt;&lt; indices[i+1] &lt;&lt; "-" &lt;&lt; indi</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">ces[i+2] &lt;&lt; ":"</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//                              &lt;&lt; vertexArr[3*indices[i]]   &lt;&lt; vertexArr[3</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">*indices[i]+1]   &lt;&lt; vertexArr[3*indices[i]+2]   &lt;&lt; "/"</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//                              &lt;&lt; vertexArr[3*indices[i+1]] &lt;&lt; vertexArr[3</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">*indices[i+1]+1] &lt;&lt; vertexArr[3*indices[i+1]+2] &lt;&lt; "/"</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">//                              &lt;&lt; vertexArr[3*indices[i+2]] &lt;&lt; vertexArr[3</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">*indices[i+2]+1] &lt;&lt; vertexArr[3*indices[i+2]+2];</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                                                           </td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0029" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">// These are to avoid having index arrays for each comet when all are equal</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">bool Comet::createTailIndices=true;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">bool Comet::createTailTextureCoords=true;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">StelTextureSP Comet::comaTexture;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">StelTextureSP Comet::tailTexture;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">QVector&lt;float&gt; Comet::tailTexCoordArr; // computed only once FOR ALL COMETS</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">!</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">QVector&lt;unsigned short&gt; Comet::tailIndices; // computed only once FOR ALL C</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">OMETS!</span></td><td class="lineno" valign="top"></td></tr>

     <tr><td></td><td class="left"></td><td> </td><td class="right"></td><td></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 29 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><td></td><th><i>156 lines changed or deleted</i></th><th><i> </i></th><th><i>193 lines changed or added</i></th><td></td></tr>
     <tr><td colspan="5" align="center" class="small"><br/>This html diff was produced by rfcdiff 1.41. The latest version is available from <a href="http://www.tools.ietf.org/tools/rfcdiff/" >http://tools.ietf.org/tools/rfcdiff/</a> </td></tr>
   </table>
   </body>
   </html>
