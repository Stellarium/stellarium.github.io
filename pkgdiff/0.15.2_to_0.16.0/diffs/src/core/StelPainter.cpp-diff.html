<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"> 
<!-- Generated by rfcdiff 1.41: rfcdiff  --> 
<!-- <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional" > -->
<!-- System: Linux fomalhaut.home 4.4.0-80-generic #101-Ubuntu SMP Thu Jun 8 15:35:06 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux --> 
<!-- Using awk: /usr/bin/gawk: GNU Awk 4.1.3, API: 1.1 (GNU MPFR 3.1.4, GNU MP 6.1.0) --> 
<!-- Using diff: /usr/bin/diff: diff (GNU diffutils) 3.3 --> 
<!-- Using wdiff: /usr/bin/wdiff: wdiff (GNU wdiff) 1.2.2 --> 
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"> 
<head> 
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /> 
  <meta http-equiv="Content-Style-Type" content="text/css" /> 
  <title>Diff: StelPainter.cpp - StelPainter.cpp</title> 
  <style type="text/css"> 
    body    { font-size:16px; margin: 0.4ex; margin-right: auto; } 
    tr      { } 
    td      { white-space: pre; font-family: Consolas, "DejaVu Sans Mono", "Droid Sans Mono", Monaco, Monospace; vertical-align: top; font-size: 0.86em;} 
    th      { font-size: 0.86em; } 
    .small  { font-size: 0.6em; font-style: italic; font-family: Verdana, Helvetica, sans-serif; } 
    .left   { background-color: #EEE; } 
    .right  { background-color: #FFF; } 
    .diff   { background-color: #CCF; } 
    .lblock { background-color: #BFB; } 
    .rblock { background-color: #FF8; } 
    .insert { background-color: #8FF; } 
    .delete { background-color: #ACF; } 
    .void   { background-color: #FFB; } 
    .cont   { background-color: #EEE; } 
    .linebr { background-color: #AAA; } 
    .lineno { color: red; background-color: #FFF; font-size: 0.7em; text-align: right; padding: 0 2px; } 
    .elipsis{ background-color: #AAA; } 
    .left .cont { background-color: #DDD; } 
    .right .cont { background-color: #EEE; } 
    .lblock .cont { background-color: #9D9; } 
    .rblock .cont { background-color: #DD6; } 
    .insert .cont { background-color: #0DD; } 
    .delete .cont { background-color: #8AD; } 
    .stats, .stats td, .stats th { background-color: #EEE; padding: 2px 0; } 
  </style> 
</head> 
<body > 
  <table border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th></th><th>&nbsp;StelPainter.cpp&nbsp;</th><th> </th><th>&nbsp;StelPainter.cpp&nbsp;</th><th></th></tr> 
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l1" /><small>skipping to change at</small><em> line 49</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 49</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#include &lt;QOpenGLTexture&gt;</td><td> </td><td class="right">#include &lt;QOpenGLTexture&gt;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#include &lt;QApplication&gt;</td><td> </td><td class="right">#include &lt;QApplication&gt;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">static const int TEX_CACHE_LIMIT = 7000000;</td><td> </td><td class="right">static const int TEX_CACHE_LIMIT = 7000000;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#ifndef NDEBUG</td><td> </td><td class="right">#ifndef NDEBUG</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">QMutex* StelPainter::globalMutex = new QMutex();</td><td> </td><td class="right">QMutex* StelPainter::globalMutex = new QMutex();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#endif</td><td> </td><td class="right">#endif</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">QCache&lt;QByteArray, StringTexture&gt; StelPainter::texCache(TEX_CACHE_LIMIT);</td><td> </td><td class="right">QCache&lt;QByteArray, StringTexture&gt; StelPainter::texCache(TEX_CACHE_LIMIT);</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">QOpenGLShaderProgram* <span class="delete">StelPainter::texturesShaderProgram=NULL;</span></td><td> </td><td class="rblock">QOpenGLShaderProgram* <span class="insert">StelPainter::texturesShaderProgram=Q_NULLPTR;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">QOpenGLShaderProgram* <span class="delete">StelPainter::basicShaderProgram=NULL;</span></td><td> </td><td class="rblock">QOpenGLShaderProgram* <span class="insert">StelPainter::basicShaderProgram=Q_NULLPTR;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">QOpenGLShaderProgram* <span class="delete">StelPainter::colorShaderProgram=NULL;</span></td><td> </td><td class="rblock">QOpenGLShaderProgram* <span class="insert">StelPainter::colorShaderProgram=Q_NULLPTR;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">QOpenGLShaderProgram* <span class="delete">StelPainter::texturesColorShaderProgram=NULL;</span></td><td> </td><td class="rblock">QOpenGLShaderProgram* <span class="insert">StelPainter::texturesColorShaderProgram=Q_NULLPTR;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">StelPainter::BasicShaderVars StelPainter::basicShaderVars;</td><td> </td><td class="right">StelPainter::BasicShaderVars StelPainter::basicShaderVars;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">StelPainter::TexturesShaderVars StelPainter::texturesShaderVars;</td><td> </td><td class="right">StelPainter::TexturesShaderVars StelPainter::texturesShaderVars;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">StelPainter::BasicShaderVars StelPainter::colorShaderVars;</td><td> </td><td class="right">StelPainter::BasicShaderVars StelPainter::colorShaderVars;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">StelPainter::TexturesColorShaderVars StelPainter::texturesColorShaderVars;</td><td> </td><td class="right">StelPainter::TexturesColorShaderVars StelPainter::texturesColorShaderVars;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">StelPainter::GLState::GLState(QOpenGLFunctions* gl)</td><td> </td><td class="right">StelPainter::GLState::GLState(QOpenGLFunctions* gl)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       : blend(false),</td><td> </td><td class="right">       : blend(false),</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">         blendSrc(GL_SRC_ALPHA), blendDst(GL_ONE_MINUS_SRC_ALPHA),</td><td> </td><td class="right">         blendSrc(GL_SRC_ALPHA), blendDst(GL_ONE_MINUS_SRC_ALPHA),</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">         depthTest(false),</td><td> </td><td class="right">         depthTest(false),</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">         depthMask(false),</td><td> </td><td class="right">         depthMask(false),</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l2" /><small>skipping to change at</small><em> line 107</em></th><th> </th><th><a name="part-r2" /><small>skipping to change at</small><em> line 107</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void StelPainter::GLState::reset()</td><td> </td><td class="right">void StelPainter::GLState::reset()</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       *this = GLState(gl);</td><td> </td><td class="right">       *this = GLState(gl);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       apply();</td><td> </td><td class="right">       apply();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">bool StelPainter::linkProg(QOpenGLShaderProgram* prog, const QString&amp; name)</td><td> </td><td class="right">bool StelPainter::linkProg(QOpenGLShaderProgram* prog, const QString&amp; name)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       bool ret = prog-&gt;link();</td><td> </td><td class="right">       bool ret = prog-&gt;link();</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0002" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       if (!ret || <span class="delete">(!prog-&gt;log().isEmpty()</span> &amp;&amp; <span class="delete">!prog-&gt;log().contains("Link w</span></td><td> </td><td class="rblock">       <span class="insert">QString log = prog-&gt;log();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">as successful")))</span></td><td> </td><td class="rblock">       if (!ret || <span class="insert">(!log.isEmpty()</span> &amp;&amp; <span class="insert">!log.contains("Link was successful") </span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">&amp;&amp; !(log=="No errors."))) //"No errors." returned on some Intel drivers</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               qWarning() &lt;&lt; QString("StelPainter: Warnings while linking %
1 shader program:\n%2").arg(name, prog-&gt;log());</td><td> </td><td class="right">               qWarning() &lt;&lt; QString("StelPainter: Warnings while linking %
1 shader program:\n%2").arg(name, prog-&gt;log());</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       return ret;</td><td> </td><td class="right">       return ret;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">StelPainter::StelPainter(const StelProjectorP&amp; proj) : QOpenGLFunctions(QOp
enGLContext::currentContext()), glState(this)</td><td> </td><td class="right">StelPainter::StelPainter(const StelProjectorP&amp; proj) : QOpenGLFunctions(QOp
enGLContext::currentContext()), glState(this)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Q_ASSERT(proj);</td><td> </td><td class="right">       Q_ASSERT(proj);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#ifndef NDEBUG</td><td> </td><td class="right">#ifndef NDEBUG</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Q_ASSERT(globalMutex);</td><td> </td><td class="right">       Q_ASSERT(globalMutex);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l3" /><small>skipping to change at</small><em> line 333</em></th><th> </th><th><a name="part-r3" /><small>skipping to change at</small><em> line 334</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               vertices[i*2+1][2] = 0.0;</td><td> </td><td class="right">               vertices[i*2+1][2] = 0.0;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       drawFromArray(TriangleStrip, (slices+1)*2, 0, false);</td><td> </td><td class="right">       drawFromArray(TriangleStrip, (slices+1)*2, 0, false);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       enableClientStates(false);</td><td> </td><td class="right">       enableClientStates(false);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if(oldBlendState)</td><td> </td><td class="right">       if(oldBlendState)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               glEnable(GL_BLEND);</td><td> </td><td class="right">               glEnable(GL_BLEND);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void StelPainter::computeFanDisk(float radius, int innerFanSlices, int leve
l, QVector&lt;double&gt;&amp; vertexArr, QVector&lt;float&gt;&amp; texCoordArr)</td><td> </td><td class="right">void StelPainter::computeFanDisk(float radius, int innerFanSlices, int leve
l, QVector&lt;double&gt;&amp; vertexArr, QVector&lt;float&gt;&amp; texCoordArr)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0003" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       Q_ASSERT(level&lt;<span class="delete">64</span>);</td><td> </td><td class="rblock">       Q_ASSERT(level&lt;<span class="insert">32</span>);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       float rad[64];</td><td> </td><td class="right">       float rad[64];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       int i,j;</td><td> </td><td class="right">       int i,j;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       rad[level] = radius;</td><td> </td><td class="right">       rad[level] = radius;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       for (i=level-1;i&gt;=0;--i)</td><td> </td><td class="right">       for (i=level-1;i&gt;=0;--i)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               rad[i] = rad[i+1]*(1.f-M_PI/(innerFanSlices&lt;&lt;(i+1)))*2.f/3.f
;</td><td> </td><td class="right">               rad[i] = rad[i+1]*(1.f-M_PI/(innerFanSlices&lt;&lt;(i+1)))*2.f/3.f
;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       int slices = innerFanSlices&lt;&lt;level;</td><td> </td><td class="right">       int slices = innerFanSlices&lt;&lt;level;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       float* cos_sin_theta = StelUtils::ComputeCosSinTheta(slices);</td><td> </td><td class="right">       float* cos_sin_theta = StelUtils::ComputeCosSinTheta(slices);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l4" /><small>skipping to change at</small><em> line 818</em></th><th> </th><th><a name="part-r4" /><small>skipping to change at</small><em> line 819</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">static Vec3d pt1, pt2;</td><td> </td><td class="right">static Vec3d pt1, pt2;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void StelPainter::drawGreatCircleArc(const Vec3d&amp; start, const Vec3d&amp; stop,
 const SphericalCap* clippingCap,</td><td> </td><td class="right">void StelPainter::drawGreatCircleArc(const Vec3d&amp; start, const Vec3d&amp; stop,
 const SphericalCap* clippingCap,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       void (*viewportEdgeIntersectCallback)(const Vec3d&amp; screenPos, const 
Vec3d&amp; direction, void* userData), void* userData)</td><td> </td><td class="right">       void (*viewportEdgeIntersectCallback)(const Vec3d&amp; screenPos, const 
Vec3d&amp; direction, void* userData), void* userData)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"> {</td><td> </td><td class="right"> {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">        if (clippingCap)</td><td> </td><td class="right">        if (clippingCap)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">        {</td><td> </td><td class="right">        {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                pt1=start;</td><td> </td><td class="right">                pt1=start;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                pt2=stop;</td><td> </td><td class="right">                pt2=stop;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                if (clippingCap-&gt;clipGreatCircle(pt1, pt2))</td><td> </td><td class="right">                if (clippingCap-&gt;clipGreatCircle(pt1, pt2))</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                {</td><td> </td><td class="right">                {</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0004" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       drawSmallCircleArc(pt1, pt2, Vec3d(0<span class="delete">), viewportEdgeI
</span>ntersectCallback, userData);</td><td> </td><td class="rblock">                       drawSmallCircleArc(pt1, pt2, Vec3d(0<span class="insert">.), viewportEdge
I</span>ntersectCallback, userData);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                }</td><td> </td><td class="right">                }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                return;</td><td> </td><td class="right">                return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0005" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       drawSmallCircleArc(start, stop, Vec3d(0<span class="delete">), viewportEdgeIntersectCallb
</span>ack, userData);</td><td> </td><td class="rblock">       drawSmallCircleArc(start, stop, Vec3d(0<span class="insert">.), viewportEdgeIntersectCall
b</span>ack, userData);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"> }</td><td> </td><td class="right"> }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">/*************************************************************************</td><td> </td><td class="right">/*************************************************************************</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"> Draw a small circle arc in the current frame</td><td> </td><td class="right"> Draw a small circle arc in the current frame</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">*************************************************************************/</td><td> </td><td class="right">*************************************************************************/</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void StelPainter::drawSmallCircleArc(const Vec3d&amp; start, const Vec3d&amp; stop,
 const Vec3d&amp; rotCenter, void (*viewportEdgeIntersectCallback)(const Vec3d&amp;
 screenPos, const Vec3d&amp; direction, void* userData), void* userData)</td><td> </td><td class="right">void StelPainter::drawSmallCircleArc(const Vec3d&amp; start, const Vec3d&amp; stop,
 const Vec3d&amp; rotCenter, void (*viewportEdgeIntersectCallback)(const Vec3d&amp;
 screenPos, const Vec3d&amp; direction, void* userData), void* userData)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Q_ASSERT(smallCircleVertexArray.empty());</td><td> </td><td class="right">       Q_ASSERT(smallCircleVertexArray.empty());</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       QLinkedList&lt;Vec3d&gt; tessArc;     // Contains the list of projected po
ints from the tesselated arc</td><td> </td><td class="right">       QLinkedList&lt;Vec3d&gt; tessArc;     // Contains the list of projected po
ints from the tesselated arc</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l5" /><small>skipping to change at</small><em> line 939</em></th><th> </th><th><a name="part-r5" /><small>skipping to change at</small><em> line 940</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// Project the passed triangle on the screen ensuring that it will look smo
oth, even for non linear distortion</td><td> </td><td class="right">// Project the passed triangle on the screen ensuring that it will look smo
oth, even for non linear distortion</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// by splitting it into subtriangles.</td><td> </td><td class="right">// by splitting it into subtriangles.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void StelPainter::projectSphericalTriangle(const SphericalCap* clippingCap,
 const Vec3d* vertices, QVarLengthArray&lt;Vec3f, 4096&gt;* outVertices,</td><td> </td><td class="right">void StelPainter::projectSphericalTriangle(const SphericalCap* clippingCap,
 const Vec3d* vertices, QVarLengthArray&lt;Vec3f, 4096&gt;* outVertices,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">        const Vec2f* texturePos, QVarLengthArray&lt;Vec2f, 4096&gt;* outTexturePo
s, const Vec3f *colors, QVarLengthArray&lt;Vec3f, 4096&gt; *outColors,</td><td> </td><td class="right">        const Vec2f* texturePos, QVarLengthArray&lt;Vec2f, 4096&gt;* outTexturePo
s, const Vec3f *colors, QVarLengthArray&lt;Vec3f, 4096&gt; *outColors,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">        double maxSqDistortion, int nbI, bool checkDisc1, bool checkDisc2, 
bool checkDisc3) const</td><td> </td><td class="right">        double maxSqDistortion, int nbI, bool checkDisc1, bool checkDisc2, 
bool checkDisc3) const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Q_ASSERT(fabs(vertices[0].length()-1.)&lt;0.00001);</td><td> </td><td class="right">       Q_ASSERT(fabs(vertices[0].length()-1.)&lt;0.00001);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Q_ASSERT(fabs(vertices[1].length()-1.)&lt;0.00001);</td><td> </td><td class="right">       Q_ASSERT(fabs(vertices[1].length()-1.)&lt;0.00001);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Q_ASSERT(fabs(vertices[2].length()-1.)&lt;0.00001);</td><td> </td><td class="right">       Q_ASSERT(fabs(vertices[2].length()-1.)&lt;0.00001);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (clippingCap &amp;&amp; clippingCap-&gt;containsTriangle(vertices))</td><td> </td><td class="right">       if (clippingCap &amp;&amp; clippingCap-&gt;containsTriangle(vertices))</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0006" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               clippingCap = <span class="delete">NULL</span>;</td><td> </td><td class="rblock">               clippingCap = <span class="insert">Q_NULLPTR</span>;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (clippingCap &amp;&amp; !clippingCap-&gt;intersectsTriangle(vertices))</td><td> </td><td class="right">       if (clippingCap &amp;&amp; !clippingCap-&gt;intersectsTriangle(vertices))</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return;</td><td> </td><td class="right">               return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       bool cDiscontinuity1 = checkDisc1 &amp;&amp; prj-&gt;intersectViewportDiscontin
uity(vertices[0], vertices[1]);</td><td> </td><td class="right">       bool cDiscontinuity1 = checkDisc1 &amp;&amp; prj-&gt;intersectViewportDiscontin
uity(vertices[0], vertices[1]);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       bool cDiscontinuity2 = checkDisc2 &amp;&amp; prj-&gt;intersectViewportDiscontin
uity(vertices[1], vertices[2]);</td><td> </td><td class="right">       bool cDiscontinuity2 = checkDisc2 &amp;&amp; prj-&gt;intersectViewportDiscontin
uity(vertices[1], vertices[2]);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       bool cDiscontinuity3 = checkDisc3 &amp;&amp; prj-&gt;intersectViewportDiscontin
uity(vertices[0], vertices[2]);</td><td> </td><td class="right">       bool cDiscontinuity3 = checkDisc3 &amp;&amp; prj-&gt;intersectViewportDiscontin
uity(vertices[0], vertices[2]);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const bool cd1=cDiscontinuity1;</td><td> </td><td class="right">       const bool cd1=cDiscontinuity1;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const bool cd2=cDiscontinuity2;</td><td> </td><td class="right">       const bool cd2=cDiscontinuity2;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const bool cd3=cDiscontinuity3;</td><td> </td><td class="right">       const bool cd3=cDiscontinuity3;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Vec3d e0=vertices[0];</td><td> </td><td class="right">       Vec3d e0=vertices[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l6" /><small>skipping to change at</small><em> line 1449</em></th><th> </th><th><a name="part-r6" /><small>skipping to change at</small><em> line 1450</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// The function object that we use as an interface between VertexArray::for
eachTriangle and</td><td> </td><td class="right">// The function object that we use as an interface between VertexArray::for
eachTriangle and</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// StelPainter::projectSphericalTriangle.</td><td> </td><td class="right">// StelPainter::projectSphericalTriangle.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//</td><td> </td><td class="right">//</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// This is used by drawSphericalTriangles to project all the triangles coor
dinates in a StelVertexArray into our global</td><td> </td><td class="right">// This is used by drawSphericalTriangles to project all the triangles coor
dinates in a StelVertexArray into our global</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// vertex array buffer.</td><td> </td><td class="right">// vertex array buffer.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">class VertexArrayProjector</td><td> </td><td class="right">class VertexArrayProjector</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">public:</td><td> </td><td class="right">public:</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       VertexArrayProjector(const StelVertexArray&amp; ar, StelPainter* apainte
r, const SphericalCap* aclippingCap,</td><td> </td><td class="right">       VertexArrayProjector(const StelVertexArray&amp; ar, StelPainter* apainte
r, const SphericalCap* aclippingCap,</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0007" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                                QVarLengthArray&lt;Vec3f, 4096
&gt;* aoutVertices, QVarLengthArray&lt;Vec2f, 4096&gt;* aoutTexturePos=<span class="delete">NULL, QVarLen
gthArray&lt;Vec3f, 4096&gt;* aoutColors=NULL, double amaxSqDistortion=5</span>.)</td><td> </td><td class="rblock">                                                QVarLengthArray&lt;Vec3f, 4096
&gt;* aoutVertices, QVarLengthArray&lt;Vec2f, 4096&gt;* aoutTexturePos=<span class="insert">Q_NULLPTR, QV
arLengthArray&lt;Vec3f, 4096&gt;* aoutColors=Q_NULLPTR, double amaxSqDistortion=5
</span>.)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                  : vertexArray(ar), painter(apainter), clippingCap(aclippi
ngCap), outVertices(aoutVertices),</td><td> </td><td class="right">                  : vertexArray(ar), painter(apainter), clippingCap(aclippi
ngCap), outVertices(aoutVertices),</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                        outColors(aoutColors), outTexturePos(aoutTexturePos
), maxSqDistortion(amaxSqDistortion)</td><td> </td><td class="right">                        outColors(aoutColors), outTexturePos(aoutTexturePos
), maxSqDistortion(amaxSqDistortion)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Project a single triangle and add it into the output arrays</td><td> </td><td class="right">       // Project a single triangle and add it into the output arrays</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       inline void operator()(const Vec3d* v0, const Vec3d* v1, const Vec3d
* v2,</td><td> </td><td class="right">       inline void operator()(const Vec3d* v0, const Vec3d* v1, const Vec3d
* v2,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                                                  const Vec2f* t0, const Ve
c2f* t1, const Vec2f* t2,</td><td> </td><td class="right">                                                  const Vec2f* t0, const Ve
c2f* t1, const Vec2f* t2,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                                                  const Vec3f* c0, const Ve
c3f* c1, const Vec3f* c2,</td><td> </td><td class="right">                                                  const Vec3f* c0, const Ve
c3f* c1, const Vec3f* c2,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                                                  unsigned int, unsigned in
t, unsigned)</td><td> </td><td class="right">                                                  unsigned int, unsigned in
t, unsigned)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l7" /><small>skipping to change at</small><em> line 1472</em></th><th> </th><th><a name="part-r7" /><small>skipping to change at</small><em> line 1473</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               const Vec3d tmpVertex[3] = {*v0, *v1, *v2};</td><td> </td><td class="right">               const Vec3d tmpVertex[3] = {*v0, *v1, *v2};</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               if ( (outTexturePos) &amp;&amp; (outColors))</td><td> </td><td class="right">               if ( (outTexturePos) &amp;&amp; (outColors))</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       const Vec2f tmpTexture[3] = {*t0, *t1, *t2};</td><td> </td><td class="right">                       const Vec2f tmpTexture[3] = {*t0, *t1, *t2};</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       const Vec3f tmpColor[3] = {*c0, *c1, *c2};</td><td> </td><td class="right">                       const Vec3f tmpColor[3] = {*c0, *c1, *c2};</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       painter-&gt;projectSphericalTriangle(clippingCap, tmpVe
rtex, outVertices, tmpTexture, outTexturePos, tmpColor, outColors, maxSqDis
tortion);</td><td> </td><td class="right">                       painter-&gt;projectSphericalTriangle(clippingCap, tmpVe
rtex, outVertices, tmpTexture, outTexturePos, tmpColor, outColors, maxSqDis
tortion);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               else if (outTexturePos)</td><td> </td><td class="right">               else if (outTexturePos)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       const Vec2f tmpTexture[3] = {*t0, *t1, *t2};</td><td> </td><td class="right">                       const Vec2f tmpTexture[3] = {*t0, *t1, *t2};</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0008" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       painter-&gt;projectSphericalTriangle(clippingCap, tmpVe
rtex, outVertices, tmpTexture, outTexturePos, <span class="delete">NULL, NULL, maxSqDi</span>stortion);</td><td> </td><td class="rblock">                       painter-&gt;projectSphericalTriangle(clippingCap, tmpVe
rtex, outVertices, tmpTexture, outTexturePos, <span class="insert">Q_NULLPTR, Q_NULLPTR, maxSqDi
</span>stortion);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               else if (outColors)</td><td> </td><td class="right">               else if (outColors)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       const Vec3f tmpColor[3] = {*c0, *c1, *c2};</td><td> </td><td class="right">                       const Vec3f tmpColor[3] = {*c0, *c1, *c2};</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0009" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       painter-&gt;projectSphericalTriangle(clippingCap, tmpVe
rtex, outVertices, <span class="delete">NULL, NULL, tmpColor, outColors, maxSqDistorti</span>on);</td><td> </td><td class="rblock">                       painter-&gt;projectSphericalTriangle(clippingCap, tmpVe
rtex, outVertices, <span class="insert">Q_NULLPTR, Q_NULLPTR, tmpColor, outColors, maxSqDistorti
</span>on);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               else</td><td> </td><td class="right">               else</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0010" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       painter-&gt;projectSphericalTriangle(clippingCap, tmpVe
rtex, outVertices, <span class="delete">NULL, NULL, NULL, NULL, maxSqDistort</span>ion);</td><td> </td><td class="rblock">                       painter-&gt;projectSphericalTriangle(clippingCap, tmpVe
rtex, outVertices, <span class="insert">Q_NULLPTR, Q_NULLPTR, Q_NULLPTR, Q_NULLPTR, maxSqDistort
</span>ion);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Draw the resulting arrays</td><td> </td><td class="right">       // Draw the resulting arrays</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       void drawResult()</td><td> </td><td class="right">       void drawResult()</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               painter-&gt;setVertexPointer(3, GL_FLOAT, outVertices-&gt;constDat
a());</td><td> </td><td class="right">               painter-&gt;setVertexPointer(3, GL_FLOAT, outVertices-&gt;constDat
a());</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               if (outTexturePos)</td><td> </td><td class="right">               if (outTexturePos)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       painter-&gt;setTexCoordPointer(2, GL_FLOAT, outTextureP
os-&gt;constData());</td><td> </td><td class="right">                       painter-&gt;setTexCoordPointer(2, GL_FLOAT, outTextureP
os-&gt;constData());</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               if (outColors)</td><td> </td><td class="right">               if (outColors)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       painter-&gt;setColorPointer(3, GL_FLOAT, outColors-&gt;con
stData());</td><td> </td><td class="right">                       painter-&gt;setColorPointer(3, GL_FLOAT, outColors-&gt;con
stData());</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0011" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               painter-&gt;enableClientStates(true, outTexturePos != <span class="delete">NULL, out
Colors != NULL</span>);</td><td> </td><td class="rblock">               painter-&gt;enableClientStates(true, outTexturePos != <span class="insert">Q_NULLPTR
, outColors != Q_NULLPTR</span>);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               painter-&gt;drawFromArray(StelPainter::Triangles, outVertices-&gt;
size(), 0, false);</td><td> </td><td class="right">               painter-&gt;drawFromArray(StelPainter::Triangles, outVertices-&gt;
size(), 0, false);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               painter-&gt;enableClientStates(false);</td><td> </td><td class="right">               painter-&gt;enableClientStates(false);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">private:</td><td> </td><td class="right">private:</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const StelVertexArray&amp; vertexArray;</td><td> </td><td class="right">       const StelVertexArray&amp; vertexArray;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       StelPainter* painter;</td><td> </td><td class="right">       StelPainter* painter;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const SphericalCap* clippingCap;</td><td> </td><td class="right">       const SphericalCap* clippingCap;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       QVarLengthArray&lt;Vec3f, 4096&gt;* outVertices;</td><td> </td><td class="right">       QVarLengthArray&lt;Vec3f, 4096&gt;* outVertices;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       QVarLengthArray&lt;Vec3f, 4096&gt;* outColors;</td><td> </td><td class="right">       QVarLengthArray&lt;Vec3f, 4096&gt;* outColors;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l8" /><small>skipping to change at</small><em> line 1567</em></th><th> </th><th><a name="part-r8" /><small>skipping to change at</small><em> line 1568</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (!doSubDivide)</td><td> </td><td class="right">       if (!doSubDivide)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               // The simplest case, we don't need to iterate through the t
riangles at all.</td><td> </td><td class="right">               // The simplest case, we don't need to iterate through the t
riangles at all.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               drawStelVertexArray(va);</td><td> </td><td class="right">               drawStelVertexArray(va);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return;</td><td> </td><td class="right">               return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // the last case.  It is the slowest, it process the triangles one b
y one.</td><td> </td><td class="right">       // the last case.  It is the slowest, it process the triangles one b
y one.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               // Project all the triangles of the VertexArray into our buf
fer arrays.</td><td> </td><td class="right">               // Project all the triangles of the VertexArray into our buf
fer arrays.</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0012" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               VertexArrayProjector result = va.foreachTriangle(VertexArray
Projector(va, this, clippingCap, &amp;polygonVertexArray, textured ? &amp;polygonTe
xtureCoordArray : <span class="delete">NULL, colored ? &amp;polygonColorArray : NULL, maxSqDistortio
</span>n));</td><td> </td><td class="rblock">               VertexArrayProjector result = va.foreachTriangle(VertexArray
Projector(va, this, clippingCap, &amp;polygonVertexArray, textured ? &amp;polygonTe
xtureCoordArray : <span class="insert">Q_NULLPTR, colored ? &amp;polygonColorArray : Q_NULLPTR, maxS
qDistortio</span>n));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               result.drawResult();</td><td> </td><td class="right">               result.drawResult();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return;</td><td> </td><td class="right">               return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// Draw the given SphericalPolygon.</td><td> </td><td class="right">// Draw the given SphericalPolygon.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void StelPainter::drawSphericalRegion(const SphericalRegion* poly, Spherica
lPolygonDrawMode drawMode, const SphericalCap* clippingCap, const bool doSu
bDivise, const double maxSqDistortion)</td><td> </td><td class="right">void StelPainter::drawSphericalRegion(const SphericalRegion* poly, Spherica
lPolygonDrawMode drawMode, const SphericalCap* clippingCap, const bool doSu
bDivise, const double maxSqDistortion)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (!prj-&gt;getBoundingCap().intersects(poly-&gt;getBoundingCap()))</td><td> </td><td class="right">       if (!prj-&gt;getBoundingCap().intersects(poly-&gt;getBoundingCap()))</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return;</td><td> </td><td class="right">               return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l9" /><small>skipping to change at</small><em> line 1774</em></th><th> </th><th><a name="part-r9" /><small>skipping to change at</small><em> line 1775</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               nsign = -1.f;</td><td> </td><td class="right">               nsign = -1.f;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               t=0.f; // from inside texture is reversed</td><td> </td><td class="right">               t=0.f; // from inside texture is reversed</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       else</td><td> </td><td class="right">       else</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               nsign = 1.f;</td><td> </td><td class="right">               nsign = 1.f;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               t=1.f;</td><td> </td><td class="right">               t=1.f;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0013" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       const float* cos_sin_rho = <span class="delete">NULL</span>;</td><td> </td><td class="rblock">       const float* cos_sin_rho = <span class="insert">Q_NULLPTR</span>;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Q_ASSERT(topAngle&lt;bottomAngle); // don't forget: These are opening a
ngles counted from top.</td><td> </td><td class="right">       Q_ASSERT(topAngle&lt;bottomAngle); // don't forget: These are opening a
ngles counted from top.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if ((bottomAngle&gt;3.1415f) &amp;&amp; (topAngle&lt;0.0001f)) // safety margin.</td><td> </td><td class="right">       if ((bottomAngle&gt;3.1415f) &amp;&amp; (topAngle&lt;0.0001f)) // safety margin.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               cos_sin_rho = StelUtils::ComputeCosSinRho(stacks);</td><td> </td><td class="right">               cos_sin_rho = StelUtils::ComputeCosSinRho(stacks);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       else</td><td> </td><td class="right">       else</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               const float drho = (bottomAngle-topAngle) / stacks; // delta
Rho:  originally just 180degrees/stacks, now the range clamped.</td><td> </td><td class="right">               const float drho = (bottomAngle-topAngle) / stacks; // delta
Rho:  originally just 180degrees/stacks, now the range clamped.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               cos_sin_rho = StelUtils::ComputeCosSinRhoZone(drho, stacks, 
M_PI-bottomAngle);</td><td> </td><td class="right">               cos_sin_rho = StelUtils::ComputeCosSinRhoZone(drho, stacks, 
M_PI-bottomAngle);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Allow parameters so that pole regions may remain free.</td><td> </td><td class="right">       // Allow parameters so that pole regions may remain free.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const float* cos_sin_rho_p;</td><td> </td><td class="right">       const float* cos_sin_rho_p;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l10" /><small>skipping to change at</small><em> line 1857</em></th><th> </th><th><a name="part-r10" /><small>skipping to change at</small><em> line 1858</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               nsign = -1.f;</td><td> </td><td class="right">               nsign = -1.f;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               t=0.f; // from inside texture is reversed</td><td> </td><td class="right">               t=0.f; // from inside texture is reversed</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       else</td><td> </td><td class="right">       else</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               nsign = 1.f;</td><td> </td><td class="right">               nsign = 1.f;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               t=1.f;</td><td> </td><td class="right">               t=1.f;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0014" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       const float* cos_sin_rho = <span class="delete">NULL; //StelUtils::ComputeCosSinRho(stack
</span>s);</td><td> </td><td class="rblock">       const float* cos_sin_rho = <span class="insert">Q_NULLPTR; //StelUtils::ComputeCosSinRho(
stack</span>s);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Q_ASSERT(topAngle&lt;bottomAngle); // don't forget: These are opening a
ngles counted from top.</td><td> </td><td class="right">       Q_ASSERT(topAngle&lt;bottomAngle); // don't forget: These are opening a
ngles counted from top.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if ((bottomAngle&gt;3.1415f) &amp;&amp; (topAngle&lt;0.0001f)) // safety margin.</td><td> </td><td class="right">       if ((bottomAngle&gt;3.1415f) &amp;&amp; (topAngle&lt;0.0001f)) // safety margin.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               cos_sin_rho = StelUtils::ComputeCosSinRho(stacks);</td><td> </td><td class="right">               cos_sin_rho = StelUtils::ComputeCosSinRho(stacks);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       else</td><td> </td><td class="right">       else</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               const float drho = (bottomAngle-topAngle) / stacks; // delta
Rho:  originally just 180degrees/stacks, now the range clamped.</td><td> </td><td class="right">               const float drho = (bottomAngle-topAngle) / stacks; // delta
Rho:  originally just 180degrees/stacks, now the range clamped.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               cos_sin_rho = StelUtils::ComputeCosSinRhoZone(drho, stacks, 
M_PI-bottomAngle);</td><td> </td><td class="right">               cos_sin_rho = StelUtils::ComputeCosSinRhoZone(drho, stacks, 
M_PI-bottomAngle);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Allow parameters so that pole regions may remain free.</td><td> </td><td class="right">       // Allow parameters so that pole regions may remain free.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const float* cos_sin_rho_p;</td><td> </td><td class="right">       const float* cos_sin_rho_p;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l11" /><small>skipping to change at</small><em> line 2086</em></th><th> </th><th><a name="part-r11" /><small>skipping to change at</small><em> line 2087</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       texturesColorShaderVars.projectionMatrix = texturesColorShaderProgra
m-&gt;uniformLocation("projectionMatrix");</td><td> </td><td class="right">       texturesColorShaderVars.projectionMatrix = texturesColorShaderProgra
m-&gt;uniformLocation("projectionMatrix");</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       texturesColorShaderVars.texCoord = texturesColorShaderProgram-&gt;attri
buteLocation("texCoord");</td><td> </td><td class="right">       texturesColorShaderVars.texCoord = texturesColorShaderProgram-&gt;attri
buteLocation("texCoord");</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       texturesColorShaderVars.vertex = texturesColorShaderProgram-&gt;attribu
teLocation("vertex");</td><td> </td><td class="right">       texturesColorShaderVars.vertex = texturesColorShaderProgram-&gt;attribu
teLocation("vertex");</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       texturesColorShaderVars.color = texturesColorShaderProgram-&gt;attribut
eLocation("color");</td><td> </td><td class="right">       texturesColorShaderVars.color = texturesColorShaderProgram-&gt;attribut
eLocation("color");</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       texturesColorShaderVars.texture = texturesColorShaderProgram-&gt;unifor
mLocation("tex");</td><td> </td><td class="right">       texturesColorShaderVars.texture = texturesColorShaderProgram-&gt;unifor
mLocation("tex");</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void StelPainter::deinitGLShaders()</td><td> </td><td class="right">void StelPainter::deinitGLShaders()</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       delete basicShaderProgram;</td><td> </td><td class="right">       delete basicShaderProgram;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0015" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       basicShaderProgram = <span class="delete">NULL</span>;</td><td> </td><td class="rblock">       basicShaderProgram = <span class="insert">Q_NULLPTR</span>;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       delete colorShaderProgram;</td><td> </td><td class="right">       delete colorShaderProgram;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0016" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       colorShaderProgram = <span class="delete">NULL</span>;</td><td> </td><td class="rblock">       colorShaderProgram = <span class="insert">Q_NULLPTR</span>;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       delete texturesShaderProgram;</td><td> </td><td class="right">       delete texturesShaderProgram;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0017" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       texturesShaderProgram = <span class="delete">NULL</span>;</td><td> </td><td class="rblock">       texturesShaderProgram = <span class="insert">Q_NULLPTR</span>;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       delete texturesColorShaderProgram;</td><td> </td><td class="right">       delete texturesColorShaderProgram;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0018" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       texturesColorShaderProgram = <span class="delete">NULL</span>;</td><td> </td><td class="rblock">       texturesColorShaderProgram = <span class="insert">Q_NULLPTR</span>;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       texCache.clear();</td><td> </td><td class="right">       texCache.clear();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void StelPainter::setArrays(const Vec3d* vertices, const Vec2f* texCoords, 
const Vec3f* colorArray, const Vec3f* normalArray)</td><td> </td><td class="right">void StelPainter::setArrays(const Vec3d* vertices, const Vec2f* texCoords, 
const Vec3f* colorArray, const Vec3f* normalArray)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       enableClientStates(vertices, texCoords, colorArray, normalArray);</td><td> </td><td class="right">       enableClientStates(vertices, texCoords, colorArray, normalArray);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       setVertexPointer(3, GL_DOUBLE, vertices);</td><td> </td><td class="right">       setVertexPointer(3, GL_DOUBLE, vertices);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       setTexCoordPointer(2, GL_FLOAT, texCoords);</td><td> </td><td class="right">       setTexCoordPointer(2, GL_FLOAT, texCoords);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       setColorPointer(3, GL_FLOAT, colorArray);</td><td> </td><td class="right">       setColorPointer(3, GL_FLOAT, colorArray);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       setNormalPointer(GL_FLOAT, normalArray);</td><td> </td><td class="right">       setNormalPointer(GL_FLOAT, normalArray);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l12" /><small>skipping to change at</small><em> line 2131</em></th><th> </th><th><a name="part-r12" /><small>skipping to change at</small><em> line 2132</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void StelPainter::drawFromArray(DrawingMode mode, int count, int offset, bo
ol doProj, const unsigned short* indices)</td><td> </td><td class="right">void StelPainter::drawFromArray(DrawingMode mode, int count, int offset, bo
ol doProj, const unsigned short* indices)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       ArrayDesc projectedVertexArray = vertexArray;</td><td> </td><td class="right">       ArrayDesc projectedVertexArray = vertexArray;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (doProj)</td><td> </td><td class="right">       if (doProj)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               // Project the vertex array using current projection</td><td> </td><td class="right">               // Project the vertex array using current projection</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               if (indices)</td><td> </td><td class="right">               if (indices)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       projectedVertexArray = projectArray(vertexArray, 0, 
count, indices + offset);</td><td> </td><td class="right">                       projectedVertexArray = projectArray(vertexArray, 0, 
count, indices + offset);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               else</td><td> </td><td class="right">               else</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0019" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       projectedVertexArray = projectArray(vertexArray, off
set, count, <span class="delete">NULL</span>);</td><td> </td><td class="rblock">                       projectedVertexArray = projectArray(vertexArray, off
set, count, <span class="insert">Q_NULLPTR</span>);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0020" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       QOpenGLShaderProgram* pr=<span class="delete">NULL</span>;</td><td> </td><td class="rblock">       QOpenGLShaderProgram* pr=<span class="insert">Q_NULLPTR</span>;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const Mat4f&amp; m = getProjector()-&gt;getProjectionMatrix();</td><td> </td><td class="right">       const Mat4f&amp; m = getProjector()-&gt;getProjectionMatrix();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const QMatrix4x4 qMat(m[0], m[4], m[8], m[12], m[1], m[5], m[9], m[1
3], m[2], m[6], m[10], m[14], m[3], m[7], m[11], m[15]);</td><td> </td><td class="right">       const QMatrix4x4 qMat(m[0], m[4], m[8], m[12], m[1], m[5], m[9], m[1
3], m[2], m[6], m[10], m[14], m[3], m[7], m[11], m[15]);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (!texCoordArray.enabled &amp;&amp; !colorArray.enabled &amp;&amp; !normalArray.en
abled)</td><td> </td><td class="right">       if (!texCoordArray.enabled &amp;&amp; !colorArray.enabled &amp;&amp; !normalArray.en
abled)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               pr = basicShaderProgram;</td><td> </td><td class="right">               pr = basicShaderProgram;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               pr-&gt;bind();</td><td> </td><td class="right">               pr-&gt;bind();</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0021" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               pr-&gt;setAttributeArray(basicShaderVars.vertex, <span class="delete">(const GLfloat
*)</span>projectedVertexArray.pointer, projectedVertexArray.size);</td><td> </td><td class="rblock">               pr-&gt;setAttributeArray(basicShaderVars.vertex, <span class="insert">projectedVerte
xArray.type, </span>projectedVertexArray.pointer, projectedVertexArray.size);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               pr-&gt;enableAttributeArray(basicShaderVars.vertex);</td><td> </td><td class="right">               pr-&gt;enableAttributeArray(basicShaderVars.vertex);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               pr-&gt;setUniformValue(basicShaderVars.projectionMatrix, qMat);</td><td> </td><td class="right">               pr-&gt;setUniformValue(basicShaderVars.projectionMatrix, qMat);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               pr-&gt;setUniformValue(basicShaderVars.color, currentColor[0], 
currentColor[1], currentColor[2], currentColor[3]);</td><td> </td><td class="right">               pr-&gt;setUniformValue(basicShaderVars.color, currentColor[0], 
currentColor[1], currentColor[2], currentColor[3]);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       else if (texCoordArray.enabled &amp;&amp; !colorArray.enabled &amp;&amp; !normalArra
y.enabled)</td><td> </td><td class="right">       else if (texCoordArray.enabled &amp;&amp; !colorArray.enabled &amp;&amp; !normalArra
y.enabled)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               pr = texturesShaderProgram;</td><td> </td><td class="right">               pr = texturesShaderProgram;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               pr-&gt;bind();</td><td> </td><td class="right">               pr-&gt;bind();</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0022" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               pr-&gt;setAttributeArray(texturesShaderVars.vertex, <span class="delete">(const GLfl
oat*)</span>projectedVertexArray.pointer, projectedVertexArray.size);</td><td> </td><td class="rblock">               pr-&gt;setAttributeArray(texturesShaderVars.vertex, <span class="insert">projectedVe
rtexArray.type, </span>projectedVertexArray.pointer, projectedVertexArray.size);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               pr-&gt;enableAttributeArray(texturesShaderVars.vertex);</td><td> </td><td class="right">               pr-&gt;enableAttributeArray(texturesShaderVars.vertex);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               pr-&gt;setUniformValue(texturesShaderVars.projectionMatrix, qMa
t);</td><td> </td><td class="right">               pr-&gt;setUniformValue(texturesShaderVars.projectionMatrix, qMa
t);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               pr-&gt;setUniformValue(texturesShaderVars.texColor, currentColo
r[0], currentColor[1], currentColor[2], currentColor[3]);</td><td> </td><td class="right">               pr-&gt;setUniformValue(texturesShaderVars.texColor, currentColo
r[0], currentColor[1], currentColor[2], currentColor[3]);</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0023" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               pr-&gt;setAttributeArray(texturesShaderVars.texCoord, <span class="delete">(const GL
float*)texCoordArray.pointer, 2</span>);</td><td> </td><td class="rblock">               pr-&gt;setAttributeArray(texturesShaderVars.texCoord, <span class="insert">texCoordA
rray.type, texCoordArray.pointer, texCoordArray.size</span>);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               pr-&gt;enableAttributeArray(texturesShaderVars.texCoord);</td><td> </td><td class="right">               pr-&gt;enableAttributeArray(texturesShaderVars.texCoord);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               //pr-&gt;setUniformValue(texturesShaderVars.texture, 0);    // 
use texture unit 0</td><td> </td><td class="right">               //pr-&gt;setUniformValue(texturesShaderVars.texture, 0);    // 
use texture unit 0</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       else if (texCoordArray.enabled &amp;&amp; colorArray.enabled &amp;&amp; !normalArray
.enabled)</td><td> </td><td class="right">       else if (texCoordArray.enabled &amp;&amp; colorArray.enabled &amp;&amp; !normalArray
.enabled)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               pr = texturesColorShaderProgram;</td><td> </td><td class="right">               pr = texturesColorShaderProgram;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               pr-&gt;bind();</td><td> </td><td class="right">               pr-&gt;bind();</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0024" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               pr-&gt;setAttributeArray(texturesColorShaderVars.vertex, <span class="delete">(const
 GLfloat*)projectedVertexArray.pointer, projectedVertexArray.siz</span>e);</td><td> </td><td class="rblock">               pr-&gt;setAttributeArray(texturesColorShaderVars.vertex, <span class="insert">projec
tedVertexArray.type, projectedVertexArray.pointer, projectedVertexArray.siz
</span>e);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               pr-&gt;enableAttributeArray(texturesColorShaderVars.vertex);</td><td> </td><td class="right">               pr-&gt;enableAttributeArray(texturesColorShaderVars.vertex);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               pr-&gt;setUniformValue(texturesColorShaderVars.projectionMatrix
, qMat);</td><td> </td><td class="right">               pr-&gt;setUniformValue(texturesColorShaderVars.projectionMatrix
, qMat);</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0025" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               pr-&gt;setAttributeArray(texturesColorShaderVars.texCoord, <span class="delete">(con
st GLfloat*)texCoordArray.pointer, 2</span>);</td><td> </td><td class="rblock">               pr-&gt;setAttributeArray(texturesColorShaderVars.texCoord, <span class="insert">texC
oordArray.type, texCoordArray.pointer, texCoordArray.size</span>);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               pr-&gt;enableAttributeArray(texturesColorShaderVars.texCoord);</td><td> </td><td class="right">               pr-&gt;enableAttributeArray(texturesColorShaderVars.texCoord);</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0026" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               pr-&gt;setAttributeArray(texturesColorShaderVars.color, <span class="delete">(const 
GLfloat*)</span>colorArray.pointer, colorArray.size);</td><td> </td><td class="rblock">               pr-&gt;setAttributeArray(texturesColorShaderVars.color, <span class="insert">colorAr
ray.type, </span>colorArray.pointer, colorArray.size);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               pr-&gt;enableAttributeArray(texturesColorShaderVars.color);</td><td> </td><td class="right">               pr-&gt;enableAttributeArray(texturesColorShaderVars.color);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               //pr-&gt;setUniformValue(texturesShaderVars.texture, 0);    // 
use texture unit 0</td><td> </td><td class="right">               //pr-&gt;setUniformValue(texturesShaderVars.texture, 0);    // 
use texture unit 0</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       else if (!texCoordArray.enabled &amp;&amp; colorArray.enabled &amp;&amp; !normalArra
y.enabled)</td><td> </td><td class="right">       else if (!texCoordArray.enabled &amp;&amp; colorArray.enabled &amp;&amp; !normalArra
y.enabled)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               pr = colorShaderProgram;</td><td> </td><td class="right">               pr = colorShaderProgram;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               pr-&gt;bind();</td><td> </td><td class="right">               pr-&gt;bind();</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0027" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               pr-&gt;setAttributeArray(colorShaderVars.vertex, <span class="delete">(const GLfloat
*)</span>projectedVertexArray.pointer, projectedVertexArray.size);</td><td> </td><td class="rblock">               pr-&gt;setAttributeArray(colorShaderVars.vertex, <span class="insert">projectedVerte
xArray.type, </span>projectedVertexArray.pointer, projectedVertexArray.size);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               pr-&gt;enableAttributeArray(colorShaderVars.vertex);</td><td> </td><td class="right">               pr-&gt;enableAttributeArray(colorShaderVars.vertex);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               pr-&gt;setUniformValue(colorShaderVars.projectionMatrix, qMat);</td><td> </td><td class="right">               pr-&gt;setUniformValue(colorShaderVars.projectionMatrix, qMat);</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0028" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               pr-&gt;setAttributeArray(colorShaderVars.color, <span class="delete">(const GLfloat*
)</span>colorArray.pointer, colorArray.size);</td><td> </td><td class="rblock">               pr-&gt;setAttributeArray(colorShaderVars.color, <span class="insert">colorArray.type
, </span>colorArray.pointer, colorArray.size);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               pr-&gt;enableAttributeArray(colorShaderVars.color);</td><td> </td><td class="right">               pr-&gt;enableAttributeArray(colorShaderVars.color);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       else</td><td> </td><td class="right">       else</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               qDebug() &lt;&lt; "Unhandled parameters." &lt;&lt; texCoordArray.enabled
 &lt;&lt; colorArray.enabled &lt;&lt; normalArray.enabled;</td><td> </td><td class="right">               qDebug() &lt;&lt; "Unhandled parameters." &lt;&lt; texCoordArray.enabled
 &lt;&lt; colorArray.enabled &lt;&lt; normalArray.enabled;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               Q_ASSERT(0);</td><td> </td><td class="right">               Q_ASSERT(0);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return;</td><td> </td><td class="right">               return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (indices)</td><td> </td><td class="right">       if (indices)</td><td class="lineno" valign="top"></td></tr>

     <tr><td></td><td class="left"></td><td> </td><td class="right"></td><td></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 28 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><td></td><th><i>32 lines changed or deleted</i></th><th><i> </i></th><th><i>33 lines changed or added</i></th><td></td></tr>
     <tr><td colspan="5" align="center" class="small"><br/>This html diff was produced by rfcdiff 1.41. The latest version is available from <a href="http://www.tools.ietf.org/tools/rfcdiff/" >http://tools.ietf.org/tools/rfcdiff/</a> </td></tr>
   </table>
   </body>
   </html>
