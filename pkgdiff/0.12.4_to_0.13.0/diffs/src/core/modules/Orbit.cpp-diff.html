<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"> 
<!-- Generated by rfcdiff 1.41: rfcdiff  --> 
<!-- <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional" > -->
<!-- System: Linux fomalhaut.local 3.13.0-38-generic #65-Ubuntu SMP Thu Oct 9 11:36:50 UTC 2014 x86_64 x86_64 x86_64 GNU/Linux --> 
<!-- Using awk: /usr/bin/gawk: GNU Awk 4.0.1 --> 
<!-- Using diff: /usr/bin/diff: diff (GNU diffutils) 3.3 --> 
<!-- Using wdiff: /usr/bin/wdiff: wdiff (GNU wdiff) 1.2.1 --> 
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"> 
<head> 
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /> 
  <meta http-equiv="Content-Style-Type" content="text/css" /> 
  <title>Diff: Orbit.cpp - Orbit.cpp</title> 
  <style type="text/css"> 
    body    { font-size:16px; margin: 0.4ex; margin-right: auto; } 
    tr      { } 
    td      { white-space: pre; font-family: Consolas, "DejaVu Sans Mono", "Droid Sans Mono", Monaco, Monospace; vertical-align: top; font-size: 0.86em;} 
    th      { font-size: 0.86em; } 
    .small  { font-size: 0.6em; font-style: italic; font-family: Verdana, Helvetica, sans-serif; } 
    .left   { background-color: #EEE; } 
    .right  { background-color: #FFF; } 
    .diff   { background-color: #CCF; } 
    .lblock { background-color: #BFB; } 
    .rblock { background-color: #FF8; } 
    .insert { background-color: #8FF; } 
    .delete { background-color: #ACF; } 
    .void   { background-color: #FFB; } 
    .cont   { background-color: #EEE; } 
    .linebr { background-color: #AAA; } 
    .lineno { color: red; background-color: #FFF; font-size: 0.7em; text-align: right; padding: 0 2px; } 
    .elipsis{ background-color: #AAA; } 
    .left .cont { background-color: #DDD; } 
    .right .cont { background-color: #EEE; } 
    .lblock .cont { background-color: #9D9; } 
    .rblock .cont { background-color: #DD6; } 
    .insert .cont { background-color: #0DD; } 
    .delete .cont { background-color: #8AD; } 
    .stats, .stats td, .stats th { background-color: #EEE; padding: 2px 0; } 
  </style> 
</head> 
<body > 
  <table border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th></th><th>&nbsp;Orbit.cpp&nbsp;</th><th> </th><th>&nbsp;Orbit.cpp&nbsp;</th><th></th></tr> 
      <tr><td class="lineno" valign="top"></td><td class="left">// orbit.cpp</td><td> </td><td class="right">// orbit.cpp</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//</td><td> </td><td class="right">//</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// Copyright (C) 2001, Chris Laurel &lt;claurel@shatters.net&gt;</td><td> </td><td class="right">// Copyright (C) 2001, Chris Laurel &lt;claurel@shatters.net&gt;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//</td><td> </td><td class="right">//</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// CometOrbit, InitHyp,InitPar,InitEll,Init3D: Copyright (C) 1995,2007,2008
 Johannes Gajdosik</td><td> </td><td class="right">// CometOrbit, InitHyp,InitPar,InitEll,Init3D: Copyright (C) 1995,2007,2008
 Johannes Gajdosik</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">// InitHyp,InitPar,InitEll,Init3D checked, improved, extended, annotated 20</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">13 Georg Zotti (GZ).</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">// Algorithms identified and extended from:</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//    Meeus: Astronomical Algorithms 1998</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//    Heafner: Fundamental Ephemeris Computations 1999</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//</td><td> </td><td class="right">//</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// This program is free software; you can redistribute it and/or</td><td> </td><td class="right">// This program is free software; you can redistribute it and/or</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// modify it under the terms of the GNU General Public License</td><td> </td><td class="right">// modify it under the terms of the GNU General Public License</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// as published by the Free Software Foundation; either version 2</td><td> </td><td class="right">// as published by the Free Software Foundation; either version 2</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// of the License, or (at your option) any later version.</td><td> </td><td class="right">// of the License, or (at your option) any later version.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0002" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#include "Solve.hpp"</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#include "Orbit.hpp"</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#include "StelUtils.hpp"</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#include &lt;functional&gt;</td><td> </td><td class="right">#include &lt;functional&gt;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#include &lt;algorithm&gt;</td><td> </td><td class="right">#include &lt;algorithm&gt;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#include &lt;cmath&gt;</td><td> </td><td class="right">#include &lt;cmath&gt;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#include &lt;cstring&gt;</td><td> </td><td class="right">#include &lt;cstring&gt;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0003" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                                                           </td><td> </td><td class="rblock">#include <span class="insert">&lt;QDebug&gt;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">#include <span class="delete">"Solve.hpp"</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">#include "Orbit.hpp"</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">using namespace std;</td><td> </td><td class="right">using namespace std;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#define EPSILON 1e-10</td><td> </td><td class="right">#define EPSILON 1e-10</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0004" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//#define EPSILON 1e-4</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">// line from vsop87.c, but also used by Heafner, 5.3.12. This is mu, we ign</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ore the comet's mass i.r.t. the Sun's.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define GAUSS_GRAV_CONST (0.01720209895*0.01720209895)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#if defined(_MSC_VER)</td><td> </td><td class="right">#if defined(_MSC_VER)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// cuberoot is missing in VC++ !?</td><td> </td><td class="right">// cuberoot is missing in VC++ !?</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#define cbrt(x) pow((x),1./3.)</td><td> </td><td class="right">#define cbrt(x) pow((x),1./3.)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#endif</td><td> </td><td class="right">#endif</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0005" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">static</td><td> </td><td class="rblock"><span class="insert">//! Solve true anomaly nu for hyperbolic orbit.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">void <span class="delete">InitHyp(double q,double n,double e,double dt,double &amp;a1,double &amp;a2)</span> {</td><td> </td><td class="rblock"><span class="insert">//! @param q: perihel distance</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//! @param n: mean motion</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//! @param e: excentricity</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//! @param dt: days from perihel</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//! @param rCosNu: r*cos(nu)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//! @param rSinNu: r*sin(nu)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">static void <span class="insert">InitHyp(const double q, const double n, const double e, const d</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ouble dt, double &amp;rCosNu, double &amp;rSinNu)</span> {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//    qDebug() &lt;&lt; "InitHyp";</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  Q_ASSERT(e&gt;1.0);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">  const double a = q/(e-1.0);</td><td> </td><td class="right">  const double a = q/(e-1.0);</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0006" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  Q_ASSERT(a&gt;0.0);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">  const double M = n * dt;</td><td> </td><td class="right">  const double M = n * dt;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0007" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  double H = M;</td><td> </td><td class="rblock"><span class="insert">//</span>  double H = M;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  for (;;) { // Newton</td><td> </td><td class="rblock"><span class="insert">//</span>  for (;;) { // Newton</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    const double Hp = H;</td><td> </td><td class="rblock"><span class="insert">//</span>    const double Hp = H;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    H = H-(e*sinh(H)-H-M)/(e*cosh(H)-1);</td><td> </td><td class="rblock"><span class="insert">//</span>    H = H-(e*sinh(H)-H-M)/(e*cosh(H)-1);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    if (fabs(H - Hp) &lt; EPSILON) break;</td><td> </td><td class="rblock"><span class="insert">//</span>    if (fabs(H - Hp) <span class="insert">&lt; EPSILON) break;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//  }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//  const double h1 = q*sqrt((e+1.0)/(e-1.0));</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//  a1 = a*(e-cosh(H));</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//  a2 = h1*sinh(H);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  // GZ Again I prefer Heafner, ch.5.4</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  double E=StelUtils::sign(M)*log(2.0*fabs(M)/e + 1.85);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//  qDebug() &lt;&lt; "InitHyp: E=" &lt;&lt; E &lt;&lt; " M=" &lt;&lt; M ;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  for (;;){</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">      const double Ep=E;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">      const double f2=e*sinh(E);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">      const double f=f2-E-M;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">      const double f1=e*cosh(E)-1.0;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">      E+= (-5.0*f)/(f1+StelUtils::sign(f1)*sqrt(fabs(16.0*f1*f1-20.0*f*f2))</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">      if (fabs(E-Ep)</span> &lt; EPSILON) break;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">  }</td><td> </td><td class="right">  }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0008" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  <span class="delete">const double h1</span> = <span class="delete">q*sqrt((e+1.0)/(e-1.0));</span></td><td> </td><td class="rblock">  <span class="insert">rCosNu</span> = <span class="insert">a*(e-cosh(E));</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">  a1</span> = <span class="delete">a*(e-cosh(H));</span></td><td> </td><td class="rblock"><span class="insert">  rSinNu</span> = <span class="insert">a*sqrt(e*e-1.0)*sinh(E);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">  a2 = h1*sinh(H);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0009" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">static</td><td> </td><td class="rblock"><span class="insert">//! Solve true anomaly nu for parabolic orbit.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">void <span class="delete">InitPar(double q,double n,double dt,double &amp;a1,double</span> &amp;a2) {</td><td> </td><td class="rblock"><span class="insert">//! @param q: perihel distance</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//! @param n: mean motion equivalent related to W (n=W/dt) in Heafner, ch5.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">5</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//! @param dt: days from perihel</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//! @param rCosNu: r*cos(nu)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//! @param rSinNu: r*sin(nu)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/*</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">  static void <span class="insert">InitPar(const double q, const double n, const double dt, doub</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">le &amp;a1, double</span> &amp;a2) {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">  const double A = n*dt;</td><td> </td><td class="right">  const double A = n*dt;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">  const double h = sqrt(A*A+1.0);</td><td> </td><td class="right">  const double h = sqrt(A*A+1.0);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">  double c = cbrt(fabs(A)+h);</td><td> </td><td class="right">  double c = cbrt(fabs(A)+h);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">  c = c*c;</td><td> </td><td class="right">  c = c*c;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">  const double tan_nu_h = 2*A/(1+c+1/c);</td><td> </td><td class="right">  const double tan_nu_h = 2*A/(1+c+1/c);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">  a1 = q*(1-tan_nu_h*tan_nu_h);</td><td> </td><td class="right">  a1 = q*(1-tan_nu_h*tan_nu_h);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">  a2 = 2.0*q*tan_nu_h;</td><td> </td><td class="right">  a2 = 2.0*q*tan_nu_h;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0010" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                                                           </td><td> </td><td class="rblock"><span class="insert">*/</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">static</td><td> </td><td class="rblock"><span class="insert">// GZ This implementation now follows Heafner, ch 5.5</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">void <span class="delete">InitEll(double q,double n,double e,double dt,double &amp;a1,double &amp;a2)</span> {</td><td> </td><td class="rblock">static void <span class="insert">InitPar(const double q, const double n, const double dt, double</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  const double a = q/(1.0-e);</td><td> </td><td class="rblock"><span class="insert"> &amp;rCosNu, double &amp;rSinNu) {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  double M = fmod(n*dt,2*M_PI);</td><td> </td><td class="rblock"><span class="insert">//        qDebug() &lt;&lt; "InitPar";</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//    const double M=dt*sqrt(GAUSS_GRAV_CONST/(2.0*q*q*q));</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//    const double W=1.5*M;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    const double W=dt*n;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    const double Y=cbrt(W+sqrt(W*W+1));</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    const double tanNu2=Y-1.0/Y; // Heafner (5.5.8) has an error here, writ</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">es (Y-1)/Y.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    rCosNu=q*(1.0-tanNu2*tanNu2);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    rSinNu=2.0*q*tanNu2;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">}</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//! Solve true anomaly nu for elliptical orbit with Laguerre-Conway's metho</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">d. (May have high e)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//! @param q: perihel distance</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//! @param n: mean motion</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//! @param e: excentricity</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//! @param dt: days from perihel</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//! @param rCosNu: r*cos(nu)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//! @param rSinNu: r*sin(nu)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">static void InitEll(const double q, const double n, const double e, const d</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ouble dt, double &amp;rCosNu, double &amp;rSinNu)</span> {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//    qDebug() &lt;&lt; "InitEll";</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">    Q_ASSERT(e&lt;1.0);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">  const double a = q/(1.0-e); <span class="insert">// semimajor axis</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">  double M = fmod(n*dt,2*M_PI);  <span class="insert">// Mean Anomaly</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">  if (M &lt; 0.0) M += 2.0*M_PI;</td><td> </td><td class="right">  if (M &lt; 0.0) M += 2.0*M_PI;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0011" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  double <span class="delete">H</span> = M;</td><td> </td><td class="rblock"><span class="insert">//</span>  double <span class="insert">E</span> = M;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  for (;;) { // <span class="delete">Newton</span></td><td> </td><td class="rblock"><span class="insert">//</span>  for (;;) { // <span class="insert">Newton(?) Solve Kepler's equation (similar to Meeus secon</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    const double <span class="delete">Hp</span> = <span class="delete">H;</span></td><td> </td><td class="rblock"><span class="insert">d method, Astro.Alg. 1998 p.199)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">    H = H-(M-H+e*sin(H))/(e*cos(H)-1);</span></td><td> </td><td class="rblock"><span class="insert">//</span>    const double <span class="insert">Ep</span> = <span class="insert">E;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    if <span class="delete">(fabs(H-Hp)</span> &lt; EPSILON) break;</td><td> </td><td class="rblock"><span class="insert">//    E -= (M-E+e*sin(E))/(e*cos(E)-1);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//    if (fabs(E-Ep) &lt; EPSILON) break;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//  }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  // GZ: Comet orbits are quite often near-parabolic, where this may still </span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">only converge slowly.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  // Better always use Laguerre-Conway. See Heafner, Ch. 5.3</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  double E=M+0.85*e*StelUtils::sign(sin(M));</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  for (;;){</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">      const double Ep=E;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">      const double f2=e*sin(E);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">      const double f=E-f2-M;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">      const double f1=1.0-e*cos(E);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">      E+= (-5.0*f)/(f1+StelUtils::sign(f1)*sqrt(fabs(16.0*f1*f1-20.0*f*f2))</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">      if <span class="insert">(fabs(E-Ep)</span> &lt; EPSILON) break;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">  }</td><td> </td><td class="right">  }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0012" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  const double h1 = q*sqrt((1.0+e)/(1.0-e));</td><td> </td><td class="rblock">  <span class="insert">// Note: q=a*(1-e)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  <span class="delete">a1</span> = <span class="delete">a*(cos(H)-e);</span></td><td> </td><td class="rblock">  const double h1 = q*sqrt((1.0+e)/(1.0-e));  <span class="insert">// elsewhere: a sqrt(1-eÂ²)   </span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">  a2</span> = <span class="delete">h1*sin(H);</span></td><td> </td><td class="rblock"><span class="insert">  ... q / (1-e) sqrt( (1+e)(1-e))</span> = <span class="insert">q sqrt((1+e)/(1-e))</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">}</td><td> </td><td class="rblock"><span class="insert">  rCosNu</span> = <span class="insert">a*(cos(E)-e);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                                                           </td><td> </td><td class="rblock"><span class="insert">  rSinNu = h1*sin(E);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">void <span class="delete">Init3D(double i,double Omega,double o,double a1,double a2,</span></td><td> </td><td class="rblock">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">            double &amp;x1,double &amp;x2,double &amp;x3)</span> {</td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  const double <span class="delete">co</span> = <span class="delete">cos(o);</span></td><td> </td><td class="rblock"><span class="insert">//! Compute position vector and (optional) speed vector from orbital elemen</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  const double <span class="delete">so</span> = <span class="delete">sin(o);</span></td><td> </td><td class="rblock"><span class="insert">ts and true anomaly components. See e.g. Heafner, Fund.Eph.Comp.1999</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//! @param i inclination</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//! @param Omega, longitude of ascending node</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//! @param w omega, argument of pericenter</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//! @param rCosNu: r*cos(nu)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//! @param rSinNu: r*sin(nu)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//! @param rx: x component of position vector, AU</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//! @param ry: y component of position vector, AU</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//! @param rz: z component of position vector, AU</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//! @param withVelVector also compute velocity vector (required for comet t</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ails)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//! @param e excentricity (required if withVelVector=true)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//! @param q perihel distance, AU (required if withVelVector=true)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//! @param rdotx: x component of velocity vector, AU/d</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//! @param rdoty: y component of velocity vector, AU/d</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//! @param rdotz: z component of velocity vector, AU/d</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">void <span class="insert">Init3D(const double i, const double Omega, const double w, const doubl</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">e rCosNu, const double rSinNu,</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">            double &amp;rx,double &amp;ry,double &amp;rz, double &amp;rdotx, double &amp;rdoty,</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> double &amp;rdotz, const bool withVelVector=false, const double e=0.0, const d</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ouble q=0.0)</span> {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//        qDebug() &lt;&lt; "Init3D";</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">  const double <span class="insert">cw</span> = <span class="insert">cos(w);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">  const double <span class="insert">sw</span> = <span class="insert">sin(w);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">  const double cOm = cos(Omega);</td><td> </td><td class="right">  const double cOm = cos(Omega);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">  const double sOm = sin(Omega);</td><td> </td><td class="right">  const double sOm = sin(Omega);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">  const double ci = cos(i);</td><td> </td><td class="right">  const double ci = cos(i);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">  const double si = sin(i);</td><td> </td><td class="right">  const double si = sin(i);</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0013" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  const double <span class="delete">d11=-so*sOm*ci+co*cOm;</span></td><td> </td><td class="rblock">  const double <span class="insert">Px=-sw*sOm*ci+cw*cOm; // Heafner, 5.3.1 Px</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  const double <span class="delete">d12=-co*sOm*ci-so*cOm;</span></td><td> </td><td class="rblock">  const double <span class="insert">Qx=-cw*sOm*ci-sw*cOm; // Heafner, 5.3.4 Qx</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  const double <span class="delete">d21= so*cOm*ci+co*sOm;</span></td><td> </td><td class="rblock">  const double <span class="insert">Py= sw*cOm*ci+cw*sOm; // Heafner, 5.3.2 Py</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  const double <span class="delete">d22= co*cOm*ci-so*sOm;</span></td><td> </td><td class="rblock">  const double <span class="insert">Qy= cw*cOm*ci-sw*sOm; // Heafner, 5.3.5 Qy</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  const double <span class="delete">d31= so*si;</span></td><td> </td><td class="rblock">  const double <span class="insert">Pz= sw*si;            // Heafner, 5.3.3 Pz</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  const double <span class="delete">d32= co*si;</span></td><td> </td><td class="rblock">  const double <span class="insert">Qz= cw*si;            // Heafner, 5.3.6 Qz</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">  x1</span> = <span class="delete">d11*a1+d12*a2;</span></td><td> </td><td class="rblock"><span class="insert">  rx</span> = <span class="insert">Px*rCosNu+Qx*rSinNu; // Heafner, 5.3.18 r</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">  x2</span> = <span class="delete">d21*a1+d22*a2;</span></td><td> </td><td class="rblock"><span class="insert">  ry</span> = <span class="insert">Py*rCosNu+Qy*rSinNu;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">  x3</span> = <span class="delete">d31*a1+d32*a2;</span></td><td> </td><td class="rblock"><span class="insert">  rz</span> = <span class="insert">Pz*rCosNu+Qz*rSinNu;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  if (withVelVector) {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">      const double r=sqrt(rSinNu*rSinNu+rCosNu*rCosNu);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">      const double sinNu=rSinNu/r;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">      const double cosNu=rCosNu/r;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">      const double p=q*(1.0+e);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">      const double sqrtMuP=sqrt(GAUSS_GRAV_CONST/p);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">      rdotx=sqrtMuP*((e+cosNu)*Qx - sinNu*Px); // Heafner, 5.3.19 r'</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">      rdoty=sqrtMuP*((e+cosNu)*Qy - sinNu*Py);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">      rdotz=sqrtMuP*((e+cosNu)*Qz - sinNu*Pz);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">CometOrbit::CometOrbit(double pericenterDistance,</td><td> </td><td class="right">CometOrbit::CometOrbit(double pericenterDistance,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       double eccentricity,</td><td> </td><td class="right">                       double eccentricity,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       double inclination,</td><td> </td><td class="right">                       double inclination,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       double ascendingNode,</td><td> </td><td class="right">                       double ascendingNode,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       double argOfPerhelion,</td><td> </td><td class="right">                       double argOfPerhelion,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       double timeAtPerihelion,</td><td> </td><td class="right">                       double timeAtPerihelion,</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0014" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       double meanMotion,</td><td> </td><td class="rblock">                       double <span class="insert">orbitGoodDays,</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       double parentRotObliquity,</td><td> </td><td class="rblock"><span class="insert">                       double</span> meanMotion,              <span class="insert">// GZ: for parabolic</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       double parentRotAscendingnode,</td><td> </td><td class="rblock"><span class="insert">s, this is W/dt in Heafner's lettering</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       double parentRotJ2000Longitude)</td><td> </td><td class="rblock">                       double parentRotObliquity,      <span class="insert">// GZ: I don't see a</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">           :q(pericenterDistance),e(eccentricity),i(inclination),</td><td> </td><td class="rblock"><span class="insert">ny use for this, should be 0 for comets.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">            <span class="delete">Om(ascendingNode),o(argOfPerhelion),t0(timeAtPerihelion),</span></td><td> </td><td class="rblock">                       double parentRotAscendingnode,  <span class="insert">// GZ: I don't see a</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">            n(meanMotion)</span> {</td><td> </td><td class="rblock"><span class="insert">ny use for this, should be 0 for comets.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  const double c_obl = cos(parentRotObliquity);</td><td> </td><td class="rblock">                       double parentRotJ2000Longitude) <span class="insert">// GZ: I don't see a</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  const double s_obl = sin(parentRotObliquity);</td><td> </td><td class="rblock"><span class="insert">ny use for this, should be 0 for comets.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  const double c_nod = cos(parentRotAscendingnode);</td><td> </td><td class="rblock"><span class="insert">                      //)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  const double s_nod = sin(parentRotAscendingnode);</td><td> </td><td class="rblock">            :q(pericenterDistance),e(eccentricity),i(inclination),</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  const double cj = cos(parentRotJ2000Longitude);</td><td> </td><td class="rblock">            <span class="insert">Om(ascendingNode),w(argOfPerhelion),t0(timeAtPerihelion),</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  const double sj = sin(parentRotJ2000Longitude);</td><td> </td><td class="rblock"><span class="insert">           n(meanMotion), updateTails(true), orbitGood(orbitGoodDays)</span> {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//        qDebug() &lt;&lt; "CometOrbit::()";</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  rdot.set(0.0, 0.0, 0.0);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">  const double c_obl = cos(parentRotObliquity);         <span class="insert">// 1?</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">  const double s_obl = sin(parentRotObliquity);         <span class="insert">// 0?</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">  const double c_nod = cos(parentRotAscendingnode);     <span class="insert">// 1?</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">  const double s_nod = sin(parentRotAscendingnode);     <span class="insert">// 0?</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">  const double cj = cos(parentRotJ2000Longitude);       <span class="insert">// 1?</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">  const double sj = sin(parentRotJ2000Longitude);       <span class="insert">// 0?</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  // GZ: Test my assumptions before breaking anything...</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//  Q_ASSERT(c_obl==1.0);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//  Q_ASSERT(c_nod==1.0);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//  Q_ASSERT(cj   ==1.0);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//  Q_ASSERT(s_obl==0.0);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//  Q_ASSERT(s_nod==0.0);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//  Q_ASSERT(sj   ==0.0);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  // GZ NO, this is necessary!</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//  rotateToVsop87[0] =  c_nod;</td><td> </td><td class="right">//  rotateToVsop87[0] =  c_nod;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//  rotateToVsop87[1] = -s_nod * c_obl;</td><td> </td><td class="right">//  rotateToVsop87[1] = -s_nod * c_obl;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//  rotateToVsop87[2] =  s_nod * s_obl;</td><td> </td><td class="right">//  rotateToVsop87[2] =  s_nod * s_obl;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//  rotateToVsop87[3] =  s_nod;</td><td> </td><td class="right">//  rotateToVsop87[3] =  s_nod;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//  rotateToVsop87[4] =  c_nod * c_obl;</td><td> </td><td class="right">//  rotateToVsop87[4] =  c_nod * c_obl;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//  rotateToVsop87[5] = -c_nod * s_obl;</td><td> </td><td class="right">//  rotateToVsop87[5] = -c_nod * s_obl;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//  rotateToVsop87[6] =  0.0;</td><td> </td><td class="right">//  rotateToVsop87[6] =  0.0;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//  rotateToVsop87[7] =          s_obl;</td><td> </td><td class="right">//  rotateToVsop87[7] =          s_obl;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//  rotateToVsop87[8] =          c_obl;</td><td> </td><td class="right">//  rotateToVsop87[8] =          c_obl;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0015" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  rotateToVsop87[0] =  c_nod*cj-s_nod*c_obl*sj;</td><td> </td><td class="rblock">  rotateToVsop87[0] =  c_nod*cj-s_nod*c_obl*sj; <span class="insert">// 1 in case of comet orbit</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  rotateToVsop87[1] = -c_nod*sj-s_nod*c_obl*cj;</td><td> </td><td class="rblock"><span class="insert">ing the sun, these names are misleading, however they do the right thing.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  rotateToVsop87[2] =           s_nod*s_obl;</td><td> </td><td class="rblock">  rotateToVsop87[1] = -c_nod*sj-s_nod*c_obl*cj; <span class="insert">// 0 OK, this is NOT an ide</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  rotateToVsop87[3] =  s_nod*cj+c_nod*c_obl*sj;</td><td> </td><td class="rblock"><span class="insert">ntity matrix...</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  rotateToVsop87[4] = -s_nod*sj+c_nod*c_obl*cj;</td><td> </td><td class="rblock">  rotateToVsop87[2] =           s_nod*s_obl;    <span class="insert">// 0</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  rotateToVsop87[5] =          -c_nod*s_obl;</td><td> </td><td class="rblock">  rotateToVsop87[3] =  s_nod*cj+c_nod*c_obl*sj; <span class="insert">// 0</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  rotateToVsop87[6] =                 s_obl*sj;</td><td> </td><td class="rblock">  rotateToVsop87[4] = -s_nod*sj+c_nod*c_obl*cj; <span class="insert">// 1</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  rotateToVsop87[7] =                 s_obl*cj;</td><td> </td><td class="rblock">  rotateToVsop87[5] =          -c_nod*s_obl;    <span class="insert">// 0</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  rotateToVsop87[8] =                 c_obl;</td><td> </td><td class="rblock">  rotateToVsop87[6] =                 s_obl*sj; <span class="insert">// 0</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">  rotateToVsop87[7] =                 s_obl*cj; <span class="insert">// 0</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">  rotateToVsop87[8] =                 c_obl;    <span class="insert">// 1</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">//  qDebug() &lt;&lt; "CometOrbit::()...done";</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0016" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">void CometOrbit::positionAtTimevInVSOP87Coordinates(double JD,<span class="delete">double *v) co
nst</span> {</td><td> </td><td class="rblock">void CometOrbit::positionAtTimevInVSOP87Coordinates(double JD,<span class="insert"> double *v, b
ool updateVelocityVector) </span> {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">  JD -= t0;</td><td> </td><td class="right">  JD -= t0;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0017" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  double <span class="delete">a1,a2</span>;</td><td> </td><td class="rblock">  double <span class="insert">rCosNu,rSinNu</span>;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">  // temporary solve freezes for near-parabolic comets - using (e &lt; 0.9999)
 for elliptical orbits</td><td> </td><td class="right">  // temporary solve freezes for near-parabolic comets - using (e &lt; 0.9999)
 for elliptical orbits</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">  // TODO: improve calculations orbits for near-parabolic comets --AW</td><td> </td><td class="right">  // TODO: improve calculations orbits for near-parabolic comets --AW</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0018" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  if (e &lt; 0.9999) InitEll(q,n,e,JD,a1,a2);</td><td> </td><td class="rblock"><span class="insert">//</span>  if (e &lt; 0.9999) InitEll(q,n,e,JD,a1,a2);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  else if (e &gt; 1.0) <span class="delete">InitHyp(q,n,e,JD,a1,a2);</span></td><td> </td><td class="rblock">  <span class="insert">if (e &lt; 1.0) InitEll(q,n,e,JD,rCosNu,rSinNu); // GZ: After solving with L</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  else <span class="delete">InitPar(q,n,JD,a1,a2);</span></td><td> </td><td class="rblock"><span class="insert">aguerre-Conway, I dare to go for 1.0.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  double <span class="delete">p0,p1,p2;</span></td><td> </td><td class="rblock">  else if (e &gt; 1.0) <span class="insert">{</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">  Init3D(i,Om,o,a1,a2,p0,p1,p2);</span></td><td> </td><td class="rblock"><span class="insert">//      qDebug() &lt;&lt; "Hyperbolic orbit for ecc=" &lt;&lt; e &lt;&lt; ", i=" &lt;&lt; i &lt;&lt; ", w</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">=" &lt;&lt; w &lt;&lt; ", Mean Motion n=" &lt;&lt; n;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">      InitHyp(q,n,e,JD,rCosNu,rSinNu);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">  else <span class="insert">InitPar(q,n,JD,rCosNu,rSinNu);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">  double <span class="insert">p0,p1,p2, s0, s1, s2;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  Init3D(i,Om,w,rCosNu,rSinNu,p0,p1,p2, s0, s1, s2, updateVelocityVector, e</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">, q);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  // GZ: The next 3 lines are meaningless for a comet orbiting the sun. Or </span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">not?</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">  v[0] = rotateToVsop87[0]*p0 + rotateToVsop87[1]*p1 + rotateToVsop87[2]*p2
;</td><td> </td><td class="right">  v[0] = rotateToVsop87[0]*p0 + rotateToVsop87[1]*p1 + rotateToVsop87[2]*p2
;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">  v[1] = rotateToVsop87[3]*p0 + rotateToVsop87[4]*p1 + rotateToVsop87[5]*p2
;</td><td> </td><td class="right">  v[1] = rotateToVsop87[3]*p0 + rotateToVsop87[4]*p1 + rotateToVsop87[5]*p2
;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">  v[2] = rotateToVsop87[6]*p0 + rotateToVsop87[7]*p1 + rotateToVsop87[8]*p2
;</td><td> </td><td class="right">  v[2] = rotateToVsop87[6]*p0 + rotateToVsop87[7]*p1 + rotateToVsop87[8]*p2
;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0019" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">  <span class="insert">//GZ replace with:</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  //v[0]=p0;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  //v[1]=p1;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  //v[2]=p2;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  if (updateVelocityVector) {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">      rdot.set(s0, s1, s2); // TODO: ROTATE?</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">      updateTails=true;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">EllipticalOrbit::EllipticalOrbit(double pericenterDistance,</td><td> </td><td class="right">EllipticalOrbit::EllipticalOrbit(double pericenterDistance,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                                 double eccentricity,</td><td> </td><td class="right">                                 double eccentricity,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                                 double inclination,</td><td> </td><td class="right">                                 double inclination,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                                 double ascendingNode,</td><td> </td><td class="right">                                 double ascendingNode,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                                 double argOfPeriapsis,</td><td> </td><td class="right">                                 double argOfPeriapsis,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                                 double meanAnomalyAtEpoch,</td><td> </td><td class="right">                                 double meanAnomalyAtEpoch,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                                 double period,</td><td> </td><td class="right">                                 double period,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                                 double epoch,</td><td> </td><td class="right">                                 double epoch,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l2" /><small>skipping to change at</small><em> line 230</em></th><th> </th><th><a name="part-r2" /><small>skipping to change at</small><em> line 351</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">    else</td><td> </td><td class="right">    else</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">        return 0.;</td><td> </td><td class="right">        return 0.;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">struct SolveKeplerLaguerreConway : public unary_function&lt;double, double&gt;</td><td> </td><td class="right">struct SolveKeplerLaguerreConway : public unary_function&lt;double, double&gt;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">    double ecc;</td><td> </td><td class="right">    double ecc;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">    double M;</td><td> </td><td class="right">    double M;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">    SolveKeplerLaguerreConway(double _ecc, double _M) : ecc(_ecc), M(_M) {}
;</td><td> </td><td class="right">    SolveKeplerLaguerreConway(double _ecc, double _M) : ecc(_ecc), M(_M) {}
;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0020" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                                                           </td><td> </td><td class="rblock">    <span class="insert">// cf Heafner, Fundamental Ephemeris Computations p.73</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    double operator()(double <span class="delete">x)</span> const</td><td> </td><td class="rblock"><span class="insert">    // GZ: note&amp;add Heafner's initial guess for E!</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    {</td><td> </td><td class="rblock">    double operator()(double <span class="insert">E)</span> const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">        double s = ecc * <span class="delete">sin(x);</span></td><td> </td><td class="rblock">    {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">        double c = ecc * <span class="delete">cos(x);</span></td><td> </td><td class="rblock">        double s = ecc * <span class="insert">sin(E);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">        double f = <span class="delete">x</span> - s - M;</td><td> </td><td class="rblock">        double c = ecc * <span class="insert">cos(E);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">        double f = <span class="insert">E</span> - s - M;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">        double f1 = 1 - c;</td><td> </td><td class="right">        double f1 = 1 - c;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">        double f2 = s;</td><td> </td><td class="right">        double f2 = s;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0021" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">        <span class="delete">x</span> += -5 * f / (f1 + sign(f1) * sqrt(abs(16 * f1 * f1 - 20 * f * f2)
));</td><td> </td><td class="rblock">        <span class="insert">E</span> += -5 * f / (f1 + sign(f1) * sqrt(abs(16 * f1 * f1 - 20 * f * f2)
));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0022" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">        return <span class="delete">x</span>;</td><td> </td><td class="rblock">        return <span class="insert">E</span>;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">    }</td><td> </td><td class="right">    }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">};</td><td> </td><td class="right">};</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">struct SolveKeplerLaguerreConwayHyp : public unary_function&lt;double, double&gt;</td><td> </td><td class="right">struct SolveKeplerLaguerreConwayHyp : public unary_function&lt;double, double&gt;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">    double ecc;</td><td> </td><td class="right">    double ecc;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">    double M;</td><td> </td><td class="right">    double M;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">    SolveKeplerLaguerreConwayHyp(double _ecc, double _M) : ecc(_ecc), M(_M)
 {};</td><td> </td><td class="right">    SolveKeplerLaguerreConwayHyp(double _ecc, double _M) : ecc(_ecc), M(_M)
 {};</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0023" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    <span class="delete">                                                                       </span></td><td> </td><td class="rblock">    <span class="insert">// cf Heafner, Fundamental Ephemeris Computations p.73</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">    double operator()(double x) const</td><td> </td><td class="right">    double operator()(double x) const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">    {</td><td> </td><td class="right">    {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">        double s = ecc * sinh(x);</td><td> </td><td class="right">        double s = ecc * sinh(x);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">        double c = ecc * cosh(x);</td><td> </td><td class="right">        double c = ecc * cosh(x);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">        double f = s - x - M;</td><td> </td><td class="right">        double f = s - x - M;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">        double f1 = c - 1;</td><td> </td><td class="right">        double f1 = c - 1;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">        double f2 = s;</td><td> </td><td class="right">        double f2 = s;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">        x += -5 * f / (f1 + sign(f1) * sqrt(abs(16 * f1 * f1 - 20 * f * f2)
));</td><td> </td><td class="right">        x += -5 * f / (f1 + sign(f1) * sqrt(abs(16 * f1 * f1 - 20 * f * f2)
));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">        return x;</td><td> </td><td class="right">        return x;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">    }</td><td> </td><td class="right">    }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">};</td><td> </td><td class="right">};</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">typedef pair&lt;double, double&gt; Solution;</td><td> </td><td class="right">typedef pair&lt;double, double&gt; Solution;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0024" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">double EllipticalOrbit::eccentricAnomaly(double M) const</td><td> </td><td class="rblock">double EllipticalOrbit::eccentricAnomaly(<span class="insert">const </span>double M) const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">    if (eccentricity == 0.0)</td><td> </td><td class="right">    if (eccentricity == 0.0)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">    {</td><td> </td><td class="right">    {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">        // Circular orbit</td><td> </td><td class="right">        // Circular orbit</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">        return M;</td><td> </td><td class="right">        return M;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">    }</td><td> </td><td class="right">    }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">    else if (eccentricity &lt; 0.2)</td><td> </td><td class="right">    else if (eccentricity &lt; 0.2)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">    {</td><td> </td><td class="right">    {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">        // Low eccentricity, so use the standard iteration technique</td><td> </td><td class="right">        // Low eccentricity, so use the standard iteration technique</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">        Solution sol = solveIteration_fixed(SolveKeplerFunc1(eccentricity, 
M), M, 5);</td><td> </td><td class="right">        Solution sol = solveIteration_fixed(SolveKeplerFunc1(eccentricity, 
M), M, 5);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l3" /><small>skipping to change at</small><em> line 300</em></th><th> </th><th><a name="part-r3" /><small>skipping to change at</small><em> line 422</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">    {</td><td> </td><td class="right">    {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">        // Extremely stable Laguerre-Conway method for solving Kepler's</td><td> </td><td class="right">        // Extremely stable Laguerre-Conway method for solving Kepler's</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">        // equation.  Only use this for high-eccentricity orbits, as it</td><td> </td><td class="right">        // equation.  Only use this for high-eccentricity orbits, as it</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">        // requires more calcuation.</td><td> </td><td class="right">        // requires more calcuation.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">        double E = M + 0.85 * eccentricity * sign(sin(M));</td><td> </td><td class="right">        double E = M + 0.85 * eccentricity * sign(sin(M));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">        Solution sol = solveIteration_fixed(SolveKeplerLaguerreConway(eccen
tricity, M), E, 8);</td><td> </td><td class="right">        Solution sol = solveIteration_fixed(SolveKeplerLaguerreConway(eccen
tricity, M), E, 8);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">        return sol.first;</td><td> </td><td class="right">        return sol.first;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">    }</td><td> </td><td class="right">    }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">    else if (eccentricity == 1.0)</td><td> </td><td class="right">    else if (eccentricity == 1.0)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">    {</td><td> </td><td class="right">    {</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0025" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">        // <span class="delete">Nearly</span> parabolic orbit; very common for comets</td><td> </td><td class="rblock">        // parabolic orbit; very common for comets</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">        // TODO: handle <span class="delete">this</span></td><td> </td><td class="rblock">        // TODO: handle <span class="insert">this.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        // Problem: E does not make sense here. True anomaly quantities (rS</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">inNu, rCosNu) computed directly.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        // Anyhow, Comets use CometOrbit class.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">        return M;</td><td> </td><td class="right">        return M;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">    }</td><td> </td><td class="right">    }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">    else</td><td> </td><td class="right">    else</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">    {</td><td> </td><td class="right">    {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">        // Laguerre-Conway method for hyperbolic (ecc &gt; 1) orbits.</td><td> </td><td class="right">        // Laguerre-Conway method for hyperbolic (ecc &gt; 1) orbits.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">        double E = log(2 * M / eccentricity + 1.85);</td><td> </td><td class="right">        double E = log(2 * M / eccentricity + 1.85);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">        Solution sol = solveIteration_fixed(SolveKeplerLaguerreConwayHyp(ec
centricity, M), E, 30);</td><td> </td><td class="right">        Solution sol = solveIteration_fixed(SolveKeplerLaguerreConwayHyp(ec
centricity, M), E, 30);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">        return sol.first;</td><td> </td><td class="right">        return sol.first;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">    }</td><td> </td><td class="right">    }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0026" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">Vec3d EllipticalOrbit::positionAtE(double E) const</td><td> </td><td class="rblock">Vec3d EllipticalOrbit::positionAtE(<span class="insert">const </span>double E) const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">    double x, z;</td><td> </td><td class="right">    double x, z;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">    if (eccentricity &lt; 1.0)</td><td> </td><td class="right">    if (eccentricity &lt; 1.0)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">    {</td><td> </td><td class="right">    {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">        double a = pericenterDistance / (1.0 - eccentricity);</td><td> </td><td class="right">        double a = pericenterDistance / (1.0 - eccentricity);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">        x = a * (cos(E) - eccentricity);</td><td> </td><td class="right">        x = a * (cos(E) - eccentricity);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">        z = a * sqrt(1 - eccentricity * eccentricity) * -sin(E);</td><td> </td><td class="right">        z = a * sqrt(1 - eccentricity * eccentricity) * -sin(E);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">    }</td><td> </td><td class="right">    }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0027" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    else if (eccentricity &gt; 1.0)</td><td> </td><td class="rblock">    else if (eccentricity &gt; 1.0)<span class="insert"> // N.B. This is odd at least: elliptical m
ust have ecc&lt;1!</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">    {</td><td> </td><td class="right">    {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">        double a = pericenterDistance / (1.0 - eccentricity);</td><td> </td><td class="right">        double a = pericenterDistance / (1.0 - eccentricity);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">        x = -a * (eccentricity - cosh(E));</td><td> </td><td class="right">        x = -a * (eccentricity - cosh(E));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">        z = -a * sqrt(eccentricity * eccentricity - 1) * -sinh(E);</td><td> </td><td class="right">        z = -a * sqrt(eccentricity * eccentricity - 1) * -sinh(E);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">    }</td><td> </td><td class="right">    }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">    else</td><td> </td><td class="right">    else</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">    {</td><td> </td><td class="right">    {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">        // TODO: Handle parabolic orbits</td><td> </td><td class="right">        // TODO: Handle parabolic orbits</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">        x = 0.0;</td><td> </td><td class="right">        x = 0.0;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">        z = 0.0;</td><td> </td><td class="right">        z = 0.0;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">    }</td><td> </td><td class="right">    }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">    Mat4d R = (Mat4d::zrotation(ascendingNode) *</td><td> </td><td class="right">    Mat4d R = (Mat4d::zrotation(ascendingNode) *</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               Mat4d::xrotation(inclination) *</td><td> </td><td class="right">               Mat4d::xrotation(inclination) *</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               Mat4d::zrotation(argOfPeriapsis));</td><td> </td><td class="right">               Mat4d::zrotation(argOfPeriapsis));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">    return R * Vec3d(x, -z, 0);</td><td> </td><td class="right">    return R * Vec3d(x, -z, 0);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0028" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">// Return the offset from the <span class="delete">center</span></td><td> </td><td class="rblock">// Return the offset from the <span class="insert">center.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">Vec3d <span class="delete">EllipticalOrbit::positionAtTime(double t)</span> const</td><td> </td><td class="rblock">Vec3d <span class="insert">EllipticalOrbit::positionAtTime(const double JD)</span> const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0029" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">    t = t - epoch;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">    double meanMotion = 2.0 * M_PI / period;</td><td> </td><td class="right">    double meanMotion = 2.0 * M_PI / period;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0030" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    double meanAnomaly = meanAnomalyAtEpoch + <span class="delete">t</span> * meanMotion;</td><td> </td><td class="rblock">    double meanAnomaly = meanAnomalyAtEpoch + <span class="insert">(JD-epoch)</span> * meanMotion;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">    double E = eccentricAnomaly(meanAnomaly);</td><td> </td><td class="right">    double E = eccentricAnomaly(meanAnomaly);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">    return positionAtE(E);</td><td> </td><td class="right">    return positionAtE(E);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//void EllipticalOrbit::positionAtTime(double JD, double * X, double * Y, d
ouble * Z) const</td><td> </td><td class="right">//void EllipticalOrbit::positionAtTime(double JD, double * X, double * Y, d
ouble * Z) const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//{</td><td> </td><td class="right">//{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//     Vec3d pos = positionAtTime(JD);</td><td> </td><td class="right">//     Vec3d pos = positionAtTime(JD);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//     *X=pos[2];</td><td> </td><td class="right">//     *X=pos[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//     *Y=pos[0];</td><td> </td><td class="right">//     *Y=pos[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l4" /><small>skipping to change at</small><em> line 370</em></th><th> </th><th><a name="part-r4" /><small>skipping to change at</small><em> line 493</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//}</td><td> </td><td class="right">//}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//void EllipticalOrbit::positionAtTimev(double JD, double* v)</td><td> </td><td class="right">//void EllipticalOrbit::positionAtTimev(double JD, double* v)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//{</td><td> </td><td class="right">//{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//     Vec3d pos = positionAtTime(JD);</td><td> </td><td class="right">//     Vec3d pos = positionAtTime(JD);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//     v[0]=pos[2];</td><td> </td><td class="right">//     v[0]=pos[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//     v[1]=pos[0];</td><td> </td><td class="right">//     v[1]=pos[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//     v[2]=pos[1];</td><td> </td><td class="right">//     v[2]=pos[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//}</td><td> </td><td class="right">//}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0031" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">void EllipticalOrbit::positionAtTimevInVSOP87Coordinates(<span class="delete">double JD, double*
</span> v) const</td><td> </td><td class="rblock">void EllipticalOrbit::positionAtTimevInVSOP87Coordinates(<span class="insert">const double JD, d
ouble*</span> v) const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">  Vec3d pos = positionAtTime(JD);</td><td> </td><td class="right">  Vec3d pos = positionAtTime(JD);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">  v[0] = rotateToVsop87[0]*pos[0] + rotateToVsop87[1]*pos[1] + rotateToVsop
87[2]*pos[2];</td><td> </td><td class="right">  v[0] = rotateToVsop87[0]*pos[0] + rotateToVsop87[1]*pos[1] + rotateToVsop
87[2]*pos[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">  v[1] = rotateToVsop87[3]*pos[0] + rotateToVsop87[4]*pos[1] + rotateToVsop
87[5]*pos[2];</td><td> </td><td class="right">  v[1] = rotateToVsop87[3]*pos[0] + rotateToVsop87[4]*pos[1] + rotateToVsop
87[5]*pos[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">  v[2] = rotateToVsop87[6]*pos[0] + rotateToVsop87[7]*pos[1] + rotateToVsop
87[8]*pos[2];</td><td> </td><td class="right">  v[2] = rotateToVsop87[6]*pos[0] + rotateToVsop87[7]*pos[1] + rotateToVsop
87[8]*pos[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">double EllipticalOrbit::getPeriod() const</td><td> </td><td class="right">double EllipticalOrbit::getPeriod() const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">    return period;</td><td> </td><td class="right">    return period;</td><td class="lineno" valign="top"></td></tr>

     <tr><td></td><td class="left"></td><td> </td><td class="right"></td><td></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 31 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><td></td><th><i>91 lines changed or deleted</i></th><th><i> </i></th><th><i>244 lines changed or added</i></th><td></td></tr>
     <tr><td colspan="5" align="center" class="small"><br/>This html diff was produced by rfcdiff 1.41. The latest version is available from <a href="http://www.tools.ietf.org/tools/rfcdiff/" >http://tools.ietf.org/tools/rfcdiff/</a> </td></tr>
   </table>
   </body>
   </html>
