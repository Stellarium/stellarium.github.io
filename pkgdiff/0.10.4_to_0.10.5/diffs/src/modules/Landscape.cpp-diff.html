<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"> 
<!-- Generated by rfcdiff 1.41: rfcdiff  --> 
<!-- <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional" > -->
<!-- System: Linux fomalhaut.local 3.13.0-38-generic #65-Ubuntu SMP Thu Oct 9 11:36:50 UTC 2014 x86_64 x86_64 x86_64 GNU/Linux --> 
<!-- Using awk: /usr/bin/gawk: GNU Awk 4.0.1 --> 
<!-- Using diff: /usr/bin/diff: diff (GNU diffutils) 3.3 --> 
<!-- Using wdiff: /usr/bin/wdiff: wdiff (GNU wdiff) 1.2.1 --> 
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"> 
<head> 
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /> 
  <meta http-equiv="Content-Style-Type" content="text/css" /> 
  <title>Diff: Landscape.cpp - Landscape.cpp</title> 
  <style type="text/css"> 
    body    { font-size:16px; margin: 0.4ex; margin-right: auto; } 
    tr      { } 
    td      { white-space: pre; font-family: Consolas, "DejaVu Sans Mono", "Droid Sans Mono", Monaco, Monospace; vertical-align: top; font-size: 0.86em;} 
    th      { font-size: 0.86em; } 
    .small  { font-size: 0.6em; font-style: italic; font-family: Verdana, Helvetica, sans-serif; } 
    .left   { background-color: #EEE; } 
    .right  { background-color: #FFF; } 
    .diff   { background-color: #CCF; } 
    .lblock { background-color: #BFB; } 
    .rblock { background-color: #FF8; } 
    .insert { background-color: #8FF; } 
    .delete { background-color: #ACF; } 
    .void   { background-color: #FFB; } 
    .cont   { background-color: #EEE; } 
    .linebr { background-color: #AAA; } 
    .lineno { color: red; background-color: #FFF; font-size: 0.7em; text-align: right; padding: 0 2px; } 
    .elipsis{ background-color: #AAA; } 
    .left .cont { background-color: #DDD; } 
    .right .cont { background-color: #EEE; } 
    .lblock .cont { background-color: #9D9; } 
    .rblock .cont { background-color: #DD6; } 
    .insert .cont { background-color: #0DD; } 
    .delete .cont { background-color: #8AD; } 
    .stats, .stats td, .stats th { background-color: #EEE; padding: 2px 0; } 
  </style> 
</head> 
<body > 
  <table border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th></th><th>&nbsp;Landscape.cpp&nbsp;</th><th> </th><th>&nbsp;Landscape.cpp&nbsp;</th><th></th></tr> 
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l1" /><small>skipping to change at</small><em> line 61</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 61</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       &lt;&lt; landscapeId &lt;&lt; ". No landscape in use." &lt;&lt; endl;</td><td> </td><td class="right">                       &lt;&lt; landscapeId &lt;&lt; ". No landscape in use." &lt;&lt; endl;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               validLandscape = 0;</td><td> </td><td class="right">               validLandscape = 0;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return;</td><td> </td><td class="right">               return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       else</td><td> </td><td class="right">       else</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               validLandscape = 1;</td><td> </td><td class="right">               validLandscape = 1;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Optional data</td><td> </td><td class="right">       // Optional data</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">// Patch GZ:</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       if (landscapeIni.contains("landscape/tesselate_rows"))</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               rows = landscapeIni.value("landscape/tesselate_rows").toInt(</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       else rows=20;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       if (landscapeIni.contains("landscape/tesselate_cols"))</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               cols = landscapeIni.value("landscape/tesselate_cols").toInt(</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       else cols=40;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (landscapeIni.contains("location/planet"))</td><td> </td><td class="right">       if (landscapeIni.contains("location/planet"))</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               location.planetName = landscapeIni.value("location/planet").
toString();</td><td> </td><td class="right">               location.planetName = landscapeIni.value("location/planet").
toString();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       else</td><td> </td><td class="right">       else</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               location.planetName = "Earth";</td><td> </td><td class="right">               location.planetName = "Earth";</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (landscapeIni.contains("location/altitude"))</td><td> </td><td class="right">       if (landscapeIni.contains("location/altitude"))</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               location.altitude = landscapeIni.value("location/altitude").
toInt();</td><td> </td><td class="right">               location.altitude = landscapeIni.value("location/altitude").
toInt();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (landscapeIni.contains("location/latitude"))</td><td> </td><td class="right">       if (landscapeIni.contains("location/latitude"))</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               location.latitude = StelUtils::getDecAngle(landscapeIni.valu
e("location/latitude").toString())*180./M_PI;</td><td> </td><td class="right">               location.latitude = StelUtils::getDecAngle(landscapeIni.valu
e("location/latitude").toString())*180./M_PI;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (landscapeIni.contains("location/longitude"))</td><td> </td><td class="right">       if (landscapeIni.contains("location/longitude"))</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               location.longitude = StelUtils::getDecAngle(landscapeIni.val
ue("location/longitude").toString())*180./M_PI;</td><td> </td><td class="right">               location.longitude = StelUtils::getDecAngle(landscapeIni.val
ue("location/longitude").toString())*180./M_PI;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l2" /><small>skipping to change at</small><em> line 98</em></th><th> </th><th><a name="part-r2" /><small>skipping to change at</small><em> line 106</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               path = StelFileMgr::findFile("landscapes/" + landscapeId + "
/" + basename);</td><td> </td><td class="right">               path = StelFileMgr::findFile("landscapes/" + landscapeId + "
/" + basename);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return path;</td><td> </td><td class="right">               return path;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       catch (std::runtime_error&amp; e)</td><td> </td><td class="right">       catch (std::runtime_error&amp; e)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               path = StelFileMgr::findFile("textures/" + basename);</td><td> </td><td class="right">               path = StelFileMgr::findFile("textures/" + basename);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return path;</td><td> </td><td class="right">               return path;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0002" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">LandscapeOldStyle::LandscapeOldStyle(float _radius) : Landscape(_radius), s
ideTexs(NULL), sides(NULL), tanMode(false)</td><td> </td><td class="rblock">LandscapeOldStyle::LandscapeOldStyle(float _radius) : Landscape(_radius), s
ideTexs(NULL), sides(NULL), tanMode(false)<span class="insert">, calibrated(false)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{}</td><td> </td><td class="right">{}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">LandscapeOldStyle::~LandscapeOldStyle()</td><td> </td><td class="right">LandscapeOldStyle::~LandscapeOldStyle()</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (sideTexs)</td><td> </td><td class="right">       if (sideTexs)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               delete [] sideTexs;</td><td> </td><td class="right">               delete [] sideTexs;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               sideTexs = NULL;</td><td> </td><td class="right">               sideTexs = NULL;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (sides) delete [] sides;</td><td> </td><td class="right">       if (sides) delete [] sides;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void LandscapeOldStyle::load(const QSettings&amp; landscapeIni, const QString&amp; 
landscapeId)</td><td> </td><td class="right">void LandscapeOldStyle::load(const QSettings&amp; landscapeIni, const QString&amp; 
landscapeId)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // TODO: put values into hash and call create method to consolidate 
code</td><td> </td><td class="right">       // TODO: put values into hash and call create method to consolidate 
code</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       loadCommon(landscapeIni, landscapeId);</td><td> </td><td class="right">       loadCommon(landscapeIni, landscapeId);</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0003" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">// Patch GZ:</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       if (landscapeIni.contains("landscape/tesselate_rows"))</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               rows = landscapeIni.value("landscape/tesselate_rows").toInt(</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       else rows=8;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       if (landscapeIni.contains("landscape/tesselate_cols"))</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               cols = landscapeIni.value("landscape/tesselate_cols").toInt(</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       else cols=16;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       QString type = landscapeIni.value("landscape/type").toString();</td><td> </td><td class="right">       QString type = landscapeIni.value("landscape/type").toString();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if(type != "old_style")</td><td> </td><td class="right">       if(type != "old_style")</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               qWarning() &lt;&lt; "Landscape type mismatch for landscape " &lt;&lt; la
ndscapeId</td><td> </td><td class="right">               qWarning() &lt;&lt; "Landscape type mismatch for landscape " &lt;&lt; la
ndscapeId</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0004" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                          <span class="delete">&lt;&lt; ", expected old_style, found " &lt;&lt; type &lt;&lt; ".  
</span>No landscape in use.";</td><td> </td><td class="rblock">                          <span class="insert">        &lt;&lt; ", expected old_style, found " &lt;&lt; type
 &lt;&lt; ".  </span>No landscape in use.";</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               validLandscape = 0;</td><td> </td><td class="right">               validLandscape = 0;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return;</td><td> </td><td class="right">               return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Load sides textures</td><td> </td><td class="right">       // Load sides textures</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       nbSideTexs = landscapeIni.value("landscape/nbsidetex", 0).toInt();</td><td> </td><td class="right">       nbSideTexs = landscapeIni.value("landscape/nbsidetex", 0).toInt();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       sideTexs = new StelTextureSP[nbSideTexs];</td><td> </td><td class="right">       sideTexs = new StelTextureSP[nbSideTexs];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       for (int i=0;i&lt;nbSideTexs;++i)</td><td> </td><td class="right">       for (int i=0;i&lt;nbSideTexs;++i)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               QString tmp = QString("tex%1").arg(i);</td><td> </td><td class="right">               QString tmp = QString("tex%1").arg(i);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l3" /><small>skipping to change at</small><em> line 174</em></th><th> </th><th><a name="part-r3" /><small>skipping to change at</small><em> line 189</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       fogTex = StelApp::getInstance().getTextureManager().createTexture(ge
tTexturePath(landscapeIni.value("landscape/fogtex").toString(), landscapeId
), StelTexture::StelTextureParams(true, GL_LINEAR, GL_REPEAT));</td><td> </td><td class="right">       fogTex = StelApp::getInstance().getTextureManager().createTexture(ge
tTexturePath(landscapeIni.value("landscape/fogtex").toString(), landscapeId
), StelTexture::StelTextureParams(true, GL_LINEAR, GL_REPEAT));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       s = landscapeIni.value("landscape/fog").toString();</td><td> </td><td class="right">       s = landscapeIni.value("landscape/fog").toString();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       sscanf(s.toLocal8Bit(),"fogtex:%f:%f:%f:%f",&amp;a,&amp;b,&amp;c,&amp;d);</td><td> </td><td class="right">       sscanf(s.toLocal8Bit(),"fogtex:%f:%f:%f:%f",&amp;a,&amp;b,&amp;c,&amp;d);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       fogTexCoord.tex = fogTex;</td><td> </td><td class="right">       fogTexCoord.tex = fogTex;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       fogTexCoord.texCoords[0] = a;</td><td> </td><td class="right">       fogTexCoord.texCoords[0] = a;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       fogTexCoord.texCoords[1] = b;</td><td> </td><td class="right">       fogTexCoord.texCoords[1] = b;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       fogTexCoord.texCoords[2] = c;</td><td> </td><td class="right">       fogTexCoord.texCoords[2] = c;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       fogTexCoord.texCoords[3] = d;</td><td> </td><td class="right">       fogTexCoord.texCoords[3] = d;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0005" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       fogAltAngle        = landscapeIni.value("landscape/fog_alt_angle", 0</td><td> </td><td class="rblock">       fogAltAngle        = landscapeIni.value("landscape/fog_alt_angle", 0</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">.).toDouble();</span></td><td> </td><td class="rblock"><span class="insert">.).toFloat();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       fogAngleShift      = landscapeIni.value("landscape/fog_angle_shift",</td><td> </td><td class="rblock">       fogAngleShift      = landscapeIni.value("landscape/fog_angle_shift",</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"> <span class="delete">0.).toDouble();</span></td><td> </td><td class="rblock"> <span class="insert">0.).toFloat();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       decorAltAngle      = landscapeIni.value("landscape/decor_alt_angle",</td><td> </td><td class="rblock">       decorAltAngle      = landscapeIni.value("landscape/decor_alt_angle",</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"> <span class="delete">0.).toDouble();</span></td><td> </td><td class="rblock"> <span class="insert">0.).toFloat();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       decorAngleShift    = landscapeIni.value("landscape/decor_angle_shift</td><td> </td><td class="rblock">       decorAngleShift    = landscapeIni.value("landscape/decor_angle_shift</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">", <span class="delete">0.).toDouble();</span></td><td> </td><td class="rblock">", <span class="insert">0.).toFloat();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       angleRotateZ       = landscapeIni.value("landscape/decor_angle_rotat</td><td> </td><td class="rblock">       angleRotateZ       = landscapeIni.value("landscape/decor_angle_rotat</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">ez", <span class="delete">0.).toDouble();</span></td><td> </td><td class="rblock">ez", <span class="insert">0.).toFloat();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       groundAngleShift   = landscapeIni.value("landscape/ground_angle_shif</td><td> </td><td class="rblock">       groundAngleShift   = landscapeIni.value("landscape/ground_angle_shif</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">t", <span class="delete">0.).toDouble();</span></td><td> </td><td class="rblock">t", <span class="insert">0.).toFloat();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       groundAngleRotateZ = landscapeIni.value("landscape/ground_angle_rota</td><td> </td><td class="rblock">       groundAngleRotateZ = landscapeIni.value("landscape/ground_angle_rota</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">tez", <span class="delete">0.).toDouble();</span></td><td> </td><td class="rblock">tez", <span class="insert">0.).toFloat();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       drawGroundFirst    = landscapeIni.value("landscape/draw_ground_first
", 0).toInt();</td><td> </td><td class="right">       drawGroundFirst    = landscapeIni.value("landscape/draw_ground_first
", 0).toInt();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       tanMode            = landscapeIni.value("landscape/tan_mode", false)
.toBool();</td><td> </td><td class="right">       tanMode            = landscapeIni.value("landscape/tan_mode", false)
.toBool();</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0006" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">}</span></td><td> </td><td class="rblock"><span class="insert">       calibrated         = landscapeIni.value("landscape/calibrated", fals
e).toBool();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0007" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">// <span class="delete">create from a hash</span> of <span class="delete">parameters (no ini file needed)</span></td><td> </td><td class="rblock">       // <span class="insert">Precompute the vertex arrays for ground display</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">void LandscapeOldStyle::create(bool _fullpath, QMap&lt;QString, QString&gt; param</span></td><td> </td><td class="rblock"><span class="insert">       // Make slices_per_side=(3&lt;&lt;K) so that the innermost polygon</span> of <span class="insert">the </span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">)</span></td><td> </td><td class="rblock"><span class="insert">fandisk becomes a triangle:</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">{</span></td><td> </td><td class="rblock"><span class="insert">       int slices_per_side</span> = <span class="insert">3*64/(nbDecorRepeat*nbSide);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       name</span> = <span class="delete">param["name"];</span></td><td> </td><td class="rblock"><span class="insert">       if (slices_per_side&lt;=0)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       validLandscape</span> = 1;  // <span class="delete">assume valid if got here</span></td><td> </td><td class="rblock"><span class="insert">               slices_per_side</span> = 1;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                                                           </td><td> </td><td class="rblock">       // <span class="insert">draw a fan disk instead of a ordinary disk to that the inner slic</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       // <span class="delete">Load sides textures</span></td><td> </td><td class="rblock"><span class="insert">es</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       nbSideTexs</span> = <span class="delete">param["nbsidetex"].toInt();</span></td><td> </td><td class="rblock">       // <span class="insert">are not so slender. When they are too slender, culling errors occ</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       sideTexs</span> = <span class="delete">new StelTextureSP[nbSideTexs];</span></td><td> </td><td class="rblock"><span class="insert">ur</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"><span class="insert">       // in cylinder projection mode.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       char tmp[255];</span></td><td> </td><td class="rblock"><span class="insert">       int slices_inside</span> = <span class="insert">nbSide*slices_per_side*nbDecorRepeat;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       //StelApp::getInstance().getTextureManager().setMipmapsMode(true);</span></td><td> </td><td class="rblock"><span class="insert">       int level</span> = <span class="insert">0;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       //StelApp::getInstance().getTextureManager().setMagFilter(GL_NEAREST</span></td><td> </td><td class="rblock"><span class="insert">       while ((slices_inside&amp;1)==0 &amp;&amp; slices_inside &gt; 4)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       for (int i=0;i&lt;nbSideTexs;++i)</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0008" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               <span class="delete">sprintf(tmp,"tex%d",i);</span></td><td> </td><td class="rblock">               <span class="insert">++level;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               sideTexs[i] = StelApp::getInstance().getTextureManager().cre</span></td><td> </td><td class="rblock"><span class="insert">               slices_inside&gt;&gt;=1;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">ateTexture(param["path"] + param[tmp], StelTexture::StelTextureParams(true)</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0009" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       StelPainter::computeFanDisk(radius, slices_inside, level, groundVert
exArr, groundTexCoordArr);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0010" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       // <span class="delete">Init sides parameters</span></td><td> </td><td class="rblock">       // <span class="insert">Precompute the vertex arrays for side display</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       nbSide = param["nbside"].toInt();</span></td><td> </td><td class="rblock"><span class="insert">       static const</span> int <span class="insert">stacks = (calibrated ? 16 : 8); // GZ: 8-&gt;16, I nee</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       sides = new landscapeTexCoord[nbSide];</span></td><td> </td><td class="rblock"><span class="insert">d better precision.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       QString s;</span></td><td> </td><td class="rblock"><span class="insert">       // make slices_per_side=(3&lt;&lt;K) so that the innermost polygon of the</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       int <span class="delete">texnum;</span></td><td> </td><td class="rblock"><span class="insert">       // fandisk becomes a triangle:</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       float <span class="delete">a,b,c,d;</span></td><td> </td><td class="rblock"><span class="insert">       const double z0 = calibrated ?</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       for (int <span class="delete">i=0;i&lt;nbSide;++i)</span></td><td> </td><td class="rblock"><span class="insert">       // GZ: For calibrated, we use z=decorAngleShift...(decorAltAngle-dec</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       {</td><td> </td><td class="rblock"><span class="insert">orAngleShift), but we must compute the tan in the loop.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               <span class="delete">sprintf(tmp,"side%d",i);</span></td><td> </td><td class="rblock"><span class="insert">       decorAngleShift : (tanMode ? radius * std::tan(decorAngleShift*M_PI/</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               s</span> = <span class="delete">param[tmp];</span></td><td> </td><td class="rblock"><span class="insert">180.f) : radius * std::sin(decorAngleShift*M_PI/180.f));</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               sscanf(s.toUtf8().constData(),"tex%d:%f:%f:%f:%f",&amp;texnum,&amp;a</span></td><td> </td><td class="rblock"><span class="insert">       // GZ: The old formula is completely meaningless for photos with ope</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">,&amp;b,&amp;c,&amp;d);</span></td><td> </td><td class="rblock"><span class="insert">ning angle &gt;90,</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               sides[i].tex</span> = <span class="delete">sideTexs[texnum];</span></td><td> </td><td class="rblock"><span class="insert">       // and most likely also not what was intended for other images.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               sides[i].texCoords[0]</span> = <span class="delete">a;</span></td><td> </td><td class="rblock"><span class="insert">       // Note that GZ fills this value with a different meaning!</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               sides[i].texCoords[1]</span> = <span class="delete">b;</span></td><td> </td><td class="rblock"><span class="insert">       const double d_z = calibrated ? decorAltAngle/stacks : (tanMode ? ra</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               sides[i].texCoords[2]</span> = <span class="delete">c;</span></td><td> </td><td class="rblock"><span class="insert">dius*std::tan(decorAltAngle*M_PI/180.f)/stacks : radius*std::sin(decorAltAn</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               sides[i].texCoords[3]</span> = <span class="delete">d;</span></td><td> </td><td class="rblock"><span class="insert">gle*M_PI/180.0)/stacks);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               //qDebug("%f %f %f %f\n",a,b,c,d);</span></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       const float alpha = 2.f*M_PI/(nbDecorRepeat*nbSide*slices_per_side);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       const float ca = std::cos(alpha);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       const float sa = std::sin(alpha);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       float y0 = radius*std::cos((angleRotateZ+angleRotateZOffset)*M_PI/18</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">0.f);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       float x0 = radius*std::sin((angleRotateZ+angleRotateZOffset)*M_PI/18</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">0.f);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       LOSSide precompSide;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       precompSide.arr.primitiveType=StelVertexArray::Triangles;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       for (int n=0;n&lt;nbDecorRepeat;n++)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               for (int i=0;i&lt;nbSide;i++)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       precompSide.arr.vertex.resize(0);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       precompSide.arr.texCoords.resize(0);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       precompSide.arr.indices.resize(0);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       precompSide.tex=sideTexs[i];</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       float tx0 = sides[i].texCoords[0];</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       const float d_tx0 = (sides[i].texCoords[2]-sides[i].</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">texCoords[0]) / slices_per_side;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       const</span> float <span class="insert">d_ty = (sides[i].texCoords[3]-sides[i].t</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">exCoords[1]) / stacks;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                       for (int <span class="insert">j=0;j&lt;slices_per_side;j++)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                               <span class="insert">const float y1 = y0*ca - x0*sa;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               const float x1 = y0*sa + x0*ca;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               const float tx1</span> = <span class="insert">tx0 + d_tx0;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               float z</span> = <span class="insert">z0;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               float ty0</span> = <span class="insert">sides[i].texCoords[1];</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               for (int k=0;k&lt;=stacks*2;k+=2)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                       precompSide.arr.texCoords &lt;&lt; Vec2f(t</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">x0, ty0) &lt;&lt; Vec2f(tx1, ty0);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                       if (calibrated)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                               float tanZ=radius * std::tan</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">(z*M_PI/180.f);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                               precompSide.arr.vertex &lt;&lt; Ve</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">c3d(x0, y0, tanZ) &lt;&lt; Vec3d(x1, y1, tanZ);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                       } else</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                               precompSide.arr.vertex &lt;&lt; Ve</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">c3d(x0, y0, z) &lt;&lt; Vec3d(x1, y1, z);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                       z += d_z;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                       ty0 += d_ty;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               unsigned int offset = j*(stacks+1)*2;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               for (int k = 2;k&lt;stacks*2+2;k+=2)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                       precompSide.arr.indices &lt;&lt; offset+k-</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">2 &lt;&lt; offset+k-1 &lt;&lt; offset+k;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                       precompSide.arr.indices &lt;&lt; offset+k </span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">&lt;&lt; offset+k-1 &lt;&lt; offset+k+1;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               y0</span> = <span class="insert">y1;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               x0</span> = <span class="insert">x1;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               tx0</span> = <span class="insert">tx1;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       precomputedSides.append(precompSide);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0011" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                                                           </td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">bool ok;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       nbDecorRepeat = param["nb_decor_repeat"].toInt(&amp;ok);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       if (!ok)</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               nbDecorRepeat = 1;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       groundTex = StelApp::getInstance().getTextureManager().createTexture</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">(param["path"] + param["groundtex"], StelTexture::StelTextureParams(true));</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       s = param["ground"];</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       sscanf(s.toUtf8().constData(),"groundtex:%f:%f:%f:%f",&amp;a,&amp;b,&amp;c,&amp;d);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       groundTexCoord.tex = groundTex;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       groundTexCoord.texCoords[0] = a;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       groundTexCoord.texCoords[1] = b;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       groundTexCoord.texCoords[2] = c;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       groundTexCoord.texCoords[3] = d;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       fogTex = StelApp::getInstance().getTextureManager().createTexture(pa</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">ram["path"] + param["fogtex"], StelTexture::StelTextureParams(true, GL_LINE</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">AR, GL_REPEAT));</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       s = param["fog"];</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       sscanf(s.toUtf8().constData(),"fogtex:%f:%f:%f:%f",&amp;a,&amp;b,&amp;c,&amp;d);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       fogTexCoord.tex = fogTex;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       fogTexCoord.texCoords[0] = a;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       fogTexCoord.texCoords[1] = b;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       fogTexCoord.texCoords[2] = c;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       fogTexCoord.texCoords[3] = d;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       fogAltAngle        = param["fog_alt_angle"].toDouble();</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       fogAngleShift      = param["fog_angle_shift"].toDouble();</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       decorAltAngle      = param["decor_alt_angle"].toDouble();</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       decorAngleShift    = param["decor_angle_shift"].toDouble();</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       angleRotateZ       = param["decor_angle_rotatez"].toDouble();</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       groundAngleShift   = param["ground_angle_shift"].toDouble();</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       groundAngleRotateZ = param["ground_angle_rotatez"].toDouble();</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       drawGroundFirst    = param["draw_ground_first"].toInt();</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void LandscapeOldStyle::draw(StelCore* core)</td><td> </td><td class="right">void LandscapeOldStyle::draw(StelCore* core)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       StelPainter painter(core-&gt;getProjection(StelCore::FrameAltAz));</td><td> </td><td class="right">       StelPainter painter(core-&gt;getProjection(StelCore::FrameAltAz));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</td><td> </td><td class="right">       glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       glEnable(GL_BLEND);</td><td> </td><td class="right">       glEnable(GL_BLEND);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       painter.enableTexture2d(true);</td><td> </td><td class="right">       painter.enableTexture2d(true);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       glEnable(GL_CULL_FACE);</td><td> </td><td class="right">       glEnable(GL_CULL_FACE);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l4" /><small>skipping to change at</small><em> line 281</em></th><th> </th><th><a name="part-r4" /><small>skipping to change at</small><em> line 309</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               drawGround(core, painter);</td><td> </td><td class="right">               drawGround(core, painter);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       drawFog(core, painter);</td><td> </td><td class="right">       drawFog(core, painter);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// Draw the horizon fog</td><td> </td><td class="right">// Draw the horizon fog</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void LandscapeOldStyle::drawFog(StelCore* core, StelPainter&amp; sPainter) cons
t</td><td> </td><td class="right">void LandscapeOldStyle::drawFog(StelCore* core, StelPainter&amp; sPainter) cons
t</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (!fogFader.getInterstate())</td><td> </td><td class="right">       if (!fogFader.getInterstate())</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return;</td><td> </td><td class="right">               return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0012" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       const <span class="delete">double vpos = tanMode ? radius*std::tan(fogAngleShift*M_PI/180
</span>.) : radius*std::sin(fogAngleShift*M_PI/180.);</td><td> </td><td class="rblock">       const <span class="insert">float vpos = (tanMode||calibrated) ? radius*std::tan(fogAngleS
hift*M_PI/180</span>.) : radius*std::sin(fogAngleShift*M_PI/180.);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       sPainter.setProjector(core-&gt;getProjection(core-&gt;getNavigator()-&gt;getA
ltAzModelViewMat() * Mat4d::translation(Vec3d(0.,0.,vpos))));</td><td> </td><td class="right">       sPainter.setProjector(core-&gt;getProjection(core-&gt;getNavigator()-&gt;getA
ltAzModelViewMat() * Mat4d::translation(Vec3d(0.,0.,vpos))));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       glBlendFunc(GL_ONE, GL_ONE);</td><td> </td><td class="right">       glBlendFunc(GL_ONE, GL_ONE);</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0013" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       const float nightModeFilter = StelApp::getInstance().getVisionModeNi
ght() ? 0.<span class="delete"> : 1.</span>;</td><td> </td><td class="rblock">       const float nightModeFilter = StelApp::getInstance().getVisionModeNi
ght() ? 0.<span class="insert">f : 1.f</span>;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       sPainter.setColor(fogFader.getInterstate()*(0.1f+0.1f*skyBrightness)
,</td><td> </td><td class="right">       sPainter.setColor(fogFader.getInterstate()*(0.1f+0.1f*skyBrightness)
,</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0014" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                 <span class="delete">fogFader.getInterstate()*(0.1f+0.1f*skyBrightness)*nightMo
</span>deFilter,</td><td> </td><td class="rblock">                 <span class="insert">        fogFader.getInterstate()*(0.1f+0.1f*skyBrightness)
*nightMo</span>deFilter,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                         fogFader.getInterstate()*(0.1f+0.1f*skyBrightness)
*nightModeFilter);</td><td> </td><td class="right">                         fogFader.getInterstate()*(0.1f+0.1f*skyBrightness)
*nightModeFilter);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       fogTex-&gt;bind();</td><td> </td><td class="right">       fogTex-&gt;bind();</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0015" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       const <span class="delete">double</span> height = <span class="delete">tanMode</span> ? <span class="delete">radius*std::tan(fogAltAngle*M_PI/180</span></td><td> </td><td class="rblock">       const <span class="insert">float</span> height = <span class="insert">(tanMode||calibrated)</span> ? <span class="insert">radius*std::tan(fogAltA</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">.)</span> : radius*std::sin(fogAltAngle*M_PI/180.);</td><td> </td><td class="rblock"><span class="insert">ngle*M_PI/180.)</span> : radius*std::sin(fogAltAngle*M_PI/180.);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       sPainter.sCylinder(radius, height, <span class="delete">128,</span> 1);</td><td> </td><td class="rblock">       sPainter.sCylinder(radius, height, <span class="insert">64,</span> 1);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</td><td> </td><td class="right">       glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// Draw the mountains with a few pieces of texture</td><td> </td><td class="right">// Draw the mountains with a few pieces of texture</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void LandscapeOldStyle::drawDecor(StelCore* core, StelPainter&amp; sPainter) co
nst</td><td> </td><td class="right">void LandscapeOldStyle::drawDecor(StelCore* core, StelPainter&amp; sPainter) co
nst</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0016" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">// Patched by Georg Zotti: I located an undocumented switch tan_mode</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">, maybe tan_mode=true means cylindrical panorama projection.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       // anyway, the old code makes unfortunately no sense.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       // I added a switch "calibrated" for the ini file. If true, it works</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> as this landscape apparently was originally intended.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       // So I corrected the texture coordinates so that decorAltAngle is t</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">he total angle, decorAngleShift the lower angle,</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       // and the texture in between is correctly stretched.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       // TODO: (1) Replace fog cylinder by similar texture, which could be</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> painted as image layer in Photoshop/Gimp.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //       (2) Implement calibrated &amp;&amp; tan_mode</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       sPainter.setProjector(core-&gt;getProjection(StelCore::FrameAltAz));</td><td> </td><td class="right">       sPainter.setProjector(core-&gt;getProjection(StelCore::FrameAltAz));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (!landFader.getInterstate())</td><td> </td><td class="right">       if (!landFader.getInterstate())</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return;</td><td> </td><td class="right">               return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0017" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       const float nightModeFilter = StelApp::getInstance().getVisionModeNi
ght() ? 0.<span class="delete"> : 1.</span>;</td><td> </td><td class="rblock">       const float nightModeFilter = StelApp::getInstance().getVisionModeNi
ght() ? 0.<span class="insert">f : 1.f</span>;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       sPainter.setColor(skyBrightness, skyBrightness*nightModeFilter, skyB
rightness*nightModeFilter, landFader.getInterstate());</td><td> </td><td class="right">       sPainter.setColor(skyBrightness, skyBrightness*nightModeFilter, skyB
rightness*nightModeFilter, landFader.getInterstate());</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0018" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">static const int stacks = 8;</span></td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">         // make slices_per_side=(3&lt;&lt;K) so that the innermost polygon of th</span></td><td> </td><td class="rblock">       <span class="insert">foreach (const LOSSide&amp; side, precomputedSides)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">e</span></td><td> </td><td class="rblock">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">         // fandisk becomes a triangle:</span></td><td> </td><td class="rblock">               <span class="insert">side.tex-&gt;bind();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       int slices_per_side = 3*64/(nbDecorRepeat*nbSide);</span></td><td> </td><td class="rblock"><span class="insert">               sPainter.drawSphericalTriangles(side.arr,</span> true, NULL, <span class="insert">false)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       if (slices_per_side&lt;=0) slices_per_side = 1;</span></td><td> </td><td class="rblock"><span class="insert">;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       const double z0 = tanMode ? radius * std::tan(decorAngleShift*M_PI/1</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">80.0) :</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               radius * std::sin(decorAngleShift*M_PI/180.0);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       const double d_z = tanMode ? radius * std::tan(decorAltAngle*M_PI/18</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">0.0) / stacks :</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               radius * std::sin(decorAltAngle*M_PI/180.0) / stacks;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       const double alpha = 2.0*M_PI/(nbDecorRepeat*nbSide*slices_per_side)</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       const double ca = cos(alpha);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       const double sa = sin(alpha);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       double y0 = radius*cos((angleRotateZ+angleRotateZOffset)*M_PI/180.0)</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       double x0 = radius*sin((angleRotateZ+angleRotateZOffset)*M_PI/180.0)</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       QVector&lt;Vec2f&gt; texCoordsArray(stacks*2+2);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       QVector&lt;Vec3d&gt; vertexArray(stacks*2+2);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       for (int n=0;n&lt;nbDecorRepeat;n++) for (int i=0;i&lt;nbSide;i++)</span> {</td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               <span class="delete">sides[i].tex-&gt;bind();</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               double tx0 = sides[i].texCoords[0];</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               const float d_tx0 = (sides[i].texCoords[2]-sides[i].texCoord</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">s[0]) / slices_per_side;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               const float d_ty = (sides[i].texCoords[3]-sides[i].texCoords</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">[1]) / stacks;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               for (int j=0;j&lt;slices_per_side;j++) {</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       const double y1 = y0*ca - x0*sa;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       const double x1 = y0*sa + x0*ca;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       const float tx1 = tx0 + d_tx0;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       double z = z0;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       float ty0 = sides[i].texCoords[1];</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       for (int k=0;k&lt;=stacks*2;k+=2) {</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                               texCoordsArray[k].set(tx0, ty0);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                               texCoordsArray[k+1].set(tx1, ty0);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                               vertexArray[k].set(x0, y0, z);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                               vertexArray[k+1].set(x1, y1, z);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                               z += d_z;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                               ty0 += d_ty;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       }</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       StelVertexArray array(vertexArray, StelVertexArray::</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">TriangleStrip, texCoordsArray);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       sPainter.drawSphericalTriangles(array,</span> true, NULL, <span class="delete">f</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">alse);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       y0 = y1;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       x0 = x1;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       tx0 = tx1;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               }</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// Draw the ground</td><td> </td><td class="right">// Draw the ground</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void LandscapeOldStyle::drawGround(StelCore* core, StelPainter&amp; sPainter) c
onst</td><td> </td><td class="right">void LandscapeOldStyle::drawGround(StelCore* core, StelPainter&amp; sPainter) c
onst</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (!landFader.getInterstate())</td><td> </td><td class="right">       if (!landFader.getInterstate())</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return;</td><td> </td><td class="right">               return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const StelNavigator* nav = core-&gt;getNavigator();</td><td> </td><td class="right">       const StelNavigator* nav = core-&gt;getNavigator();</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0019" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       const <span class="delete">double</span> vshift = <span class="delete">tanMode</span> ? <span class="delete">radius*std::tan(groundAngleShift*M_P</span></td><td> </td><td class="rblock">       const <span class="insert">float</span> vshift = <span class="insert">(tanMode || calibrated)</span> ?</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">I/180.)</span> : radius*std::sin(groundAngleShift*M_PI/180.);</td><td> </td><td class="rblock">         <span class="insert">radius*std::tan(groundAngleShift*M_PI/180.)</span> :</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">         radius*std::sin(groundAngleShift*M_PI/180.);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Mat4d mat = nav-&gt;getAltAzModelViewMat() * Mat4d::zrotation((groundAn
gleRotateZ-angleRotateZOffset)*M_PI/180.f) * Mat4d::translation(Vec3d(0,0,v
shift));</td><td> </td><td class="right">       Mat4d mat = nav-&gt;getAltAzModelViewMat() * Mat4d::zrotation((groundAn
gleRotateZ-angleRotateZOffset)*M_PI/180.f) * Mat4d::translation(Vec3d(0,0,v
shift));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       sPainter.setProjector(core-&gt;getProjection(mat));</td><td> </td><td class="right">       sPainter.setProjector(core-&gt;getProjection(mat));</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0020" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       float nightModeFilter = StelApp::getInstance().getVisionModeNight() 
? 0.<span class="delete"> : 1.</span>;</td><td> </td><td class="rblock">       float nightModeFilter = StelApp::getInstance().getVisionModeNight() 
? 0.<span class="insert">f : 1.f</span>;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       sPainter.setColor(skyBrightness, skyBrightness*nightModeFilter, skyB
rightness*nightModeFilter, landFader.getInterstate());</td><td> </td><td class="right">       sPainter.setColor(skyBrightness, skyBrightness*nightModeFilter, skyB
rightness*nightModeFilter, landFader.getInterstate());</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       groundTex-&gt;bind();</td><td> </td><td class="right">       groundTex-&gt;bind();</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0021" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">         <span class="delete">// make slices_per_side=(3&lt;&lt;K) so that the innermost polygon of th</span></td><td> </td><td class="rblock">       <span class="insert">sPainter.setArrays((Vec3d*)groundVertexArr.constData(), (Vec2f*)grou</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">e</span></td><td> </td><td class="rblock"><span class="insert">ndTexCoordArr.constData());</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">         // fandisk becomes a triangle:</span></td><td> </td><td class="rblock"><span class="insert">       sPainter.drawFromArray(StelPainter::Triangles, groundVertexArr.size(</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       int slices_per_side = 3*64/(nbDecorRepeat*nbSide);</span></td><td> </td><td class="rblock"><span class="insert">)/3);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       if (slices_per_side&lt;=0) slices_per_side = 1;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       // draw a fan disk instead of a ordinary disk to that the inner slic</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">es</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       // are not so slender. When they are too slender, culling errors occ</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">ur</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       // in cylinder projection mode.</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       int slices_inside = nbSide*slices_per_side*nbDecorRepeat;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       int level = 0;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       while ((slices_inside&amp;1)==0 &amp;&amp; slices_inside &gt; 4)</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       {</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               ++level;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               slices_inside&gt;&gt;=1;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       }</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       sPainter.sFanDisk(radius,slices_inside,level);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">LandscapeFisheye::LandscapeFisheye(float _radius) : Landscape(_radius)</td><td> </td><td class="right">LandscapeFisheye::LandscapeFisheye(float _radius) : Landscape(_radius)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{}</td><td> </td><td class="right">{}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">LandscapeFisheye::~LandscapeFisheye()</td><td> </td><td class="right">LandscapeFisheye::~LandscapeFisheye()</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void LandscapeFisheye::load(const QSettings&amp; landscapeIni, const QString&amp; l
andscapeId)</td><td> </td><td class="right">void LandscapeFisheye::load(const QSettings&amp; landscapeIni, const QString&amp; l
andscapeId)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       loadCommon(landscapeIni, landscapeId);</td><td> </td><td class="right">       loadCommon(landscapeIni, landscapeId);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       QString type = landscapeIni.value("landscape/type").toString();</td><td> </td><td class="right">       QString type = landscapeIni.value("landscape/type").toString();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if(type != "fisheye")</td><td> </td><td class="right">       if(type != "fisheye")</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               qWarning() &lt;&lt; "Landscape type mismatch for landscape "&lt;&lt; lan
dscapeId &lt;&lt; ", expected fisheye, found " &lt;&lt; type &lt;&lt; ".  No landscape in use
.\n";</td><td> </td><td class="right">               qWarning() &lt;&lt; "Landscape type mismatch for landscape "&lt;&lt; lan
dscapeId &lt;&lt; ", expected fisheye, found " &lt;&lt; type &lt;&lt; ".  No landscape in use
.\n";</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               validLandscape = 0;</td><td> </td><td class="right">               validLandscape = 0;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return;</td><td> </td><td class="right">               return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0022" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       create(name, <span class="delete">0, getTexturePath(landscapeIni.value("landscape/maptex"</span></td><td> </td><td class="rblock">       create(name, <span class="insert">getTexturePath(landscapeIni.value("landscape/maptex").t</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">).toString(),</span> landscapeId),</td><td> </td><td class="rblock"><span class="insert">oString(),</span> landscapeId),</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               landscapeIni.value("landscape/texturefov", <span class="delete">360).toDouble(),</span></td><td> </td><td class="rblock">               landscapeIni.value("landscape/texturefov", <span class="insert">360).toFloat(),</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               landscapeIni.value("landscape/angle_rotatez", <span class="delete">0.).toDouble()</span></td><td> </td><td class="rblock">               landscapeIni.value("landscape/angle_rotatez", <span class="insert">0.).toFloat())</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">);</span></td><td> </td><td class="rblock"><span class="insert">;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// create a fisheye landscape from basic parameters (no ini file needed)</td><td> </td><td class="right">// create a fisheye landscape from basic parameters (no ini file needed)</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0023" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">void LandscapeFisheye::create(const QString _name, <span class="delete">bool _fullpath,</span> const <span class="delete">QS</span></td><td> </td><td class="rblock">void LandscapeFisheye::create(const QString _name, const <span class="insert">QString&amp;</span> _maptex, </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">tring&amp;</span> _maptex,</td><td> </td><td class="rblock"><span class="insert">float atexturefov, float aangleRotateZ)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                 <span class="delete">double _texturefov, double _angleRotateZ)</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // qDebug() &lt;&lt; _name &lt;&lt; " " &lt;&lt; _fullpath &lt;&lt; " " &lt;&lt; _maptex &lt;&lt; " " &lt;&lt;
 _texturefov;</td><td> </td><td class="right">       // qDebug() &lt;&lt; _name &lt;&lt; " " &lt;&lt; _fullpath &lt;&lt; " " &lt;&lt; _maptex &lt;&lt; " " &lt;&lt;
 _texturefov;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       validLandscape = 1;  // assume ok...</td><td> </td><td class="right">       validLandscape = 1;  // assume ok...</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       name = _name;</td><td> </td><td class="right">       name = _name;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       mapTex = StelApp::getInstance().getTextureManager().createTexture(_m
aptex, StelTexture::StelTextureParams(true));</td><td> </td><td class="right">       mapTex = StelApp::getInstance().getTextureManager().createTexture(_m
aptex, StelTexture::StelTextureParams(true));</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0024" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       texFov = <span class="delete">_texturefov*M_PI/180.;</span></td><td> </td><td class="rblock">       texFov = <span class="insert">atexturefov*M_PI/180.f;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       angleRotateZ = <span class="delete">_angleRotateZ*M_PI/180.;</span></td><td> </td><td class="rblock">       angleRotateZ = <span class="insert">aangleRotateZ*M_PI/180.f;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void LandscapeFisheye::draw(StelCore* core)</td><td> </td><td class="right">void LandscapeFisheye::draw(StelCore* core)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if(!validLandscape) return;</td><td> </td><td class="right">       if(!validLandscape) return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if(!landFader.getInterstate()) return;</td><td> </td><td class="right">       if(!landFader.getInterstate()) return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       StelNavigator* nav = core-&gt;getNavigator();</td><td> </td><td class="right">       StelNavigator* nav = core-&gt;getNavigator();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const StelProjectorP prj = core-&gt;getProjection(nav-&gt;getAltAzModelVie
wMat() * Mat4d::zrotation(-(angleRotateZ+(angleRotateZOffset*2*M_PI/360.)))
);</td><td> </td><td class="right">       const StelProjectorP prj = core-&gt;getProjection(nav-&gt;getAltAzModelVie
wMat() * Mat4d::zrotation(-(angleRotateZ+(angleRotateZOffset*2*M_PI/360.)))
);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       StelPainter sPainter(prj);</td><td> </td><td class="right">       StelPainter sPainter(prj);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Normal transparency mode</td><td> </td><td class="right">       // Normal transparency mode</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</td><td> </td><td class="right">       glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0025" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       float nightModeFilter = StelApp::getInstance().getVisionModeNight() 
? 0.<span class="delete"> : 1.</span>;</td><td> </td><td class="rblock">       float nightModeFilter = StelApp::getInstance().getVisionModeNight() 
? 0.<span class="insert">f : 1.f</span>;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       sPainter.setColor(skyBrightness, skyBrightness*nightModeFilter, skyB
rightness*nightModeFilter, landFader.getInterstate());</td><td> </td><td class="right">       sPainter.setColor(skyBrightness, skyBrightness*nightModeFilter, skyB
rightness*nightModeFilter, landFader.getInterstate());</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       glEnable(GL_CULL_FACE);</td><td> </td><td class="right">       glEnable(GL_CULL_FACE);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       sPainter.enableTexture2d(true);</td><td> </td><td class="right">       sPainter.enableTexture2d(true);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       glEnable(GL_BLEND);</td><td> </td><td class="right">       glEnable(GL_BLEND);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       mapTex-&gt;bind();</td><td> </td><td class="right">       mapTex-&gt;bind();</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0026" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">sPainter.sSphereMap(radius,40,20,texFov,1);</span></td><td> </td><td class="rblock">       <span class="insert">// Patch GZ: (40,20)-&gt;(cols,rows)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       sPainter.sSphereMap(radius,cols,rows,texFov,1);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       glDisable(GL_CULL_FACE);</td><td> </td><td class="right">       glDisable(GL_CULL_FACE);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// spherical panoramas</td><td> </td><td class="right">// spherical panoramas</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">LandscapeSpherical::LandscapeSpherical(float _radius) : Landscape(_radius)</td><td> </td><td class="right">LandscapeSpherical::LandscapeSpherical(float _radius) : Landscape(_radius)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{}</td><td> </td><td class="right">{}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">LandscapeSpherical::~LandscapeSpherical()</td><td> </td><td class="right">LandscapeSpherical::~LandscapeSpherical()</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l5" /><small>skipping to change at</small><em> line 459</em></th><th> </th><th><a name="part-r5" /><small>skipping to change at</small><em> line 446</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       QString type = landscapeIni.value("landscape/type").toString();</td><td> </td><td class="right">       QString type = landscapeIni.value("landscape/type").toString();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (type != "spherical")</td><td> </td><td class="right">       if (type != "spherical")</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               qWarning() &lt;&lt; "Landscape type mismatch for landscape "&lt;&lt; lan
dscapeId</td><td> </td><td class="right">               qWarning() &lt;&lt; "Landscape type mismatch for landscape "&lt;&lt; lan
dscapeId</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       &lt;&lt; ", expected spherical, found " &lt;&lt; type</td><td> </td><td class="right">                       &lt;&lt; ", expected spherical, found " &lt;&lt; type</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       &lt;&lt; ".  No landscape in use.\n";</td><td> </td><td class="right">                       &lt;&lt; ".  No landscape in use.\n";</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               validLandscape = 0;</td><td> </td><td class="right">               validLandscape = 0;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return;</td><td> </td><td class="right">               return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0027" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       create(name, <span class="delete">0, getTexturePath(landscapeIni.value("landscape/maptex"</span></td><td> </td><td class="rblock">       create(name, <span class="insert">getTexturePath(landscapeIni.value("landscape/maptex").t</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">).toString(),</span> landscapeId),</td><td> </td><td class="rblock"><span class="insert">oString(),</span> landscapeId),</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               landscapeIni.value("landscape/angle_rotatez", <span class="delete">0.).toDouble()</span></td><td> </td><td class="rblock">               landscapeIni.value("landscape/angle_rotatez", <span class="insert">0.f).toFloat()</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">);</td><td> </td><td class="rblock">);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// create a spherical landscape from basic parameters (no ini file needed)</td><td> </td><td class="right">// create a spherical landscape from basic parameters (no ini file needed)</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0028" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">void LandscapeSpherical::create(const QString _name, <span class="delete">bool _fullpath,</span> const </td><td> </td><td class="rblock">void LandscapeSpherical::create(const QString _name, const QString&amp; <span class="insert">_maptex</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">QString&amp; <span class="delete">_maptex,</span></td><td> </td><td class="rblock"><span class="insert">, float</span> _angleRotateZ)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                                   double</span> _angleRotateZ)</td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // qDebug() &lt;&lt; _name &lt;&lt; " " &lt;&lt; _fullpath &lt;&lt; " " &lt;&lt; _maptex &lt;&lt; " " &lt;&lt;
 _texturefov;</td><td> </td><td class="right">       // qDebug() &lt;&lt; _name &lt;&lt; " " &lt;&lt; _fullpath &lt;&lt; " " &lt;&lt; _maptex &lt;&lt; " " &lt;&lt;
 _texturefov;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       validLandscape = 1;  // assume ok...</td><td> </td><td class="right">       validLandscape = 1;  // assume ok...</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       name = _name;</td><td> </td><td class="right">       name = _name;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       mapTex = StelApp::getInstance().getTextureManager().createTexture(_m
aptex, StelTexture::StelTextureParams(true));</td><td> </td><td class="right">       mapTex = StelApp::getInstance().getTextureManager().createTexture(_m
aptex, StelTexture::StelTextureParams(true));</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0029" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       angleRotateZ = _angleRotateZ*M_PI/180.;</td><td> </td><td class="rblock">       angleRotateZ = _angleRotateZ*M_PI/180.<span class="insert">f</span>;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void LandscapeSpherical::draw(StelCore* core)</td><td> </td><td class="right">void LandscapeSpherical::draw(StelCore* core)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if(!validLandscape) return;</td><td> </td><td class="right">       if(!validLandscape) return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if(!landFader.getInterstate()) return;</td><td> </td><td class="right">       if(!landFader.getInterstate()) return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       StelNavigator* nav = core-&gt;getNavigator();</td><td> </td><td class="right">       StelNavigator* nav = core-&gt;getNavigator();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const StelProjectorP prj = core-&gt;getProjection(nav-&gt;getAltAzModelVie
wMat() * Mat4d::zrotation(-(angleRotateZ+(angleRotateZOffset*2*M_PI/360.)))
);</td><td> </td><td class="right">       const StelProjectorP prj = core-&gt;getProjection(nav-&gt;getAltAzModelVie
wMat() * Mat4d::zrotation(-(angleRotateZ+(angleRotateZOffset*2*M_PI/360.)))
);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       StelPainter sPainter(prj);</td><td> </td><td class="right">       StelPainter sPainter(prj);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l6" /><small>skipping to change at</small><em> line 495</em></th><th> </th><th><a name="part-r6" /><small>skipping to change at</small><em> line 481</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       float nightModeFilter = StelApp::getInstance().getVisionModeNight() 
? 0. : 1.;</td><td> </td><td class="right">       float nightModeFilter = StelApp::getInstance().getVisionModeNight() 
? 0. : 1.;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       sPainter.setColor(skyBrightness, skyBrightness*nightModeFilter, skyB
rightness*nightModeFilter, landFader.getInterstate());</td><td> </td><td class="right">       sPainter.setColor(skyBrightness, skyBrightness*nightModeFilter, skyB
rightness*nightModeFilter, landFader.getInterstate());</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       glEnable(GL_CULL_FACE);</td><td> </td><td class="right">       glEnable(GL_CULL_FACE);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       sPainter.enableTexture2d(true);</td><td> </td><td class="right">       sPainter.enableTexture2d(true);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       glEnable(GL_BLEND);</td><td> </td><td class="right">       glEnable(GL_BLEND);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       mapTex-&gt;bind();</td><td> </td><td class="right">       mapTex-&gt;bind();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // TODO: verify that this works correctly for custom projections</td><td> </td><td class="right">       // TODO: verify that this works correctly for custom projections</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // seam is at East</td><td> </td><td class="right">       // seam is at East</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0030" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">sPainter.sSphere(radius,</span> 1.0, 40, 20, 1, true);</td><td> </td><td class="rblock">       <span class="insert">//sPainter.sSphere(radius,</span> 1.0, 40, 20, <span class="insert">1, true);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       // GZ: Want better angle resolution, optional!</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       sPainter.sSphere(radius, 1.0, cols, rows,</span> 1, true);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       glDisable(GL_CULL_FACE);</td><td> </td><td class="right">       glDisable(GL_CULL_FACE);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>

     <tr><td></td><td class="left"></td><td> </td><td class="right"></td><td></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 30 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><td></td><th><i>193 lines changed or deleted</i></th><th><i> </i></th><th><i>189 lines changed or added</i></th><td></td></tr>
     <tr><td colspan="5" align="center" class="small"><br/>This html diff was produced by rfcdiff 1.41. The latest version is available from <a href="http://www.tools.ietf.org/tools/rfcdiff/" >http://tools.ietf.org/tools/rfcdiff/</a> </td></tr>
   </table>
   </body>
   </html>
