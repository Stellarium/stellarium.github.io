<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"> 
<!-- Generated by rfcdiff 1.41: rfcdiff  --> 
<!-- <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional" > -->
<!-- System: Linux fomalhaut.local 3.13.0-38-generic #65-Ubuntu SMP Thu Oct 9 11:36:50 UTC 2014 x86_64 x86_64 x86_64 GNU/Linux --> 
<!-- Using awk: /usr/bin/gawk: GNU Awk 4.0.1 --> 
<!-- Using diff: /usr/bin/diff: diff (GNU diffutils) 3.3 --> 
<!-- Using wdiff: /usr/bin/wdiff: wdiff (GNU wdiff) 1.2.1 --> 
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"> 
<head> 
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /> 
  <meta http-equiv="Content-Style-Type" content="text/css" /> 
  <title>Diff: StelPainter.cpp - StelPainter.cpp</title> 
  <style type="text/css"> 
    body    { font-size:16px; margin: 0.4ex; margin-right: auto; } 
    tr      { } 
    td      { white-space: pre; font-family: Consolas, "DejaVu Sans Mono", "Droid Sans Mono", Monaco, Monospace; vertical-align: top; font-size: 0.86em;} 
    th      { font-size: 0.86em; } 
    .small  { font-size: 0.6em; font-style: italic; font-family: Verdana, Helvetica, sans-serif; } 
    .left   { background-color: #EEE; } 
    .right  { background-color: #FFF; } 
    .diff   { background-color: #CCF; } 
    .lblock { background-color: #BFB; } 
    .rblock { background-color: #FF8; } 
    .insert { background-color: #8FF; } 
    .delete { background-color: #ACF; } 
    .void   { background-color: #FFB; } 
    .cont   { background-color: #EEE; } 
    .linebr { background-color: #AAA; } 
    .lineno { color: red; background-color: #FFF; font-size: 0.7em; text-align: right; padding: 0 2px; } 
    .elipsis{ background-color: #AAA; } 
    .left .cont { background-color: #DDD; } 
    .right .cont { background-color: #EEE; } 
    .lblock .cont { background-color: #9D9; } 
    .rblock .cont { background-color: #DD6; } 
    .insert .cont { background-color: #0DD; } 
    .delete .cont { background-color: #8AD; } 
    .stats, .stats td, .stats th { background-color: #EEE; padding: 2px 0; } 
  </style> 
</head> 
<body > 
  <table border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th></th><th>&nbsp;StelPainter.cpp&nbsp;</th><th> </th><th>&nbsp;StelPainter.cpp&nbsp;</th><th></th></tr> 
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l1" /><small>skipping to change at</small><em> line 46</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 46</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#ifndef GL_MULTISAMPLE</td><td> </td><td class="right">#ifndef GL_MULTISAMPLE</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#define GL_MULTISAMPLE  0x809D</td><td> </td><td class="right">#define GL_MULTISAMPLE  0x809D</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#endif</td><td> </td><td class="right">#endif</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#ifndef NDEBUG</td><td> </td><td class="right">#ifndef NDEBUG</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">QMutex* StelPainter::globalMutex = new QMutex();</td><td> </td><td class="right">QMutex* StelPainter::globalMutex = new QMutex();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#endif</td><td> </td><td class="right">#endif</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">QPainter* StelPainter::qPainter = NULL;</td><td> </td><td class="right">QPainter* StelPainter::qPainter = NULL;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">QGLContext* StelPainter::glContext = NULL;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#ifdef STELPAINTER_GL2</td><td> </td><td class="right">#ifdef STELPAINTER_GL2</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"> QGLShaderProgram* StelPainter::colorShaderProgram=NULL;</td><td> </td><td class="right"> QGLShaderProgram* StelPainter::colorShaderProgram=NULL;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"> QGLShaderProgram* StelPainter::texturesShaderProgram=NULL;</td><td> </td><td class="right"> QGLShaderProgram* StelPainter::texturesShaderProgram=NULL;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"> QGLShaderProgram* StelPainter::basicShaderProgram=NULL;</td><td> </td><td class="right"> QGLShaderProgram* StelPainter::basicShaderProgram=NULL;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"> QGLShaderProgram* StelPainter::texturesColorShaderProgram=NULL;</td><td> </td><td class="right"> QGLShaderProgram* StelPainter::texturesColorShaderProgram=NULL;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"> StelPainter::BasicShaderVars StelPainter::basicShaderVars;</td><td> </td><td class="right"> StelPainter::BasicShaderVars StelPainter::basicShaderVars;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"> StelPainter::TexturesShaderVars StelPainter::texturesShaderVars;</td><td> </td><td class="right"> StelPainter::TexturesShaderVars StelPainter::texturesShaderVars;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"> StelPainter::TexturesColorShaderVars StelPainter::texturesColorShaderVars;</td><td> </td><td class="right"> StelPainter::TexturesColorShaderVars StelPainter::texturesColorShaderVars;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#endif</td><td> </td><td class="right">#endif</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void StelPainter::setQPainter(QPainter* p)</td><td> </td><td class="right">void StelPainter::setQPainter(QPainter* p)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       qPainter=p;</td><td> </td><td class="right">       qPainter=p;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0002" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">if (p==NULL)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               return;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       if (p-&gt;paintEngine()-&gt;type() != QPaintEngine::OpenGL &amp;&amp; p-&gt;paintEngi</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ne()-&gt;type() != QPaintEngine::OpenGL2)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               qCritical("StelPainter::setQPainter(): StelPainter needs a Q</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">GLWidget to be set as viewport on the graphics view");</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               return;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       QGLWidget* glwidget = dynamic_cast&lt;QGLWidget*&gt;(p-&gt;device());</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       if (glwidget &amp;&amp; glwidget-&gt;context()!=glContext)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               qCritical("StelPainter::setQPainter(): StelPainter needs to </span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">paint on a GLWidget with the same GL context as the one used for initializa</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">tion.");</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               return;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">}</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">void StelPainter::makeMainGLContextCurrent()</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">{</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       Q_ASSERT(glContext!=NULL);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       Q_ASSERT(glContext-&gt;isValid());</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       glContext-&gt;makeCurrent();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">}</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">void StelPainter::swapBuffer()</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">{</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       Q_ASSERT(glContext!=NULL);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       Q_ASSERT(glContext-&gt;isValid());</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       glContext-&gt;swapBuffers();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">StelPainter::StelPainter(const StelProjectorP&amp; proj) : prj(proj)</td><td> </td><td class="right">StelPainter::StelPainter(const StelProjectorP&amp; proj) : prj(proj)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Q_ASSERT(proj);</td><td> </td><td class="right">       Q_ASSERT(proj);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#ifndef NDEBUG</td><td> </td><td class="right">#ifndef NDEBUG</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Q_ASSERT(globalMutex);</td><td> </td><td class="right">       Q_ASSERT(globalMutex);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       GLenum er = glGetError();</td><td> </td><td class="right">       GLenum er = glGetError();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (er!=GL_NO_ERROR)</td><td> </td><td class="right">       if (er!=GL_NO_ERROR)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l2" /><small>skipping to change at</small><em> line 256</em></th><th> </th><th><a name="part-r2" /><small>skipping to change at</small><em> line 285</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               vertices[i*2][2] = 0.0;</td><td> </td><td class="right">               vertices[i*2][2] = 0.0;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               vertices[i*2+1][0]= prj-&gt;viewportCenter[0] + radiusHigh*sinC
ache[i];</td><td> </td><td class="right">               vertices[i*2+1][0]= prj-&gt;viewportCenter[0] + radiusHigh*sinC
ache[i];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               vertices[i*2+1][1]= prj-&gt;viewportCenter[1] + radiusHigh*cosC
ache[i];</td><td> </td><td class="right">               vertices[i*2+1][1]= prj-&gt;viewportCenter[1] + radiusHigh*cosC
ache[i];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               vertices[i*2+1][2] = 0.0;</td><td> </td><td class="right">               vertices[i*2+1][2] = 0.0;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       drawFromArray(TriangleStrip, (slices+1)*2, 0, false);</td><td> </td><td class="right">       drawFromArray(TriangleStrip, (slices+1)*2, 0, false);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       enableClientStates(false);</td><td> </td><td class="right">       enableClientStates(false);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#define MAX_STACKS 4096</td><td> </td><td class="right">#define MAX_STACKS 4096</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0003" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">static <span class="delete">double</span> cos_sin_rho[2*(MAX_STACKS+1)];</td><td> </td><td class="rblock">static <span class="insert">float</span> cos_sin_rho[2*(MAX_STACKS+1)];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#define MAX_SLICES 4096</td><td> </td><td class="right">#define MAX_SLICES 4096</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0004" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">static <span class="delete">double</span> cos_sin_theta[2*(MAX_SLICES+1)];</td><td> </td><td class="rblock">static <span class="insert">float</span> cos_sin_theta[2*(MAX_SLICES+1)];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0005" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">static</td><td> </td><td class="rblock">static void <span class="insert">ComputeCosSinTheta(float</span> phi,int segments)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">void <span class="delete">ComputeCosSinTheta(double</span> phi,int segments) {</td><td> </td><td class="rblock">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  <span class="delete">double</span> *cos_sin = cos_sin_theta;</td><td> </td><td class="rblock">       <span class="insert">float</span> *cos_sin = cos_sin_theta;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  <span class="delete">double</span> *cos_sin_rev = cos_sin + 2*(segments+1);</td><td> </td><td class="rblock">       <span class="insert">float</span> *cos_sin_rev = cos_sin + 2*(segments+1);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  const <span class="delete">double</span> c = <span class="delete">cos(phi);</span></td><td> </td><td class="rblock">       const <span class="insert">float</span> c = <span class="insert">std::cos(phi);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  const <span class="delete">double</span> s = <span class="delete">sin(phi);</span></td><td> </td><td class="rblock">       const <span class="insert">float</span> s = <span class="insert">std::sin(phi);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  *cos_sin++ = <span class="delete">1.0;</span></td><td> </td><td class="rblock">       *cos_sin++ = <span class="insert">1.f;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  *cos_sin++ = <span class="delete">0.0;</span></td><td> </td><td class="rblock">       *cos_sin++ = <span class="insert">0.f;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">  *--cos_sin_rev = -cos_sin[-1];</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">  *--cos_sin_rev =  cos_sin[-2];</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">  *cos_sin++ = c;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">  *cos_sin++ = s;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">  *--cos_sin_rev = -cos_sin[-1];</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">  *--cos_sin_rev =  cos_sin[-2];</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">  while (cos_sin &lt; cos_sin_rev) {</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       cos_sin[0] = cos_sin[-2]*c - cos_sin[-1]*s;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       cos_sin[1] = cos_sin[-2]*s + cos_sin[-1]*c;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       cos_sin += 2;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       *--cos_sin_rev = -cos_sin[-1];</td><td> </td><td class="right">       *--cos_sin_rev = -cos_sin[-1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       *--cos_sin_rev =  cos_sin[-2];</td><td> </td><td class="right">       *--cos_sin_rev =  cos_sin[-2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0006" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  }</td><td> </td><td class="rblock">       <span class="insert">*cos_sin++ = c;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       *cos_sin++ = s;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       *--cos_sin_rev = -cos_sin[-1];</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       *--cos_sin_rev =  cos_sin[-2];</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       while (cos_sin &lt; cos_sin_rev)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               cos_sin[0] = cos_sin[-2]*c - cos_sin[-1]*s;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               cos_sin[1] = cos_sin[-2]*s + cos_sin[-1]*c;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               cos_sin += 2;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               *--cos_sin_rev = -cos_sin[-1];</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               *--cos_sin_rev =  cos_sin[-2];</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0007" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">static</td><td> </td><td class="rblock">static void <span class="insert">ComputeCosSinRho(float phi, int</span> segments)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">void <span class="delete">ComputeCosSinRho(double phi,int</span> segments) {</td><td> </td><td class="rblock">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  <span class="delete">double</span> *cos_sin = cos_sin_rho;</td><td> </td><td class="rblock">       <span class="insert">float</span> *cos_sin = cos_sin_rho;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  <span class="delete">double</span> *cos_sin_rev = cos_sin + 2*(segments+1);</td><td> </td><td class="rblock">       <span class="insert">float</span> *cos_sin_rev = cos_sin + 2*(segments+1);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  const <span class="delete">double</span> c = cos(phi);</td><td> </td><td class="rblock">       const <span class="insert">float</span> c = cos(phi);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  const <span class="delete">double</span> s = sin(phi);</td><td> </td><td class="rblock">       const <span class="insert">float</span> s = sin(phi);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  *cos_sin++ = <span class="delete">1.0;</span></td><td> </td><td class="rblock">       *cos_sin++ = <span class="insert">1.f;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  *cos_sin++ = <span class="delete">0.0;</span></td><td> </td><td class="rblock">       *cos_sin++ = <span class="insert">0.f;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  *--cos_sin_rev =  cos_sin[-1];</td><td> </td><td class="rblock">       *--cos_sin_rev =  cos_sin[-1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  *--cos_sin_rev = -cos_sin[-2];</td><td> </td><td class="rblock">       *--cos_sin_rev = -cos_sin[-2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  *cos_sin++ = c;</td><td> </td><td class="rblock">       *cos_sin++ = c;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  *cos_sin++ = s;</td><td> </td><td class="rblock">       *cos_sin++ = s;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  <span class="delete">*--cos_sin_rev =  cos_sin[-1];</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">  *--cos_sin_rev = -cos_sin[-2];</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">  while (cos_sin &lt; cos_sin_rev) {</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       cos_sin[0] = cos_sin[-2]*c - cos_sin[-1]*s;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       cos_sin[1] = cos_sin[-2]*s + cos_sin[-1]*c;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       cos_sin += 2;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       *--cos_sin_rev =  cos_sin[-1];</td><td> </td><td class="right">       *--cos_sin_rev =  cos_sin[-1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       *--cos_sin_rev = -cos_sin[-2];</td><td> </td><td class="right">       *--cos_sin_rev = -cos_sin[-2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0008" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       segments--;</td><td> </td><td class="rblock">       <span class="insert">while (cos_sin &lt; cos_sin_rev)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  }</td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               cos_sin[0] = cos_sin[-2]*c - cos_sin[-1]*s;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               cos_sin[1] = cos_sin[-2]*s + cos_sin[-1]*c;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               cos_sin += 2;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               *--cos_sin_rev =  cos_sin[-1];</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               *--cos_sin_rev = -cos_sin[-2];</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">               segments--;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0009" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">void StelPainter::<span class="delete">sFanDisk(double radius, int innerFanSlices, int level</span>)</td><td> </td><td class="rblock">void StelPainter::<span class="insert">computeFanDisk(float radius, int innerFanSlices, int leve
l, QVector&lt;double&gt;&amp; vertexArr, QVector&lt;float&gt;&amp; texCoordArr</span>)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Q_ASSERT(level&lt;64);</td><td> </td><td class="right">       Q_ASSERT(level&lt;64);</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0010" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">double</span> rad[64];</td><td> </td><td class="rblock">       <span class="insert">float</span> rad[64];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       int i,j;</td><td> </td><td class="right">       int i,j;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       rad[level] = radius;</td><td> </td><td class="right">       rad[level] = radius;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       for (i=level-1;i&gt;=0;--i)</td><td> </td><td class="right">       for (i=level-1;i&gt;=0;--i)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0011" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               rad[i] = rad[i+1]*(1.<span class="delete">0-M_PI/(innerFanSlices&lt;&lt;(i+1)))*2.0/3.0</span>
;</td><td> </td><td class="rblock">               rad[i] = rad[i+1]*(1.<span class="insert">f-M_PI/(innerFanSlices&lt;&lt;(i+1)))*2.f/3.f</span>
;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       int slices = innerFanSlices&lt;&lt;level;</td><td> </td><td class="right">       int slices = innerFanSlices&lt;&lt;level;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0012" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       const <span class="delete">double dtheta = 2.0</span> * M_PI / slices;</td><td> </td><td class="rblock">       const <span class="insert">float dtheta = 2.f</span> * M_PI / slices;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Q_ASSERT(slices&lt;=MAX_SLICES);</td><td> </td><td class="right">       Q_ASSERT(slices&lt;=MAX_SLICES);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       ComputeCosSinTheta(dtheta,slices);</td><td> </td><td class="right">       ComputeCosSinTheta(dtheta,slices);</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0013" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">double *</span>cos_sin_theta_p;</td><td> </td><td class="rblock">       <span class="insert">float* </span>cos_sin_theta_p;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       int slices_step = 2;</td><td> </td><td class="right">       int slices_step = 2;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0014" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">static QVector&lt;double&gt; vertexArr;</span></td><td> </td><td class="rblock">       <span class="insert">float x,y,xa,ya;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       static QVector&lt;float&gt; texCoordArr;</span></td><td> </td><td class="rblock"><span class="insert">       radius*=2.f;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       double x,y;</span></td><td> </td><td class="rblock"><span class="insert">       vertexArr.resize(0);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       texCoordArr.resize(0);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       for (i=level;i&gt;0;--i,slices_step&lt;&lt;=1)</td><td> </td><td class="right">       for (i=level;i&gt;0;--i,slices_step&lt;&lt;=1)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0015" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               for (j=0,cos_sin_theta_p=cos_sin_theta; j&lt;slices<span class="delete">; j+=slices_
</span>step,cos_sin_theta_p+=2*slices_step)</td><td> </td><td class="rblock">               for (j=0,cos_sin_theta_p=cos_sin_theta; j&lt;slices<span class="insert">-1; j+=slice
s_</span>step,cos_sin_theta_p+=2*slices_step)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0016" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       <span class="delete">vertexArr.resize(0);</span></td><td> </td><td class="rblock">                       <span class="insert">xa</span> = rad[i]*cos_sin_theta_p[slices_step];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       texCoordArr.resize(0);</span></td><td> </td><td class="rblock">                       <span class="insert">ya</span> = rad[i]*cos_sin_theta_p[slices_step+1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       x</span> = rad[i]*cos_sin_theta_p[slices_step];</td><td> </td><td class="rblock">                       texCoordArr &lt;&lt; <span class="insert">0.5f+xa/radius</span> &lt;&lt; <span class="insert">0.5f+ya/radius;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       <span class="delete">y</span> = rad[i]*cos_sin_theta_p[slices_step+1];</td><td> </td><td class="rblock">                       vertexArr &lt;&lt; <span class="insert">xa</span> &lt;&lt; <span class="insert">ya</span> &lt;&lt; 0;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       texCoordArr &lt;&lt; <span class="delete">0.5*(1.0+x/radius)</span> &lt;&lt; <span class="delete">0.5*(1.0+y/radi</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">us);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       vertexArr &lt;&lt; <span class="delete">x</span> &lt;&lt; <span class="delete">y</span> &lt;&lt; 0;</td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       x = rad[i]*cos_sin_theta_p[2*slices_step];</td><td> </td><td class="right">                       x = rad[i]*cos_sin_theta_p[2*slices_step];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       y = rad[i]*cos_sin_theta_p[2*slices_step+1];</td><td> </td><td class="right">                       y = rad[i]*cos_sin_theta_p[2*slices_step+1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0017" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       texCoordArr &lt;&lt; 0.5<span class="delete">*(1.0+x/radius) &lt;&lt; 0.5*(1.0+y/radi
us)</span>;</td><td> </td><td class="rblock">                       texCoordArr &lt;&lt; 0.5<span class="insert">f+x/radius &lt;&lt; 0.5f+y/radius</span>;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       vertexArr &lt;&lt; x &lt;&lt; y &lt;&lt; 0;</td><td> </td><td class="right">                       vertexArr &lt;&lt; x &lt;&lt; y &lt;&lt; 0;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       x = rad[i-1]*cos_sin_theta_p[2*slices_step];</td><td> </td><td class="right">                       x = rad[i-1]*cos_sin_theta_p[2*slices_step];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       y = rad[i-1]*cos_sin_theta_p[2*slices_step+1];</td><td> </td><td class="right">                       y = rad[i-1]*cos_sin_theta_p[2*slices_step+1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0018" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       texCoordArr &lt;&lt; <span class="delete">0.5*(1.0+x/radius)</span> &lt;&lt; <span class="delete">0.5*(1.0+y/radi</span></td><td> </td><td class="rblock">                       texCoordArr &lt;&lt; <span class="insert">0.5f+x/radius</span> &lt;&lt; <span class="insert">0.5f+y/radius;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">us);</span></td><td> </td><td class="rblock"><span class="insert">                       vertexArr &lt;&lt; x &lt;&lt; y &lt;&lt; 0;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       texCoordArr &lt;&lt; 0.5f+xa/radius &lt;&lt; 0.5f+ya/radius;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       vertexArr &lt;&lt; xa &lt;&lt; ya &lt;&lt; 0;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       texCoordArr &lt;&lt; 0.5f+x/radius &lt;&lt; 0.5f+y/radius;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       vertexArr &lt;&lt; x &lt;&lt; y &lt;&lt; 0;</td><td> </td><td class="right">                       vertexArr &lt;&lt; x &lt;&lt; y &lt;&lt; 0;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       x = rad[i-1]*cos_sin_theta_p[0];</td><td> </td><td class="right">                       x = rad[i-1]*cos_sin_theta_p[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       y = rad[i-1]*cos_sin_theta_p[1];</td><td> </td><td class="right">                       y = rad[i-1]*cos_sin_theta_p[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0019" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       texCoordArr &lt;&lt; <span class="delete">0.5*(1.0+x/radius)</span> &lt;&lt; <span class="delete">0.5*(1.0+y/radi</span></td><td> </td><td class="rblock">                       texCoordArr &lt;&lt; <span class="insert">0.5f+x/radius</span> &lt;&lt; <span class="insert">0.5f+y/radius;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">us);</span></td><td> </td><td class="rblock"><span class="insert">                       vertexArr &lt;&lt; x &lt;&lt; y &lt;&lt; 0;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       texCoordArr &lt;&lt; 0.5f+xa/radius &lt;&lt; 0.5f+ya/radius;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       vertexArr &lt;&lt; xa &lt;&lt; ya &lt;&lt; 0;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       texCoordArr &lt;&lt; 0.5f+x/radius &lt;&lt; 0.5f+y/radius;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       vertexArr &lt;&lt; x &lt;&lt; y &lt;&lt; 0;</td><td> </td><td class="right">                       vertexArr &lt;&lt; x &lt;&lt; y &lt;&lt; 0;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       x = rad[i]*cos_sin_theta_p[0];</td><td> </td><td class="right">                       x = rad[i]*cos_sin_theta_p[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       y = rad[i]*cos_sin_theta_p[1];</td><td> </td><td class="right">                       y = rad[i]*cos_sin_theta_p[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0020" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       texCoordArr &lt;&lt; 0.5<span class="delete">*(1.0+x/radius) &lt;&lt; 0.5*(1.0+y/radi
us)</span>;</td><td> </td><td class="rblock">                       texCoordArr &lt;&lt; 0.5<span class="insert">f+x/radius &lt;&lt; 0.5f+y/radius</span>;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       vertexArr &lt;&lt; x &lt;&lt; y &lt;&lt; 0;</td><td> </td><td class="right">                       vertexArr &lt;&lt; x &lt;&lt; y &lt;&lt; 0;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0021" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       <span class="delete">setArrays((Vec3d*)vertexArr.constData(), (Vec2f*)tex</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">CoordArr.constData());</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       drawFromArray(TriangleFan, vertexArr.size()/3);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // draw the inner polygon</td><td> </td><td class="right">       // draw the inner polygon</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       slices_step&gt;&gt;=1;</td><td> </td><td class="right">       slices_step&gt;&gt;=1;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0022" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">vertexArr.resize(0);</span></td><td> </td><td class="rblock">       <span class="insert">cos_sin_theta_p=cos_sin_theta;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       texCoordArr.resize(0);</span></td><td> </td><td class="rblock"><span class="insert">       x = rad[0]*cos_sin_theta_p[0];</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       texCoordArr &lt;&lt; <span class="delete">0.5</span> &lt;&lt; <span class="delete">0.5;</span></td><td> </td><td class="rblock"><span class="insert">       y = rad[0]*cos_sin_theta_p[1];</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       vertexArr &lt;&lt; <span class="delete">0</span> &lt;&lt; <span class="delete">0</span> &lt;&lt; 0;</td><td> </td><td class="rblock"><span class="insert">       texCoordArr &lt;&lt; 0.5f+x/radius &lt;&lt; 0.5f+y/radius;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">for (j=0,cos_sin_theta_p=cos_sin_theta; j&lt;=slices; j+=slices_step,co</span></td><td> </td><td class="rblock"><span class="insert">       vertexArr &lt;&lt; x &lt;&lt; y &lt;&lt; 0;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">s_sin_theta_p+=2*slices_step)</span></td><td> </td><td class="rblock"><span class="insert">       cos_sin_theta_p+=2*slices_step;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       {</span></td><td> </td><td class="rblock"><span class="insert">       x = rad[0]*cos_sin_theta_p[0];</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               x = rad[0]*cos_sin_theta_p[0];</td><td> </td><td class="rblock"><span class="insert">       y = rad[0]*cos_sin_theta_p[1];</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               y = rad[0]*cos_sin_theta_p[1];</td><td> </td><td class="rblock">       texCoordArr &lt;&lt; <span class="insert">0.5f+x/radius</span> &lt;&lt; <span class="insert">0.5f+y/radius;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               texCoordArr &lt;&lt; <span class="delete">0.5*(1.0+x/radius)</span> &lt;&lt; <span class="delete">0.5*(1.0+y/radius);</span></td><td> </td><td class="rblock">       vertexArr &lt;&lt; <span class="insert">x</span> &lt;&lt; <span class="insert">y</span> &lt;&lt; 0;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               vertexArr &lt;&lt; x &lt;&lt; y &lt;&lt; 0;</td><td> </td><td class="rblock">       <span class="insert">cos_sin_theta_p+=2*slices_step;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">}</span></td><td> </td><td class="rblock">       x = rad[0]*cos_sin_theta_p[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       setArrays((Vec3d*)vertexArr.constData(), (Vec2f*)texCoordArr.constDa</span></td><td> </td><td class="rblock">       y = rad[0]*cos_sin_theta_p[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">ta());</span></td><td> </td><td class="rblock">       texCoordArr &lt;&lt; <span class="insert">0.5f+x/radius</span> &lt;&lt; <span class="insert">0.5f+y/radius;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       drawFromArray(TriangleFan, vertexArr.size()/3);</span></td><td> </td><td class="rblock">       vertexArr &lt;&lt; x &lt;&lt; y &lt;&lt; 0;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0023" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">void StelPainter::sRing(<span class="delete">double rMin, double rMax, int slices, int stacks, i
nt</span> orientInside)</td><td> </td><td class="rblock">void StelPainter::sRing(<span class="insert">float rMin, float rMax, int slices, int stacks, int
</span> orientInside)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0024" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">double</span> x,y;</td><td> </td><td class="rblock">       <span class="insert">float</span> x,y;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       int j;</td><td> </td><td class="right">       int j;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0025" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       const <span class="delete">double</span> nsign = <span class="delete">(orientInside)?-1.0:1.0;</span></td><td> </td><td class="rblock">       <span class="insert">static Vec3f lightPos3;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       static Vec4f ambientLight;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       static Vec4f diffuseLight;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       float c;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       const <span class="insert">bool isLightOn = light.isEnabled();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       if (isLightOn)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               lightPos3.set(light.getPosition()[0], light.getPosition()[1]</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">, light.getPosition()[2]);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               lightPos3 -= prj-&gt;modelViewMatrixf * Vec3f(0.f); // -posCent</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">erEye</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               lightPos3 = prj-&gt;modelViewMatrixf.transpose().multiplyWithou</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">tTranslation(lightPos3);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               lightPos3.normalize();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               ambientLight = light.getAmbient();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               diffuseLight = light.getDiffuse();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       const float</span> nsign = <span class="insert">orientInside?-1.f:1.f;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0026" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       const <span class="delete">double</span> dr = (rMax-rMin) / stacks;</td><td> </td><td class="rblock">       const <span class="insert">float</span> dr = (rMax-rMin) / stacks;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       const <span class="delete">double</span> dtheta = <span class="delete">2.0</span> * M_PI / slices;</td><td> </td><td class="rblock">       const <span class="insert">float</span> dtheta = <span class="insert">2.f</span> * M_PI / slices;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (slices &lt; 0) slices = -slices;</td><td> </td><td class="right">       if (slices &lt; 0) slices = -slices;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Q_ASSERT(slices&lt;=MAX_SLICES);</td><td> </td><td class="right">       Q_ASSERT(slices&lt;=MAX_SLICES);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       ComputeCosSinTheta(dtheta,slices);</td><td> </td><td class="right">       ComputeCosSinTheta(dtheta,slices);</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0027" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">double</span> *cos_sin_theta_p;</td><td> </td><td class="rblock">       <span class="insert">float</span> *cos_sin_theta_p;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       static QVector&lt;double&gt; vertexArr;</td><td> </td><td class="right">       static QVector&lt;double&gt; vertexArr;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       static QVector&lt;float&gt; texCoordArr;</td><td> </td><td class="right">       static QVector&lt;float&gt; texCoordArr;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0028" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       static QVector&lt;float&gt; <span class="delete">normal</span>Arr;</td><td> </td><td class="rblock">       static QVector&lt;float&gt; <span class="insert">color</span>Arr;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // draw intermediate stacks as quad strips</td><td> </td><td class="right">       // draw intermediate stacks as quad strips</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0029" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       for (<span class="delete">double</span> r = rMin; r &lt; rMax; r+=dr)</td><td> </td><td class="rblock">       for (<span class="insert">float</span> r = rMin; r &lt; rMax; r+=dr)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0030" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               const <span class="delete">double</span> tex_r0 = (r-rMin)/(rMax-rMin);</td><td> </td><td class="rblock">               const <span class="insert">float</span> tex_r0 = (r-rMin)/(rMax-rMin);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               const <span class="delete">double</span> tex_r1 = (r+dr-rMin)/(rMax-rMin);</td><td> </td><td class="rblock">               const <span class="insert">float</span> tex_r1 = (r+dr-rMin)/(rMax-rMin);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               vertexArr.resize(0);</td><td> </td><td class="right">               vertexArr.resize(0);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               texCoordArr.resize(0);</td><td> </td><td class="right">               texCoordArr.resize(0);</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0031" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               <span class="delete">normal</span>Arr.resize(0);</td><td> </td><td class="rblock">               <span class="insert">color</span>Arr.resize(0);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               for (j=0,cos_sin_theta_p=cos_sin_theta; j&lt;=slices; ++j,cos_s
in_theta_p+=2)</td><td> </td><td class="right">               for (j=0,cos_sin_theta_p=cos_sin_theta; j&lt;=slices; ++j,cos_s
in_theta_p+=2)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       x = r*cos_sin_theta_p[0];</td><td> </td><td class="right">                       x = r*cos_sin_theta_p[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       y = r*cos_sin_theta_p[1];</td><td> </td><td class="right">                       y = r*cos_sin_theta_p[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0032" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       <span class="delete">normalArr &lt;&lt; 0 &lt;&lt; 0 &lt;&lt; nsign;</span></td><td> </td><td class="rblock">                       <span class="insert">if (isLightOn)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       texCoordArr &lt;&lt; tex_r0 &lt;&lt; <span class="delete">0.5;</span></td><td> </td><td class="rblock"><span class="insert">                       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       vertexArr &lt;&lt; x &lt;&lt; y &lt;&lt; <span class="delete">0;</span></td><td> </td><td class="rblock"><span class="insert">                               c = nsign * (lightPos3[0]*x + lightPos3[1]*y</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               if (c&lt;0) {c=0;}</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               colorArr &lt;&lt; c*diffuseLight[0] + ambientLight</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">[0] &lt;&lt; c*diffuseLight[1] + ambientLight[1] &lt;&lt; c*diffuseLight[2] + ambientLi</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ght[2];</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                       texCoordArr &lt;&lt; tex_r0 &lt;&lt; <span class="insert">0.5f;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                       vertexArr &lt;&lt; x &lt;&lt; y &lt;&lt; <span class="insert">0.f;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       x = (r+dr)*cos_sin_theta_p[0];</td><td> </td><td class="right">                       x = (r+dr)*cos_sin_theta_p[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       y = (r+dr)*cos_sin_theta_p[1];</td><td> </td><td class="right">                       y = (r+dr)*cos_sin_theta_p[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0033" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       <span class="delete">normalArr &lt;&lt; 0 &lt;&lt; 0 &lt;&lt; nsign;</span></td><td> </td><td class="rblock">                       <span class="insert">if (isLightOn)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       texCoordArr &lt;&lt; tex_r1 &lt;&lt; <span class="delete">0.5;</span></td><td> </td><td class="rblock"><span class="insert">                       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       vertexArr &lt;&lt; x &lt;&lt; y &lt;&lt; <span class="delete">0;</span></td><td> </td><td class="rblock"><span class="insert">                               c = nsign * (lightPos3[0]*x + lightPos3[1]*y</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               if (c&lt;0) {c=0;}</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               colorArr &lt;&lt; c*diffuseLight[0] + ambientLight</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">[0] &lt;&lt; c*diffuseLight[1] + ambientLight[1] &lt;&lt; c*diffuseLight[2] + ambientLi</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ght[2];</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                       texCoordArr &lt;&lt; tex_r1 &lt;&lt; <span class="insert">0.5f;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                       vertexArr &lt;&lt; x &lt;&lt; y &lt;&lt; <span class="insert">0.f;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0034" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               setArrays((Vec3d*)vertexArr.constData(), <span class="delete">(Vec2f*)texCoordArr</span></td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">.constData(), NULL, (Vec3f*)normalArr.constData());</span></td><td> </td><td class="rblock">               <span class="insert">if (isLightOn)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                       setArrays((Vec3d*)vertexArr.constData(), <span class="insert">(Vec2f*)tex</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">CoordArr.constData(), (Vec3f*)colorArr.constData());</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               else</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       setArrays((Vec3d*)vertexArr.constData(), (Vec2f*)tex</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">CoordArr.constData());</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               drawFromArray(TriangleStrip, vertexArr.size()/3);</td><td> </td><td class="right">               drawFromArray(TriangleStrip, vertexArr.size()/3);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0035" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">static void sSphereMapTexCoordFast(<span class="delete">double rho_div_fov, double costheta, dou
ble</span> sintheta, QVector&lt;float&gt;&amp; out)</td><td> </td><td class="rblock">static void sSphereMapTexCoordFast(<span class="insert">float rho_div_fov, float costheta, float
</span> sintheta, QVector&lt;float&gt;&amp; out)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0036" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       if <span class="delete">(rho_div_fov&gt;0.5)</span></td><td> </td><td class="rblock">       if <span class="insert">(rho_div_fov&gt;0.5f)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               rho_div_fov=0.5;</span></td><td> </td><td class="rblock"><span class="insert">               rho_div_fov=0.5f;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       out &lt;&lt; <span class="delete">0.5</span> + rho_div_fov * costheta &lt;&lt; <span class="delete">0.5</span> + rho_div_fov * <span class="delete">sintheta;</span></td><td> </td><td class="rblock">       out &lt;&lt; <span class="insert">0.5f</span> + rho_div_fov * costheta &lt;&lt; <span class="insert">0.5f</span> + rho_div_fov * <span class="insert">sinthet</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">a;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0037" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">void StelPainter::sSphereMap(<span class="delete">double radius, int slices, int stacks, double 
te</span>xtureFov, int orientInside)</td><td> </td><td class="rblock">void StelPainter::sSphereMap(<span class="insert">float radius, int slices, int stacks, float te
</span>xtureFov, int orientInside)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0038" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">double</span> rho,x,y,z;</td><td> </td><td class="rblock">       <span class="insert">float</span> rho,x,y,z;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       int i, j;</td><td> </td><td class="right">       int i, j;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0039" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">double</span> drho = M_PI / stacks;</td><td> </td><td class="rblock">       <span class="insert">float</span> drho = M_PI / stacks;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Q_ASSERT(stacks&lt;=MAX_STACKS);</td><td> </td><td class="right">       Q_ASSERT(stacks&lt;=MAX_STACKS);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       ComputeCosSinRho(drho,stacks);</td><td> </td><td class="right">       ComputeCosSinRho(drho,stacks);</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0040" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">double *</span>cos_sin_rho_p;</td><td> </td><td class="rblock">       <span class="insert">float* </span>cos_sin_rho_p;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0041" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       const <span class="delete">double dtheta = 2.0</span> * M_PI / slices;</td><td> </td><td class="rblock">       const <span class="insert">float dtheta = 2.f</span> * M_PI / slices;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Q_ASSERT(slices&lt;=MAX_SLICES);</td><td> </td><td class="right">       Q_ASSERT(slices&lt;=MAX_SLICES);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       ComputeCosSinTheta(dtheta,slices);</td><td> </td><td class="right">       ComputeCosSinTheta(dtheta,slices);</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0042" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">double *</span>cos_sin_theta_p;</td><td> </td><td class="rblock">       <span class="insert">float* </span>cos_sin_theta_p;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       drho/=textureFov;</td><td> </td><td class="right">       drho/=textureFov;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // texturing: s goes from 0.0/0.25/0.5/0.75/1.0 at +y/+x/-y/-x/+y ax
is</td><td> </td><td class="right">       // texturing: s goes from 0.0/0.25/0.5/0.75/1.0 at +y/+x/-y/-x/+y ax
is</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // t goes from -1.0/+1.0 at z = -radius/+radius (linear along longit
udes)</td><td> </td><td class="right">       // t goes from -1.0/+1.0 at z = -radius/+radius (linear along longit
udes)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // cannot use triangle fan on texturing (s coord. at top/bottom tip 
varies)</td><td> </td><td class="right">       // cannot use triangle fan on texturing (s coord. at top/bottom tip 
varies)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const int imax = stacks;</td><td> </td><td class="right">       const int imax = stacks;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       static QVector&lt;double&gt; vertexArr;</td><td> </td><td class="right">       static QVector&lt;double&gt; vertexArr;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       static QVector&lt;float&gt; texCoordArr;</td><td> </td><td class="right">       static QVector&lt;float&gt; texCoordArr;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // draw intermediate stacks as quad strips</td><td> </td><td class="right">       // draw intermediate stacks as quad strips</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (!orientInside) // nsign==1</td><td> </td><td class="right">       if (!orientInside) // nsign==1</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0043" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               for (i = 0,cos_sin_rho_p=cos_sin_rho,rho=0.<span class="delete">0</span>; i &lt; imax; ++i,
cos_sin_rho_p+=2,rho+=drho)</td><td> </td><td class="rblock">               for (i = 0,cos_sin_rho_p=cos_sin_rho,rho=0.<span class="insert">f</span>; i &lt; imax; ++i,
cos_sin_rho_p+=2,rho+=drho)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       vertexArr.resize(0);</td><td> </td><td class="right">                       vertexArr.resize(0);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       texCoordArr.resize(0);</td><td> </td><td class="right">                       texCoordArr.resize(0);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       for (j=0,cos_sin_theta_p=cos_sin_theta;j&lt;=slices;++j
,cos_sin_theta_p+=2)</td><td> </td><td class="right">                       for (j=0,cos_sin_theta_p=cos_sin_theta;j&lt;=slices;++j
,cos_sin_theta_p+=2)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       {</td><td> </td><td class="right">                       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               x = -cos_sin_theta_p[1] * cos_sin_rho_p[1];</td><td> </td><td class="right">                               x = -cos_sin_theta_p[1] * cos_sin_rho_p[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               y = cos_sin_theta_p[0] * cos_sin_rho_p[1];</td><td> </td><td class="right">                               y = cos_sin_theta_p[0] * cos_sin_rho_p[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               z = cos_sin_rho_p[0];</td><td> </td><td class="right">                               z = cos_sin_rho_p[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               sSphereMapTexCoordFast(rho, cos_sin_theta_p[
0], cos_sin_theta_p[1], texCoordArr);</td><td> </td><td class="right">                               sSphereMapTexCoordFast(rho, cos_sin_theta_p[
0], cos_sin_theta_p[1], texCoordArr);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               vertexArr &lt;&lt; x*radius &lt;&lt; y*radius &lt;&lt; z*radiu
s;</td><td> </td><td class="right">                               vertexArr &lt;&lt; x*radius &lt;&lt; y*radius &lt;&lt; z*radiu
s;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l3" /><small>skipping to change at</small><em> line 481</em></th><th> </th><th><a name="part-r3" /><small>skipping to change at</small><em> line 551</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               z = cos_sin_rho_p[2];</td><td> </td><td class="right">                               z = cos_sin_rho_p[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               sSphereMapTexCoordFast(rho + drho, cos_sin_t
heta_p[0], cos_sin_theta_p[1], texCoordArr);</td><td> </td><td class="right">                               sSphereMapTexCoordFast(rho + drho, cos_sin_t
heta_p[0], cos_sin_theta_p[1], texCoordArr);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               vertexArr &lt;&lt; x*radius &lt;&lt; y*radius &lt;&lt; z*radiu
s;</td><td> </td><td class="right">                               vertexArr &lt;&lt; x*radius &lt;&lt; y*radius &lt;&lt; z*radiu
s;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       }</td><td> </td><td class="right">                       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       setArrays((Vec3d*)vertexArr.constData(), (Vec2f*)tex
CoordArr.constData());</td><td> </td><td class="right">                       setArrays((Vec3d*)vertexArr.constData(), (Vec2f*)tex
CoordArr.constData());</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       drawFromArray(TriangleStrip, vertexArr.size()/3);</td><td> </td><td class="right">                       drawFromArray(TriangleStrip, vertexArr.size()/3);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       else</td><td> </td><td class="right">       else</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0044" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               for (i = 0,cos_sin_rho_p=cos_sin_rho,rho=0.<span class="delete">0</span>; i &lt; imax; ++i,
cos_sin_rho_p+=2,rho+=drho)</td><td> </td><td class="rblock">               for (i = 0,cos_sin_rho_p=cos_sin_rho,rho=0.<span class="insert">f</span>; i &lt; imax; ++i,
cos_sin_rho_p+=2,rho+=drho)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       vertexArr.resize(0);</td><td> </td><td class="right">                       vertexArr.resize(0);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       texCoordArr.resize(0);</td><td> </td><td class="right">                       texCoordArr.resize(0);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       for (j=0,cos_sin_theta_p=cos_sin_theta;j&lt;=slices;++j
,cos_sin_theta_p+=2)</td><td> </td><td class="right">                       for (j=0,cos_sin_theta_p=cos_sin_theta;j&lt;=slices;++j
,cos_sin_theta_p+=2)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       {</td><td> </td><td class="right">                       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               x = -cos_sin_theta_p[1] * cos_sin_rho_p[3];</td><td> </td><td class="right">                               x = -cos_sin_theta_p[1] * cos_sin_rho_p[3];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               y = cos_sin_theta_p[0] * cos_sin_rho_p[3];</td><td> </td><td class="right">                               y = cos_sin_theta_p[0] * cos_sin_rho_p[3];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               z = cos_sin_rho_p[2];</td><td> </td><td class="right">                               z = cos_sin_rho_p[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               sSphereMapTexCoordFast(rho + drho, cos_sin_t
heta_p[0], -cos_sin_theta_p[1], texCoordArr);</td><td> </td><td class="right">                               sSphereMapTexCoordFast(rho + drho, cos_sin_t
heta_p[0], -cos_sin_theta_p[1], texCoordArr);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               vertexArr &lt;&lt; x*radius &lt;&lt; y*radius &lt;&lt; z*radiu
s;</td><td> </td><td class="right">                               vertexArr &lt;&lt; x*radius &lt;&lt; y*radius &lt;&lt; z*radiu
s;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l4" /><small>skipping to change at</small><em> line 520</em></th><th> </th><th><a name="part-r4" /><small>skipping to change at</small><em> line 590</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       d = std::sqrt(dx*dx + dy*dy);</td><td> </td><td class="right">       d = std::sqrt(dx*dx + dy*dy);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // If the text is too far away to be visible in the screen return</td><td> </td><td class="right">       // If the text is too far away to be visible in the screen return</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (d&gt;qMax(prj-&gt;viewportXywh[3], prj-&gt;viewportXywh[2])*2)</td><td> </td><td class="right">       if (d&gt;qMax(prj-&gt;viewportXywh[3], prj-&gt;viewportXywh[2])*2)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return;</td><td> </td><td class="right">               return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       theta = M_PI + std::atan2(dx, dy - 1);</td><td> </td><td class="right">       theta = M_PI + std::atan2(dx, dy - 1);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       psi = std::atan2((float)qPainter-&gt;fontMetrics().width(ws)/ws.length(
),d + 1) * 180./M_PI;</td><td> </td><td class="right">       psi = std::atan2((float)qPainter-&gt;fontMetrics().width(ws)/ws.length(
),d + 1) * 180./M_PI;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (psi&gt;5)</td><td> </td><td class="right">       if (psi&gt;5)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               psi = 5;</td><td> </td><td class="right">               psi = 5;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0045" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       qPainter-&gt;translate(x, y);</td><td> </td><td class="rblock">       <span class="insert">if (qPainter-&gt;paintEngine()-&gt;type()==QPaintEngine::OpenGL2)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">if (prj-&gt;gravityLabels)</span></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               qPainter-&gt;translate(x, prj-&gt;viewportXywh[3]-y);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               qPainter-&gt;rotate(theta*180./M_PI);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               qPainter-&gt;translate(xshift, -yshift);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       else</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">               qPainter-&gt;translate(x, y);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               qPainter-&gt;rotate(-theta*180./M_PI);</td><td> </td><td class="right">               qPainter-&gt;rotate(-theta*180./M_PI);</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0046" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       qPainter-&gt;translate(xshift, yshift);</td><td> </td><td class="rblock">               qPainter-&gt;translate(xshift, yshift);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       qPainter-&gt;scale(1, -1);</td><td> </td><td class="rblock">               qPainter-&gt;scale(1, -1);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">}</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       for (int i=0;i&lt;ws.length();++i)</td><td> </td><td class="right">       for (int i=0;i&lt;ws.length();++i)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               qPainter-&gt;drawText(0,0,ws[i]);</td><td> </td><td class="right">               qPainter-&gt;drawText(0,0,ws[i]);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               // with typeface need to manually advance</td><td> </td><td class="right">               // with typeface need to manually advance</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               // TODO, absolute rotation would be better than relative</td><td> </td><td class="right">               // TODO, absolute rotation would be better than relative</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               // TODO: would look better with kerning information...</td><td> </td><td class="right">               // TODO: would look better with kerning information...</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               qPainter-&gt;translate((float)qPainter-&gt;fontMetrics().width(ws.
mid(i,1)) * 1.05, 0);</td><td> </td><td class="right">               qPainter-&gt;translate((float)qPainter-&gt;fontMetrics().width(ws.
mid(i,1)) * 1.05, 0);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               qPainter-&gt;rotate(-psi);</td><td> </td><td class="right">               qPainter-&gt;rotate(-psi);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l5" /><small>skipping to change at</small><em> line 569</em></th><th> </th><th><a name="part-r5" /><small>skipping to change at</small><em> line 648</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       glPushMatrix();</td><td> </td><td class="right">       glPushMatrix();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       glMatrixMode(GL_MODELVIEW);</td><td> </td><td class="right">       glMatrixMode(GL_MODELVIEW);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       glPushMatrix();</td><td> </td><td class="right">       glPushMatrix();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       glGetFloatv(GL_CURRENT_COLOR, color);</td><td> </td><td class="right">       glGetFloatv(GL_CURRENT_COLOR, color);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#else</td><td> </td><td class="right">#else</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       color[0]=currentColor[0];</td><td> </td><td class="right">       color[0]=currentColor[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       color[1]=currentColor[1];</td><td> </td><td class="right">       color[1]=currentColor[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       color[2]=currentColor[2];</td><td> </td><td class="right">       color[2]=currentColor[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       color[3]=currentColor[3];</td><td> </td><td class="right">       color[3]=currentColor[3];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#endif</td><td> </td><td class="right">#endif</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0047" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">glEnable(GL_BLEND);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       qPainter-&gt;endNativePainting();</td><td> </td><td class="right">       qPainter-&gt;endNativePainting();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       qPainter-&gt;save();</td><td> </td><td class="right">       qPainter-&gt;save();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       qPainter-&gt;resetTransform();</td><td> </td><td class="right">       qPainter-&gt;resetTransform();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       qPainter-&gt;resetMatrix();</td><td> </td><td class="right">       qPainter-&gt;resetMatrix();</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0048" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       qPainter-&gt;setRenderHints(QPainter::TextAntialiasing | QPainter::High
QualityAntialiasing);<span class="delete">       //</span></td><td> </td><td class="rblock">       qPainter-&gt;setRenderHints(QPainter::TextAntialiasing | QPainter::High
QualityAntialiasing);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const QColor qCol=QColor::fromRgbF(qMax(qMin(1.f,color[0]),0.f), qMa
x(qMin(1.f,color[1]),0.f), qMax(qMin(1.f,color[2]),0.f), qMax(qMin(1.f,colo
r[3]),0.f));</td><td> </td><td class="right">       const QColor qCol=QColor::fromRgbF(qMax(qMin(1.f,color[0]),0.f), qMa
x(qMin(1.f,color[1]),0.f), qMax(qMin(1.f,color[2]),0.f), qMax(qMin(1.f,colo
r[3]),0.f));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       qPainter-&gt;setPen(qCol);</td><td> </td><td class="right">       qPainter-&gt;setPen(qCol);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (prj-&gt;gravityLabels &amp;&amp; !noGravity)</td><td> </td><td class="right">       if (prj-&gt;gravityLabels &amp;&amp; !noGravity)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               drawTextGravity180(x, y, str, xshift, yshift);</td><td> </td><td class="right">               drawTextGravity180(x, y, str, xshift, yshift);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       else</td><td> </td><td class="right">       else</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               // There are 2 version here depending on the OpenGL engine</td><td> </td><td class="right">               // There are 2 version here depending on the OpenGL engine</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               // OpenGL 1 need to reverse the text vertically, not OpenGL 
2...</td><td> </td><td class="right">               // OpenGL 1 need to reverse the text vertically, not OpenGL 
2...</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               // This sounds like a Qt bug</td><td> </td><td class="right">               // This sounds like a Qt bug</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               if (qPainter-&gt;paintEngine()-&gt;type()==QPaintEngine::OpenGL2)</td><td> </td><td class="right">               if (qPainter-&gt;paintEngine()-&gt;type()==QPaintEngine::OpenGL2)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0049" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       <span class="delete">qPainter-&gt;translate(x+xshift, prj-&gt;viewportXywh[3]-y</span></td><td> </td><td class="rblock">                       <span class="insert">qPainter-&gt;translate(x, prj-&gt;viewportXywh[3]-y);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">-yshift);</td><td> </td><td class="rblock"><span class="insert">                       qPainter-&gt;rotate(-angleDeg);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       qPainter-&gt;translate(xshift,</span> -yshift);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               else</td><td> </td><td class="right">               else</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0050" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       qPainter-&gt;translate(<span class="delete">x+xshift, y+yshift</span>);</td><td> </td><td class="rblock">                       qPainter-&gt;translate(<span class="insert">round(x), round(y)</span>);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       qPainter-&gt;scale(1, -1);</td><td> </td><td class="right">                       qPainter-&gt;scale(1, -1);</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0051" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                       <span class="insert">qPainter-&gt;rotate(-angleDeg);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       qPainter-&gt;translate(round(xshift), round(-yshift));</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               qPainter-&gt;drawText(0, 0, str);</td><td> </td><td class="right">               qPainter-&gt;drawText(0, 0, str);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       qPainter-&gt;restore();</td><td> </td><td class="right">       qPainter-&gt;restore();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       qPainter-&gt;beginNativePainting();</td><td> </td><td class="right">       qPainter-&gt;beginNativePainting();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#ifndef STELPAINTER_GL2</td><td> </td><td class="right">#ifndef STELPAINTER_GL2</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       glMatrixMode(GL_TEXTURE);</td><td> </td><td class="right">       glMatrixMode(GL_TEXTURE);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       glPopMatrix();</td><td> </td><td class="right">       glPopMatrix();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l6" /><small>skipping to change at</small><em> line 636</em></th><th> </th><th><a name="part-r6" /><small>skipping to change at</small><em> line 717</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               vertexList.insert(iter, win2);</td><td> </td><td class="right">               vertexList.insert(iter, win2);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return;</td><td> </td><td class="right">               return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Vec3d newVertex(p1); newVertex+=p2;</td><td> </td><td class="right">       Vec3d newVertex(p1); newVertex+=p2;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       newVertex.normalize();</td><td> </td><td class="right">       newVertex.normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       newVertex*=radius;</td><td> </td><td class="right">       newVertex*=radius;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Vec3d win3(newVertex[0]+center[0], newVertex[1]+center[1], newVertex
[2]+center[2]);</td><td> </td><td class="right">       Vec3d win3(newVertex[0]+center[0], newVertex[1]+center[1], newVertex
[2]+center[2]);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const bool isValidVertex = prj-&gt;projectInPlace(win3);</td><td> </td><td class="right">       const bool isValidVertex = prj-&gt;projectInPlace(win3);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0052" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       const <span class="delete">double</span> v10=win1[0]-win3[0];</td><td> </td><td class="rblock">       const <span class="insert">float</span> v10=win1[0]-win3[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       const <span class="delete">double</span> v11=win1[1]-win3[1];</td><td> </td><td class="rblock">       const <span class="insert">float</span> v11=win1[1]-win3[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       const <span class="delete">double</span> v20=win2[0]-win3[0];</td><td> </td><td class="rblock">       const <span class="insert">float</span> v20=win2[0]-win3[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       const <span class="delete">double</span> v21=win2[1]-win3[1];</td><td> </td><td class="rblock">       const <span class="insert">float</span> v21=win2[1]-win3[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                                                           </td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       const <span class="delete">double</span> dist = std::sqrt((v10*v10+v11*v11)*(v20*v20+v21*v21));</td><td> </td><td class="rblock">       const <span class="insert">float</span> dist = std::sqrt((v10*v10+v11*v11)*(v20*v20+v21*v21));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       const <span class="delete">double</span> cosAngle = (v10*v20+v11*v21)/dist;</td><td> </td><td class="rblock">       const <span class="insert">float</span> cosAngle = (v10*v20+v11*v21)/dist;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       if <span class="delete">((cosAngle&gt;-0.999</span> || dist&gt;50*50 || crossDiscontinuity) &amp;&amp; <span class="delete">nbI&lt;10)</span></td><td> </td><td class="rblock">       if <span class="insert">((cosAngle&gt;-0.999f</span> || dist&gt;50*50 || crossDiscontinuity) &amp;&amp; <span class="insert">nbI&lt;10</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               // Use the 3rd component of the vector to store whether the 
vertex is valid</td><td> </td><td class="right">               // Use the 3rd component of the vector to store whether the 
vertex is valid</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               win3[2]= isValidVertex ? 1.0 : -1.;</td><td> </td><td class="right">               win3[2]= isValidVertex ? 1.0 : -1.;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               fIter(prj, p1, newVertex, win1, win3, vertexList, vertexList
.insert(iter, win3), radius, center, nbI+1, crossDiscontinuity || dist&gt;50*5
0);</td><td> </td><td class="right">               fIter(prj, p1, newVertex, win1, win3, vertexList, vertexList
.insert(iter, win3), radius, center, nbI+1, crossDiscontinuity || dist&gt;50*5
0);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               fIter(prj, newVertex, p2, win3, win2, vertexList, iter, radi
us, center, nbI+1, crossDiscontinuity || dist&gt;50*50 );</td><td> </td><td class="right">               fIter(prj, newVertex, p2, win3, win2, vertexList, iter, radi
us, center, nbI+1, crossDiscontinuity || dist&gt;50*50 );</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// Used by the method below</td><td> </td><td class="right">// Used by the method below</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">QVector&lt;Vec2f&gt; StelPainter::smallCircleVertexArray;</td><td> </td><td class="right">QVector&lt;Vec2f&gt; StelPainter::smallCircleVertexArray;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l7" /><small>skipping to change at</small><em> line 714</em></th><th> </th><th><a name="part-r7" /><small>skipping to change at</small><em> line 795</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       else</td><td> </td><td class="right">       else</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               Vec3d tmp = (rotCenter^start)/rotCenter.length();</td><td> </td><td class="right">               Vec3d tmp = (rotCenter^start)/rotCenter.length();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               const double radius = fabs(tmp.length());</td><td> </td><td class="right">               const double radius = fabs(tmp.length());</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               // Perform the tesselation of the arc in small segments in a
 way so that the lines look smooth</td><td> </td><td class="right">               // Perform the tesselation of the arc in small segments in a
 way so that the lines look smooth</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               fIter(prj, start-rotCenter, stop-rotCenter, win1, win2, tess
Arc, tessArc.insert(tessArc.end(), win2), radius, rotCenter);</td><td> </td><td class="right">               fIter(prj, start-rotCenter, stop-rotCenter, win1, win2, tess
Arc, tessArc.insert(tessArc.end(), win2), radius, rotCenter);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // And draw.</td><td> </td><td class="right">       // And draw.</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0053" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       QLinkedList&lt;Vec3d&gt;::ConstIterator i = <span class="delete">tessArc.begin();</span></td><td> </td><td class="rblock">       QLinkedList&lt;Vec3d&gt;::ConstIterator i = <span class="insert">tessArc.constBegin();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       while (i+1 != <span class="delete">tessArc.end())</span></td><td> </td><td class="rblock">       while (i+1 != <span class="insert">tessArc.constEnd())</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               const Vec3d&amp; p1 = *i;</td><td> </td><td class="right">               const Vec3d&amp; p1 = *i;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               const Vec3d&amp; p2 = *(++i);</td><td> </td><td class="right">               const Vec3d&amp; p2 = *(++i);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               const bool p1InViewport = prj-&gt;checkInViewport(p1);</td><td> </td><td class="right">               const bool p1InViewport = prj-&gt;checkInViewport(p1);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               const bool p2InViewport = prj-&gt;checkInViewport(p2);</td><td> </td><td class="right">               const bool p2InViewport = prj-&gt;checkInViewport(p2);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               if ((p1[2]&gt;0 &amp;&amp; p1InViewport) || (p2[2]&gt;0 &amp;&amp; p2InViewport))</td><td> </td><td class="right">               if ((p1[2]&gt;0 &amp;&amp; p1InViewport) || (p2[2]&gt;0 &amp;&amp; p2InViewport))</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       smallCircleVertexArray.append(Vec2f(p1[0], p1[1]));</td><td> </td><td class="right">                       smallCircleVertexArray.append(Vec2f(p1[0], p1[1]));</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0054" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       if (i+1==tessArc.<span class="delete">e</span>nd())</td><td> </td><td class="rblock">                       if (i+1==tessArc.<span class="insert">constE</span>nd())</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       {</td><td> </td><td class="right">                       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               smallCircleVertexArray.append(Vec2f(p2[0], p
2[1]));</td><td> </td><td class="right">                               smallCircleVertexArray.append(Vec2f(p2[0], p
2[1]));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               drawSmallCircleVertexArray();</td><td> </td><td class="right">                               drawSmallCircleVertexArray();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       }</td><td> </td><td class="right">                       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       if (viewportEdgeIntersectCallback &amp;&amp; p1InViewport!=p
2InViewport)</td><td> </td><td class="right">                       if (viewportEdgeIntersectCallback &amp;&amp; p1InViewport!=p
2InViewport)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       {</td><td> </td><td class="right">                       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               // We crossed the edge of the view port</td><td> </td><td class="right">                               // We crossed the edge of the view port</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               if (p1InViewport)</td><td> </td><td class="right">                               if (p1InViewport)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                                       viewportEdgeIntersectCallback(prj-&gt;v
iewPortIntersect(p1, p2), p2-p1, userData);</td><td> </td><td class="right">                                       viewportEdgeIntersectCallback(prj-&gt;v
iewPortIntersect(p1, p2), p2-p1, userData);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               else</td><td> </td><td class="right">                               else</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l8" /><small>skipping to change at</small><em> line 1114</em></th><th> </th><th><a name="part-r8" /><small>skipping to change at</small><em> line 1195</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               ta[1]=(texturePos[1]+texturePos[2])*0.5;</td><td> </td><td class="right">               ta[1]=(texturePos[1]+texturePos[2])*0.5;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               ta[2]=texturePos[2];</td><td> </td><td class="right">               ta[2]=texturePos[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       projectSphericalTriangle(clippingCap, va, outVertices, ta, outTextur
ePos, nbI+1);</td><td> </td><td class="right">       projectSphericalTriangle(clippingCap, va, outVertices, ta, outTextur
ePos, nbI+1);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       return;</td><td> </td><td class="right">       return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">static QVarLengthArray&lt;Vec3f, 4096&gt; polygonVertexArray;</td><td> </td><td class="right">static QVarLengthArray&lt;Vec3f, 4096&gt; polygonVertexArray;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">static QVarLengthArray&lt;Vec2f, 4096&gt; polygonTextureCoordArray;</td><td> </td><td class="right">static QVarLengthArray&lt;Vec2f, 4096&gt; polygonTextureCoordArray;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0055" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">// XXX: We should change the type to unsigned int</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">static QVarLengthArray&lt;unsigned int, 4096&gt; indexArray;</td><td> </td><td class="right">static QVarLengthArray&lt;unsigned int, 4096&gt; indexArray;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0056" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">void StelPainter::drawGreatCircleArcs(const StelVertexArray&amp; va, const Sphe
ricalCap* clippingCap<span class="delete">, bool doSubDivise</span>)</td><td> </td><td class="rblock">void StelPainter::drawGreatCircleArcs(const StelVertexArray&amp; va, const Sphe
ricalCap* clippingCap)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Q_ASSERT(va.vertex.size()!=1);</td><td> </td><td class="right">       Q_ASSERT(va.vertex.size()!=1);</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0057" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       Q_ASSERT(!va.isIndexed());      // Indexed unsupported yet</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       switch (va.primitiveType)</td><td> </td><td class="right">       switch (va.primitiveType)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               case StelVertexArray::Lines:</td><td> </td><td class="right">               case StelVertexArray::Lines:</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       Q_ASSERT(va.vertex.size()%2==0);</td><td> </td><td class="right">                       Q_ASSERT(va.vertex.size()%2==0);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       for (int i=0;i&lt;va.vertex.size();i+=2)</td><td> </td><td class="right">                       for (int i=0;i&lt;va.vertex.size();i+=2)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               drawGreatCircleArc(va.vertex.at(i), va.verte
x.at(i+1), clippingCap);</td><td> </td><td class="right">                               drawGreatCircleArc(va.vertex.at(i), va.verte
x.at(i+1), clippingCap);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       return;</td><td> </td><td class="right">                       return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               case StelVertexArray::LineStrip:</td><td> </td><td class="right">               case StelVertexArray::LineStrip:</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       for (int i=0;i&lt;va.vertex.size()-1;++i)</td><td> </td><td class="right">                       for (int i=0;i&lt;va.vertex.size()-1;++i)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               drawGreatCircleArc(va.vertex.at(i), va.verte
x.at(i+1), clippingCap);</td><td> </td><td class="right">                               drawGreatCircleArc(va.vertex.at(i), va.verte
x.at(i+1), clippingCap);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l9" /><small>skipping to change at</small><em> line 1159</em></th><th> </th><th><a name="part-r9" /><small>skipping to change at</small><em> line 1240</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       VertexArrayProjector(const StelVertexArray&amp; ar, StelPainter* apainte
r, const SphericalCap* aclippingCap,</td><td> </td><td class="right">       VertexArrayProjector(const StelVertexArray&amp; ar, StelPainter* apainte
r, const SphericalCap* aclippingCap,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                                                QVarLengthArray&lt;Vec3f, 4096
&gt;* aoutVertices, QVarLengthArray&lt;Vec2f, 4096&gt;* aoutTexturePos=NULL)</td><td> </td><td class="right">                                                QVarLengthArray&lt;Vec3f, 4096
&gt;* aoutVertices, QVarLengthArray&lt;Vec2f, 4096&gt;* aoutTexturePos=NULL)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                  : vertexArray(ar), painter(apainter), clippingCap(aclippi
ngCap), outVertices(aoutVertices),</td><td> </td><td class="right">                  : vertexArray(ar), painter(apainter), clippingCap(aclippi
ngCap), outVertices(aoutVertices),</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                        outTexturePos(aoutTexturePos)</td><td> </td><td class="right">                        outTexturePos(aoutTexturePos)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Project a single triangle and add it into the output arrays</td><td> </td><td class="right">       // Project a single triangle and add it into the output arrays</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       inline void operator()(const Vec3d* v0, const Vec3d* v1, const Vec3d
* v2,</td><td> </td><td class="right">       inline void operator()(const Vec3d* v0, const Vec3d* v1, const Vec3d
* v2,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                                                  const Vec2f* t0, const Ve
c2f* t1, const Vec2f* t2,</td><td> </td><td class="right">                                                  const Vec2f* t0, const Ve
c2f* t1, const Vec2f* t2,</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0058" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                                  unsigned int<span class="delete"> i0, unsigned
 int i1, unsigned i2</span>)</td><td> </td><td class="rblock">                                                  unsigned int<span class="insert">, unsigned in
t, unsigned</span>)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               // XXX: we may optimize more by putting the declaration and 
the test outside of this method.</td><td> </td><td class="right">               // XXX: we may optimize more by putting the declaration and 
the test outside of this method.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               const Vec3d tmpVertex[3] = {*v0, *v1, *v2};</td><td> </td><td class="right">               const Vec3d tmpVertex[3] = {*v0, *v1, *v2};</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               if (outTexturePos)</td><td> </td><td class="right">               if (outTexturePos)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       const Vec2f tmpTexture[3] = {*t0, *t1, *t2};</td><td> </td><td class="right">                       const Vec2f tmpTexture[3] = {*t0, *t1, *t2};</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       painter-&gt;projectSphericalTriangle(clippingCap, tmpVe
rtex, outVertices, tmpTexture, outTexturePos);</td><td> </td><td class="right">                       painter-&gt;projectSphericalTriangle(clippingCap, tmpVe
rtex, outVertices, tmpTexture, outTexturePos);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               else</td><td> </td><td class="right">               else</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       painter-&gt;projectSphericalTriangle(clippingCap, tmpVe
rtex, outVertices, NULL, NULL);</td><td> </td><td class="right">                       painter-&gt;projectSphericalTriangle(clippingCap, tmpVe
rtex, outVertices, NULL, NULL);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l10" /><small>skipping to change at</small><em> line 1191</em></th><th> </th><th><a name="part-r10" /><small>skipping to change at</small><em> line 1272</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">private:</td><td> </td><td class="right">private:</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const StelVertexArray&amp; vertexArray;</td><td> </td><td class="right">       const StelVertexArray&amp; vertexArray;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       StelPainter* painter;</td><td> </td><td class="right">       StelPainter* painter;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const SphericalCap* clippingCap;</td><td> </td><td class="right">       const SphericalCap* clippingCap;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       QVarLengthArray&lt;Vec3f, 4096&gt;* outVertices;</td><td> </td><td class="right">       QVarLengthArray&lt;Vec3f, 4096&gt;* outVertices;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       QVarLengthArray&lt;Vec2f, 4096&gt;* outTexturePos;</td><td> </td><td class="right">       QVarLengthArray&lt;Vec2f, 4096&gt;* outTexturePos;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">};</td><td> </td><td class="right">};</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0059" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">void StelPainter::drawStelVertexArray(const StelVertexArray&amp; arr)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">{</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       setVertexPointer(3, GL_DOUBLE, arr.vertex.constData());</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       if (arr.isTextured())</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               setTexCoordPointer(2, GL_FLOAT, arr.texCoords.constData());</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               enableClientStates(true, true);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       else</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               enableClientStates(true, false);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       if (arr.isIndexed())</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               drawFromArray((StelPainter::DrawingMode)arr.primitiveType, a</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">rr.indices.size(), 0, true, arr.indices.constData());</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       else</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               drawFromArray((StelPainter::DrawingMode)arr.primitiveType, a</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">rr.vertex.size());</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       enableClientStates(false);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">}</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void StelPainter::drawSphericalTriangles(const StelVertexArray&amp; va, bool te
xtured, const SphericalCap* clippingCap, bool doSubDivide)</td><td> </td><td class="right">void StelPainter::drawSphericalTriangles(const StelVertexArray&amp; va, bool te
xtured, const SphericalCap* clippingCap, bool doSubDivide)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (va.vertex.isEmpty())</td><td> </td><td class="right">       if (va.vertex.isEmpty())</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return;</td><td> </td><td class="right">               return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0060" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">// Never need to do clipping if the projection doesn't have a discon</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">tinuity</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       const bool doClip = prj-&gt;hasDiscontinuity();</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                                                           </td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Q_ASSERT(va.vertex.size()&gt;2);</td><td> </td><td class="right">       Q_ASSERT(va.vertex.size()&gt;2);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#ifndef STELPAINTER_GL2</td><td> </td><td class="right">#ifndef STELPAINTER_GL2</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);</td><td> </td><td class="right">       glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#endif</td><td> </td><td class="right">#endif</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       polygonVertexArray.clear();</td><td> </td><td class="right">       polygonVertexArray.clear();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       polygonTextureCoordArray.clear();</td><td> </td><td class="right">       polygonTextureCoordArray.clear();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       indexArray.clear();</td><td> </td><td class="right">       indexArray.clear();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0061" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">// The simplest case, we don't need to iterate through the triangles</span></td><td> </td><td class="rblock">       if <span class="insert">(!doSubDivide)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"> at all.</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       if <span class="delete">(!doClip &amp;&amp; !doSubDivide)</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       {</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               va.draw(this);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               return;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       }</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       if (doClip &amp;&amp; !doSubDivide)</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0062" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               <span class="delete">StelVertexArray</span> cleanVa = <span class="delete">va.removeDiscontinuousTriangles(th</span></td><td> </td><td class="rblock">               <span class="insert">if (prj-&gt;hasDiscontinuity())</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">is-&gt;getProjector().data());</span></td><td> </td><td class="rblock"><span class="insert">               {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               cleanVa.draw(this);</span></td><td> </td><td class="rblock"><span class="insert">                       // We don't want to subdivise the triangles, but the</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> projection has discontinuities,</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       // so we need to make sure that no triangle is cross</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ing them.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       const StelVertexArray&amp;</span> cleanVa = <span class="insert">va.removeDiscontinu</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ousTriangles(this-&gt;getProjector().data());</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       drawStelVertexArray(cleanVa);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               else</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       // The simplest case, we don't need to iterate throu</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">gh the triangles at all.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       drawStelVertexArray(va);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return;</td><td> </td><td class="right">               return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // the last case.  It is the slowest, it process the triangles one b
y one.</td><td> </td><td class="right">       // the last case.  It is the slowest, it process the triangles one b
y one.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               // Project all the triangles of the VertexArray into our buf
fer arrays.</td><td> </td><td class="right">               // Project all the triangles of the VertexArray into our buf
fer arrays.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               VertexArrayProjector result = va.foreachTriangle(VertexArray
Projector(va, this, clippingCap, &amp;polygonVertexArray, textured ? &amp;polygonTe
xtureCoordArray : NULL));</td><td> </td><td class="right">               VertexArrayProjector result = va.foreachTriangle(VertexArray
Projector(va, this, clippingCap, &amp;polygonVertexArray, textured ? &amp;polygonTe
xtureCoordArray : NULL));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               result.drawResult();</td><td> </td><td class="right">               result.drawResult();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return;</td><td> </td><td class="right">               return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// Draw the given SphericalPolygon.</td><td> </td><td class="right">// Draw the given SphericalPolygon.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void StelPainter::drawSphericalRegion(const SphericalRegion* poly, Spherica
lPolygonDrawMode drawMode, const SphericalCap* clippingCap, bool doSubDivis
e)</td><td> </td><td class="right">void StelPainter::drawSphericalRegion(const SphericalRegion* poly, Spherica
lPolygonDrawMode drawMode, const SphericalCap* clippingCap, bool doSubDivis
e)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0063" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">if (!prj-&gt;getBoundingCap().intersects(poly-&gt;getBoundingCap()))</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               return;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       switch (drawMode)</td><td> </td><td class="right">       switch (drawMode)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               case SphericalPolygonDrawModeBoundary:</td><td> </td><td class="right">               case SphericalPolygonDrawModeBoundary:</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0064" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       <span class="delete">drawGreatCircleArcs(poly-&gt;getOutlineVertexArray(), c</span></td><td> </td><td class="rblock">                       <span class="insert">if (doSubDivise || prj-&gt;intersectViewportDiscontinui</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">lippingCap, doSubDivise);</span></td><td> </td><td class="rblock"><span class="insert">ty(poly-&gt;getBoundingCap()))</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               drawGreatCircleArcs(poly-&gt;getOutlineVertexAr</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ray(), clippingCap);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       else</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               drawStelVertexArray(poly-&gt;getOutlineVertexAr</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ray());</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       break;</td><td> </td><td class="right">                       break;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               case SphericalPolygonDrawModeFill:</td><td> </td><td class="right">               case SphericalPolygonDrawModeFill:</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               case SphericalPolygonDrawModeTextureFill:</td><td> </td><td class="right">               case SphericalPolygonDrawModeTextureFill:</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       glEnable(GL_CULL_FACE);</td><td> </td><td class="right">                       glEnable(GL_CULL_FACE);</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0065" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       // <span class="delete">Assumes the</span> polygon is already tesselated as <span class="delete">tria</span></td><td> </td><td class="rblock">                       // <span class="insert">The</span> polygon is already tesselated as <span class="insert">triangles</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">ngles</span></td><td> </td><td class="rblock"><span class="insert">                       if (doSubDivise || prj-&gt;intersectViewportDiscontinui</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       drawSphericalTriangles(poly-&gt;getFillVertexArray(), d</span></td><td> </td><td class="rblock"><span class="insert">ty(poly-&gt;getBoundingCap()))</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">rawMode==SphericalPolygonDrawModeTextureFill,</span> clippingCap, <span class="delete">doSubDivise);</span></td><td> </td><td class="rblock"><span class="insert">                               drawSphericalTriangles(poly-&gt;getFillVertexAr</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ray(), drawMode==SphericalPolygonDrawModeTextureFill,</span> clippingCap, <span class="insert">doSubDiv</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ise);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       else</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                               drawStelVertexArray(poly-&gt;getFillVertexArray</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">());</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       glDisable(GL_CULL_FACE);</td><td> </td><td class="right">                       glDisable(GL_CULL_FACE);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       break;</td><td> </td><td class="right">                       break;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               default:</td><td> </td><td class="right">               default:</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       Q_ASSERT(0);</td><td> </td><td class="right">                       Q_ASSERT(0);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">/*************************************************************************</td><td> </td><td class="right">/*************************************************************************</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"> draw a simple circle, 2d viewport coordinates in pixel</td><td> </td><td class="right"> draw a simple circle, 2d viewport coordinates in pixel</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">*************************************************************************/</td><td> </td><td class="right">*************************************************************************/</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0066" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">void StelPainter::drawCircle(<span class="delete">double x,double y,double</span> r)</td><td> </td><td class="rblock">void StelPainter::drawCircle(<span class="insert">float x, float y, float</span> r)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (r &lt;= 1.0)</td><td> </td><td class="right">       if (r &lt;= 1.0)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return;</td><td> </td><td class="right">               return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0067" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       const <span class="delete">Vec2d</span> center(x,y);</td><td> </td><td class="rblock">       const <span class="insert">Vec2f</span> center(x,y);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       const <span class="delete">Vec2d v_center(0.5*prj-&gt;viewportXywh[2],0.5*prj-&gt;viewportXywh[</span></td><td> </td><td class="rblock">       const <span class="insert">Vec2f v_center(0.5f*prj-&gt;viewportXywh[2],0.5f*prj-&gt;viewportXyw</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">3]);</span></td><td> </td><td class="rblock"><span class="insert">h[3]);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       const <span class="delete">double</span> R = v_center.length();</td><td> </td><td class="rblock">       const <span class="insert">float</span> R = v_center.length();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       const <span class="delete">double</span> d = (v_center-center).length();</td><td> </td><td class="rblock">       const <span class="insert">float</span> d = (v_center-center).length();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (d &gt; r+R || d &lt; r-R)</td><td> </td><td class="right">       if (d &gt; r+R || d &lt; r-R)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return;</td><td> </td><td class="right">               return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const int segments = 180;</td><td> </td><td class="right">       const int segments = 180;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0068" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       const <span class="delete">double</span> phi = 2.0*M_PI/segments;</td><td> </td><td class="rblock">       const <span class="insert">float</span> phi = 2.0*M_PI/segments;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       const <span class="delete">double</span> cp = <span class="delete">cos(phi);</span></td><td> </td><td class="rblock">       const <span class="insert">float</span> cp = <span class="insert">std::cos(phi);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       const <span class="delete">double</span> sp = <span class="delete">sin(phi);</span></td><td> </td><td class="rblock">       const <span class="insert">float</span> sp = <span class="insert">std::sin(phi);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       double</span> dx = r;</td><td> </td><td class="rblock"><span class="insert">       float</span> dx = r;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">double</span> dy = 0;</td><td> </td><td class="rblock">       <span class="insert">float</span> dy = 0;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       static QVarLengthArray&lt;Vec3f, 180&gt; circleVertexArray(180);</td><td> </td><td class="right">       static QVarLengthArray&lt;Vec3f, 180&gt; circleVertexArray(180);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       for (int i=0;i&lt;segments;i++)</td><td> </td><td class="right">       for (int i=0;i&lt;segments;i++)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               circleVertexArray[i].set(x+dx,y+dy,0);</td><td> </td><td class="right">               circleVertexArray[i].set(x+dx,y+dy,0);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               r = dx*cp-dy*sp;</td><td> </td><td class="right">               r = dx*cp-dy*sp;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               dy = dx*sp+dy*cp;</td><td> </td><td class="right">               dy = dx*sp+dy*cp;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               dx = r;</td><td> </td><td class="right">               dx = r;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       enableClientStates(true);</td><td> </td><td class="right">       enableClientStates(true);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       setVertexPointer(3, GL_FLOAT, circleVertexArray.data());</td><td> </td><td class="right">       setVertexPointer(3, GL_FLOAT, circleVertexArray.data());</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       drawFromArray(LineLoop, 180, 0, false);</td><td> </td><td class="right">       drawFromArray(LineLoop, 180, 0, false);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       enableClientStates(false);</td><td> </td><td class="right">       enableClientStates(false);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0069" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">void StelPainter::drawSprite2dMode(<span class="delete">double x, double</span> y, float radius)</td><td> </td><td class="rblock">void StelPainter::drawSprite2dMode(<span class="insert">float x, float</span> y, float radius)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       static float vertexData[] = {-10.,-10.,10.,-10., 10.,10., -10.,10.};</td><td> </td><td class="right">       static float vertexData[] = {-10.,-10.,10.,-10., 10.,10., -10.,10.};</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       static const float texCoordData[] = {0.,0., 1.,0., 0.,1., 1.,1.};</td><td> </td><td class="right">       static const float texCoordData[] = {0.,0., 1.,0., 0.,1., 1.,1.};</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       vertexData[0]=x-radius; vertexData[1]=y-radius;</td><td> </td><td class="right">       vertexData[0]=x-radius; vertexData[1]=y-radius;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       vertexData[2]=x+radius; vertexData[3]=y-radius;</td><td> </td><td class="right">       vertexData[2]=x+radius; vertexData[3]=y-radius;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       vertexData[4]=x-radius; vertexData[5]=y+radius;</td><td> </td><td class="right">       vertexData[4]=x-radius; vertexData[5]=y+radius;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       vertexData[6]=x+radius; vertexData[7]=y+radius;</td><td> </td><td class="right">       vertexData[6]=x+radius; vertexData[7]=y+radius;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       enableClientStates(true, true);</td><td> </td><td class="right">       enableClientStates(true, true);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       setVertexPointer(2, GL_FLOAT, vertexData);</td><td> </td><td class="right">       setVertexPointer(2, GL_FLOAT, vertexData);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       setTexCoordPointer(2, GL_FLOAT, texCoordData);</td><td> </td><td class="right">       setTexCoordPointer(2, GL_FLOAT, texCoordData);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l11" /><small>skipping to change at</small><em> line 1305</em></th><th> </th><th><a name="part-r11" /><small>skipping to change at</small><em> line 1417</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       enableClientStates(false);</td><td> </td><td class="right">       enableClientStates(false);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void StelPainter::drawSprite2dMode(const Vec3d&amp; v, float radius)</td><td> </td><td class="right">void StelPainter::drawSprite2dMode(const Vec3d&amp; v, float radius)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Vec3d win;</td><td> </td><td class="right">       Vec3d win;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       prj-&gt;project(v, win);</td><td> </td><td class="right">       prj-&gt;project(v, win);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       drawSprite2dMode(win[0], win[1], radius);</td><td> </td><td class="right">       drawSprite2dMode(win[0], win[1], radius);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0070" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">void StelPainter::drawSprite2dMode(<span class="delete">double x, double y, float radius, float 
ro</span>tation)</td><td> </td><td class="rblock">void StelPainter::drawSprite2dMode(<span class="insert">float x, float y, float radius, float ro
</span>tation)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       static float vertexData[8];</td><td> </td><td class="right">       static float vertexData[8];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       static const float texCoordData[] = {0.,0., 1.,0., 0.,1., 1.,1.};</td><td> </td><td class="right">       static const float texCoordData[] = {0.,0., 1.,0., 0.,1., 1.,1.};</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // compute the vertex coordinates applying the translation and the r
otation</td><td> </td><td class="right">       // compute the vertex coordinates applying the translation and the r
otation</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       static const float vertexBase[] = {-1., -1., 1., -1., -1., 1., 1., 1
.};</td><td> </td><td class="right">       static const float vertexBase[] = {-1., -1., 1., -1., -1., 1., 1., 1
.};</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const float cosr = std::cos(rotation / 180 * M_PI);</td><td> </td><td class="right">       const float cosr = std::cos(rotation / 180 * M_PI);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const float sinr = std::sin(rotation / 180 * M_PI);</td><td> </td><td class="right">       const float sinr = std::sin(rotation / 180 * M_PI);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       for (int i = 0; i &lt; 8; i+=2)</td><td> </td><td class="right">       for (int i = 0; i &lt; 8; i+=2)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l12" /><small>skipping to change at</small><em> line 1353</em></th><th> </th><th><a name="part-r12" /><small>skipping to change at</small><em> line 1465</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               enableClientStates(true);</td><td> </td><td class="right">               enableClientStates(true);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               setVertexPointer(2, GL_FLOAT, vertexData);</td><td> </td><td class="right">               setVertexPointer(2, GL_FLOAT, vertexData);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       drawFromArray(TriangleStrip, 4, 0, false);</td><td> </td><td class="right">       drawFromArray(TriangleStrip, 4, 0, false);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       enableClientStates(false);</td><td> </td><td class="right">       enableClientStates(false);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">/*************************************************************************</td><td> </td><td class="right">/*************************************************************************</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"> Draw a GL_POINT at the given position</td><td> </td><td class="right"> Draw a GL_POINT at the given position</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">*************************************************************************/</td><td> </td><td class="right">*************************************************************************/</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0071" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">void StelPainter::drawPoint2d(<span class="delete">double x, double</span> y)</td><td> </td><td class="rblock">void StelPainter::drawPoint2d(<span class="insert">float x, float</span> y)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       static float vertexData[] = {0.,0.};</td><td> </td><td class="right">       static float vertexData[] = {0.,0.};</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       vertexData[0]=x;</td><td> </td><td class="right">       vertexData[0]=x;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       vertexData[1]=y;</td><td> </td><td class="right">       vertexData[1]=y;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       enableClientStates(true);</td><td> </td><td class="right">       enableClientStates(true);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       setVertexPointer(2, GL_FLOAT, vertexData);</td><td> </td><td class="right">       setVertexPointer(2, GL_FLOAT, vertexData);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       drawFromArray(Points, 1, 0, false);</td><td> </td><td class="right">       drawFromArray(Points, 1, 0, false);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       enableClientStates(false);</td><td> </td><td class="right">       enableClientStates(false);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">/*************************************************************************</td><td> </td><td class="right">/*************************************************************************</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"> Draw a line between the 2 points.</td><td> </td><td class="right"> Draw a line between the 2 points.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">*************************************************************************/</td><td> </td><td class="right">*************************************************************************/</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0072" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">void StelPainter::drawLine2d(<span class="delete">double x1, double y1, double x2, double</span> y2)</td><td> </td><td class="rblock">void StelPainter::drawLine2d(<span class="insert">float x1, float y1, float x2, float</span> y2)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       static float vertexData[] = {0.,0.,0.,0.};</td><td> </td><td class="right">       static float vertexData[] = {0.,0.,0.,0.};</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       vertexData[0]=x1;</td><td> </td><td class="right">       vertexData[0]=x1;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       vertexData[1]=y1;</td><td> </td><td class="right">       vertexData[1]=y1;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       vertexData[2]=x2;</td><td> </td><td class="right">       vertexData[2]=x2;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       vertexData[3]=y2;</td><td> </td><td class="right">       vertexData[3]=y2;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       enableClientStates(true);</td><td> </td><td class="right">       enableClientStates(true);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       setVertexPointer(2, GL_FLOAT, vertexData);</td><td> </td><td class="right">       setVertexPointer(2, GL_FLOAT, vertexData);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       drawFromArray(Lines, 2, 0, false);</td><td> </td><td class="right">       drawFromArray(Lines, 2, 0, false);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       enableClientStates(false);</td><td> </td><td class="right">       enableClientStates(false);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">///////////////////////////////////////////////////////////////////////////</td><td> </td><td class="right">///////////////////////////////////////////////////////////////////////////</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// Drawing methods for general (non-linear) mode</td><td> </td><td class="right">// Drawing methods for general (non-linear) mode</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0073" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">void StelPainter::sSphere(<span class="delete">double radius, double oneMinusOblateness, int sli
ce</span>s, int stacks, int orientInside, bool flipTexture)</td><td> </td><td class="rblock">void StelPainter::sSphere(<span class="insert">float radius, float oneMinusOblateness, int slice
</span>s, int stacks, int orientInside, bool flipTexture)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // It is really good for performance to have Vec4f,Vec3f objects</td><td> </td><td class="right">       // It is really good for performance to have Vec4f,Vec3f objects</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // static rather than on the stack. But why?</td><td> </td><td class="right">       // static rather than on the stack. But why?</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Is the constructor/destructor so expensive?</td><td> </td><td class="right">       // Is the constructor/destructor so expensive?</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       static Vec3f lightPos3;</td><td> </td><td class="right">       static Vec3f lightPos3;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0074" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">float c;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                                                           </td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       static Vec4f ambientLight;</td><td> </td><td class="right">       static Vec4f ambientLight;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       static Vec4f diffuseLight;</td><td> </td><td class="right">       static Vec4f diffuseLight;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0075" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                                                           </td><td> </td><td class="rblock">       <span class="insert">float c;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       bool isLightOn = light.isEnabled();</td><td> </td><td class="rblock"><span class="insert">       const</span> bool isLightOn = light.isEnabled();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                                                           </td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (isLightOn)</td><td> </td><td class="right">       if (isLightOn)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               lightPos3.set(light.getPosition()[0], light.getPosition()[1]
, light.getPosition()[2]);</td><td> </td><td class="right">               lightPos3.set(light.getPosition()[0], light.getPosition()[1]
, light.getPosition()[2]);</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0076" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               lightPos3 -= <span class="delete">prj-&gt;modelViewMatrix</span> * <span class="delete">Vec3d(0.,0.,0.); // -pos</span></td><td> </td><td class="rblock">               lightPos3 -= <span class="insert">prj-&gt;modelViewMatrixf</span> * <span class="insert">Vec3f(0.f);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">CenterEye</span></td><td> </td><td class="rblock">               lightPos3 = <span class="insert">prj-&gt;modelViewMatrixf.transpose().multiplyWithou</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               lightPos3 = <span class="delete">prj-&gt;modelViewMatrix.transpose().multiplyWithout</span></td><td> </td><td class="rblock"><span class="insert">tTranslation(lightPos3);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">Translation(lightPos3);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               lightPos3.normalize();</td><td> </td><td class="right">               lightPos3.normalize();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               ambientLight = light.getAmbient();</td><td> </td><td class="right">               ambientLight = light.getAmbient();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               diffuseLight = light.getDiffuse();</td><td> </td><td class="right">               diffuseLight = light.getDiffuse();</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0077" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               light.disable();</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       GLfloat x, y, z;</td><td> </td><td class="right">       GLfloat x, y, z;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       GLfloat s=0.f, t=0.f;</td><td> </td><td class="right">       GLfloat s=0.f, t=0.f;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       GLint i, j;</td><td> </td><td class="right">       GLint i, j;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       GLfloat nsign;</td><td> </td><td class="right">       GLfloat nsign;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (orientInside)</td><td> </td><td class="right">       if (orientInside)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0078" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               nsign = <span class="delete">-1.0;</span></td><td> </td><td class="rblock">               nsign = <span class="insert">-1.f;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               t=0.0;</span> // from inside texture is reversed</td><td> </td><td class="rblock"><span class="insert">               t=0.f;</span> // from inside texture is reversed</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       else</td><td> </td><td class="right">       else</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0079" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               nsign = <span class="delete">1.0;</span></td><td> </td><td class="rblock">               nsign = <span class="insert">1.f;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               t=1.0;</span></td><td> </td><td class="rblock"><span class="insert">               t=1.f;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0080" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       const <span class="delete">double</span> drho = M_PI / stacks;</td><td> </td><td class="rblock">       const <span class="insert">float</span> drho = M_PI / stacks;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Q_ASSERT(stacks&lt;=MAX_STACKS);</td><td> </td><td class="right">       Q_ASSERT(stacks&lt;=MAX_STACKS);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       ComputeCosSinRho(drho,stacks);</td><td> </td><td class="right">       ComputeCosSinRho(drho,stacks);</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0081" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">double *</span>cos_sin_rho_p;</td><td> </td><td class="rblock">       <span class="insert">float* </span>cos_sin_rho_p;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0082" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       const <span class="delete">double dtheta = 2.0</span> * M_PI / slices;</td><td> </td><td class="rblock">       const <span class="insert">float dtheta = 2.f</span> * M_PI / slices;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Q_ASSERT(slices&lt;=MAX_SLICES);</td><td> </td><td class="right">       Q_ASSERT(slices&lt;=MAX_SLICES);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       ComputeCosSinTheta(dtheta,slices);</td><td> </td><td class="right">       ComputeCosSinTheta(dtheta,slices);</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0083" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       const <span class="delete">double</span> *cos_sin_theta_p;</td><td> </td><td class="rblock">       const <span class="insert">float</span> *cos_sin_theta_p;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // texturing: s goes from 0.0/0.25/0.5/0.75/1.0 at +y/+x/-y/-x/+y ax
is</td><td> </td><td class="right">       // texturing: s goes from 0.0/0.25/0.5/0.75/1.0 at +y/+x/-y/-x/+y ax
is</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // t goes from -1.0/+1.0 at z = -radius/+radius (linear along longit
udes)</td><td> </td><td class="right">       // t goes from -1.0/+1.0 at z = -radius/+radius (linear along longit
udes)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // cannot use triangle fan on texturing (s coord. at top/bottom tip 
varies)</td><td> </td><td class="right">       // cannot use triangle fan on texturing (s coord. at top/bottom tip 
varies)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // If the texture is flipped, we iterate the coordinates backward.</td><td> </td><td class="right">       // If the texture is flipped, we iterate the coordinates backward.</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0084" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       const GLfloat ds = (<span class="delete">(flipTexture) ? -1 : 1) * 1.0</span> / slices;</td><td> </td><td class="rblock">       const GLfloat ds = (<span class="insert">flipTexture ? -1.f : 1.f)</span> / slices;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const GLfloat dt = nsign / stacks; // from inside texture is reverse
d</td><td> </td><td class="right">       const GLfloat dt = nsign / stacks; // from inside texture is reverse
d</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // draw intermediate  as quad strips</td><td> </td><td class="right">       // draw intermediate  as quad strips</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       static QVector&lt;double&gt; vertexArr;</td><td> </td><td class="right">       static QVector&lt;double&gt; vertexArr;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       static QVector&lt;float&gt; texCoordArr;</td><td> </td><td class="right">       static QVector&lt;float&gt; texCoordArr;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       static QVector&lt;float&gt; colorArr;</td><td> </td><td class="right">       static QVector&lt;float&gt; colorArr;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0085" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">static QVector&lt;unsigned int&gt; indiceArr;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       texCoordArr.resize(0);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       vertexArr.resize(0);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       colorArr.resize(0);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       indiceArr.resize(0);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       for (i = 0,cos_sin_rho_p = cos_sin_rho; i &lt; stacks; ++i,cos_sin_rho_
p+=2)</td><td> </td><td class="right">       for (i = 0,cos_sin_rho_p = cos_sin_rho; i &lt; stacks; ++i,cos_sin_rho_
p+=2)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0086" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               <span class="delete">texCoordArr.resize(0);</span></td><td> </td><td class="rblock">               s = <span class="insert">!flipTexture</span> ? <span class="insert">0.f</span> : <span class="insert">1.f;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               vertexArr.resize(0);</span></td><td> </td><td class="rblock">               for (j = 0,cos_sin_theta_p = cos_sin_theta; <span class="insert">j&lt;=slices;++j,co</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               colorArr.resize(0);</span></td><td> </td><td class="rblock"><span class="insert">s_sin_theta_p+=2)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               s = <span class="delete">(!flipTexture)</span> ? <span class="delete">0.0</span> : <span class="delete">1.0;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               for (j = 0,cos_sin_theta_p = cos_sin_theta; <span class="delete">j &lt;= slices;++j,</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">cos_sin_theta_p+=2)</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       x = -cos_sin_theta_p[1] * cos_sin_rho_p[1];</td><td> </td><td class="right">                       x = -cos_sin_theta_p[1] * cos_sin_rho_p[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       y = cos_sin_theta_p[0] * cos_sin_rho_p[1];</td><td> </td><td class="right">                       y = cos_sin_theta_p[0] * cos_sin_rho_p[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       z = nsign * cos_sin_rho_p[0];</td><td> </td><td class="right">                       z = nsign * cos_sin_rho_p[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       texCoordArr &lt;&lt; s &lt;&lt; t;</td><td> </td><td class="right">                       texCoordArr &lt;&lt; s &lt;&lt; t;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       if (isLightOn)</td><td> </td><td class="right">                       if (isLightOn)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       {</td><td> </td><td class="right">                       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               c = nsign * (lightPos3[0]*x*oneMinusOblatene
ss + lightPos3[1]*y*oneMinusOblateness + lightPos3[2]*z);</td><td> </td><td class="right">                               c = nsign * (lightPos3[0]*x*oneMinusOblatene
ss + lightPos3[1]*y*oneMinusOblateness + lightPos3[2]*z);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               if (c&lt;0) {c=0;}</td><td> </td><td class="right">                               if (c&lt;0) {c=0;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               colorArr &lt;&lt; c*diffuseLight[0] + ambientLight
[0] &lt;&lt; c*diffuseLight[1] + ambientLight[1] &lt;&lt; c*diffuseLight[2] + ambientLi
ght[2];</td><td> </td><td class="right">                               colorArr &lt;&lt; c*diffuseLight[0] + ambientLight
[0] &lt;&lt; c*diffuseLight[1] + ambientLight[1] &lt;&lt; c*diffuseLight[2] + ambientLi
ght[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l13" /><small>skipping to change at</small><em> line 1477</em></th><th> </th><th><a name="part-r13" /><small>skipping to change at</small><em> line 1587</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       texCoordArr &lt;&lt; s &lt;&lt; t - dt;</td><td> </td><td class="right">                       texCoordArr &lt;&lt; s &lt;&lt; t - dt;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       if (isLightOn)</td><td> </td><td class="right">                       if (isLightOn)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       {</td><td> </td><td class="right">                       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               c = nsign * (lightPos3[0]*x*oneMinusOblatene
ss + lightPos3[1]*y*oneMinusOblateness + lightPos3[2]*z);</td><td> </td><td class="right">                               c = nsign * (lightPos3[0]*x*oneMinusOblatene
ss + lightPos3[1]*y*oneMinusOblateness + lightPos3[2]*z);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               if (c&lt;0) {c=0;}</td><td> </td><td class="right">                               if (c&lt;0) {c=0;}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                               colorArr &lt;&lt; c*diffuseLight[0] + ambientLight
[0] &lt;&lt; c*diffuseLight[1] + ambientLight[1] &lt;&lt; c*diffuseLight[2] + ambientLi
ght[2];</td><td> </td><td class="right">                               colorArr &lt;&lt; c*diffuseLight[0] + ambientLight
[0] &lt;&lt; c*diffuseLight[1] + ambientLight[1] &lt;&lt; c*diffuseLight[2] + ambientLi
ght[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       }</td><td> </td><td class="right">                       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       vertexArr &lt;&lt; x * radius &lt;&lt; y * radius &lt;&lt; z * oneMinu
sOblateness * radius;</td><td> </td><td class="right">                       vertexArr &lt;&lt; x * radius &lt;&lt; y * radius &lt;&lt; z * oneMinu
sOblateness * radius;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       s += ds;</td><td> </td><td class="right">                       s += ds;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0087" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               <span class="delete">// Draw the array now</span></td><td> </td><td class="rblock">               <span class="insert">unsigned int offset = i*(slices+1)*2;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               if (isLightOn)</span></td><td> </td><td class="rblock"><span class="insert">               for (j = 2;j&lt;slices*2+2;j+=2)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       setArrays((Vec3d*)vertexArr.constData(), (Vec2f*)tex</span></td><td> </td><td class="rblock"><span class="insert">               {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">CoordArr.constData(), (Vec3f*)colorArr.constData());</span></td><td> </td><td class="rblock"><span class="insert">                       indiceArr &lt;&lt; offset+j-2 &lt;&lt; offset+j-1 &lt;&lt; offset+j;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               else</span></td><td> </td><td class="rblock"><span class="insert">                       indiceArr &lt;&lt; offset+j &lt;&lt; offset+j-1 &lt;&lt; offset+j+1;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       setArrays((Vec3d*)vertexArr.constData(), (Vec2f*)tex</span></td><td> </td><td class="rblock"><span class="insert">               }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">CoordArr.constData());</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">               drawFromArray(TriangleStrip, vertexArr.size()/3);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               t -= dt;</td><td> </td><td class="right">               t -= dt;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0088" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       // Draw the array now</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (isLightOn)</td><td> </td><td class="right">       if (isLightOn)</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0089" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               <span class="delete">light.enable();</span></td><td> </td><td class="rblock">               <span class="insert">setArrays((Vec3d*)vertexArr.constData(), (Vec2f*)texCoordArr</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">.constData(), (Vec3f*)colorArr.constData());</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       else</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               setArrays((Vec3d*)vertexArr.constData(), (Vec2f*)texCoordArr</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">.constData());</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       drawFromArray(Triangles, indiceArr.size(), 0, true, indiceArr.constD</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ata());</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0090" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">// Reimplementation of gluCylinder : glu is overrided for non standard proj</span></td><td> </td><td class="rblock"><span class="insert">StelVertexArray StelPainter::computeSphereNoLight(float</span> radius, <span class="insert">float oneMi</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">ection</span></td><td> </td><td class="rblock"><span class="insert">nusOblateness,</span> int slices, int <span class="insert">stacks, int orientInside, bool flipTexture)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">void StelPainter::sCylinder(double</span> radius, <span class="delete">double height,</span> int slices, int <span class="delete">o</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">rientInside)</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0091" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">StelVertexArray result(StelVertexArray::Triangles);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       GLfloat x, y, z;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       GLfloat s=0.f, t=0.f;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       GLint i, j;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       GLfloat nsign;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (orientInside)</td><td> </td><td class="right">       if (orientInside)</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0092" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               <span class="delete">glCullFace(GL_FRONT);</span></td><td> </td><td class="rblock">       <span class="insert">{</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               nsign = -1.f;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               t=0.f; // from inside texture is reversed</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       else</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               nsign = 1.f;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               t=1.f;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0093" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       const float <span class="delete">da</span> = <span class="delete">2.0 *</span> M_PI / <span class="delete">slices;</span></td><td> </td><td class="rblock">       const float <span class="insert">drho</span> = M_PI / <span class="insert">stacks;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       Q_ASSERT(stacks&lt;=MAX_STACKS);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       ComputeCosSinRho(drho,stacks);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       float* cos_sin_rho_p;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0094" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       float <span class="delete">ds</span> = <span class="delete">1.0</span> / slices;</td><td> </td><td class="rblock">       <span class="insert">const</span> float <span class="insert">dtheta</span> = <span class="insert">2.f * M_PI</span> / slices;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">QVarLengthArray&lt;Vec2f, 128&gt; texCoordArray;</span></td><td> </td><td class="rblock">       <span class="insert">Q_ASSERT(slices&lt;=MAX_SLICES);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       QVarLengthArray&lt;Vec3d, 128&gt; vertexArray;</span></td><td> </td><td class="rblock"><span class="insert">       ComputeCosSinTheta(dtheta,slices);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       float s = <span class="delete">0.f;</span></td><td> </td><td class="rblock"><span class="insert">       const</span> float <span class="insert">*cos_sin_theta_p;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       float x, y;</span></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       for <span class="delete">(int i</span> = <span class="delete">0;</span> i <span class="delete">&lt;= slices; i++)</span></td><td> </td><td class="rblock"><span class="insert">       // texturing:</span> s <span class="insert">goes from 0.0/0.25/0.5/0.75/1.0 at +y/+x/-y/-x/+y ax</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">is</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       // t goes from -1.0/+1.0 at z</span> = <span class="insert">-radius/+radius (linear along longit</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">udes)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       // cannot use triangle fan on texturing (s coord. at top/bottom tip </span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">varies)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       // If the texture is flipped, we iterate the coordinates backward.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       const GLfloat ds = (flipTexture ? -1.f : 1.f) / slices;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       const GLfloat dt = nsign / stacks; // from inside texture is reverse</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">d</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       // draw intermediate  as quad strips</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       for <span class="insert">(i</span> = <span class="insert">0,cos_sin_rho_p = cos_sin_rho;</span> i <span class="insert">&lt; stacks; ++i,cos_sin_rho_</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">p+=2)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0095" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               <span class="delete">if (i == slices)</span></td><td> </td><td class="rblock">               <span class="insert">s = !flipTexture ? 0.f : 1.f;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               for (j = 0,cos_sin_theta_p = cos_sin_theta; j&lt;=slices;++j,co</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">s_sin_theta_p+=2)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0096" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       x = <span class="delete">0.f;</span></td><td> </td><td class="rblock">                       x = <span class="insert">-cos_sin_theta_p[1] * cos_sin_rho_p[1];</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       y = <span class="delete">1.f;</span></td><td> </td><td class="rblock">                       y = <span class="insert">cos_sin_theta_p[0] * cos_sin_rho_p[1];</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       z = nsign * cos_sin_rho_p[0];</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       result.texCoords &lt;&lt; Vec2f(s,t);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       result.vertex &lt;&lt; Vec3d(x*radius, y*radius, z*oneMinu</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">sOblateness*radius);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       x = -cos_sin_theta_p[1] * cos_sin_rho_p[3];</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       y = cos_sin_theta_p[0] * cos_sin_rho_p[3];</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       z = nsign * cos_sin_rho_p[2];</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       result.texCoords &lt;&lt; Vec2f(s, t-dt);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       result.vertex &lt;&lt; Vec3d(x*radius, y*radius, z*oneMinu</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">sOblateness*radius);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       s += ds;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0097" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               <span class="delete">else</span></td><td> </td><td class="rblock">               <span class="insert">unsigned int offset = i*(slices+1)*2;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               for (j = 2;j&lt;slices*2+2;j+=2)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0098" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                       <span class="delete">x = std::sin(da*i);</span></td><td> </td><td class="rblock">                       <span class="insert">result.indices &lt;&lt; offset+j-2 &lt;&lt; offset+j-1 &lt;&lt; offset</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                       y = std::cos(da*i);</span></td><td> </td><td class="rblock"><span class="insert">+j;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       result.indices &lt;&lt; offset+j &lt;&lt; offset+j-1 &lt;&lt; offset+j</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">+1;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0099" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">               <span class="insert">t -= dt;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       return result;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //setArrays((Vec3d*)vertexArr.constData(), (Vec2f*)texCoordArr.const</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">Data());</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //drawFromArray(Triangles, indiceArr.size(), 0, true, indiceArr.cons</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">tData());</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">}</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">// Reimplementation of gluCylinder : glu is overrided for non standard proj</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ection</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">void StelPainter::sCylinder(float radius, float height, int slices, int ori</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">entInside)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">{</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       if (orientInside)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               glCullFace(GL_FRONT);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       static QVarLengthArray&lt;Vec2f, 512&gt; texCoordArray;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       static QVarLengthArray&lt;Vec3d, 512&gt; vertexArray;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       texCoordArray.clear();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       vertexArray.clear();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       float s = 0.f;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       float x, y;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       const float ds = 1.f / slices;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       const float da = 2.f * M_PI / slices;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       for (int i = 0; i &lt;= slices; ++i)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               x = std::sin(da*i);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               y = std::cos(da*i);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               texCoordArray.append(Vec2f(s, 0.f));</td><td> </td><td class="right">               texCoordArray.append(Vec2f(s, 0.f));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               vertexArray.append(Vec3d(x*radius, y*radius, 0.));</td><td> </td><td class="right">               vertexArray.append(Vec3d(x*radius, y*radius, 0.));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               texCoordArray.append(Vec2f(s, 1.f));</td><td> </td><td class="right">               texCoordArray.append(Vec2f(s, 1.f));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               vertexArray.append(Vec3d(x*radius, y*radius, height));</td><td> </td><td class="right">               vertexArray.append(Vec3d(x*radius, y*radius, height));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               s += ds;</td><td> </td><td class="right">               s += ds;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       setArrays(vertexArray.constData(), texCoordArray.constData());</td><td> </td><td class="right">       setArrays(vertexArray.constData(), texCoordArray.constData());</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       drawFromArray(TriangleStrip, vertexArray.size());</td><td> </td><td class="right">       drawFromArray(TriangleStrip, vertexArray.size());</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (orientInside)</td><td> </td><td class="right">       if (orientInside)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               glCullFace(GL_BACK);</td><td> </td><td class="right">               glCullFace(GL_BACK);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void StelPainter::setPointSize(qreal size)</td><td> </td><td class="right">void StelPainter::setPointSize(qreal size)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#ifndef STELPAINTER_GL2</td><td> </td><td class="right">#ifndef STELPAINTER_GL2</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       glPointSize(size);</td><td> </td><td class="right">       glPointSize(size);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#else</td><td> </td><td class="right">#else</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0100" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">#warning GL ES2 to be done</span></td><td> </td><td class="rblock"><span class="insert">       Q_UNUSED(size);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#endif</td><td> </td><td class="right">#endif</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void StelPainter::setShadeModel(ShadeModel m)</td><td> </td><td class="right">void StelPainter::setShadeModel(ShadeModel m)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#ifndef STELPAINTER_GL2</td><td> </td><td class="right">#ifndef STELPAINTER_GL2</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       glShadeModel(m);</td><td> </td><td class="right">       glShadeModel(m);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#else</td><td> </td><td class="right">#else</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0101" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">#warning GL ES2 to be done</span></td><td> </td><td class="rblock"><span class="insert">       Q_UNUSED(m);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#endif</td><td> </td><td class="right">#endif</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void StelPainter::enableTexture2d(bool b)</td><td> </td><td class="right">void StelPainter::enableTexture2d(bool b)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#ifndef STELPAINTER_GL2</td><td> </td><td class="right">#ifndef STELPAINTER_GL2</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (b)</td><td> </td><td class="right">       if (b)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               glEnable(GL_TEXTURE_2D);</td><td> </td><td class="right">               glEnable(GL_TEXTURE_2D);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       else</td><td> </td><td class="right">       else</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               glDisable(GL_TEXTURE_2D);</td><td> </td><td class="right">               glDisable(GL_TEXTURE_2D);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#else</td><td> </td><td class="right">#else</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       texture2dEnabled = b;</td><td> </td><td class="right">       texture2dEnabled = b;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#endif</td><td> </td><td class="right">#endif</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0102" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">void StelPainter::initSystemGLInfo()</td><td> </td><td class="rblock">void StelPainter::initSystemGLInfo(<span class="insert">QGLContext* ctx</span>)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0103" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">Q_ASSERT(glContext==NULL);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       glContext = ctx;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#ifdef STELPAINTER_GL2</td><td> </td><td class="right">#ifdef STELPAINTER_GL2</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Basic shader: just vertex filled with plain color</td><td> </td><td class="right">       // Basic shader: just vertex filled with plain color</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       QGLShader *vshader3 = new QGLShader(QGLShader::Vertex);</td><td> </td><td class="right">       QGLShader *vshader3 = new QGLShader(QGLShader::Vertex);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const char *vsrc3 =</td><td> </td><td class="right">       const char *vsrc3 =</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               "attribute mediump vec3 vertex;\n"</td><td> </td><td class="right">               "attribute mediump vec3 vertex;\n"</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               "uniform mediump mat4 projectionMatrix;\n"</td><td> </td><td class="right">               "uniform mediump mat4 projectionMatrix;\n"</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               "void main(void)\n"</td><td> </td><td class="right">               "void main(void)\n"</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               "{\n"</td><td> </td><td class="right">               "{\n"</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               "    gl_Position = projectionMatrix*vec4(vertex, 1.);\n"</td><td> </td><td class="right">               "    gl_Position = projectionMatrix*vec4(vertex, 1.);\n"</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               "}\n";</td><td> </td><td class="right">               "}\n";</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l14" /><small>skipping to change at</small><em> line 1644</em></th><th> </th><th><a name="part-r14" /><small>skipping to change at</small><em> line 1820</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               "}\n";</td><td> </td><td class="right">               "}\n";</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       fshader2-&gt;compileSourceCode(fsrc2);</td><td> </td><td class="right">       fshader2-&gt;compileSourceCode(fsrc2);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       texturesShaderProgram = new QGLShaderProgram(QGLContext::currentCont
ext());</td><td> </td><td class="right">       texturesShaderProgram = new QGLShaderProgram(QGLContext::currentCont
ext());</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       texturesShaderProgram-&gt;addShader(vshader2);</td><td> </td><td class="right">       texturesShaderProgram-&gt;addShader(vshader2);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       texturesShaderProgram-&gt;addShader(fshader2);</td><td> </td><td class="right">       texturesShaderProgram-&gt;addShader(fshader2);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       texturesShaderProgram-&gt;link();</td><td> </td><td class="right">       texturesShaderProgram-&gt;link();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       texturesShaderVars.projectionMatrix = texturesShaderProgram-&gt;uniform
Location("projectionMatrix");</td><td> </td><td class="right">       texturesShaderVars.projectionMatrix = texturesShaderProgram-&gt;uniform
Location("projectionMatrix");</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       texturesShaderVars.texCoord = texturesShaderProgram-&gt;attributeLocati
on("texCoord");</td><td> </td><td class="right">       texturesShaderVars.texCoord = texturesShaderProgram-&gt;attributeLocati
on("texCoord");</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       texturesShaderVars.vertex = texturesShaderProgram-&gt;attributeLocation
("vertex");</td><td> </td><td class="right">       texturesShaderVars.vertex = texturesShaderProgram-&gt;attributeLocation
("vertex");</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       texturesShaderVars.texColor = texturesShaderProgram-&gt;uniformLocation
("texColor");</td><td> </td><td class="right">       texturesShaderVars.texColor = texturesShaderProgram-&gt;uniformLocation
("texColor");</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0104" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       texturesShaderVars.texture = texturesShaderProgram-&gt;uniformLocation(
"tex");</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Texture shader program + interpolated color per vertex</td><td> </td><td class="right">       // Texture shader program + interpolated color per vertex</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       QGLShader *vshader4 = new QGLShader(QGLShader::Vertex);</td><td> </td><td class="right">       QGLShader *vshader4 = new QGLShader(QGLShader::Vertex);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const char *vsrc4 =</td><td> </td><td class="right">       const char *vsrc4 =</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               "attribute highp vec3 vertex;\n"</td><td> </td><td class="right">               "attribute highp vec3 vertex;\n"</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               "attribute mediump vec2 texCoord;\n"</td><td> </td><td class="right">               "attribute mediump vec2 texCoord;\n"</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               "attribute mediump vec4 color;\n"</td><td> </td><td class="right">               "attribute mediump vec4 color;\n"</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               "uniform mediump mat4 projectionMatrix;\n"</td><td> </td><td class="right">               "uniform mediump mat4 projectionMatrix;\n"</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               "varying mediump vec2 texc;\n"</td><td> </td><td class="right">               "varying mediump vec2 texc;\n"</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               "varying mediump vec4 outColor;\n"</td><td> </td><td class="right">               "varying mediump vec4 outColor;\n"</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l15" /><small>skipping to change at</small><em> line 1679</em></th><th> </th><th><a name="part-r15" /><small>skipping to change at</small><em> line 1856</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               "}\n";</td><td> </td><td class="right">               "}\n";</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       fshader4-&gt;compileSourceCode(fsrc4);</td><td> </td><td class="right">       fshader4-&gt;compileSourceCode(fsrc4);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       texturesColorShaderProgram = new QGLShaderProgram(QGLContext::curren
tContext());</td><td> </td><td class="right">       texturesColorShaderProgram = new QGLShaderProgram(QGLContext::curren
tContext());</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       texturesColorShaderProgram-&gt;addShader(vshader4);</td><td> </td><td class="right">       texturesColorShaderProgram-&gt;addShader(vshader4);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       texturesColorShaderProgram-&gt;addShader(fshader4);</td><td> </td><td class="right">       texturesColorShaderProgram-&gt;addShader(fshader4);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       texturesColorShaderProgram-&gt;link();</td><td> </td><td class="right">       texturesColorShaderProgram-&gt;link();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       texturesColorShaderVars.projectionMatrix = texturesColorShaderProgra
m-&gt;uniformLocation("projectionMatrix");</td><td> </td><td class="right">       texturesColorShaderVars.projectionMatrix = texturesColorShaderProgra
m-&gt;uniformLocation("projectionMatrix");</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       texturesColorShaderVars.texCoord = texturesColorShaderProgram-&gt;attri
buteLocation("texCoord");</td><td> </td><td class="right">       texturesColorShaderVars.texCoord = texturesColorShaderProgram-&gt;attri
buteLocation("texCoord");</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       texturesColorShaderVars.vertex = texturesColorShaderProgram-&gt;attribu
teLocation("vertex");</td><td> </td><td class="right">       texturesColorShaderVars.vertex = texturesColorShaderProgram-&gt;attribu
teLocation("vertex");</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       texturesColorShaderVars.color = texturesColorShaderProgram-&gt;attribut
eLocation("color");</td><td> </td><td class="right">       texturesColorShaderVars.color = texturesColorShaderProgram-&gt;attribut
eLocation("color");</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0105" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       texturesColorShaderVars.texture = texturesColorShaderProgram-&gt;unifor
mLocation("tex");</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#endif</td><td> </td><td class="right">#endif</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void StelPainter::setArrays(const Vec3d* vertice, const Vec2f* texCoords, c
onst Vec3f* colorArray, const Vec3f* normalArray)</td><td> </td><td class="right">void StelPainter::setArrays(const Vec3d* vertice, const Vec2f* texCoords, c
onst Vec3f* colorArray, const Vec3f* normalArray)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       enableClientStates(vertice, texCoords, colorArray, normalArray);</td><td> </td><td class="right">       enableClientStates(vertice, texCoords, colorArray, normalArray);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       setVertexPointer(3, GL_DOUBLE, vertice);</td><td> </td><td class="right">       setVertexPointer(3, GL_DOUBLE, vertice);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       setTexCoordPointer(2, GL_FLOAT, texCoords);</td><td> </td><td class="right">       setTexCoordPointer(2, GL_FLOAT, texCoords);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       setColorPointer(3, GL_FLOAT, colorArray);</td><td> </td><td class="right">       setColorPointer(3, GL_FLOAT, colorArray);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       setNormalPointer(GL_FLOAT, normalArray);</td><td> </td><td class="right">       setNormalPointer(GL_FLOAT, normalArray);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l16" /><small>skipping to change at</small><em> line 1760</em></th><th> </th><th><a name="part-r16" /><small>skipping to change at</small><em> line 1938</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       else if (texCoordArray.enabled &amp;&amp; !colorArray.enabled &amp;&amp; !normalArra
y.enabled)</td><td> </td><td class="right">       else if (texCoordArray.enabled &amp;&amp; !colorArray.enabled &amp;&amp; !normalArra
y.enabled)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               pr = texturesShaderProgram;</td><td> </td><td class="right">               pr = texturesShaderProgram;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               pr-&gt;bind();</td><td> </td><td class="right">               pr-&gt;bind();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               pr-&gt;setAttributeArray(texturesShaderVars.vertex, (const GLfl
oat*)projectedVertexArray.pointer, projectedVertexArray.size);</td><td> </td><td class="right">               pr-&gt;setAttributeArray(texturesShaderVars.vertex, (const GLfl
oat*)projectedVertexArray.pointer, projectedVertexArray.size);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               pr-&gt;enableAttributeArray(texturesShaderVars.vertex);</td><td> </td><td class="right">               pr-&gt;enableAttributeArray(texturesShaderVars.vertex);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               pr-&gt;setUniformValue(texturesShaderVars.projectionMatrix, qMa
t);</td><td> </td><td class="right">               pr-&gt;setUniformValue(texturesShaderVars.projectionMatrix, qMa
t);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               pr-&gt;setUniformValue(texturesShaderVars.texColor, currentColo
r[0], currentColor[1], currentColor[2], currentColor[3]);</td><td> </td><td class="right">               pr-&gt;setUniformValue(texturesShaderVars.texColor, currentColo
r[0], currentColor[1], currentColor[2], currentColor[3]);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               pr-&gt;setAttributeArray(texturesShaderVars.texCoord, (const GL
float*)texCoordArray.pointer, 2);</td><td> </td><td class="right">               pr-&gt;setAttributeArray(texturesShaderVars.texCoord, (const GL
float*)texCoordArray.pointer, 2);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               pr-&gt;enableAttributeArray(texturesShaderVars.texCoord);</td><td> </td><td class="right">               pr-&gt;enableAttributeArray(texturesShaderVars.texCoord);</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0106" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               //pr-&gt;setUniformValue(texturesShaderVars.texture, 0);    // 
use texture unit 0</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       else if (texCoordArray.enabled &amp;&amp; colorArray.enabled &amp;&amp; !normalArray
.enabled)</td><td> </td><td class="right">       else if (texCoordArray.enabled &amp;&amp; colorArray.enabled &amp;&amp; !normalArray
.enabled)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               pr = texturesColorShaderProgram;</td><td> </td><td class="right">               pr = texturesColorShaderProgram;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               pr-&gt;bind();</td><td> </td><td class="right">               pr-&gt;bind();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               pr-&gt;setAttributeArray(texturesColorShaderVars.vertex, (const
 GLfloat*)projectedVertexArray.pointer, projectedVertexArray.size);</td><td> </td><td class="right">               pr-&gt;setAttributeArray(texturesColorShaderVars.vertex, (const
 GLfloat*)projectedVertexArray.pointer, projectedVertexArray.size);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               pr-&gt;enableAttributeArray(texturesColorShaderVars.vertex);</td><td> </td><td class="right">               pr-&gt;enableAttributeArray(texturesColorShaderVars.vertex);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               pr-&gt;setUniformValue(texturesColorShaderVars.projectionMatrix
, qMat);</td><td> </td><td class="right">               pr-&gt;setUniformValue(texturesColorShaderVars.projectionMatrix
, qMat);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               pr-&gt;setAttributeArray(texturesColorShaderVars.texCoord, (con
st GLfloat*)texCoordArray.pointer, 2);</td><td> </td><td class="right">               pr-&gt;setAttributeArray(texturesColorShaderVars.texCoord, (con
st GLfloat*)texCoordArray.pointer, 2);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               pr-&gt;enableAttributeArray(texturesColorShaderVars.texCoord);</td><td> </td><td class="right">               pr-&gt;enableAttributeArray(texturesColorShaderVars.texCoord);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               pr-&gt;setAttributeArray(texturesColorShaderVars.color, (const 
GLfloat*)colorArray.pointer, colorArray.size);</td><td> </td><td class="right">               pr-&gt;setAttributeArray(texturesColorShaderVars.color, (const 
GLfloat*)colorArray.pointer, colorArray.size);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               pr-&gt;enableAttributeArray(texturesColorShaderVars.color);</td><td> </td><td class="right">               pr-&gt;enableAttributeArray(texturesColorShaderVars.color);</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0107" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               //pr-&gt;setUniformValue(texturesShaderVars.texture, 0);    // 
use texture unit 0</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       else</td><td> </td><td class="right">       else</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               qDebug() &lt;&lt; "Unhandled parameters." &lt;&lt; texCoordArray.enabled
 &lt;&lt; colorArray.enabled &lt;&lt; normalArray.enabled;</td><td> </td><td class="right">               qDebug() &lt;&lt; "Unhandled parameters." &lt;&lt; texCoordArray.enabled
 &lt;&lt; colorArray.enabled &lt;&lt; normalArray.enabled;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               qDebug() &lt;&lt; "Light: " &lt;&lt; light.isEnabled();</td><td> </td><td class="right">               qDebug() &lt;&lt; "Light: " &lt;&lt; light.isEnabled();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return;</td><td> </td><td class="right">               return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#endif</td><td> </td><td class="right">#endif</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (indices)</td><td> </td><td class="right">       if (indices)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               glDrawElements(mode, count, GL_UNSIGNED_INT, indices + offse
t);</td><td> </td><td class="right">               glDrawElements(mode, count, GL_UNSIGNED_INT, indices + offse
t);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l17" /><small>skipping to change at</small><em> line 1857</em></th><th> </th><th><a name="part-r17" /><small>skipping to change at</small><em> line 2037</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       ret.pointer = polygonVertexArray.constData();</td><td> </td><td class="right">       ret.pointer = polygonVertexArray.constData();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       ret.enabled = array.enabled;</td><td> </td><td class="right">       ret.enabled = array.enabled;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       return ret;</td><td> </td><td class="right">       return ret;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// Light methods</td><td> </td><td class="right">// Light methods</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void StelPainterLight::setPosition(const Vec4f&amp; v)</td><td> </td><td class="right">void StelPainterLight::setPosition(const Vec4f&amp; v)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       position = v;</td><td> </td><td class="right">       position = v;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0108" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">#ifndef STELPAINTER_GL2</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       glLightfv(GL_LIGHT0 + light, GL_POSITION, v);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">#endif</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void StelPainterLight::setDiffuse(const Vec4f&amp; v)</td><td> </td><td class="right">void StelPainterLight::setDiffuse(const Vec4f&amp; v)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       diffuse = v;</td><td> </td><td class="right">       diffuse = v;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0109" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">#ifndef STELPAINTER_GL2</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       glLightfv(GL_LIGHT0 + light, GL_DIFFUSE, v);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">#endif</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void StelPainterLight::setSpecular(const Vec4f&amp; v)</td><td> </td><td class="right">void StelPainterLight::setSpecular(const Vec4f&amp; v)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       specular = v;</td><td> </td><td class="right">       specular = v;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0110" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">#ifndef STELPAINTER_GL2</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       glLightfv(GL_LIGHT0 + light, GL_SPECULAR, v);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">#endif</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void StelPainterLight::setAmbient(const Vec4f&amp; v)</td><td> </td><td class="right">void StelPainterLight::setAmbient(const Vec4f&amp; v)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       ambient = v;</td><td> </td><td class="right">       ambient = v;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0111" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">#ifndef STELPAINTER_GL2</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       glLightfv(GL_LIGHT0 + light, GL_AMBIENT, v);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">#endif</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void StelPainterLight::setEnable(bool v)</td><td> </td><td class="right">void StelPainterLight::setEnable(bool v)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (v)</td><td> </td><td class="right">       if (v)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               enable();</td><td> </td><td class="right">               enable();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       else</td><td> </td><td class="right">       else</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               disable();</td><td> </td><td class="right">               disable();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void StelPainterLight::enable()</td><td> </td><td class="right">void StelPainterLight::enable()</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       enabled = true;</td><td> </td><td class="right">       enabled = true;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0112" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">#ifndef STELPAINTER_GL2</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       glEnable(GL_LIGHTING);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">#endif</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void StelPainterLight::disable()</td><td> </td><td class="right">void StelPainterLight::disable()</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       enabled = false;</td><td> </td><td class="right">       enabled = false;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0113" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">#ifndef STELPAINTER_GL2</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       glDisable(GL_LIGHTING);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">#endif</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// material functions</td><td> </td><td class="right">// material functions</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">StelPainterMaterial::StelPainterMaterial()</td><td> </td><td class="right">StelPainterMaterial::StelPainterMaterial()</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       : specular(0, 0, 0, 1), ambient(0.2, 0.2, 0.2, 1.0), emission(0, 0, 
0, 1), shininess(0)</td><td> </td><td class="right">       : specular(0, 0, 0, 1), ambient(0.2, 0.2, 0.2, 1.0), emission(0, 0, 
0, 1), shininess(0)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void StelPainterMaterial::setSpecular(const Vec4f&amp; v)</td><td> </td><td class="right">void StelPainterMaterial::setSpecular(const Vec4f&amp; v)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       specular = v;</td><td> </td><td class="right">       specular = v;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0114" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">#ifndef STELPAINTER_GL2</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       glMaterialfv(GL_FRONT, GL_SPECULAR, v);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">#endif</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void StelPainterMaterial::setAmbient(const Vec4f&amp; v)</td><td> </td><td class="right">void StelPainterMaterial::setAmbient(const Vec4f&amp; v)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       ambient = v;</td><td> </td><td class="right">       ambient = v;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0115" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">#ifndef STELPAINTER_GL2</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       glMaterialfv(GL_FRONT, GL_AMBIENT, v);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">#endif</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void StelPainterMaterial::setEmission(const Vec4f&amp; v)</td><td> </td><td class="right">void StelPainterMaterial::setEmission(const Vec4f&amp; v)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       emission = v;</td><td> </td><td class="right">       emission = v;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0116" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">#ifndef STELPAINTER_GL2</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       glMaterialfv(GL_FRONT, GL_EMISSION, v);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">#endif</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void StelPainterMaterial::setShininess(float v)</td><td> </td><td class="right">void StelPainterMaterial::setShininess(float v)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       shininess = v;</td><td> </td><td class="right">       shininess = v;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0117" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">#ifndef STELPAINTER_GL2</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       glMaterialfv(GL_FRONT, GL_SHININESS, &amp;v);</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">#endif</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>

     <tr><td></td><td class="left"></td><td> </td><td class="right"></td><td></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 117 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><td></td><th><i>258 lines changed or deleted</i></th><th><i> </i></th><th><i>437 lines changed or added</i></th><td></td></tr>
     <tr><td colspan="5" align="center" class="small"><br/>This html diff was produced by rfcdiff 1.41. The latest version is available from <a href="http://www.tools.ietf.org/tools/rfcdiff/" >http://tools.ietf.org/tools/rfcdiff/</a> </td></tr>
   </table>
   </body>
   </html>
