<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"> 
<!-- Generated by rfcdiff 1.41: rfcdiff  --> 
<!-- <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional" > -->
<!-- System: Linux fomalhaut.local 3.13.0-49-generic #81-Ubuntu SMP Tue Mar 24 19:29:48 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux --> 
<!-- Using awk: /usr/bin/gawk: GNU Awk 4.0.1 --> 
<!-- Using diff: /usr/bin/diff: diff (GNU diffutils) 3.3 --> 
<!-- Using wdiff: /usr/bin/wdiff: wdiff (GNU wdiff) 1.2.1 --> 
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"> 
<head> 
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /> 
  <meta http-equiv="Content-Style-Type" content="text/css" /> 
  <title>Diff: Landscape.cpp - Landscape.cpp</title> 
  <style type="text/css"> 
    body    { font-size:16px; margin: 0.4ex; margin-right: auto; } 
    tr      { } 
    td      { white-space: pre; font-family: Consolas, "DejaVu Sans Mono", "Droid Sans Mono", Monaco, Monospace; vertical-align: top; font-size: 0.86em;} 
    th      { font-size: 0.86em; } 
    .small  { font-size: 0.6em; font-style: italic; font-family: Verdana, Helvetica, sans-serif; } 
    .left   { background-color: #EEE; } 
    .right  { background-color: #FFF; } 
    .diff   { background-color: #CCF; } 
    .lblock { background-color: #BFB; } 
    .rblock { background-color: #FF8; } 
    .insert { background-color: #8FF; } 
    .delete { background-color: #ACF; } 
    .void   { background-color: #FFB; } 
    .cont   { background-color: #EEE; } 
    .linebr { background-color: #AAA; } 
    .lineno { color: red; background-color: #FFF; font-size: 0.7em; text-align: right; padding: 0 2px; } 
    .elipsis{ background-color: #AAA; } 
    .left .cont { background-color: #DDD; } 
    .right .cont { background-color: #EEE; } 
    .lblock .cont { background-color: #9D9; } 
    .rblock .cont { background-color: #DD6; } 
    .insert .cont { background-color: #0DD; } 
    .delete .cont { background-color: #8AD; } 
    .stats, .stats td, .stats th { background-color: #EEE; padding: 2px 0; } 
  </style> 
</head> 
<body > 
  <table border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th></th><th>&nbsp;Landscape.cpp&nbsp;</th><th> </th><th>&nbsp;Landscape.cpp&nbsp;</th><th></th></tr> 
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l1" /><small>skipping to change at</small><em> line 267</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 267</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void LandscapeOldStyle::load(const QSettings&amp; landscapeIni, const QString&amp; 
landscapeId)</td><td> </td><td class="right">void LandscapeOldStyle::load(const QSettings&amp; landscapeIni, const QString&amp; 
landscapeId)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // TODO: put values into hash and call create() method to consolidat
e code</td><td> </td><td class="right">       // TODO: put values into hash and call create() method to consolidat
e code</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       loadCommon(landscapeIni, landscapeId);</td><td> </td><td class="right">       loadCommon(landscapeIni, landscapeId);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // rows, cols have been loaded already, but with different defaults.</td><td> </td><td class="right">       // rows, cols have been loaded already, but with different defaults.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // GZ Hey, they are not used altogether! Resolution is constant, bel
ow!</td><td> </td><td class="right">       // GZ Hey, they are not used altogether! Resolution is constant, bel
ow!</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //rows = landscapeIni.value("landscape/tesselate_rows", 8).toInt();</td><td> </td><td class="right">       //rows = landscapeIni.value("landscape/tesselate_rows", 8).toInt();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //cols = landscapeIni.value("landscape/tesselate_cols", 16).toInt();</td><td> </td><td class="right">       //cols = landscapeIni.value("landscape/tesselate_cols", 16).toInt();</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                                                                           </span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       QString type = landscapeIni.value("landscape/type").toString();</td><td> </td><td class="right">       QString type = landscapeIni.value("landscape/type").toString();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if(type != "old_style")</td><td> </td><td class="right">       if(type != "old_style")</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               qWarning() &lt;&lt; "Landscape type mismatch for landscape " &lt;&lt; la
ndscapeId</td><td> </td><td class="right">               qWarning() &lt;&lt; "Landscape type mismatch for landscape " &lt;&lt; la
ndscapeId</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                                  &lt;&lt; ", expected old_style, found " &lt;&lt; type
 &lt;&lt; ".  No landscape in use.";</td><td> </td><td class="right">                                  &lt;&lt; ", expected old_style, found " &lt;&lt; type
 &lt;&lt; ".  No landscape in use.";</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               validLandscape = 0;</td><td> </td><td class="right">               validLandscape = 0;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return;</td><td> </td><td class="right">               return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0002" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">nbDecorRepeat      = landscapeIni.value("landscape/nb_decor_repeat",</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> 1).toInt();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       fogAltAngle        = landscapeIni.value("landscape/fog_alt_angle", 0</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">.).toFloat();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       fogAngleShift      = landscapeIni.value("landscape/fog_angle_shift",</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> 0.).toFloat();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       decorAltAngle      = landscapeIni.value("landscape/decor_alt_angle",</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> 0.).toFloat();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       decorAngleShift    = landscapeIni.value("landscape/decor_angle_shift</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">", 0.).toFloat();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       angleRotateZ       = landscapeIni.value("landscape/decor_angle_rotat</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ez", 0.).toFloat()  * M_PI/180.f;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       groundAngleShift   = landscapeIni.value("landscape/ground_angle_shif</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">t", 0.).toFloat()   * M_PI/180.f;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       groundAngleRotateZ = landscapeIni.value("landscape/ground_angle_rota</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">tez", 0.).toFloat() * M_PI/180.f;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       drawGroundFirst    = landscapeIni.value("landscape/draw_ground_first</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">", 0).toInt();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       tanMode            = landscapeIni.value("landscape/tan_mode", false)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">.toBool();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       calibrated         = landscapeIni.value("landscape/calibrated", fals</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">e).toBool();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Load sides textures</td><td> </td><td class="right">       // Load sides textures</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       nbSideTexs = landscapeIni.value("landscape/nbsidetex", 0).toInt();</td><td> </td><td class="right">       nbSideTexs = landscapeIni.value("landscape/nbsidetex", 0).toInt();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       sideTexs = new StelTextureSP[2*nbSideTexs]; // 0.14: allow upper hal
f for light textures!</td><td> </td><td class="right">       sideTexs = new StelTextureSP[2*nbSideTexs]; // 0.14: allow upper hal
f for light textures!</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       for (int i=0; i&lt;nbSideTexs; ++i)</td><td> </td><td class="right">       for (int i=0; i&lt;nbSideTexs; ++i)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               QString textureKey = QString("landscape/tex%1").arg(i);</td><td> </td><td class="right">               QString textureKey = QString("landscape/tex%1").arg(i);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               QString textureName = landscapeIni.value(textureKey).toStrin
g();</td><td> </td><td class="right">               QString textureName = landscapeIni.value(textureKey).toStrin
g();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               const QString texturePath = getTexturePath(textureName, land
scapeId);</td><td> </td><td class="right">               const QString texturePath = getTexturePath(textureName, land
scapeId);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               sideTexs[i] = StelApp::getInstance().getTextureManager().cre
ateTexture(texturePath);</td><td> </td><td class="right">               sideTexs[i] = StelApp::getInstance().getTextureManager().cre
ateTexture(texturePath);</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0003" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               // GZ: To query the textures, also <span class="delete">fill</span> an array of QImage*,
 but only</td><td> </td><td class="rblock">               // GZ: To query the textures, also <span class="insert">keep</span> an array of QImage*,
 but only</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               // if that query is not going to be prevented by the polygon
 that already has been loaded at that point...</td><td> </td><td class="right">               // if that query is not going to be prevented by the polygon
 that already has been loaded at that point...</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               if ( (!horizonPolygon) &amp;&amp; calibrated ) { // for uncalibrated
 landscapes the texture is currently never queried, so no need to store.</td><td> </td><td class="right">               if ( (!horizonPolygon) &amp;&amp; calibrated ) { // for uncalibrated
 landscapes the texture is currently never queried, so no need to store.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       QImage *image = new QImage(texturePath);</td><td> </td><td class="right">                       QImage *image = new QImage(texturePath);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       sidesImages.append(image); // indices identical to t
hose in sideTexs</td><td> </td><td class="right">                       sidesImages.append(image); // indices identical to t
hose in sideTexs</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               }</td><td> </td><td class="right">               }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               // Also allow light textures. The light textures must cover 
the same geometry as the sides. It is allowed that not all or even any ligh
t textures are present!</td><td> </td><td class="right">               // Also allow light textures. The light textures must cover 
the same geometry as the sides. It is allowed that not all or even any ligh
t textures are present!</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               textureKey = QString("landscape/light%1").arg(i);</td><td> </td><td class="right">               textureKey = QString("landscape/light%1").arg(i);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               textureName = landscapeIni.value(textureKey).toString();</td><td> </td><td class="right">               textureName = landscapeIni.value(textureKey).toString();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               if (textureName.length())</td><td> </td><td class="right">               if (textureName.length())</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               {</td><td> </td><td class="right">               {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l2" /><small>skipping to change at</small><em> line 364</em></th><th> </th><th><a name="part-r2" /><small>skipping to change at</small><em> line 375</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // GZ 2013/11: I don't see any use of this:</td><td> </td><td class="right">       // GZ 2013/11: I don't see any use of this:</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//     QString description = landscapeIni.value("landscape/fog").toString()
;</td><td> </td><td class="right">//     QString description = landscapeIni.value("landscape/fog").toString()
;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//     //sscanf(description.toLocal8Bit(),"fogtex:%f:%f:%f:%f",&amp;a,&amp;b,&amp;c,&amp;d)
;</td><td> </td><td class="right">//     //sscanf(description.toLocal8Bit(),"fogtex:%f:%f:%f:%f",&amp;a,&amp;b,&amp;c,&amp;d)
;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//     QStringList parameters = description.split(':');</td><td> </td><td class="right">//     QStringList parameters = description.split(':');</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//     fogTexCoord.tex = fogTex;</td><td> </td><td class="right">//     fogTexCoord.tex = fogTex;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//     fogTexCoord.texCoords[0] = parameters.at(1).toFloat();</td><td> </td><td class="right">//     fogTexCoord.texCoords[0] = parameters.at(1).toFloat();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//     fogTexCoord.texCoords[1] = parameters.at(2).toFloat();</td><td> </td><td class="right">//     fogTexCoord.texCoords[1] = parameters.at(2).toFloat();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//     fogTexCoord.texCoords[2] = parameters.at(3).toFloat();</td><td> </td><td class="right">//     fogTexCoord.texCoords[2] = parameters.at(3).toFloat();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//     fogTexCoord.texCoords[3] = parameters.at(4).toFloat();</td><td> </td><td class="right">//     fogTexCoord.texCoords[3] = parameters.at(4).toFloat();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0004" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">nbDecorRepeat      = landscapeIni.value("landscape/nb_decor_repeat",</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"> 1).toInt();</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       fogAltAngle        = landscapeIni.value("landscape/fog_alt_angle", 0</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">.).toFloat();</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       fogAngleShift      = landscapeIni.value("landscape/fog_angle_shift",</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"> 0.).toFloat();</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       decorAltAngle      = landscapeIni.value("landscape/decor_alt_angle",</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete"> 0.).toFloat();</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       decorAngleShift    = landscapeIni.value("landscape/decor_angle_shift</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">", 0.).toFloat();</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       angleRotateZ       = landscapeIni.value("landscape/decor_angle_rotat</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">ez", 0.).toFloat()  * M_PI/180.f;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       groundAngleShift   = landscapeIni.value("landscape/ground_angle_shif</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">t", 0.).toFloat()   * M_PI/180.f;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       groundAngleRotateZ = landscapeIni.value("landscape/ground_angle_rota</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">tez", 0.).toFloat() * M_PI/180.f;</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       drawGroundFirst    = landscapeIni.value("landscape/draw_ground_first</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">", 0).toInt();</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       tanMode            = landscapeIni.value("landscape/tan_mode", false)</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">.toBool();</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       calibrated         = landscapeIni.value("landscape/calibrated", fals</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">e).toBool();</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                                                           </td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Precompute the vertex arrays for ground display</td><td> </td><td class="right">       // Precompute the vertex arrays for ground display</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Make slices_per_side=(3&lt;&lt;K) so that the innermost polygon of the 
fandisk becomes a triangle:</td><td> </td><td class="right">       // Make slices_per_side=(3&lt;&lt;K) so that the innermost polygon of the 
fandisk becomes a triangle:</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //const int slices_per_side = 3*64/(nbDecorRepeat*nbSide);</td><td> </td><td class="right">       //const int slices_per_side = 3*64/(nbDecorRepeat*nbSide);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //if (slices_per_side&lt;=0) // GZ: How can negative ever happen?</td><td> </td><td class="right">       //if (slices_per_side&lt;=0) // GZ: How can negative ever happen?</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //      slices_per_side = 1;</td><td> </td><td class="right">       //      slices_per_side = 1;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const int slices_per_side = qMax(3*64/(nbDecorRepeat*nbSide), 1);</td><td> </td><td class="right">       const int slices_per_side = qMax(3*64/(nbDecorRepeat*nbSide), 1);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // draw a fan disk instead of a ordinary disk to that the inner slic
es</td><td> </td><td class="right">       // draw a fan disk instead of a ordinary disk to that the inner slic
es</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // are not so slender. When they are too slender, culling errors occ
ur</td><td> </td><td class="right">       // are not so slender. When they are too slender, culling errors occ
ur</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // in cylinder projection mode.</td><td> </td><td class="right">       // in cylinder projection mode.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l3" /><small>skipping to change at</small><em> line 398</em></th><th> </th><th><a name="part-r3" /><small>skipping to change at</small><em> line 397</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       while ((slices_inside&amp;1)==0 &amp;&amp; slices_inside &gt; 4)</td><td> </td><td class="right">       while ((slices_inside&amp;1)==0 &amp;&amp; slices_inside &gt; 4)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               ++level;</td><td> </td><td class="right">               ++level;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               slices_inside&gt;&gt;=1;</td><td> </td><td class="right">               slices_inside&gt;&gt;=1;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       StelPainter::computeFanDisk(radius, slices_inside, level, groundVert
exArr, groundTexCoordArr);</td><td> </td><td class="right">       StelPainter::computeFanDisk(radius, slices_inside, level, groundVert
exArr, groundTexCoordArr);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Precompute the vertex arrays for side display. The geometry of th
e sides is always a cylinder.</td><td> </td><td class="right">       // Precompute the vertex arrays for side display. The geometry of th
e sides is always a cylinder.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // The texture is split into regular quads.</td><td> </td><td class="right">       // The texture is split into regular quads.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0005" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       // GZ: the <span class="delete">old</span> code for vertical placement makes unfortunately no <span class="delete">se</span></td><td> </td><td class="rblock">       // GZ: the <span class="insert">original</span> code for vertical placement makes unfortunately </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">nse.</span> There are many approximately-fitted landscapes, though.</td><td> </td><td class="rblock">no <span class="insert">sense.</span> There are many approximately-fitted landscapes, though.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       // I added a switch "calibrated" for the ini file. If true, it works</td><td> </td><td class="rblock">       // I added a switch "calibrated" for the ini file. If true, it works</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"> as this landscape apparently was originally <span class="delete">intended.</span></td><td> </td><td class="rblock"> as this landscape apparently was originally <span class="insert">intended,</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       // if false (or missing) it uses the original code.</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // So I corrected the texture coordinates so that decorAltAngle is t
he total vertical angle, decorAngleShift the lower angle,</td><td> </td><td class="right">       // So I corrected the texture coordinates so that decorAltAngle is t
he total vertical angle, decorAngleShift the lower angle,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // and the texture in between is correctly stretched.</td><td> </td><td class="right">       // and the texture in between is correctly stretched.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // I located an undocumented switch tan_mode, maybe tan_mode=true me
ans cylindrical panorama projection.</td><td> </td><td class="right">       // I located an undocumented switch tan_mode, maybe tan_mode=true me
ans cylindrical panorama projection.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Since V0.13, calibrated&amp;&amp;tanMode also works!</td><td> </td><td class="right">       // Since V0.13, calibrated&amp;&amp;tanMode also works!</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // In calibrated &amp;&amp; !tan_mode, the vertical position is computed cor
rectly, so that quads off the horizon are larger.</td><td> </td><td class="right">       // In calibrated &amp;&amp; !tan_mode, the vertical position is computed cor
rectly, so that quads off the horizon are larger.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // in calibrated &amp;&amp;  tan_mode, d_z can become a constant because the
 texture is already predistorted in cylindrical projection.</td><td> </td><td class="right">       // in calibrated &amp;&amp;  tan_mode, d_z can become a constant because the
 texture is already predistorted in cylindrical projection.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       static const int stacks = (calibrated ? 16 : 8); // GZ: 8-&gt;16, I nee
d better precision.</td><td> </td><td class="right">       static const int stacks = (calibrated ? 16 : 8); // GZ: 8-&gt;16, I nee
d better precision.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       float z0, d_z;</td><td> </td><td class="right">       float z0, d_z;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (calibrated)</td><td> </td><td class="right">       if (calibrated)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l4" /><small>skipping to change at</small><em> line 606</em></th><th> </th><th><a name="part-r4" /><small>skipping to change at</small><em> line 606</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (!landFader.getInterstate())</td><td> </td><td class="right">       if (!landFader.getInterstate())</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return;</td><td> </td><td class="right">               return;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const float vshift = radius * ((tanMode || calibrated) ? std::tan(gr
oundAngleShift) : std::sin(groundAngleShift));</td><td> </td><td class="right">       const float vshift = radius * ((tanMode || calibrated) ? std::tan(gr
oundAngleShift) : std::sin(groundAngleShift));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       StelProjector::ModelViewTranformP transfo = core-&gt;getAltAzModelViewT
ransform(StelCore::RefractionOff);</td><td> </td><td class="right">       StelProjector::ModelViewTranformP transfo = core-&gt;getAltAzModelViewT
ransform(StelCore::RefractionOff);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       transfo-&gt;combine(Mat4d::zrotation(groundAngleRotateZ-angleRotateZOff
set) * Mat4d::translation(Vec3d(0,0,vshift)));</td><td> </td><td class="right">       transfo-&gt;combine(Mat4d::zrotation(groundAngleRotateZ-angleRotateZOff
set) * Mat4d::translation(Vec3d(0,0,vshift)));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       sPainter.setProjector(core-&gt;getProjection(transfo));</td><td> </td><td class="right">       sPainter.setProjector(core-&gt;getProjection(transfo));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       sPainter.setColor(landscapeBrightness, landscapeBrightness, landscap
eBrightness, landFader.getInterstate());</td><td> </td><td class="right">       sPainter.setColor(landscapeBrightness, landscapeBrightness, landscap
eBrightness, landFader.getInterstate());</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0006" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       groundTex-&gt;bind();</td><td> </td><td class="rblock">       <span class="insert">if(groundTex.isNull())</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               qWarning()&lt;&lt;"LandscapeOldStyle groundTex is invalid!";</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       else</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">               groundTex-&gt;bind();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">}</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       sPainter.setArrays((Vec3d*)groundVertexArr.constData(), (Vec2f*)grou
ndTexCoordArr.constData());</td><td> </td><td class="right">       sPainter.setArrays((Vec3d*)groundVertexArr.constData(), (Vec2f*)grou
ndTexCoordArr.constData());</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       sPainter.drawFromArray(StelPainter::Triangles, groundVertexArr.size(
)/3);</td><td> </td><td class="right">       sPainter.drawFromArray(StelPainter::Triangles, groundVertexArr.size(
)/3);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">float LandscapeOldStyle::getOpacity(Vec3d azalt) const</td><td> </td><td class="right">float LandscapeOldStyle::getOpacity(Vec3d azalt) const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (angleRotateZOffset!=0.0f)</td><td> </td><td class="right">       if (angleRotateZOffset!=0.0f)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               azalt.transfo4d(Mat4d::zrotation(angleRotateZOffset));</td><td> </td><td class="right">               azalt.transfo4d(Mat4d::zrotation(angleRotateZOffset));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // in case we also have a horizon polygon defined, this is trivial a
nd fast.</td><td> </td><td class="right">       // in case we also have a horizon polygon defined, this is trivial a
nd fast.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (horizonPolygon)</td><td> </td><td class="right">       if (horizonPolygon)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               if (horizonPolygon-&gt;contains(azalt)     ) return 1.0f; else 
return 0.0f;</td><td> </td><td class="right">               if (horizonPolygon-&gt;contains(azalt)     ) return 1.0f; else 
return 0.0f;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // Else, sample the images...</td><td> </td><td class="right">       // Else, sample the images...</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0007" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                                                                           </span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const float alt_rad = std::asin(azalt[2]);  // sampled altitude, rad
ians</td><td> </td><td class="right">       const float alt_rad = std::asin(azalt[2]);  // sampled altitude, rad
ians</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (alt_rad &lt; decorAngleShift*M_PI/180.0f) return 1.0f; // below dec
or, i.e. certainly opaque ground.</td><td> </td><td class="right">       if (alt_rad &lt; decorAngleShift*M_PI/180.0f) return 1.0f; // below dec
or, i.e. certainly opaque ground.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (alt_rad &gt; (decorAltAngle+decorAngleShift)*M_PI/180.0f) return 0.
0f; // above decor, i.e. certainly free sky.</td><td> </td><td class="right">       if (alt_rad &gt; (decorAltAngle+decorAngleShift)*M_PI/180.0f) return 0.
0f; // above decor, i.e. certainly free sky.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (!calibrated) // the result of this function has no real use here
: just complain and return result for math. horizon.</td><td> </td><td class="right">       if (!calibrated) // the result of this function has no real use here
: just complain and return result for math. horizon.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0008" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               <span class="delete">qDebug()</span> &lt;&lt; "Dubious result: Landscape \"" &lt;&lt; name &lt;&lt; "\" <span class="delete">no</span></td><td> </td><td class="rblock">               <span class="insert">static QString lastLandscapeName;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">t</span> calibrated. <span class="delete">Result for</span> mathematical horizon <span class="delete">only.";</span></td><td> </td><td class="rblock"><span class="insert">               if (lastLandscapeName != name)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       qWarning()</span> &lt;&lt; "Dubious result: Landscape \"" &lt;&lt; name</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"> &lt;&lt; "\" <span class="insert">not</span> calibrated. <span class="insert">Opacity test represents</span> mathematical horizon <span class="insert">only."</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       lastLandscapeName=name;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               }</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               return (azalt[2] &gt; 0 ? 0.0f : 1.0f);</td><td> </td><td class="right">               return (azalt[2] &gt; 0 ? 0.0f : 1.0f);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0009" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                                                                           </span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       float az=atan2(azalt[0], azalt[1]) / M_PI + 0.5f;  // -0.5..+1.5</td><td> </td><td class="right">       float az=atan2(azalt[0], azalt[1]) / M_PI + 0.5f;  // -0.5..+1.5</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (az&lt;0) az+=2.0f;                                //  0..2 = N.E.S.
W.N</td><td> </td><td class="right">       if (az&lt;0) az+=2.0f;                                //  0..2 = N.E.S.
W.N</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0010" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                                                                           </span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // we go to 0..1 domain, it's easier to think.</td><td> </td><td class="right">       // we go to 0..1 domain, it's easier to think.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const float xShift=angleRotateZ /(2.0f*M_PI); // shift value in -1..
1</td><td> </td><td class="right">       const float xShift=angleRotateZ /(2.0f*M_PI); // shift value in -1..
1</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0011" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">Q_ASSERT(xShift &gt;= -1.0f);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       Q_ASSERT(xShift &lt;=  1.0f);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       float az_phot=az*0.5f - 0.25f - xShift;      // The 0.25 is caused b
y regular pano left edge being East. The xShift compensates any configured 
angleRotateZ</td><td> </td><td class="right">       float az_phot=az*0.5f - 0.25f - xShift;      // The 0.25 is caused b
y regular pano left edge being East. The xShift compensates any configured 
angleRotateZ</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       az_phot=fmodf(az_phot, 1.0f);</td><td> </td><td class="right">       az_phot=fmodf(az_phot, 1.0f);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (az_phot&lt;0) az_phot+=1.0f;                                //  0..
1 = image-X for a non-repeating pano photo</td><td> </td><td class="right">       if (az_phot&lt;0) az_phot+=1.0f;                                //  0..
1 = image-X for a non-repeating pano photo</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0012" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                                                                           </span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       float az_panel =  nbSide*nbDecorRepeat * az_phot; // azimuth in "pan
el space". Ex for nbS=4, nbDR=3: [0..[12, say 11.4</td><td> </td><td class="right">       float az_panel =  nbSide*nbDecorRepeat * az_phot; // azimuth in "pan
el space". Ex for nbS=4, nbDR=3: [0..[12, say 11.4</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       float x_in_panel=fmodf(az_panel, 1.0f);</td><td> </td><td class="right">       float x_in_panel=fmodf(az_panel, 1.0f);</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0013" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       int currentSide = (int) floor(fmodf(az_panel, nbSide)); <span class="delete">// must beco</span></td><td> </td><td class="rblock">       int currentSide = (int) floor(fmodf(az_panel, nbSide));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">me 3</span></td><td> </td><td class="rblock">       <span class="insert">Q_ASSERT(currentSide&gt;=0);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       Q_ASSERT(currentSide&lt;=nbSideTexs);</span></td><td> </td><td class="rblock"><span class="insert">       Q_ASSERT(currentSide&lt;nbSideTexs);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       int x= (sides[currentSide].texCoords[0] + x_in_panel*(sides[currentS
ide].texCoords[2]-sides[currentSide].texCoords[0]))</td><td> </td><td class="right">       int x= (sides[currentSide].texCoords[0] + x_in_panel*(sides[currentS
ide].texCoords[2]-sides[currentSide].texCoords[0]))</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       * sidesImages[currentSide]-&gt;width(); // pixel X from
 left.</td><td> </td><td class="right">                       * sidesImages[currentSide]-&gt;width(); // pixel X from
 left.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // QImage has pixel 0/0 in top left corner. We must find image Y for
 optionally cropped images.</td><td> </td><td class="right">       // QImage has pixel 0/0 in top left corner. We must find image Y for
 optionally cropped images.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // It should no longer be possible that sample position is outside c
ropped texture. in this case, assert(0) but again assume full transparency 
and exit early.</td><td> </td><td class="right">       // It should no longer be possible that sample position is outside c
ropped texture. in this case, assert(0) but again assume full transparency 
and exit early.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       float y_img_1; // y of the sampled altitude in 0..1 visible image he
ight from bottom</td><td> </td><td class="right">       float y_img_1; // y of the sampled altitude in 0..1 visible image he
ight from bottom</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (tanMode)</td><td> </td><td class="right">       if (tanMode)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               const float tanAlt=std::tan(alt_rad);</td><td> </td><td class="right">               const float tanAlt=std::tan(alt_rad);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l5" /><small>skipping to change at</small><em> line 669</em></th><th> </th><th><a name="part-r5" /><small>skipping to change at</small><em> line 680</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       else</td><td> </td><td class="right">       else</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       { // adapted from spherical...</td><td> </td><td class="right">       { // adapted from spherical...</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               const float alt_pm1 = 2.0f * alt_rad  / M_PI;  // sampled al
titude, -1...+1 linear in altitude angle</td><td> </td><td class="right">               const float alt_pm1 = 2.0f * alt_rad  / M_PI;  // sampled al
titude, -1...+1 linear in altitude angle</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               const float img_top_pm1 = 1.0f-( (90.0f-decorAltAngle-decorA
ngleShift) / 90.0f); // the top line in -1..+1 (angular)</td><td> </td><td class="right">               const float img_top_pm1 = 1.0f-( (90.0f-decorAltAngle-decorA
ngleShift) / 90.0f); // the top line in -1..+1 (angular)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               if (alt_pm1&gt;img_top_pm1) { Q_ASSERT(0); return 0.0f; } // sh
ould have been caught above with alt_rad tests</td><td> </td><td class="right">               if (alt_pm1&gt;img_top_pm1) { Q_ASSERT(0); return 0.0f; } // sh
ould have been caught above with alt_rad tests</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               const float img_bot_pm1 = 1.0f-((90.0f-decorAngleShift) / 90
.0f); // the bottom line in -1..+1 (angular)</td><td> </td><td class="right">               const float img_bot_pm1 = 1.0f-((90.0f-decorAngleShift) / 90
.0f); // the bottom line in -1..+1 (angular)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               if (alt_pm1&lt;img_bot_pm1) { Q_ASSERT(0); return 1.0f; } // sh
ould have been caught above with alt_rad tests</td><td> </td><td class="right">               if (alt_pm1&lt;img_bot_pm1) { Q_ASSERT(0); return 1.0f; } // sh
ould have been caught above with alt_rad tests</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               y_img_1=(alt_pm1-img_bot_pm1)/(img_top_pm1-img_bot_pm1); // 
the sampled altitude in 0..1 visible image height from bottom</td><td> </td><td class="right">               y_img_1=(alt_pm1-img_bot_pm1)/(img_top_pm1-img_bot_pm1); // 
the sampled altitude in 0..1 visible image height from bottom</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       }</td><td> </td><td class="right">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0014" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                                                                           </span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // x0/y0 is lower left, x1/y1 upper right corner.</td><td> </td><td class="right">       // x0/y0 is lower left, x1/y1 upper right corner.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       float y_baseImg_1 = sides[currentSide].texCoords[1]+ y_img_1*(sides[
currentSide].texCoords[3]-sides[currentSide].texCoords[1]);</td><td> </td><td class="right">       float y_baseImg_1 = sides[currentSide].texCoords[1]+ y_img_1*(sides[
currentSide].texCoords[3]-sides[currentSide].texCoords[1]);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       int y=(1.0-y_baseImg_1)*sidesImages[currentSide]-&gt;height();         
  // pixel Y from top.</td><td> </td><td class="right">       int y=(1.0-y_baseImg_1)*sidesImages[currentSide]-&gt;height();         
  // pixel Y from top.</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0015" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">                                                                           </span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       QRgb pixVal=sidesImages[currentSide]-&gt;pixel(x, y);</td><td> </td><td class="right">       QRgb pixVal=sidesImages[currentSide]-&gt;pixel(x, y);</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0016" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#ifndef NDEBUG</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // GZ: please leave the comment available for further development!</td><td> </td><td class="right">       // GZ: please leave the comment available for further development!</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       qDebug() &lt;&lt; "Oldstyle Landscape sampling: az=" &lt;&lt; az*180.0 &lt;&lt; " alt
=" &lt;&lt; alt_rad*180.0f/M_PI</td><td> </td><td class="right">       qDebug() &lt;&lt; "Oldstyle Landscape sampling: az=" &lt;&lt; az*180.0 &lt;&lt; " alt
=" &lt;&lt; alt_rad*180.0f/M_PI</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                        &lt;&lt; ", xShift[-1..+1]=" &lt;&lt; xShift &lt;&lt; " az_phot[0..1
]=" &lt;&lt; az_phot</td><td> </td><td class="right">                        &lt;&lt; ", xShift[-1..+1]=" &lt;&lt; xShift &lt;&lt; " az_phot[0..1
]=" &lt;&lt; az_phot</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                        &lt;&lt; " --&gt; current side panel " &lt;&lt; currentSide</td><td> </td><td class="right">                        &lt;&lt; " --&gt; current side panel " &lt;&lt; currentSide</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                        &lt;&lt; ", w=" &lt;&lt; sidesImages[currentSide]-&gt;width() &lt;&lt; "
 h=" &lt;&lt; sidesImages[currentSide]-&gt;height()</td><td> </td><td class="right">                        &lt;&lt; ", w=" &lt;&lt; sidesImages[currentSide]-&gt;width() &lt;&lt; "
 h=" &lt;&lt; sidesImages[currentSide]-&gt;height()</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                        &lt;&lt; " --&gt; x:" &lt;&lt; x &lt;&lt; " y:" &lt;&lt; y &lt;&lt; " alpha:" &lt;&lt; qAl
pha(pixVal)/255.0f;</td><td> </td><td class="right">                        &lt;&lt; " --&gt; x:" &lt;&lt; x &lt;&lt; " y:" &lt;&lt; y &lt;&lt; " alpha:" &lt;&lt; qAl
pha(pixVal)/255.0f;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0017" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#endif</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       return qAlpha(pixVal)/255.0f;</td><td> </td><td class="right">       return qAlpha(pixVal)/255.0f;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">///////////////////////////////////////////////////////////////////////////
/////////////////////////</td><td> </td><td class="right">///////////////////////////////////////////////////////////////////////////
/////////////////////////</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">LandscapePolygonal::LandscapePolygonal(float _radius) : Landscape(_radius)</td><td> </td><td class="right">LandscapePolygonal::LandscapePolygonal(float _radius) : Landscape(_radius)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{}</td><td> </td><td class="right">{}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">LandscapePolygonal::~LandscapePolygonal()</td><td> </td><td class="right">LandscapePolygonal::~LandscapePolygonal()</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{}</td><td> </td><td class="right">{}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l6" /><small>skipping to change at</small><em> line 885</em></th><th> </th><th><a name="part-r6" /><small>skipping to change at</small><em> line 896</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (M_PI/2-alt_rad &gt; texFov/2.0 ) return 1.0; // outside fov, in the
 clamped texture zone: always opaque.</td><td> </td><td class="right">       if (M_PI/2-alt_rad &gt; texFov/2.0 ) return 1.0; // outside fov, in the
 clamped texture zone: always opaque.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       float radius=(M_PI/2-alt_rad)*2.0f/texFov; // radius in units of map
Image.height/2</td><td> </td><td class="right">       float radius=(M_PI/2-alt_rad)*2.0f/texFov; // radius in units of map
Image.height/2</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       float az=atan2(azalt[0], azalt[1]) + M_PI/2 - angleRotateZ; // -pi/2
..+3pi/2, real azimuth. NESW</td><td> </td><td class="right">       float az=atan2(azalt[0], azalt[1]) + M_PI/2 - angleRotateZ; // -pi/2
..+3pi/2, real azimuth. NESW</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //  The texture map has south on top, east at right (if anglerotateZ
=0)</td><td> </td><td class="right">       //  The texture map has south on top, east at right (if anglerotateZ
=0)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       int x= mapImage-&gt;height()/2*(1 + radius*std::sin(az));</td><td> </td><td class="right">       int x= mapImage-&gt;height()/2*(1 + radius*std::sin(az));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       int y= mapImage-&gt;height()/2*(1 + radius*std::cos(az));</td><td> </td><td class="right">       int y= mapImage-&gt;height()/2*(1 + radius*std::cos(az));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       QRgb pixVal=mapImage-&gt;pixel(x, y);</td><td> </td><td class="right">       QRgb pixVal=mapImage-&gt;pixel(x, y);</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0018" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#ifndef NDEBUG</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // GZ: please leave the comment available for further development!</td><td> </td><td class="right">       // GZ: please leave the comment available for further development!</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       qDebug() &lt;&lt; "Landscape sampling: az=" &lt;&lt; (az+angleRotateZ)/M_PI*180.
0f &lt;&lt; " alt=" &lt;&lt; alt_rad/M_PI*180.f</td><td> </td><td class="right">       qDebug() &lt;&lt; "Landscape sampling: az=" &lt;&lt; (az+angleRotateZ)/M_PI*180.
0f &lt;&lt; " alt=" &lt;&lt; alt_rad/M_PI*180.f</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                        &lt;&lt; ", w=" &lt;&lt; mapImage-&gt;width() &lt;&lt; " h=" &lt;&lt; mapImag
e-&gt;height()</td><td> </td><td class="right">                        &lt;&lt; ", w=" &lt;&lt; mapImage-&gt;width() &lt;&lt; " h=" &lt;&lt; mapImag
e-&gt;height()</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                        &lt;&lt; " --&gt; x:" &lt;&lt; x &lt;&lt; " y:" &lt;&lt; y &lt;&lt; " alpha:" &lt;&lt; qAl
pha(pixVal)/255.0f;</td><td> </td><td class="right">                        &lt;&lt; " --&gt; x:" &lt;&lt; x &lt;&lt; " y:" &lt;&lt; y &lt;&lt; " alpha:" &lt;&lt; qAl
pha(pixVal)/255.0f;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0019" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#endif</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       return qAlpha(pixVal)/255.0f;</td><td> </td><td class="right">       return qAlpha(pixVal)/255.0f;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">///////////////////////////////////////////////////////////////////////////
//////////////////////</td><td> </td><td class="right">///////////////////////////////////////////////////////////////////////////
//////////////////////</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// spherical panoramas</td><td> </td><td class="right">// spherical panoramas</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">LandscapeSpherical::LandscapeSpherical(float _radius)</td><td> </td><td class="right">LandscapeSpherical::LandscapeSpherical(float _radius)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       : Landscape(_radius)</td><td> </td><td class="right">       : Landscape(_radius)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       , mapTexTop(0.)</td><td> </td><td class="right">       , mapTexTop(0.)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       , mapTexBottom(0.)</td><td> </td><td class="right">       , mapTexBottom(0.)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l7" /><small>skipping to change at</small><em> line 1068</em></th><th> </th><th><a name="part-r7" /><small>skipping to change at</small><em> line 1081</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (az&lt;0) az+=2.0f;                                //  0..2 = N.E.S.
W.N</td><td> </td><td class="right">       if (az&lt;0) az+=2.0f;                                //  0..2 = N.E.S.
W.N</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       const float xShift=(angleRotateZ) /M_PI; // shift value in -2..2</td><td> </td><td class="right">       const float xShift=(angleRotateZ) /M_PI; // shift value in -2..2</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       float az_phot=az - 0.5f - xShift;      // The 0.5 is caused by regul
ar pano left edge being East. The xShift compensates any configured angleRo
tateZ</td><td> </td><td class="right">       float az_phot=az - 0.5f - xShift;      // The 0.5 is caused by regul
ar pano left edge being East. The xShift compensates any configured angleRo
tateZ</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       az_phot=fmodf(az_phot, 2.0f);</td><td> </td><td class="right">       az_phot=fmodf(az_phot, 2.0f);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if (az_phot&lt;0) az_phot+=2.0f;                                //  0..
2 = image-X</td><td> </td><td class="right">       if (az_phot&lt;0) az_phot+=2.0f;                                //  0..
2 = image-X</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       int x=(az_phot/2.0f) * mapImage-&gt;width(); // pixel X from left.</td><td> </td><td class="right">       int x=(az_phot/2.0f) * mapImage-&gt;width(); // pixel X from left.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       QRgb pixVal=mapImage-&gt;pixel(x, y);</td><td> </td><td class="right">       QRgb pixVal=mapImage-&gt;pixel(x, y);</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0020" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#ifndef NDEBUG</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       // GZ: please leave the comment available for further development!</td><td> </td><td class="right">       // GZ: please leave the comment available for further development!</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       qDebug() &lt;&lt; "Landscape sampling: az=" &lt;&lt; az*180.0 &lt;&lt; " alt=" &lt;&lt; alt
_pm1*90.0f</td><td> </td><td class="right">       qDebug() &lt;&lt; "Landscape sampling: az=" &lt;&lt; az*180.0 &lt;&lt; " alt=" &lt;&lt; alt
_pm1*90.0f</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                        &lt;&lt; ", xShift[-2..+2]=" &lt;&lt; xShift &lt;&lt; " az_phot[0..2
]=" &lt;&lt; az_phot</td><td> </td><td class="right">                        &lt;&lt; ", xShift[-2..+2]=" &lt;&lt; xShift &lt;&lt; " az_phot[0..2
]=" &lt;&lt; az_phot</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                        &lt;&lt; ", w=" &lt;&lt; mapImage-&gt;width() &lt;&lt; " h=" &lt;&lt; mapImage
-&gt;height()</td><td> </td><td class="right">                        &lt;&lt; ", w=" &lt;&lt; mapImage-&gt;width() &lt;&lt; " h=" &lt;&lt; mapImage
-&gt;height()</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                        &lt;&lt; " --&gt; x:" &lt;&lt; x &lt;&lt; " y:" &lt;&lt; y &lt;&lt; " alpha:" &lt;&lt; qAl
pha(pixVal)/255.0f;</td><td> </td><td class="right">                        &lt;&lt; " --&gt; x:" &lt;&lt; x &lt;&lt; " y:" &lt;&lt; y &lt;&lt; " alpha:" &lt;&lt; qAl
pha(pixVal)/255.0f;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0021" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#endif</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       return qAlpha(pixVal)/255.0f;</td><td> </td><td class="right">       return qAlpha(pixVal)/255.0f;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>

     <tr><td></td><td class="left"></td><td> </td><td class="right"></td><td></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 21 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><td></td><th><i>41 lines changed or deleted</i></th><th><i> </i></th><th><i>56 lines changed or added</i></th><td></td></tr>
     <tr><td colspan="5" align="center" class="small"><br/>This html diff was produced by rfcdiff 1.41. The latest version is available from <a href="http://www.tools.ietf.org/tools/rfcdiff/" >http://tools.ietf.org/tools/rfcdiff/</a> </td></tr>
   </table>
   </body>
   </html>
