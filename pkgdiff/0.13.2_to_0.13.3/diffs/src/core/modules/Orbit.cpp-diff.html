<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"> 
<!-- Generated by rfcdiff 1.41: rfcdiff  --> 
<!-- <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional" > -->
<!-- System: Linux fomalhaut.local 3.13.0-49-generic #81-Ubuntu SMP Tue Mar 24 19:29:48 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux --> 
<!-- Using awk: /usr/bin/gawk: GNU Awk 4.0.1 --> 
<!-- Using diff: /usr/bin/diff: diff (GNU diffutils) 3.3 --> 
<!-- Using wdiff: /usr/bin/wdiff: wdiff (GNU wdiff) 1.2.1 --> 
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"> 
<head> 
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /> 
  <meta http-equiv="Content-Style-Type" content="text/css" /> 
  <title>Diff: Orbit.cpp - Orbit.cpp</title> 
  <style type="text/css"> 
    body    { font-size:16px; margin: 0.4ex; margin-right: auto; } 
    tr      { } 
    td      { white-space: pre; font-family: Consolas, "DejaVu Sans Mono", "Droid Sans Mono", Monaco, Monospace; vertical-align: top; font-size: 0.86em;} 
    th      { font-size: 0.86em; } 
    .small  { font-size: 0.6em; font-style: italic; font-family: Verdana, Helvetica, sans-serif; } 
    .left   { background-color: #EEE; } 
    .right  { background-color: #FFF; } 
    .diff   { background-color: #CCF; } 
    .lblock { background-color: #BFB; } 
    .rblock { background-color: #FF8; } 
    .insert { background-color: #8FF; } 
    .delete { background-color: #ACF; } 
    .void   { background-color: #FFB; } 
    .cont   { background-color: #EEE; } 
    .linebr { background-color: #AAA; } 
    .lineno { color: red; background-color: #FFF; font-size: 0.7em; text-align: right; padding: 0 2px; } 
    .elipsis{ background-color: #AAA; } 
    .left .cont { background-color: #DDD; } 
    .right .cont { background-color: #EEE; } 
    .lblock .cont { background-color: #9D9; } 
    .rblock .cont { background-color: #DD6; } 
    .insert .cont { background-color: #0DD; } 
    .delete .cont { background-color: #8AD; } 
    .stats, .stats td, .stats th { background-color: #EEE; padding: 2px 0; } 
  </style> 
</head> 
<body > 
  <table border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th></th><th>&nbsp;Orbit.cpp&nbsp;</th><th> </th><th>&nbsp;Orbit.cpp&nbsp;</th><th></th></tr> 
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l1" /><small>skipping to change at</small><em> line 45</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 45</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#define cbrt(x) pow((x),1./3.)</td><td> </td><td class="right">#define cbrt(x) pow((x),1./3.)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#endif</td><td> </td><td class="right">#endif</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! Solve true anomaly nu for hyperbolic orbit.</td><td> </td><td class="right">//! Solve true anomaly nu for hyperbolic orbit.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! @param q: perihel distance</td><td> </td><td class="right">//! @param q: perihel distance</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! @param n: mean motion</td><td> </td><td class="right">//! @param n: mean motion</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! @param e: excentricity</td><td> </td><td class="right">//! @param e: excentricity</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! @param dt: days from perihel</td><td> </td><td class="right">//! @param dt: days from perihel</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! @param rCosNu: r*cos(nu)</td><td> </td><td class="right">//! @param rCosNu: r*cos(nu)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! @param rSinNu: r*sin(nu)</td><td> </td><td class="right">//! @param rSinNu: r*sin(nu)</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">static void InitHyp(const double q, const double n, const double e, const d</td><td> </td><td class="rblock">static void InitHyp(const double q, const double n, const double e, const d</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">ouble dt, double &amp;rCosNu, double &amp;rSinNu) {</td><td> </td><td class="rblock">ouble dt, double &amp;rCosNu, double &amp;rSinNu)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">//    qDebug() &lt;&lt; "InitHyp";</td><td> </td><td class="rblock">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  Q_ASSERT(e&gt;1.0);</td><td> </td><td class="rblock">//     qDebug() &lt;&lt; "InitHyp";</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  const double a = q/(e-1.0);</td><td> </td><td class="rblock">       Q_ASSERT(e&gt;1.0);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  Q_ASSERT(a&gt;0.0);</td><td> </td><td class="rblock">       const double a = q/(e-1.0);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  const double M = n * dt;</td><td> </td><td class="rblock">       Q_ASSERT(a&gt;0.0);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">//  double H = M;</td><td> </td><td class="rblock">       const double M = n * dt;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">//  for (;;) { // Newton</td><td> </td><td class="rblock">//     double H = M;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">//    const double Hp = H;</td><td> </td><td class="rblock">//     for (;;) { // Newton</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">//    H = H-(e*sinh(H)-H-M)/(e*cosh(H)-1);</td><td> </td><td class="rblock">//             const double Hp = H;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">//    if (fabs(H - Hp) &lt; EPSILON) break;</td><td> </td><td class="rblock">//             H = H-(e*sinh(H)-H-M)/(e*cosh(H)-1);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">//  }</td><td> </td><td class="rblock">//             if (fabs(H - Hp) &lt; EPSILON) break;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">//  const double h1 = q*sqrt((e+1.0)/(e-1.0));</td><td> </td><td class="rblock">//     }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">//  a1 = a*(e-cosh(H));</td><td> </td><td class="rblock">//     const double h1 = q*sqrt((e+1.0)/(e-1.0));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">//  a2 = h1*sinh(H);</td><td> </td><td class="rblock">//     a1 = a*(e-cosh(H));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  // GZ Again I prefer Heafner, ch.5.4</td><td> </td><td class="rblock">//     a2 = h1*sinh(H);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  double E=StelUtils::sign(M)*log(2.0*fabs(M)/e + 1.85);</td><td> </td><td class="rblock">//     GZ Again I prefer Heafner, ch.5.4</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">//  qDebug() &lt;&lt; "InitHyp: E=" &lt;&lt; E &lt;&lt; " M=" &lt;&lt; M ;</td><td> </td><td class="rblock">       double E=StelUtils::sign(M)*log(2.0*fabs(M)/e + 1.85);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  for <span class="delete">(;;){</span></td><td> </td><td class="rblock">//     qDebug() &lt;&lt; "InitHyp: E=" &lt;&lt; E &lt;&lt; " M=" &lt;&lt; M ;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">      const double Ep=E;</td><td> </td><td class="rblock">       for <span class="insert">(;;)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">      const double f2=e*sinh(E);</td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">      const double f=f2-E-M;</td><td> </td><td class="rblock">               const double Ep=E;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">      const double f1=e*cosh(E)-1.0;</td><td> </td><td class="rblock">               const double f2=e*sinh(E);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">      E+= <span class="delete">(-5.0*f)/(f1+StelUtils::sign(f1)*sqrt(fabs(16.0*f1*f1-20.0*f*f2))</span></td><td> </td><td class="rblock">               const double f=f2-E-M;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">);</span></td><td> </td><td class="rblock">               const double f1=e*cosh(E)-1.0;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">      if (fabs(E-Ep) &lt; EPSILON) break;</td><td> </td><td class="rblock">               E+= <span class="insert">(-5.0*f)/(f1+StelUtils::sign(f1)*std::sqrt(fabs(16.0*f1*</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  }</td><td> </td><td class="rblock"><span class="insert">f1-20.0*f*f2)));</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  rCosNu = a*(e-cosh(E));</td><td> </td><td class="rblock">               if (fabs(E-Ep) &lt; EPSILON) break;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  rSinNu = <span class="delete">a*sqrt(e*e-1.0)*sinh(E);</span></td><td> </td><td class="rblock">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       rCosNu = a*(e-cosh(E));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       rSinNu = <span class="insert">a*std::sqrt(e*e-1.0)*sinh(E);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! Solve true anomaly nu for parabolic orbit.</td><td> </td><td class="right">//! Solve true anomaly nu for parabolic orbit.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! @param q: perihel distance</td><td> </td><td class="right">//! @param q: perihel distance</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! @param n: mean motion equivalent related to W (n=W/dt) in Heafner, ch5.
5</td><td> </td><td class="right">//! @param n: mean motion equivalent related to W (n=W/dt) in Heafner, ch5.
5</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! @param dt: days from perihel</td><td> </td><td class="right">//! @param dt: days from perihel</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! @param rCosNu: r*cos(nu)</td><td> </td><td class="right">//! @param rCosNu: r*cos(nu)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! @param rSinNu: r*sin(nu)</td><td> </td><td class="right">//! @param rSinNu: r*sin(nu)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">/*</td><td> </td><td class="right">/*</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0002" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  static void InitPar(const double q, const double n, const double dt, <span class="delete">doub</span></td><td> </td><td class="rblock">static void InitPar(const double q, const double n, const double dt, <span class="insert">double</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">le</span> &amp;a1, double &amp;a2) {</td><td> </td><td class="rblock"> &amp;a1, double &amp;a2)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  const double A = n*dt;</td><td> </td><td class="rblock">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  const double h = sqrt(A*A+1.0);</td><td> </td><td class="rblock">       const double A = n*dt;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  double c = cbrt(fabs(A)+h);</td><td> </td><td class="rblock">       const double h = sqrt(A*A+1.0);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  c = c*c;</td><td> </td><td class="rblock">       double c = cbrt(fabs(A)+h);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  const double tan_nu_h = 2*A/(1+c+1/c);</td><td> </td><td class="rblock">       c = c*c;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  a1 = q*(1-tan_nu_h*tan_nu_h);</td><td> </td><td class="rblock">       const double tan_nu_h = 2*A/(1+c+1/c);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  a2 = 2.0*q*tan_nu_h;</td><td> </td><td class="rblock">       a1 = q*(1-tan_nu_h*tan_nu_h);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       a2 = 2.0*q*tan_nu_h;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">*/</td><td> </td><td class="right">*/</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// GZ This implementation now follows Heafner, ch 5.5</td><td> </td><td class="right">// GZ This implementation now follows Heafner, ch 5.5</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0003" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">static void InitPar(const double q, const double n, const double dt, double</td><td> </td><td class="rblock">static void InitPar(const double q, const double n, const double dt, double</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"> &amp;rCosNu, double &amp;rSinNu) {</td><td> </td><td class="rblock"> &amp;rCosNu, double &amp;rSinNu)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">//        qDebug() &lt;&lt; "InitPar";</td><td> </td><td class="rblock">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">//    const double M=dt*sqrt(GAUSS_GRAV_CONST/(2.0*q*q*q));</td><td> </td><td class="rblock">//     qDebug() &lt;&lt; "InitPar";</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">//    const double W=1.5*M;</td><td> </td><td class="rblock">//     const double M=dt*sqrt(GAUSS_GRAV_CONST/(2.0*q*q*q));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    const double W=dt*n;</td><td> </td><td class="rblock">//     const double W=1.5*M;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    const double <span class="delete">Y=cbrt(W+sqrt(W*W+1));</span></td><td> </td><td class="rblock">       const double W=dt*n;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    const double tanNu2=Y-1.0/Y; // Heafner (5.5.8) has an error here, <span class="delete">writ</span></td><td> </td><td class="rblock">       const double <span class="insert">Y=cbrt(W+std::sqrt(W*W+1));</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">es</span> (Y-1)/Y.</td><td> </td><td class="rblock">       const double tanNu2=Y-1.0/Y; // Heafner (5.5.8) has an error here, <span class="insert">w</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    rCosNu=q*(1.0-tanNu2*tanNu2);</td><td> </td><td class="rblock"><span class="insert">rites</span> (Y-1)/Y.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    rSinNu=2.0*q*tanNu2;</td><td> </td><td class="rblock">       rCosNu=q*(1.0-tanNu2*tanNu2);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       rSinNu=2.0*q*tanNu2;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! Solve true anomaly nu for elliptical orbit with Laguerre-Conway's metho
d. (May have high e)</td><td> </td><td class="right">//! Solve true anomaly nu for elliptical orbit with Laguerre-Conway's metho
d. (May have high e)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! @param q: perihel distance</td><td> </td><td class="right">//! @param q: perihel distance</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! @param n: mean motion</td><td> </td><td class="right">//! @param n: mean motion</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! @param e: excentricity</td><td> </td><td class="right">//! @param e: excentricity</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! @param dt: days from perihel</td><td> </td><td class="right">//! @param dt: days from perihel</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! @param rCosNu: r*cos(nu)</td><td> </td><td class="right">//! @param rCosNu: r*cos(nu)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! @param rSinNu: r*sin(nu)</td><td> </td><td class="right">//! @param rSinNu: r*sin(nu)</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0004" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">static void InitEll(const double q, const double n, const double e, const d</td><td> </td><td class="rblock">static void InitEll(const double q, const double n, const double e, const d</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">ouble dt, double &amp;rCosNu, double &amp;rSinNu) {</td><td> </td><td class="rblock">ouble dt, double &amp;rCosNu, double &amp;rSinNu)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">//    qDebug() &lt;&lt; "InitEll";</td><td> </td><td class="rblock">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    Q_ASSERT(e&lt;1.0);</td><td> </td><td class="rblock">//     qDebug() &lt;&lt; "InitEll";</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  const double a = q/(1.0-e); // semimajor axis</td><td> </td><td class="rblock">       Q_ASSERT(e&lt;1.0);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  double M = fmod(n*dt,2*M_PI);  // Mean Anomaly</td><td> </td><td class="rblock">       const double a = q/(1.0-e); // semimajor axis</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  if (M &lt; 0.0) M += 2.0*M_PI;</td><td> </td><td class="rblock">       double M = fmod(n*dt,2*M_PI);  // Mean Anomaly</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">//  double E = M;</td><td> </td><td class="rblock">       if (M &lt; 0.0) M += 2.0*M_PI;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">//  for (;;) { // Newton(?) Solve Kepler's equation (similar to Meeus <span class="delete">secon</span></td><td> </td><td class="rblock">//     double E = M;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">d</span> method, Astro.Alg. 1998 p.199)</td><td> </td><td class="rblock">//     for (;;) { // Newton(?) Solve Kepler's equation (similar to Meeus <span class="insert">se</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">//    const double Ep = E;</td><td> </td><td class="rblock"><span class="insert">cond</span> method, Astro.Alg. 1998 p.199)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">//    E -= (M-E+e*sin(E))/(e*cos(E)-1);</td><td> </td><td class="rblock">//             const double Ep = E;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">//    if (fabs(E-Ep) &lt; EPSILON) break;</td><td> </td><td class="rblock">//             E -= (M-E+e*sin(E))/(e*cos(E)-1);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">//  }</td><td> </td><td class="rblock">//             if (fabs(E-Ep) &lt; EPSILON) break;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  // GZ: Comet orbits are quite often near-parabolic, where this may <span class="delete">still</span> </td><td> </td><td class="rblock">//     }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">only converge slowly.</td><td> </td><td class="rblock">//     GZ: Comet orbits are quite often near-parabolic, where this may <span class="insert">stil</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  // Better always use Laguerre-Conway. See Heafner, Ch. 5.3</td><td> </td><td class="rblock"><span class="insert">l</span> only converge slowly.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  double E=M+0.85*e*StelUtils::sign(sin(M));</td><td> </td><td class="rblock">//     Better always use Laguerre-Conway. See Heafner, Ch. 5.3</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  for <span class="delete">(;;){</span></td><td> </td><td class="rblock">       double E=M+0.85*e*StelUtils::sign(sin(M));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">      const double Ep=E;</td><td> </td><td class="rblock">       for <span class="insert">(;;)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">      const double f2=e*sin(E);</td><td> </td><td class="rblock"><span class="insert">       {</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">      const double f=E-f2-M;</td><td> </td><td class="rblock">               const double Ep=E;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">      const double f1=1.0-e*cos(E);</td><td> </td><td class="rblock">               const double f2=e*sin(E);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">      E+= <span class="delete">(-5.0*f)/(f1+StelUtils::sign(f1)*sqrt(fabs(16.0*f1*f1-20.0*f*f2))</span></td><td> </td><td class="rblock">               const double f=E-f2-M;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">);</span></td><td> </td><td class="rblock">               const double f1=1.0-e*cos(E);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">      if (fabs(E-Ep) &lt; EPSILON) break;</td><td> </td><td class="rblock">               E+= <span class="insert">(-5.0*f)/(f1+StelUtils::sign(f1)*std::sqrt(fabs(16.0*f1*</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  }</td><td> </td><td class="rblock"><span class="insert">f1-20.0*f*f2)));</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  // Note: q=a*(1-e)</td><td> </td><td class="rblock">               if (fabs(E-Ep) &lt; EPSILON) break;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  const double h1 = <span class="delete">q*sqrt((1.0+e)/(1.0-e));</span>  // elsewhere: a <span class="delete">sqrt(1-e²)</span>   </td><td> </td><td class="rblock">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  ... q / (1-e) sqrt( (1+e)(1-e)) = q sqrt((1+e)/(1-e))</td><td> </td><td class="rblock">//     Note: q=a*(1-e)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  rCosNu = a*(cos(E)-e);</td><td> </td><td class="rblock">       const double h1 = <span class="insert">q*std::sqrt((1.0+e)/(1.0-e));</span>  // elsewhere: a <span class="insert">sqr</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  rSinNu = h1*sin(E);</td><td> </td><td class="rblock"><span class="insert">t(1-e²)</span>     ... q / (1-e) sqrt( (1+e)(1-e)) = q sqrt((1+e)/(1-e))</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       rCosNu = a*(cos(E)-e);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       rSinNu = h1*sin(E);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! Compute position vector and (optional) speed vector from orbital elemen
ts and true anomaly components. See e.g. Heafner, Fund.Eph.Comp.1999</td><td> </td><td class="right">//! Compute position vector and (optional) speed vector from orbital elemen
ts and true anomaly components. See e.g. Heafner, Fund.Eph.Comp.1999</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! @param i inclination</td><td> </td><td class="right">//! @param i inclination</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! @param Omega, longitude of ascending node</td><td> </td><td class="right">//! @param Omega, longitude of ascending node</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! @param w omega, argument of pericenter</td><td> </td><td class="right">//! @param w omega, argument of pericenter</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! @param rCosNu: r*cos(nu)</td><td> </td><td class="right">//! @param rCosNu: r*cos(nu)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! @param rSinNu: r*sin(nu)</td><td> </td><td class="right">//! @param rSinNu: r*sin(nu)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! @param rx: x component of position vector, AU</td><td> </td><td class="right">//! @param rx: x component of position vector, AU</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! @param ry: y component of position vector, AU</td><td> </td><td class="right">//! @param ry: y component of position vector, AU</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! @param rz: z component of position vector, AU</td><td> </td><td class="right">//! @param rz: z component of position vector, AU</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! @param withVelVector also compute velocity vector (required for comet t
ails)</td><td> </td><td class="right">//! @param withVelVector also compute velocity vector (required for comet t
ails)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! @param e excentricity (required if withVelVector=true)</td><td> </td><td class="right">//! @param e excentricity (required if withVelVector=true)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! @param q perihel distance, AU (required if withVelVector=true)</td><td> </td><td class="right">//! @param q perihel distance, AU (required if withVelVector=true)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! @param rdotx: x component of velocity vector, AU/d</td><td> </td><td class="right">//! @param rdotx: x component of velocity vector, AU/d</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! @param rdoty: y component of velocity vector, AU/d</td><td> </td><td class="right">//! @param rdoty: y component of velocity vector, AU/d</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//! @param rdotz: z component of velocity vector, AU/d</td><td> </td><td class="right">//! @param rdotz: z component of velocity vector, AU/d</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void Init3D(const double i, const double Omega, const double w, const doubl
e rCosNu, const double rSinNu,</td><td> </td><td class="right">void Init3D(const double i, const double Omega, const double w, const doubl
e rCosNu, const double rSinNu,</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0005" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">            double &amp;rx,double &amp;ry,double &amp;rz, double &amp;rdotx, double &amp;rdoty,</td><td> </td><td class="rblock">           double &amp;rx,double &amp;ry,double &amp;rz, double &amp;rdotx, double &amp;rdoty, </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"> double &amp;rdotz, const bool withVelVector=false, const double e=0.0, const <span class="delete">d</span></td><td> </td><td class="rblock">double &amp;rdotz, const bool withVelVector=false,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">ouble</span> q=0.0) {</td><td> </td><td class="rblock">           const double e=0.0, const <span class="insert">double</span> q=0.0)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  const double cw = cos(w);</td><td> </td><td class="rblock">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  const double sw = sin(w);</td><td> </td><td class="rblock">       const double cw = cos(w);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  const double cOm = cos(Omega);</td><td> </td><td class="rblock">       const double sw = sin(w);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  const double sOm = sin(Omega);</td><td> </td><td class="rblock">       const double cOm = cos(Omega);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  const double ci = cos(i);</td><td> </td><td class="rblock">       const double sOm = sin(Omega);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  const double si = sin(i);</td><td> </td><td class="rblock">       const double ci = cos(i);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  const double Px=-sw*sOm*ci+cw*cOm; // Heafner, 5.3.1 Px</td><td> </td><td class="rblock">       const double si = sin(i);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  const double Qx=-cw*sOm*ci-sw*cOm; // Heafner, 5.3.4 Qx</td><td> </td><td class="rblock">       const double Px=-sw*sOm*ci+cw*cOm; // Heafner, 5.3.1 Px</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  const double Py= sw*cOm*ci+cw*sOm; // Heafner, 5.3.2 Py</td><td> </td><td class="rblock">       const double Qx=-cw*sOm*ci-sw*cOm; // Heafner, 5.3.4 Qx</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  const double Qy= cw*cOm*ci-sw*sOm; // Heafner, 5.3.5 Qy</td><td> </td><td class="rblock">       const double Py= sw*cOm*ci+cw*sOm; // Heafner, 5.3.2 Py</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  const double Pz= sw*si;            // Heafner, 5.3.3 Pz</td><td> </td><td class="rblock">       const double Qy= cw*cOm*ci-sw*sOm; // Heafner, 5.3.5 Qy</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  const double Qz= cw*si;            // Heafner, 5.3.6 Qz</td><td> </td><td class="rblock">       const double Pz= sw*si;            // Heafner, 5.3.3 Pz</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  rx = Px*rCosNu+Qx*rSinNu; // Heafner, 5.3.18 r</td><td> </td><td class="rblock">       const double Qz= cw*si;            // Heafner, 5.3.6 Qz</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  ry = Py*rCosNu+Qy*rSinNu;</td><td> </td><td class="rblock">       rx = Px*rCosNu+Qx*rSinNu; // Heafner, 5.3.18 r</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  rz = Pz*rCosNu+Qz*rSinNu;</td><td> </td><td class="rblock">       ry = Py*rCosNu+Qy*rSinNu;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  if (withVelVector) {</td><td> </td><td class="rblock">       rz = Pz*rCosNu+Qz*rSinNu;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">      const double <span class="delete">r=sqrt(rSinNu*rSinNu+rCosNu*rCosNu);</span></td><td> </td><td class="rblock">       if (withVelVector)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">      const double sinNu=rSinNu/r;</td><td> </td><td class="rblock">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">      const double cosNu=rCosNu/r;</td><td> </td><td class="rblock">               const double <span class="insert">r=std::sqrt(rSinNu*rSinNu+rCosNu*rCosNu);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">      const double p=q*(1.0+e);</td><td> </td><td class="rblock">               const double sinNu=rSinNu/r;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">      const double <span class="delete">sqrtMuP=sqrt(GAUSS_GRAV_CONST/p);</span></td><td> </td><td class="rblock">               const double cosNu=rCosNu/r;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">      rdotx=sqrtMuP*((e+cosNu)*Qx - sinNu*Px); // Heafner, 5.3.19 r'</td><td> </td><td class="rblock">               const double p=q*(1.0+e);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">      rdoty=sqrtMuP*((e+cosNu)*Qy - sinNu*Py);</td><td> </td><td class="rblock">               const double <span class="insert">sqrtMuP=std::sqrt(GAUSS_GRAV_CONST/p);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">      rdotz=sqrtMuP*((e+cosNu)*Qz - sinNu*Pz);</td><td> </td><td class="rblock">               rdotx=sqrtMuP*((e+cosNu)*Qx - sinNu*Px); // Heafner, 5.3.19 </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  }</td><td> </td><td class="rblock">r'</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">               rdoty=sqrtMuP*((e+cosNu)*Qy - sinNu*Py);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">               rdotz=sqrtMuP*((e+cosNu)*Qz - sinNu*Pz);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">CometOrbit::CometOrbit(double pericenterDistance,</td><td> </td><td class="right">CometOrbit::CometOrbit(double pericenterDistance,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       double eccentricity,</td><td> </td><td class="right">                       double eccentricity,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       double inclination,</td><td> </td><td class="right">                       double inclination,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       double ascendingNode,</td><td> </td><td class="right">                       double ascendingNode,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       double argOfPerhelion,</td><td> </td><td class="right">                       double argOfPerhelion,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       double timeAtPerihelion,</td><td> </td><td class="right">                       double timeAtPerihelion,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       double orbitGoodDays,</td><td> </td><td class="right">                       double orbitGoodDays,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                       double meanMotion,              // GZ: for parabolic
s, this is W/dt in Heafner's lettering</td><td> </td><td class="right">                       double meanMotion,              // GZ: for parabolic
s, this is W/dt in Heafner's lettering</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                      double parentRotObliquity,</td><td> </td><td class="right">                      double parentRotObliquity,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                      double parentRotAscendingnode,</td><td> </td><td class="right">                      double parentRotAscendingnode,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                      double parentRotJ2000Longitude)</td><td> </td><td class="right">                      double parentRotJ2000Longitude)</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0006" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                      //)</td><td> </td><td class="rblock">                     //)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">            <span class="delete">:q(pericenterDistance),e(eccentricity),i(inclination),</span></td><td> </td><td class="rblock">       <span class="insert">: q(pericenterDistance),</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">            Om(ascendingNode),w(argOfPerhelion),t0(timeAtPerihelion),</span></td><td> </td><td class="rblock"><span class="insert">         e(eccentricity),</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">           n(meanMotion), updateTails(true), orbitGood(orbitGoodDays) {</td><td> </td><td class="rblock"><span class="insert">         i(inclination),</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  rdot.set(0.0, 0.0, 0.0);</td><td> </td><td class="rblock"><span class="insert">         Om(ascendingNode),</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  const double c_obl = cos(parentRotObliquity);</td><td> </td><td class="rblock"><span class="insert">         w(argOfPerhelion),</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  const double s_obl = sin(parentRotObliquity);</td><td> </td><td class="rblock"><span class="insert">         t0(timeAtPerihelion),</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  const double c_nod = cos(parentRotAscendingnode);</td><td> </td><td class="rblock">         n(meanMotion),</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  const double s_nod = sin(parentRotAscendingnode);</td><td> </td><td class="rblock">         updateTails(true),</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  const double cj = cos(parentRotJ2000Longitude);</td><td> </td><td class="rblock">         orbitGood(orbitGoodDays)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  const double sj = sin(parentRotJ2000Longitude);</td><td> </td><td class="rblock">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                                                           </td><td> </td><td class="rblock">       rdot.set(0.0, 0.0, 0.0);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">//  rotateToVsop87[0] =  c_nod;</td><td> </td><td class="rblock">       const double c_obl = cos(parentRotObliquity);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">//  rotateToVsop87[1] = -s_nod * c_obl;</td><td> </td><td class="rblock">       const double s_obl = sin(parentRotObliquity);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">//  rotateToVsop87[2] =  s_nod * s_obl;</td><td> </td><td class="rblock">       const double c_nod = cos(parentRotAscendingnode);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">//  rotateToVsop87[3] =  s_nod;</td><td> </td><td class="rblock">       const double s_nod = sin(parentRotAscendingnode);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">//  rotateToVsop87[4] =  c_nod * c_obl;</td><td> </td><td class="rblock">       const double cj = cos(parentRotJ2000Longitude);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">//  rotateToVsop87[5] = -c_nod * s_obl;</td><td> </td><td class="rblock">       const double sj = sin(parentRotJ2000Longitude);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">//  rotateToVsop87[6] =  0.0;</td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">//  rotateToVsop87[7] =          s_obl;</td><td> </td><td class="rblock">//     rotateToVsop87[0] =  c_nod;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">//  rotateToVsop87[8] =          c_obl;</td><td> </td><td class="rblock">//     rotateToVsop87[1] = -s_nod * c_obl;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  rotateToVsop87[0] =  c_nod*cj-s_nod*c_obl*sj;</td><td> </td><td class="rblock">//     rotateToVsop87[2] =  s_nod * s_obl;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  rotateToVsop87[1] = -c_nod*sj-s_nod*c_obl*cj;</td><td> </td><td class="rblock">//     rotateToVsop87[3] =  s_nod;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  rotateToVsop87[2] =           s_nod*s_obl;</td><td> </td><td class="rblock">//     rotateToVsop87[4] =  c_nod * c_obl;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  rotateToVsop87[3] =  s_nod*cj+c_nod*c_obl*sj;</td><td> </td><td class="rblock">//     rotateToVsop87[5] = -c_nod * s_obl;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  rotateToVsop87[4] = -s_nod*sj+c_nod*c_obl*cj;</td><td> </td><td class="rblock">//     rotateToVsop87[6] =  0.0;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  rotateToVsop87[5] =          -c_nod*s_obl;</td><td> </td><td class="rblock">//     rotateToVsop87[7] =          s_obl;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  rotateToVsop87[6] =                 s_obl*sj;</td><td> </td><td class="rblock">//     rotateToVsop87[8] =          c_obl;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  rotateToVsop87[7] =                 s_obl*cj;</td><td> </td><td class="rblock">       rotateToVsop87[0] =  c_nod*cj-s_nod*c_obl*sj;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  rotateToVsop87[8] =                 c_obl;</td><td> </td><td class="rblock">       rotateToVsop87[1] = -c_nod*sj-s_nod*c_obl*cj;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">//  qDebug() &lt;&lt; "CometOrbit::()...done";</td><td> </td><td class="rblock">       rotateToVsop87[2] =           s_nod*s_obl;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">}</td><td> </td><td class="rblock">       rotateToVsop87[3] =  s_nod*cj+c_nod*c_obl*sj;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                                                           </td><td> </td><td class="rblock">       rotateToVsop87[4] = -s_nod*sj+c_nod*c_obl*cj;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">void CometOrbit::positionAtTimevInVSOP87Coordinates(double JD, double *v, b</td><td> </td><td class="rblock">       rotateToVsop87[5] =          -c_nod*s_obl;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">ool updateVelocityVector)  {</td><td> </td><td class="rblock">       rotateToVsop87[6] =                 s_obl*sj;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  JD -= t0;</td><td> </td><td class="rblock">       rotateToVsop87[7] =                 s_obl*cj;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  double rCosNu,rSinNu;</td><td> </td><td class="rblock">       rotateToVsop87[8] =                 c_obl;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  // temporary solve freezes for near-parabolic comets - using (e &lt; <span class="delete">0.9999)</span></td><td> </td><td class="rblock">       //  qDebug() &lt;&lt; "CometOrbit::()...done";</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"> for elliptical orbits</td><td> </td><td class="rblock">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  // TODO: improve calculations orbits for near-parabolic comets --AW</td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">//  if (e &lt; 0.9999) InitEll(q,n,e,JD,a1,a2);</td><td> </td><td class="rblock">void CometOrbit::positionAtTimevInVSOP87Coordinates(double JD, double *v, b</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  if (e &lt; 1.0) InitEll(q,n,e,JD,rCosNu,rSinNu); // GZ: After solving <span class="delete">with L</span></td><td> </td><td class="rblock">ool updateVelocityVector)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">aguerre-Conway,</span> I dare to go for 1.0.</td><td> </td><td class="rblock">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  else if (e &gt; 1.0) {</td><td> </td><td class="rblock">       JD -= t0;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">//      qDebug() &lt;&lt; "Hyperbolic orbit for ecc=" &lt;&lt; e &lt;&lt; ", i=" &lt;&lt; i &lt;&lt; ", <span class="delete">w</span></td><td> </td><td class="rblock">       double rCosNu,rSinNu;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">="</span> &lt;&lt; w &lt;&lt; ", Mean Motion n=" &lt;&lt; n;</td><td> </td><td class="rblock">//     temporary solve freezes for near-parabolic comets - using (e &lt; <span class="insert">0.999</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">      InitHyp(q,n,e,JD,rCosNu,rSinNu);</td><td> </td><td class="rblock"><span class="insert">9)</span> for elliptical orbits</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  }</td><td> </td><td class="rblock">//     TODO: improve calculations orbits for near-parabolic comets --AW</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  else InitPar(q,n,JD,rCosNu,rSinNu);</td><td> </td><td class="rblock">//     if (e &lt; 0.9999) InitEll(q,n,e,JD,a1,a2);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  double p0,p1,p2, s0, s1, s2;</td><td> </td><td class="rblock">       if (e &lt; 1.0) InitEll(q,n,e,JD,rCosNu,rSinNu); // GZ: After solving <span class="insert">w</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  Init3D(i,Om,w,rCosNu,rSinNu,p0,p1,p2, s0, s1, s2, <span class="delete">updateVelocityVector, e</span></td><td> </td><td class="rblock"><span class="insert">ith Laguerre-Conway,</span> I dare to go for 1.0.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">,</span> q);</td><td> </td><td class="rblock">       else if (e &gt; 1.0)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  v[0] = rotateToVsop87[0]*p0 + rotateToVsop87[1]*p1 + <span class="delete">rotateToVsop87[2]*p2</span></td><td> </td><td class="rblock">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">;</span></td><td> </td><td class="rblock">               // qDebug() &lt;&lt; "Hyperbolic orbit for ecc=" &lt;&lt; e &lt;&lt; ", i=" &lt;&lt;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  v[1] = rotateToVsop87[3]*p0 + rotateToVsop87[4]*p1 + <span class="delete">rotateToVsop87[5]*p2</span></td><td> </td><td class="rblock"> i &lt;&lt; ", <span class="insert">w="</span> &lt;&lt; w &lt;&lt; ", Mean Motion n=" &lt;&lt; n;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">;</span></td><td> </td><td class="rblock">               InitHyp(q,n,e,JD,rCosNu,rSinNu);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  v[2] = rotateToVsop87[6]*p0 + rotateToVsop87[7]*p1 + <span class="delete">rotateToVsop87[8]*p2</span></td><td> </td><td class="rblock">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">;</span></td><td> </td><td class="rblock">       else InitPar(q,n,JD,rCosNu,rSinNu);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                                                           </td><td> </td><td class="rblock">       double p0,p1,p2, s0, s1, s2;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  if (updateVelocityVector) {</td><td> </td><td class="rblock">       Init3D(i,Om,w,rCosNu,rSinNu,p0,p1,p2, s0, s1, s2, <span class="insert">updateVelocityVect</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">      rdot.set(s0, s1, s2);</td><td> </td><td class="rblock"><span class="insert">or, e,</span> q);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">      updateTails=true;</td><td> </td><td class="rblock">       v[0] = rotateToVsop87[0]*p0 + rotateToVsop87[1]*p1 + <span class="insert">rotateToVsop87[</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  }</td><td> </td><td class="rblock"><span class="insert">2]*p2;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       v[1] = rotateToVsop87[3]*p0 + rotateToVsop87[4]*p1 + <span class="insert">rotateToVsop87[</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">5]*p2;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       v[2] = rotateToVsop87[6]*p0 + rotateToVsop87[7]*p1 + <span class="insert">rotateToVsop87[</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">8]*p2;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       if (updateVelocityVector)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">               rdot.set(s0, s1, s2);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">               updateTails=true;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">EllipticalOrbit::EllipticalOrbit(double pericenterDistance,</td><td> </td><td class="right">EllipticalOrbit::EllipticalOrbit(double pericenterDistance,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                                 double eccentricity,</td><td> </td><td class="right">                                 double eccentricity,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                                 double inclination,</td><td> </td><td class="right">                                 double inclination,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                                 double ascendingNode,</td><td> </td><td class="right">                                 double ascendingNode,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                                 double argOfPeriapsis,</td><td> </td><td class="right">                                 double argOfPeriapsis,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                                 double meanAnomalyAtEpoch,</td><td> </td><td class="right">                                 double meanAnomalyAtEpoch,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                                 double period,</td><td> </td><td class="right">                                 double period,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                                 double epoch,</td><td> </td><td class="right">                                 double epoch,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">                                 double parentRotObliquity,</td><td> </td><td class="right">                                 double parentRotObliquity,</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0007" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                 double parentRotAscendingnode,</td><td> </td><td class="rblock">                                double parentRotAscendingnode,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                                                double <span class="delete">pare</span></td><td> </td><td class="rblock">                                double <span class="insert">parentRotJ2000Longitude)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">ntRotJ2000Longitude)</span> :</td><td> </td><td class="rblock">       : pericenterDistance(pericenterDistance),</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                                                           </td><td> </td><td class="rblock">         eccentricity(eccentricity),</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    pericenterDistance(pericenterDistance),</td><td> </td><td class="rblock">         inclination(inclination),</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    eccentricity(eccentricity),</td><td> </td><td class="rblock">         ascendingNode(ascendingNode),</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    inclination(inclination),</td><td> </td><td class="rblock">         argOfPeriapsis(argOfPeriapsis),</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    ascendingNode(ascendingNode),</td><td> </td><td class="rblock">         meanAnomalyAtEpoch(meanAnomalyAtEpoch),</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    argOfPeriapsis(argOfPeriapsis),</td><td> </td><td class="rblock">         period(period),</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    meanAnomalyAtEpoch(meanAnomalyAtEpoch),</td><td> </td><td class="rblock">         epoch(epoch)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    period(period),</td><td> </td><td class="rblock">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    epoch(epoch)</td><td> </td><td class="rblock">       const double c_obl = cos(parentRotObliquity);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">{</td><td> </td><td class="rblock">       const double s_obl = sin(parentRotObliquity);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                                                           </td><td> </td><td class="rblock">       const double c_nod = cos(parentRotAscendingnode);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  const double c_obl = cos(parentRotObliquity);</td><td> </td><td class="rblock">       const double s_nod = sin(parentRotAscendingnode);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  const double s_obl = sin(parentRotObliquity);</td><td> </td><td class="rblock">       const double cj = cos(parentRotJ2000Longitude);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  const double c_nod = cos(parentRotAscendingnode);</td><td> </td><td class="rblock">       const double sj = sin(parentRotJ2000Longitude);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  const double s_nod = sin(parentRotAscendingnode);</td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  const double cj = cos(parentRotJ2000Longitude);</td><td> </td><td class="rblock">       rotateToVsop87[0] =  c_nod*cj-s_nod*c_obl*sj;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  const double sj = sin(parentRotJ2000Longitude);</td><td> </td><td class="rblock">       rotateToVsop87[1] = -c_nod*sj-s_nod*c_obl*cj;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                                                           </td><td> </td><td class="rblock">       rotateToVsop87[2] =           s_nod*s_obl;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  rotateToVsop87[0] =  c_nod*cj-s_nod*c_obl*sj;</td><td> </td><td class="rblock">       rotateToVsop87[3] =  s_nod*cj+c_nod*c_obl*sj;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  rotateToVsop87[1] = -c_nod*sj-s_nod*c_obl*cj;</td><td> </td><td class="rblock">       rotateToVsop87[4] = -s_nod*sj+c_nod*c_obl*cj;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  rotateToVsop87[2] =           s_nod*s_obl;</td><td> </td><td class="rblock">       rotateToVsop87[5] =          -c_nod*s_obl;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  rotateToVsop87[3] =  s_nod*cj+c_nod*c_obl*sj;</td><td> </td><td class="rblock">       rotateToVsop87[6] =                 s_obl*sj;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  rotateToVsop87[4] = -s_nod*sj+c_nod*c_obl*cj;</td><td> </td><td class="rblock">       rotateToVsop87[7] =                 s_obl*cj;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  rotateToVsop87[5] =          -c_nod*s_obl;</td><td> </td><td class="rblock">       rotateToVsop87[8] =                 c_obl;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  rotateToVsop87[6] =                 s_obl*sj;</td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  rotateToVsop87[7] =                 s_obl*cj;</td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  rotateToVsop87[8] =                 c_obl;</td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// Standard iteration for solving Kepler's Equation</td><td> </td><td class="right">// Standard iteration for solving Kepler's Equation</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">struct SolveKeplerFunc1 : public unary_function&lt;double, double&gt;</td><td> </td><td class="right">struct SolveKeplerFunc1 : public unary_function&lt;double, double&gt;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0008" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    double ecc;</td><td> </td><td class="rblock">       double ecc;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    double M;</td><td> </td><td class="rblock">       double M;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0009" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    SolveKeplerFunc1(double _ecc, double _M) : ecc(_ecc), M(_M) {}</td><td> </td><td class="rblock">    <span class="insert">   </span>SolveKeplerFunc1(double _ecc, double _M) : ecc(_ecc), M(_M) {}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0010" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    double operator()(double x) const</td><td> </td><td class="rblock">       double operator()(double x) const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    {</td><td> </td><td class="rblock">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">        return M + ecc * sin(x);</td><td> </td><td class="rblock">               return M + ecc * sin(x);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    }</td><td> </td><td class="rblock">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">};</td><td> </td><td class="right">};</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// Faster converging iteration for Kepler's Equation; more efficient</td><td> </td><td class="right">// Faster converging iteration for Kepler's Equation; more efficient</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// than above for orbits with eccentricities greater than 0.3.  This</td><td> </td><td class="right">// than above for orbits with eccentricities greater than 0.3.  This</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// is from Jean Meeus's _Astronomical Algorithms_ (2nd ed), p. 199</td><td> </td><td class="right">// is from Jean Meeus's _Astronomical Algorithms_ (2nd ed), p. 199</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">struct SolveKeplerFunc2 : public unary_function&lt;double, double&gt;</td><td> </td><td class="right">struct SolveKeplerFunc2 : public unary_function&lt;double, double&gt;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0011" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    double ecc;</td><td> </td><td class="rblock">       double ecc;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    double M;</td><td> </td><td class="rblock">       double M;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0012" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    SolveKeplerFunc2(double _ecc, double _M) : ecc(_ecc), M(_M) {}</td><td> </td><td class="rblock">    <span class="insert">   </span>SolveKeplerFunc2(double _ecc, double _M) : ecc(_ecc), M(_M) {}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0013" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    double operator()(double x) const</td><td> </td><td class="rblock">       double operator()(double x) const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    {</td><td> </td><td class="rblock">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">        return x + (M + ecc * sin(x) - x) / (1 - ecc * cos(x));</td><td> </td><td class="rblock">               return x + (M + ecc * sin(x) - x) / (1 - ecc * cos(x));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    }</td><td> </td><td class="rblock">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">};</td><td> </td><td class="right">};</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">double sign(double x)</td><td> </td><td class="right">double sign(double x)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0014" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    if (x &lt; 0.)</td><td> </td><td class="rblock">       if (x &lt; 0.)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">        return -1.;</td><td> </td><td class="rblock">               return -1.;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    else if (x &gt; 0.)</td><td> </td><td class="rblock">       else if (x &gt; 0.)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">        return 1.;</td><td> </td><td class="rblock">               return 1.;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    else</td><td> </td><td class="rblock">       else</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">        return 0.;</td><td> </td><td class="rblock">               return 0.;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">struct SolveKeplerLaguerreConway : public unary_function&lt;double, double&gt;</td><td> </td><td class="right">struct SolveKeplerLaguerreConway : public unary_function&lt;double, double&gt;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0015" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    double ecc;</td><td> </td><td class="rblock">       double ecc;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    double M;</td><td> </td><td class="rblock">       double M;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0016" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    SolveKeplerLaguerreConway(double _ecc, double _M) : ecc(_ecc), M(_M) {}</td><td> </td><td class="rblock">       SolveKeplerLaguerreConway(double _ecc, double _M) : ecc(_ecc), M(_M)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    // cf Heafner, Fundamental Ephemeris Computations p.73</td><td> </td><td class="rblock"> {}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    // GZ: note&amp;add Heafner's initial guess for E!</td><td> </td><td class="rblock">       // cf Heafner, Fundamental Ephemeris Computations p.73</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    double operator()(double E) const</td><td> </td><td class="rblock">       // GZ: note&amp;add Heafner's initial guess for E!</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    {</td><td> </td><td class="rblock">       double operator()(double E) const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">        double s = ecc * sin(E);</td><td> </td><td class="rblock">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">        double c = ecc * cos(E);</td><td> </td><td class="rblock">               double s = ecc * sin(E);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">        double f = E - s - M;</td><td> </td><td class="rblock">               double c = ecc * cos(E);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">        double f1 = 1 - c;</td><td> </td><td class="rblock">               double f = E - s - M;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">        double f2 = s;</td><td> </td><td class="rblock">               double f1 = 1 - c;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">        E += -5 * f / (f1 + sign(f1) * <span class="delete">sqrt(abs(16</span> * f1 * f1 - 20 * f * <span class="delete">f2)</span></td><td> </td><td class="rblock">               double f2 = s;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">));</span></td><td> </td><td class="rblock">               E += -5 * f / (f1 + sign(f1) * <span class="insert">std::sqrt(abs(16</span> * f1 * f1 - </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">20 * f * <span class="insert">f2)));</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0017" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">        return E;</td><td> </td><td class="rblock">               return E;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    }</td><td> </td><td class="rblock">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">};</td><td> </td><td class="right">};</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">struct SolveKeplerLaguerreConwayHyp : public unary_function&lt;double, double&gt;</td><td> </td><td class="right">struct SolveKeplerLaguerreConwayHyp : public unary_function&lt;double, double&gt;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0018" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    double ecc;</td><td> </td><td class="rblock">       double ecc;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    double M;</td><td> </td><td class="rblock">       double M;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0019" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    SolveKeplerLaguerreConwayHyp(double _ecc, double _M) : ecc(_ecc), <span class="delete">M(_M)</span></td><td> </td><td class="rblock">       SolveKeplerLaguerreConwayHyp(double _ecc, double _M) : ecc(_ecc), <span class="insert">M(</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"> {}</td><td> </td><td class="rblock"><span class="insert">_M)</span> {}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    // cf Heafner, Fundamental Ephemeris Computations p.73</td><td> </td><td class="rblock">       // cf Heafner, Fundamental Ephemeris Computations p.73</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    double operator()(double x) const</td><td> </td><td class="rblock">       double operator()(double x) const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    {</td><td> </td><td class="rblock">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">        double s = ecc * sinh(x);</td><td> </td><td class="rblock">               double s = ecc * sinh(x);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">        double c = ecc * cosh(x);</td><td> </td><td class="rblock">               double c = ecc * cosh(x);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">        double f = s - x - M;</td><td> </td><td class="rblock">               double f = s - x - M;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">        double f1 = c - 1;</td><td> </td><td class="rblock">               double f1 = c - 1;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">        double f2 = s;</td><td> </td><td class="rblock">               double f2 = s;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">        x += -5 * f / (f1 + sign(f1) * <span class="delete">sqrt(abs(16</span> * f1 * f1 - 20 * f * <span class="delete">f2)</span></td><td> </td><td class="rblock">               x += -5 * f / (f1 + sign(f1) * <span class="insert">std::sqrt(abs(16</span> * f1 * f1 - </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">));</span></td><td> </td><td class="rblock">20 * f * <span class="insert">f2)));</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0020" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">        return x;</td><td> </td><td class="rblock">               return x;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    }</td><td> </td><td class="rblock">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">};</td><td> </td><td class="right">};</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">typedef pair&lt;double, double&gt; Solution;</td><td> </td><td class="right">typedef pair&lt;double, double&gt; Solution;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">double EllipticalOrbit::eccentricAnomaly(const double M) const</td><td> </td><td class="right">double EllipticalOrbit::eccentricAnomaly(const double M) const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0021" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    if (eccentricity == 0.0)</td><td> </td><td class="rblock">       if (eccentricity == 0.0)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    {</td><td> </td><td class="rblock">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">        // Circular orbit</td><td> </td><td class="rblock">               // Circular orbit</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">        return M;</td><td> </td><td class="rblock">               return M;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    }</td><td> </td><td class="rblock">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    else if (eccentricity &lt; 0.2)</td><td> </td><td class="rblock">       else if (eccentricity &lt; 0.2)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    {</td><td> </td><td class="rblock">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">        // Low eccentricity, so use the standard iteration technique</td><td> </td><td class="rblock">               // Low eccentricity, so use the standard iteration technique</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">        Solution sol = <span class="delete">solveIteration_fixed(SolveKeplerFunc1(eccentricity,</span> </td><td> </td><td class="rblock">               Solution sol = <span class="insert">solveIteration_fixed(SolveKeplerFunc1(eccentr</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">M), M, 5);</td><td> </td><td class="rblock"><span class="insert">icity,</span> M), M, 5);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">        return sol.first;</td><td> </td><td class="rblock">               return sol.first;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    }</td><td> </td><td class="rblock">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    else if (eccentricity &lt; 0.9)</td><td> </td><td class="rblock">       else if (eccentricity &lt; 0.9)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    {</td><td> </td><td class="rblock">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">        // Higher eccentricity elliptical orbit; use a more complex but</td><td> </td><td class="rblock">               // Higher eccentricity elliptical orbit; use a more complex </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">        // much faster converging iteration.</td><td> </td><td class="rblock">but</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">        Solution sol = <span class="delete">solveIteration_fixed(SolveKeplerFunc2(eccentricity,</span> </td><td> </td><td class="rblock">               // much faster converging iteration.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">M), M, 6);</td><td> </td><td class="rblock">               Solution sol = <span class="insert">solveIteration_fixed(SolveKeplerFunc2(eccentr</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">        // Debugging</td><td> </td><td class="rblock"><span class="insert">icity,</span> M), M, 6);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">        // qDebug("ecc: %f, error: %f mas\n",</td><td> </td><td class="rblock">               // Debugging</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">        //        eccentricity, radToDeg(sol.second) * 3600000);</td><td> </td><td class="rblock">               // qDebug("ecc: %f, error: %f mas\n",</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">        return sol.first;</td><td> </td><td class="rblock">               //        eccentricity, radToDeg(sol.second) * 3600000);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    }</td><td> </td><td class="rblock">               return sol.first;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    else if (eccentricity &lt; 1.0)</td><td> </td><td class="rblock">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    {</td><td> </td><td class="rblock">       else if (eccentricity &lt; 1.0)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">        // Extremely stable Laguerre-Conway method for solving <span class="delete">Kepler's</span></td><td> </td><td class="rblock">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">        // equation.  Only use this for high-eccentricity orbits, as it</td><td> </td><td class="rblock">               // Extremely stable Laguerre-Conway method for solving <span class="insert">Keple</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       // requires more calculation.</td><td> </td><td class="rblock"><span class="insert">r's</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">        double E = M + 0.85 * eccentricity * sign(sin(M));</td><td> </td><td class="rblock">               // equation.  Only use this for high-eccentricity orbits, as</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">        Solution sol = <span class="delete">solveIteration_fixed(SolveKeplerLaguerreConway(eccen</span></td><td> </td><td class="rblock"> it</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">tricity,</span> M), E, 8);</td><td> </td><td class="rblock">               // requires more calculation.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">        return sol.first;</td><td> </td><td class="rblock">               double E = M + 0.85 * eccentricity * sign(sin(M));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    }</td><td> </td><td class="rblock">               Solution sol = <span class="insert">solveIteration_fixed(SolveKeplerLaguerreConwa</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    else if (eccentricity == 1.0)</td><td> </td><td class="rblock"><span class="insert">y(eccentricity,</span> M), E, 8);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    {</td><td> </td><td class="rblock">               return sol.first;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">        // parabolic orbit; very common for comets</td><td> </td><td class="rblock">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">        // TODO: handle this.</td><td> </td><td class="rblock">       else if (eccentricity == 1.0)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">        // Problem: E does not make sense here. True anomaly <span class="delete">quantities (rS</span></td><td> </td><td class="rblock">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">inNu,</span> rCosNu) computed directly.</td><td> </td><td class="rblock">               // parabolic orbit; very common for comets</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">        // Anyhow, Comets use CometOrbit class.</td><td> </td><td class="rblock">               // TODO: handle this.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">        return M;</td><td> </td><td class="rblock">               // Problem: E does not make sense here. True anomaly <span class="insert">quantit</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    }</td><td> </td><td class="rblock"><span class="insert">ies (rSinNu,</span> rCosNu) computed directly.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    else</td><td> </td><td class="rblock">               // Anyhow, Comets use CometOrbit class.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    {</td><td> </td><td class="rblock">               return M;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">        // Laguerre-Conway method for hyperbolic (ecc &gt; 1) orbits.</td><td> </td><td class="rblock">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">        double E = log(2 * M / eccentricity + 1.85);</td><td> </td><td class="rblock">       else</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">        Solution sol = <span class="delete">solveIteration_fixed(SolveKeplerLaguerreConwayHyp(ec</span></td><td> </td><td class="rblock">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">centricity,</span> M), E, 30);</td><td> </td><td class="rblock">               // Laguerre-Conway method for hyperbolic (ecc &gt; 1) orbits.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">        return sol.first;</td><td> </td><td class="rblock">               double E = log(2 * M / eccentricity + 1.85);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    }</td><td> </td><td class="rblock">               Solution sol = <span class="insert">solveIteration_fixed(SolveKeplerLaguerreConwa</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">yHyp(eccentricity,</span> M), E, 30);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">               return sol.first;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">Vec3d EllipticalOrbit::positionAtE(const double E) const</td><td> </td><td class="right">Vec3d EllipticalOrbit::positionAtE(const double E) const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0022" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    double x, z;</td><td> </td><td class="rblock">    <span class="insert">   </span>double x, z;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0023" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    if (eccentricity &lt; 1.0)</td><td> </td><td class="rblock">       if (eccentricity &lt; 1.0)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    {</td><td> </td><td class="rblock">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">        double a = pericenterDistance / (1.0 - eccentricity);</td><td> </td><td class="rblock">               double a = pericenterDistance / (1.0 - eccentricity);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">        x = a * (cos(E) - eccentricity);</td><td> </td><td class="rblock">               x = a * (cos(E) - eccentricity);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">        z = a * <span class="delete">sqrt(1</span> - eccentricity * eccentricity) * <span class="delete">-sin(E);</span></td><td> </td><td class="rblock">               z = a * <span class="insert">std::sqrt(1</span> - eccentricity * eccentricity) * <span class="insert">-sin(E)</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    }</td><td> </td><td class="rblock"><span class="insert">;</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    else if (eccentricity &gt; 1.0) // N.B. This is odd at least: <span class="delete">elliptical m</span></td><td> </td><td class="rblock">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">ust</span> have ecc&lt;1!</td><td> </td><td class="rblock">       else if (eccentricity &gt; 1.0) // N.B. This is odd at least: <span class="insert">elliptica</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    {</td><td> </td><td class="rblock"><span class="insert">l must</span> have ecc&lt;1!</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">        double a = pericenterDistance / (1.0 - eccentricity);</td><td> </td><td class="rblock">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">        x = -a * (eccentricity - cosh(E));</td><td> </td><td class="rblock">               double a = pericenterDistance / (1.0 - eccentricity);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">        z = -a * <span class="delete">sqrt(eccentricity</span> * eccentricity - 1) * <span class="delete">-sinh(E);</span></td><td> </td><td class="rblock">               x = -a * (eccentricity - cosh(E));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    }</td><td> </td><td class="rblock">               z = -a * <span class="insert">std::sqrt(eccentricity</span> * eccentricity - 1) * <span class="insert">-sinh(</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    else</td><td> </td><td class="rblock"><span class="insert">E);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    {</td><td> </td><td class="rblock">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">        // TODO: Handle parabolic orbits</td><td> </td><td class="rblock">       else</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">        x = 0.0;</td><td> </td><td class="rblock">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">        z = 0.0;</td><td> </td><td class="rblock">               // TODO: Handle parabolic orbits</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    }</td><td> </td><td class="rblock">               x = 0.0;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                                                                           </td><td> </td><td class="rblock">               z = 0.0;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    Mat4d R = (Mat4d::zrotation(ascendingNode) *</td><td> </td><td class="rblock">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               Mat4d::xrotation(inclination) *</td><td> </td><td class="rblock">                                                                           </td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">               Mat4d::zrotation(argOfPeriapsis));</td><td> </td><td class="rblock">       Mat4d R = (Mat4d::zrotation(ascendingNode) *</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                  Mat4d::xrotation(inclination) *</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">                  Mat4d::zrotation(argOfPeriapsis));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0024" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    return R * Vec3d(x, -z, 0);</td><td> </td><td class="rblock">    <span class="insert">   </span>return R * Vec3d(x, -z, 0);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">// Return the offset from the center.</td><td> </td><td class="right">// Return the offset from the center.</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">Vec3d EllipticalOrbit::positionAtTime(const double JD) const</td><td> </td><td class="right">Vec3d EllipticalOrbit::positionAtTime(const double JD) const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0025" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    double meanMotion = 2.0 * M_PI / period;</td><td> </td><td class="rblock">       double meanMotion = 2.0 * M_PI / period;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    double meanAnomaly = meanAnomalyAtEpoch + (JD-epoch) * meanMotion;</td><td> </td><td class="rblock">       double meanAnomaly = meanAnomalyAtEpoch + (JD-epoch) * meanMotion;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    double E = eccentricAnomaly(meanAnomaly);</td><td> </td><td class="rblock">       double E = eccentricAnomaly(meanAnomaly);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0026" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    return positionAtE(E);</td><td> </td><td class="rblock">    <span class="insert">   </span>return positionAtE(E);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//void EllipticalOrbit::positionAtTime(double JD, double * X, double * Y, d
ouble * Z) const</td><td> </td><td class="right">//void EllipticalOrbit::positionAtTime(double JD, double * X, double * Y, d
ouble * Z) const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//{</td><td> </td><td class="right">//{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//     Vec3d pos = positionAtTime(JD);</td><td> </td><td class="right">//     Vec3d pos = positionAtTime(JD);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//     *X=pos[2];</td><td> </td><td class="right">//     *X=pos[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//     *Y=pos[0];</td><td> </td><td class="right">//     *Y=pos[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//     *Z=pos[1];</td><td> </td><td class="right">//     *Z=pos[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//}</td><td> </td><td class="right">//}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//void EllipticalOrbit::positionAtTimev(double JD, double* v)</td><td> </td><td class="right">//void EllipticalOrbit::positionAtTimev(double JD, double* v)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//{</td><td> </td><td class="right">//{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//     Vec3d pos = positionAtTime(JD);</td><td> </td><td class="right">//     Vec3d pos = positionAtTime(JD);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//     v[0]=pos[2];</td><td> </td><td class="right">//     v[0]=pos[2];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//     v[1]=pos[0];</td><td> </td><td class="right">//     v[1]=pos[0];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//     v[2]=pos[1];</td><td> </td><td class="right">//     v[2]=pos[1];</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">//}</td><td> </td><td class="right">//}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void EllipticalOrbit::positionAtTimevInVSOP87Coordinates(const double JD, d
ouble* v) const</td><td> </td><td class="right">void EllipticalOrbit::positionAtTimevInVSOP87Coordinates(const double JD, d
ouble* v) const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0027" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  Vec3d pos = positionAtTime(JD);</td><td> </td><td class="rblock">       Vec3d pos = positionAtTime(JD);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  v[0] = rotateToVsop87[0]*pos[0] + rotateToVsop87[1]*pos[1] + <span class="delete">rotateToVsop</span></td><td> </td><td class="rblock">       v[0] = rotateToVsop87[0]*pos[0] + rotateToVsop87[1]*pos[1] + <span class="insert">rotateT</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">87[2]*pos[2];</span></td><td> </td><td class="rblock"><span class="insert">oVsop87[2]*pos[2];</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  v[1] = rotateToVsop87[3]*pos[0] + rotateToVsop87[4]*pos[1] + <span class="delete">rotateToVsop</span></td><td> </td><td class="rblock">       v[1] = rotateToVsop87[3]*pos[0] + rotateToVsop87[4]*pos[1] + <span class="insert">rotateT</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">87[5]*pos[2];</span></td><td> </td><td class="rblock"><span class="insert">oVsop87[5]*pos[2];</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">  v[2] = rotateToVsop87[6]*pos[0] + rotateToVsop87[7]*pos[1] + <span class="delete">rotateToVsop</span></td><td> </td><td class="rblock">       v[2] = rotateToVsop87[6]*pos[0] + rotateToVsop87[7]*pos[1] + <span class="insert">rotateT</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">87[8]*pos[2];</span></td><td> </td><td class="rblock"><span class="insert">oVsop87[8]*pos[2];</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">double EllipticalOrbit::getPeriod() const</td><td> </td><td class="right">double EllipticalOrbit::getPeriod() const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0028" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    return period;</td><td> </td><td class="rblock">    <span class="insert">   </span>return period;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">double EllipticalOrbit::getBoundingRadius() const</td><td> </td><td class="right">double EllipticalOrbit::getBoundingRadius() const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0029" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    // TODO: watch out for unbounded parabolic and hyperbolic orbits</td><td> </td><td class="rblock">       // TODO: watch out for unbounded parabolic and hyperbolic orbits</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    return pericenterDistance * ((1.0 + eccentricity) / (1.0 - <span class="delete">eccentricity</span></td><td> </td><td class="rblock">       return pericenterDistance * ((1.0 + eccentricity) / (1.0 - <span class="insert">eccentric</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">));</span></td><td> </td><td class="rblock"><span class="insert">ity));</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">void EllipticalOrbit::sample(double, double, int nSamples, OrbitSampleProc&amp;
 proc) const</td><td> </td><td class="right">void EllipticalOrbit::sample(double, double, int nSamples, OrbitSampleProc&amp;
 proc) const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       double dE = 2. * M_PI / (double) nSamples;</td><td> </td><td class="right">       double dE = 2. * M_PI / (double) nSamples;</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0030" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    for (int i = 0; i &lt; nSamples; i++)</td><td> </td><td class="rblock">       for (int i = 0; i &lt; nSamples; i++)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">        proc.sample(positionAtE(dE * i));</td><td> </td><td class="rblock">               proc.sample(positionAtE(dE * i));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">Vec3d CachingOrbit::positionAtTime(double jd) const</td><td> </td><td class="right">Vec3d CachingOrbit::positionAtTime(double jd) const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0031" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    if (jd != lastTime)</td><td> </td><td class="rblock">       if (jd != lastTime)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    {</td><td> </td><td class="rblock">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">        lastTime = jd;</td><td> </td><td class="rblock">               lastTime = jd;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">        lastPosition = computePosition(jd);</td><td> </td><td class="rblock">               lastPosition = computePosition(jd);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    }</td><td> </td><td class="rblock">       }</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    return lastPosition;</td><td> </td><td class="rblock">       return lastPosition;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0032" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">void CachingOrbit::sample(double start, double t, int nSamples,</td><td> </td><td class="rblock">void CachingOrbit::sample(double start, double t, int nSamples, <span class="insert">OrbitSample</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">                          <span class="delete">OrbitSampleProc&amp;</span> proc) const</td><td> </td><td class="rblock"><span class="insert">Proc&amp;</span> proc) const</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">{</td><td> </td><td class="rblock">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    double dt = t / (double) nSamples;</td><td> </td><td class="rblock">       double dt = t / (double) nSamples;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">    for (int i = 0; i &lt; nSamples; i++)</td><td> </td><td class="rblock">       for (int i = 0; i &lt; nSamples; i++)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">        proc.sample(positionAtTime(start + dt * i));</td><td> </td><td class="rblock">               proc.sample(positionAtTime(start + dt * i));</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">}</td><td> </td><td class="right">}</td><td class="lineno" valign="top"></td></tr>

     <tr><td></td><td class="left"></td><td> </td><td class="right"></td><td></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 32 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><td></td><th><i>359 lines changed or deleted</i></th><th><i> </i></th><th><i>381 lines changed or added</i></th><td></td></tr>
     <tr><td colspan="5" align="center" class="small"><br/>This html diff was produced by rfcdiff 1.41. The latest version is available from <a href="http://www.tools.ietf.org/tools/rfcdiff/" >http://tools.ietf.org/tools/rfcdiff/</a> </td></tr>
   </table>
   </body>
   </html>
