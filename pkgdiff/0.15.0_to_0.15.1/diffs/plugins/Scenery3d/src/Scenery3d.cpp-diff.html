<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"> 
<!-- Generated by rfcdiff 1.41: rfcdiff  --> 
<!-- <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional" > -->
<!-- System: Linux fomalhaut.home 4.4.0-57-generic #78-Ubuntu SMP Fri Dec 9 23:50:32 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux --> 
<!-- Using awk: /usr/bin/gawk: GNU Awk 4.1.3, API: 1.1 (GNU MPFR 3.1.4, GNU MP 6.1.0) --> 
<!-- Using diff: /usr/bin/diff: diff (GNU diffutils) 3.3 --> 
<!-- Using wdiff: /usr/bin/wdiff: wdiff (GNU wdiff) 1.2.2 --> 
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"> 
<head> 
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /> 
  <meta http-equiv="Content-Style-Type" content="text/css" /> 
  <title>Diff: Scenery3d.cpp - Scenery3d.cpp</title> 
  <style type="text/css"> 
    body    { font-size:16px; margin: 0.4ex; margin-right: auto; } 
    tr      { } 
    td      { white-space: pre; font-family: Consolas, "DejaVu Sans Mono", "Droid Sans Mono", Monaco, Monospace; vertical-align: top; font-size: 0.86em;} 
    th      { font-size: 0.86em; } 
    .small  { font-size: 0.6em; font-style: italic; font-family: Verdana, Helvetica, sans-serif; } 
    .left   { background-color: #EEE; } 
    .right  { background-color: #FFF; } 
    .diff   { background-color: #CCF; } 
    .lblock { background-color: #BFB; } 
    .rblock { background-color: #FF8; } 
    .insert { background-color: #8FF; } 
    .delete { background-color: #ACF; } 
    .void   { background-color: #FFB; } 
    .cont   { background-color: #EEE; } 
    .linebr { background-color: #AAA; } 
    .lineno { color: red; background-color: #FFF; font-size: 0.7em; text-align: right; padding: 0 2px; } 
    .elipsis{ background-color: #AAA; } 
    .left .cont { background-color: #DDD; } 
    .right .cont { background-color: #EEE; } 
    .lblock .cont { background-color: #9D9; } 
    .rblock .cont { background-color: #DD6; } 
    .insert .cont { background-color: #0DD; } 
    .delete .cont { background-color: #8AD; } 
    .stats, .stats td, .stats th { background-color: #EEE; padding: 2px 0; } 
  </style> 
</head> 
<body > 
  <table border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th></th><th>&nbsp;Scenery3d.cpp&nbsp;</th><th> </th><th>&nbsp;Scenery3d.cpp&nbsp;</th><th></th></tr> 
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l1" /><small>skipping to change at</small><em> line 95</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 95</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">      loadCancel(false),</td><td> </td><td class="right">      loadCancel(false),</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">      cubemapSize(1024),shadowmapSize(1024),</td><td> </td><td class="right">      cubemapSize(1024),shadowmapSize(1024),</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">      absolutePosition(0.0, 0.0, 0.0), moveVector(0.0, 0.0, 0.0), movement(
0.0f,0.0f,0.0f), eye_height(0.0f),</td><td> </td><td class="right">      absolutePosition(0.0, 0.0, 0.0), moveVector(0.0, 0.0, 0.0), movement(
0.0f,0.0f,0.0f), eye_height(0.0f),</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">      core(NULL), landscapeMgr(NULL),  heightmap(NULL), heightmapLoad(NULL)
,</td><td> </td><td class="right">      core(NULL), landscapeMgr(NULL),  heightmap(NULL), heightmapLoad(NULL)
,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">      mainViewUp(0.0, 0.0, 1.0), mainViewDir(1.0, 0.0, 0.0), viewPos(0.0, 0
.0, 0.0),</td><td> </td><td class="right">      mainViewUp(0.0, 0.0, 1.0), mainViewDir(1.0, 0.0, 0.0), viewPos(0.0, 0
.0, 0.0),</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">      drawnTriangles(0), drawnModels(0), materialSwitches(0), shaderSwitche
s(0),</td><td> </td><td class="right">      drawnTriangles(0), drawnModels(0), materialSwitches(0), shaderSwitche
s(0),</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">      requiresCubemap(false), cubemappingUsedLastFrame(false),</td><td> </td><td class="right">      requiresCubemap(false), cubemappingUsedLastFrame(false),</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">      lazyDrawing(false), updateOnlyDominantOnMoving(true), updateSecondDom
inantOnMoving(true), needsMovementEndUpdate(false),</td><td> </td><td class="right">      lazyDrawing(false), updateOnlyDominantOnMoving(true), updateSecondDom
inantOnMoving(true), needsMovementEndUpdate(false),</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">      needsCubemapUpdate(true), needsMovementUpdate(false), lazyInterval(2.
0), lastCubemapUpdate(0.0), lastCubemapUpdateRealTime(0), lastMovementEndRe
alTime(0),</td><td> </td><td class="right">      needsCubemapUpdate(true), needsMovementUpdate(false), lazyInterval(2.
0), lastCubemapUpdate(0.0), lastCubemapUpdateRealTime(0), lastMovementEndRe
alTime(0),</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">      cubeMapCubeTex(0), cubeMapCubeDepth(0), cubeMapTex(), cubeRB(0), domi
nantFace(0), secondDominantFace(1), cubeFBO(0), cubeSideFBO(), cubeMappingC
reated(false),</td><td> </td><td class="right">      cubeMapCubeTex(0), cubeMapCubeDepth(0), cubeMapTex(), cubeRB(0), domi
nantFace(0), secondDominantFace(1), cubeFBO(0), cubeSideFBO(), cubeMappingC
reated(false),</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">      cubeVertexBuffer(QOpenGLBuffer::VertexBuffer), <span class="delete">cubeIndexBuffer(QOpenG
LBuffer::IndexBuf</span>fer), cubeIndexCount(0),</td><td> </td><td class="rblock">      cubeVertexBuffer(QOpenGLBuffer::VertexBuffer), <span class="insert">transformedCubeVertexB
uffer(QOpenGLBuffer::VertexBuffer), cubeIndexBuffer(QOpenGLBuffer::IndexBuf
</span>fer), cubeIndexCount(0),</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">      lightOrthoNear(0.1f), lightOrthoFar(1000.0f), parallaxScale(0.015f)</td><td> </td><td class="right">      lightOrthoNear(0.1f), lightOrthoFar(1000.0f), parallaxScale(0.015f)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">{</td><td> </td><td class="right">{</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       #ifndef NDEBUG</td><td> </td><td class="right">       #ifndef NDEBUG</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       qDebug()&lt;&lt;"Scenery3d constructor...";</td><td> </td><td class="right">       qDebug()&lt;&lt;"Scenery3d constructor...";</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       #endif</td><td> </td><td class="right">       #endif</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //the arrays should all contain only zeroes</td><td> </td><td class="right">       //the arrays should all contain only zeroes</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Q_ASSERT(cubeMapTex[0]==0);</td><td> </td><td class="right">       Q_ASSERT(cubeMapTex[0]==0);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       Q_ASSERT(cubeSideFBO[0]==0);</td><td> </td><td class="right">       Q_ASSERT(cubeSideFBO[0]==0);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       shaderParameters.openglES = false;</td><td> </td><td class="right">       shaderParameters.openglES = false;</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l2" /><small>skipping to change at</small><em> line 1620</em></th><th> </th><th><a name="part-r2" /><small>skipping to change at</small><em> line 1620</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //setup shader params</td><td> </td><td class="right">       //setup shader params</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       projectionMatrix = altAzProjector-&gt;getProjectionMatrix().convertToQM
atrix();</td><td> </td><td class="right">       projectionMatrix = altAzProjector-&gt;getProjectionMatrix().convertToQM
atrix();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       cubeShader-&gt;setUniformValue(shaderManager.uniformLocation(cubeShader
,ShaderMgr::UNIFORM_MAT_PROJECTION), projectionMatrix);</td><td> </td><td class="right">       cubeShader-&gt;setUniformValue(shaderManager.uniformLocation(cubeShader
,ShaderMgr::UNIFORM_MAT_PROJECTION), projectionMatrix);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       cubeShader-&gt;setUniformValue(shaderManager.uniformLocation(cubeShader
,ShaderMgr::UNIFORM_TEX_DIFFUSE),0);</td><td> </td><td class="right">       cubeShader-&gt;setUniformValue(shaderManager.uniformLocation(cubeShader
,ShaderMgr::UNIFORM_TEX_DIFFUSE),0);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       cubeVertexBuffer.bind();</td><td> </td><td class="right">       cubeVertexBuffer.bind();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if(cubemappingMode&gt;=S3DEnum::CM_CUBEMAP)</td><td> </td><td class="right">       if(cubemappingMode&gt;=S3DEnum::CM_CUBEMAP)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               cubeShader-&gt;setAttributeBuffer(ShaderMgr::ATTLOC_TEXCOORD,GL
_FLOAT,0,3);</td><td> </td><td class="right">               cubeShader-&gt;setAttributeBuffer(ShaderMgr::ATTLOC_TEXCOORD,GL
_FLOAT,0,3);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       else // 2D tex coords are stored in the same buffer, but with an off
set</td><td> </td><td class="right">       else // 2D tex coords are stored in the same buffer, but with an off
set</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               cubeShader-&gt;setAttributeBuffer(ShaderMgr::ATTLOC_TEXCOORD,GL
_FLOAT,cubeVertices.size() * sizeof(Vec3f),2);</td><td> </td><td class="right">               cubeShader-&gt;setAttributeBuffer(ShaderMgr::ATTLOC_TEXCOORD,GL
_FLOAT,cubeVertices.size() * sizeof(Vec3f),2);</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0002" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">       cubeVertexBuffer.release();</span></td><td> </td><td class="rblock"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       cubeShader-&gt;enableAttributeArray(ShaderMgr::ATTLOC_TEXCOORD);</td><td> </td><td class="right">       cubeShader-&gt;enableAttributeArray(ShaderMgr::ATTLOC_TEXCOORD);</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0003" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock">       <span class="delete">cubeShader-&gt;setAttributeArray(ShaderMgr::ATTLOC_VERTEX, reinterpret_</span></td><td> </td><td class="rblock">       <span class="insert">cubeVertexBuffer.release();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"><span class="delete">cast&lt;const GLfloat*&gt;(transformedCubeVertices.constData()),3);</span></td><td> </td><td class="rblock"><span class="insert"></span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       //upload transformed vertex data</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       transformedCubeVertexBuffer.bind();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       transformedCubeVertexBuffer.allocate(transformedCubeVertices.constDa</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ta(), transformedCubeVertices.size() * sizeof(Vec3f));</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       cubeShader-&gt;setAttributeBuffer(ShaderMgr::ATTLOC_VERTEX, GL_FLOAT, 0</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">,3);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       cubeShader-&gt;enableAttributeArray(ShaderMgr::ATTLOC_VERTEX);</td><td> </td><td class="right">       cubeShader-&gt;enableAttributeArray(ShaderMgr::ATTLOC_VERTEX);</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0004" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       transformedCubeVertexBuffer.release();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       glEnable(GL_BLEND);</td><td> </td><td class="right">       glEnable(GL_BLEND);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //note that GL_ONE is required here for correct blending (see drawAr
rays)</td><td> </td><td class="right">       //note that GL_ONE is required here for correct blending (see drawAr
rays)</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);</td><td> </td><td class="right">       glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //depth test and culling is necessary for correct display,</td><td> </td><td class="right">       //depth test and culling is necessary for correct display,</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //because the cube faces can be projected in quite "weird" ways</td><td> </td><td class="right">       //because the cube faces can be projected in quite "weird" ways</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       glEnable(GL_DEPTH_TEST);</td><td> </td><td class="right">       glEnable(GL_DEPTH_TEST);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //glDepthFunc(GL_LESS);</td><td> </td><td class="right">       //glDepthFunc(GL_LESS);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       glDepthMask(GL_TRUE);</td><td> </td><td class="right">       glDepthMask(GL_TRUE);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       glEnable(GL_CULL_FACE);</td><td> </td><td class="right">       glEnable(GL_CULL_FACE);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno"></td></tr>
      <tr bgcolor="gray" ><td></td><th><a name="part-l3" /><small>skipping to change at</small><em> line 2059</em></th><th> </th><th><a name="part-r3" /><small>skipping to change at</small><em> line 2064</em></th><td></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#endif</td><td> </td><td class="right">#endif</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //save opengl ES state</td><td> </td><td class="right">       //save opengl ES state</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       shaderParameters.openglES = ctx-&gt;isOpenGLES();</td><td> </td><td class="right">       shaderParameters.openglES = ctx-&gt;isOpenGLES();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //find out what features we can enable</td><td> </td><td class="right">       //find out what features we can enable</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       determineFeatureSupport();</td><td> </td><td class="right">       determineFeatureSupport();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       cubeVertexBuffer.setUsagePattern(QOpenGLBuffer::StaticDraw);</td><td> </td><td class="right">       cubeVertexBuffer.setUsagePattern(QOpenGLBuffer::StaticDraw);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       cubeVertexBuffer.create();</td><td> </td><td class="right">       cubeVertexBuffer.create();</td><td class="lineno" valign="top"></td></tr>
      <tr><td><a name="diff0005" /></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">transformedCubeVertexBuffer.setUsagePattern(QOpenGLBuffer::StreamDra</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">w);</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       transformedCubeVertexBuffer.create();</span></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       cubeIndexBuffer.setUsagePattern(QOpenGLBuffer::StaticDraw);</td><td> </td><td class="right">       cubeIndexBuffer.setUsagePattern(QOpenGLBuffer::StaticDraw);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       cubeIndexBuffer.create();</td><td> </td><td class="right">       cubeIndexBuffer.create();</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left"></td><td> </td><td class="right"></td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       //enable seamless cubemapping if HW supports it</td><td> </td><td class="right">       //enable seamless cubemapping if HW supports it</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       if(ctx-&gt;hasExtension("GL_ARB_seamless_cube_map"))</td><td> </td><td class="right">       if(ctx-&gt;hasExtension("GL_ARB_seamless_cube_map"))</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">       {</td><td> </td><td class="right">       {</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#ifdef GL_TEXTURE_CUBE_MAP_SEAMLESS</td><td> </td><td class="right">#ifdef GL_TEXTURE_CUBE_MAP_SEAMLESS</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               glEnable(GL_TEXTURE_CUBE_MAP_SEAMLESS);</td><td> </td><td class="right">               glEnable(GL_TEXTURE_CUBE_MAP_SEAMLESS);</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">               qDebug()&lt;&lt;"[Scenery3d] Seamless cubemap filtering enabled";</td><td> </td><td class="right">               qDebug()&lt;&lt;"[Scenery3d] Seamless cubemap filtering enabled";</td><td class="lineno" valign="top"></td></tr>
      <tr><td class="lineno" valign="top"></td><td class="left">#endif</td><td> </td><td class="right">#endif</td><td class="lineno" valign="top"></td></tr>

     <tr><td></td><td class="left"></td><td> </td><td class="right"></td><td></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 5 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><td></td><th><i>4 lines changed or deleted</i></th><th><i> </i></th><th><i>13 lines changed or added</i></th><td></td></tr>
     <tr><td colspan="5" align="center" class="small"><br/>This html diff was produced by rfcdiff 1.41. The latest version is available from <a href="http://www.tools.ietf.org/tools/rfcdiff/" >http://tools.ietf.org/tools/rfcdiff/</a> </td></tr>
   </table>
   </body>
   </html>
